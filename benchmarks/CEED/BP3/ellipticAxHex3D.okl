/*

The MIT License (MIT)

Copyright (c) 2017 Tim Warburton, Noel Chalmers, Jesse Chan, Ali Karakus

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/


#if 0
__constant__ dfloat c_D[10][9] = {
                                   {.1, .2, .3, .4, .5, .6, .7, .8, .9},
                                   {.1, .2, .3, .4, .5, .6, .7, .8, .9},
                                   {.1, .2, .3, .4, .5, .6, .7, .8, .9},
                                   {.1, .2, .3, .4, .5, .6, .7, .8, .9},
                                   {.1, .2, .3, .4, .5, .6, .7, .8, .9},
                                   {.1, .2, .3, .4, .5, .6, .7, .8, .9},
                                   {.1, .2, .3, .4, .5, .6, .7, .8, .9},
                                   {.1, .2, .3, .4, .5, .6, .7, .8, .9},
                                   {.1, .2, .3, .4, .5, .6, .7, .8, .9},
                                   {.1, .2, .3, .4, .5, .6, .7, .8, .9}
                                 };

__constant__ dfloat c_I[10][9] = {
                                   {.1, .2, .3, .4, .5, .6, .7, .8, .9},
                                   {.1, .2, .3, .4, .5, .6, .7, .8, .9},
                                   {.1, .2, .3, .4, .5, .6, .7, .8, .9},
                                   {.1, .2, .3, .4, .5, .6, .7, .8, .9},
                                   {.1, .2, .3, .4, .5, .6, .7, .8, .9},
                                   {.1, .2, .3, .4, .5, .6, .7, .8, .9},
                                   {.1, .2, .3, .4, .5, .6, .7, .8, .9},
                                   {.1, .2, .3, .4, .5, .6, .7, .8, .9},
                                   {.1, .2, .3, .4, .5, .6, .7, .8, .9},
                                   {.1, .2, .3, .4, .5, .6, .7, .8, .9}
                                 };
#endif

// hex kernel for screened coulomb potential mat-vec
#define cubeThreads                             \
	for(int k=0; k<p_Nq; ++k; inner2)            \
		for(int j=0; j<p_Nq; ++j; inner1)          \
			for(int i=0; i<p_Nq; ++i; inner0)


// cube thread version
kernel void ellipticAxHex3D_e0(const int Nelements,
                               const dfloat * restrict ggeo,
                               const dfloat * restrict D,
                               const dfloat lambda,
                               const dfloat * restrict q,
                               dfloat * restrict Aq){

	for(int e=0; e<Nelements; ++e; outer0) {

		shared dfloat s_q[p_Nq][p_Nq][p_Nq];
		shared dfloat s_D[p_Nq][p_Nq];

		exclusive dfloat r_qr, r_qs, r_qt, r_Aq;
		exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;

		// prefetch q(:,:,:,e) to shared
		cubeThreads {
		  const int base = i + j*p_Nq + k*p_Nq*p_Nq + e*p_Np;

		  s_q[k][j][i] = q[base];

		  if(k==0) // fetch D to shared
		  s_D[j][i] = D[j*p_Nq+i];
		}

		barrier(localMemFence);

		cubeThreads {

		  const int base = e*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

		  // assumes w*J built into G entries
		  r_GwJ = ggeo[base+p_GWJID*p_Np];

		  r_G00 = ggeo[base+p_G00ID*p_Np];
		  r_G01 = ggeo[base+p_G01ID*p_Np];
		  r_G02 = ggeo[base+p_G02ID*p_Np];

		  r_G11 = ggeo[base+p_G11ID*p_Np];
		  r_G12 = ggeo[base+p_G12ID*p_Np];
		  r_G22 = ggeo[base+p_G22ID*p_Np];

		  dfloat qr = 0.f, qs = 0.f, qt = 0.f;

		  for(int n=0; n<p_Nq; ++n) {
		  qr += s_D[i][n]*s_q[k][j][n];
			  qs += s_D[j][n]*s_q[k][n][i];
			  qt += s_D[k][n]*s_q[n][j][i];
		  }

		  r_qr = qr; r_qs = qs; r_qt = qt;

		  r_Aq = r_GwJ*lambda*s_q[k][j][i];
		}

		// r term ----->
		barrier(localMemFence);

		cubeThreads {
		  s_q[k][j][i] = r_G00*r_qr + r_G01*r_qs + r_G02*r_qt;
		}

		barrier(localMemFence);

		cubeThreads {
		  dfloat tmp = 0.f;
		  for(int n=0; n<p_Nq; ++n)
		  tmp += s_D[n][i]*s_q[k][j][n];

		  r_Aq += tmp;
		}

		// s term ---->
		barrier(localMemFence);

		cubeThreads {
		  s_q[k][j][i] = r_G01*r_qr + r_G11*r_qs + r_G12*r_qt;
		}

		barrier(localMemFence);

		cubeThreads {
		  dfloat tmp = 0.f;
		  for(int n=0; n<p_Nq; ++n)
		  tmp += s_D[n][j]*s_q[k][n][i];

		  r_Aq += tmp;
		}

		// t term ---->
		barrier(localMemFence);

		cubeThreads {
		  s_q[k][j][i] = r_G02*r_qr + r_G12*r_qs + r_G22*r_qt;
		}

		barrier(localMemFence);

		cubeThreads {
		  dfloat tmp = 0.f;
		  for(int n=0; n<p_Nq; ++n)
		  tmp += s_D[n][k]*s_q[n][j][i];

		  r_Aq += tmp;

		  int base = e*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
		  Aq[base] = r_Aq;
		}
	}
}

//e0a - element list
kernel void ellipticAxHex3D_e0a(const int Nelements,
                                const int * restrict elementList,
                                const dfloat * restrict ggeo,
                                const dfloat * restrict D,
                                const dfloat lambda,
                                const dfloat * restrict q,
                                dfloat * restrict Aq){

	for(int e=0; e<Nelements; ++e; outer0) {

		shared dfloat s_q[p_Nq][p_Nq][p_Nq];
		shared dfloat s_D[p_Nq][p_Nq];

		exclusive dfloat r_qr, r_qs, r_qt, r_Aq;
		exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;

		// prefetch q(:,:,:,e) to shared
		cubeThreads {
		  const int base = i + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np;

		  s_q[k][j][i] = q[base];

		  if(k==0) // fetch D to shared
		  s_D[j][i] = D[j*p_Nq+i];
		}

		barrier(localMemFence);

		cubeThreads {

		  const int base = elementList[e]*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

		  // assumes w*J built into G entries
		  r_GwJ = ggeo[base+p_GWJID*p_Np];

		  r_G00 = ggeo[base+p_G00ID*p_Np];
		  r_G01 = ggeo[base+p_G01ID*p_Np];
		  r_G02 = ggeo[base+p_G02ID*p_Np];

		  r_G11 = ggeo[base+p_G11ID*p_Np];
		  r_G12 = ggeo[base+p_G12ID*p_Np];
		  r_G22 = ggeo[base+p_G22ID*p_Np];

		  dfloat qr = 0.f, qs = 0.f, qt = 0.f;

		  for(int n=0; n<p_Nq; ++n) {
		  qr += s_D[i][n]*s_q[k][j][n];
			  qs += s_D[j][n]*s_q[k][n][i];
			  qt += s_D[k][n]*s_q[n][j][i];
		  }

		  r_qr = qr; r_qs = qs; r_qt = qt;

		  r_Aq = r_GwJ*lambda*s_q[k][j][i];
		}

		// r term ----->
		barrier(localMemFence);

		cubeThreads {
		  s_q[k][j][i] = r_G00*r_qr + r_G01*r_qs + r_G02*r_qt;
		}

		barrier(localMemFence);

		cubeThreads {
		  dfloat tmp = 0.f;
		  for(int n=0; n<p_Nq; ++n)
		  tmp += s_D[n][i]*s_q[k][j][n];

		  r_Aq += tmp;
		}

		// s term ---->
		barrier(localMemFence);

		cubeThreads {
		  s_q[k][j][i] = r_G01*r_qr + r_G11*r_qs + r_G12*r_qt;
		}

		barrier(localMemFence);

		cubeThreads {
		  dfloat tmp = 0.f;
		  for(int n=0; n<p_Nq; ++n)
		  tmp += s_D[n][j]*s_q[k][n][i];

		  r_Aq += tmp;
		}

		// t term ---->
		barrier(localMemFence);

		cubeThreads {
		  s_q[k][j][i] = r_G02*r_qr + r_G12*r_qs + r_G22*r_qt;
		}

		barrier(localMemFence);

		cubeThreads {
		  dfloat tmp = 0.f;
		  for(int n=0; n<p_Nq; ++n)
		  tmp += s_D[n][k]*s_q[n][j][i];

		  r_Aq += tmp;

		  int base =  elementList[e]*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
		  Aq[base] = r_Aq;
		}
	}
}//e0a end

//e0b - optimized e0a

//e0c - less registers
kernel void ellipticAxHex3D_e0b(const int Nelements,
                                const int * restrict elementList,
                                const dfloat * restrict ggeo,
                                const dfloat * restrict D,
                                const dfloat lambda,
                                const dfloat * restrict q,
                                dfloat * restrict Aq){

	for(int e=0; e<Nelements; ++e; outer0) {

		shared dfloat s_q[p_Nq][p_Nq][p_Nq];
		shared dfloat s_qr[p_Nq][p_Nq][p_Nq];
		shared dfloat s_qs[p_Nq][p_Nq][p_Nq];
		shared dfloat s_qt[p_Nq][p_Nq][p_Nq];

		shared dfloat s_D[p_Nq][p_Nq];
		//	shared dfloat s_Aq[p_Nq][p_Nq][p_Nq];

		exclusive dfloat emap;
		//r_Aq;
		exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;
		exclusive dfloat r_Aq;
		// prefetch q(:,:,:,e) to shared
		cubeThreads {
		  emap = elementList[e];
		  const int base = i + j*p_Nq + k*p_Nq*p_Nq + emap*p_Np;

		  s_q[k][j][i] = q[base];

		  if(k==0) // fetch D to shared
		  s_D[j][i] = D[j*p_Nq+i];
		}

		barrier(localMemFence);



		cubeThreads {

		  //  const int base = elementList[e]*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

		  // assumes w*J built into G entries


		  const int base = emap*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

		  r_GwJ = ggeo[base+p_GWJID*p_Np];

		  r_G00 = ggeo[base+p_G00ID*p_Np];
		  r_G01 = ggeo[base+p_G01ID*p_Np];
		  r_G02 = ggeo[base+p_G02ID*p_Np];

		  r_G11 = ggeo[base+p_G11ID*p_Np];
		  r_G12 = ggeo[base+p_G12ID*p_Np];
		  r_G22 = ggeo[base+p_G22ID*p_Np];


		  dfloat qr = 0.f;
		  dfloat qs = 0.f, qt = 0.f;

		  occaUnroll(p_Nq)
		  for(int n=0; n<p_Nq; ++n) {
		  qr += s_D[i][n]*s_q[k][j][n];
			  qs += s_D[j][n]*s_q[k][n][i];
			  qt += s_D[k][n]*s_q[n][j][i];
		  }
		  
 
		  s_qr[k][j][i] = r_G00*qr + r_G01*qs + r_G02*qt;
		  s_qs[k][j][i] = r_G01*qr + r_G11*qs + r_G12*qt;
		  s_qt[k][j][i] = r_G02*qr + r_G12*qs + r_G22*qt;
		  
		  
		  r_Aq = r_GwJ*lambda*s_q[k][j][i];
		}


		// r term ----->


		barrier(localMemFence);

		cubeThreads {
		  dfloat tmp = 0.0f;

		  occaUnroll(p_Nq)
		  for(int n=0; n<p_Nq; ++n){
		    tmp += s_D[n][i]*s_qr[k][j][n];
			  tmp += s_D[n][j]*s_qs[k][n][i];
			  tmp += s_D[n][k]*s_qt[n][j][i];
		  }

		  //  r_Aq += tmp;
		  //  s_Aq[k][j][i] +=tmp;
		  r_Aq += tmp;
		  int base =  emap*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

		  Aq[base] = r_Aq;
		  //r_Aq;
		  //s_Aq[k][j][i];

		}
	}
}//e0b end

//e03 - more registers (?)



// i-j sliced version
kernel void ellipticAxHex3D_e1(const int Nelements,
                               const dfloat * restrict ggeo,
                               const dfloat * restrict D,
                               const dfloat lambda,
                               const dfloat * restrict q,
                               dfloat * restrict Aq){

	for(int eo=0; eo<Nelements; eo+=p_NblockV; outer0) {

		shared dfloat s_tmpr[p_NblockV][p_Nq][p_Nq];
		shared dfloat s_tmps[p_NblockV][p_Nq][p_Nq];
		shared dfloat s_q[p_NblockV][p_Nq][p_Nq];
		shared dfloat s_D[p_Nq][p_Nq];

		exclusive dfloat r_q[p_Nq], r_Aq[p_Nq], r_qt, r_tmpt;

		// prefetch q(i,j,:,e) to register array
		for(int es=0; es<p_NblockV; ++es; inner2) {
			for(int j=0; j<p_Nq; ++j; inner1) {
				for(int i=0; i<p_Nq; ++i; inner0) {
					const int e = eo + es;

					if(e<Nelements) {
						const int base = i + j*p_Nq + e*p_Np;

						for(int k=0; k<p_Nq; ++k) {
							r_q[k] = q[base + k*p_Nq*p_Nq];
							r_Aq[k] = 0.f;
						}
					}

					if(es==0) // fetch D to shared
						s_D[j][i] = D[j*p_Nq+i];

				}
			}
		}

		barrier(localMemFence);

		for(int k=0; k<p_Nq; ++k) {

			for(int es=0; es<p_NblockV; ++es; inner2) {
				for(int j=0; j<p_Nq; ++j; inner1) {
					for(int i=0; i<p_Nq; ++i; inner0) {
						const int e = eo + es;
						if(e<Nelements) {

							// share k-slice of q
							s_q[es][j][i] = r_q[k];

							// hide shared latency behind t-derivative
							dfloat qtk = 0.f;
							for(int n=0; n<p_Nq; ++n) {
								qtk += s_D[k][n]*r_q[n];
							}
							r_qt = qtk;

						}
					}
				}
			}

			barrier(localMemFence);

			// process k-slice (first r- and s-derivatives)
			for(int es=0; es<p_NblockV; ++es; inner2) {
				for(int j=0; j<p_Nq; ++j; inner1) {
					for(int i=0; i<p_Nq; ++i; inner0) {
						const int e = eo + es;
						if(e<Nelements) {
							const int base = e*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

							const dfloat G00 = ggeo[base+p_G00ID*p_Np];
							const dfloat G01 = ggeo[base+p_G01ID*p_Np];
							const dfloat G02 = ggeo[base+p_G02ID*p_Np];
							const dfloat G11 = ggeo[base+p_G11ID*p_Np];
							const dfloat G12 = ggeo[base+p_G12ID*p_Np];
							const dfloat G22 = ggeo[base+p_G22ID*p_Np];
							const dfloat GwJ = ggeo[base+p_GWJID*p_Np];

							dfloat qr = 0.f, qs = 0.f;
							for(int n=0; n<p_Nq; ++n) {
								qr += s_D[i][n]*s_q[es][j][n];
								qs += s_D[j][n]*s_q[es][n][i];
							}

							// assumes w*J built into G entries
							s_tmpr[es][j][i] = G00*qr + G01*qs + G02*r_qt;
							s_tmps[es][j][i] = G01*qr + G11*qs + G12*r_qt;
							r_tmpt           = G02*qr + G12*qs + G22*r_qt;

							r_Aq[k] += GwJ*lambda*r_q[k];

#if 1
							for(int n=0; n<p_Nq; ++n) {
								r_Aq[n] += s_D[k][n]*r_tmpt;
							}
#endif
						}
					}
				}
			}

			barrier(localMemFence);

			// second derivatives
			for(int es=0; es<p_NblockV; ++es; inner2) {
				for(int j=0; j<p_Nq; ++j; inner1) {
					for(int i=0; i<p_Nq; ++i; inner0) {
						const int e = eo + es;
						if(e<Nelements) {

							dfloat Aq1 = 0.0f, Aq2 = 0.0f;

							for(int n=0; n<p_Nq; ++n) {
								Aq1 += s_D[n][i]*s_tmpr[es][j][n];
								Aq2 += s_D[n][j]*s_tmps[es][n][i];
							}
#if 1
							r_Aq[k] +=  Aq1 + Aq2;
#endif
						}
					}
				}
			}
		}

		// write result out (local node storage)
		for(int es=0; es<p_NblockV; ++es; inner2) {
			for(int j=0; j<p_Nq; ++j; inner1) {
				for(int i=0; i<p_Nq; ++i; inner0) {
					const int e = eo + es;
					if(e<Nelements) {
						int base = e*p_Np + j*p_Nq + i;
						for(int k=0; k<p_Nq; ++k) {
							Aq[base] = r_Aq[k];
							base+=p_Nq*p_Nq;
						}
					}
				}
			}
		}
	}
}

//e1a (with elementList)
kernel void ellipticAxHex3D_e1a(const int Nelements,
                                const int * restrict elementList,
                                const dfloat * restrict ggeo,
                                const dfloat * restrict D,
                                const dfloat lambda,
                                const dfloat * restrict q,
                                dfloat * restrict Aq){

	for(int eo=0; eo<Nelements; eo+=p_NblockV; outer0) {

		shared dfloat s_tmpr[p_NblockV][p_Nq][p_Nq];
		shared dfloat s_tmps[p_NblockV][p_Nq][p_Nq];
		shared dfloat s_q[p_NblockV][p_Nq][p_Nq];
		shared dfloat s_D[p_Nq][p_Nq];

		exclusive dfloat r_q[p_Nq], r_Aq[p_Nq], r_qt, r_tmpt;

		// prefetch q(i,j,:,e) to register array
		for(int es=0; es<p_NblockV; ++es; inner2) {
			for(int j=0; j<p_Nq; ++j; inner1) {
				for(int i=0; i<p_Nq; ++i; inner0) {
					const int e = eo + es;

					if(e<Nelements) {
						const int base = i + j*p_Nq + elementList[e]*p_Np;

						for(int k=0; k<p_Nq; ++k) {
							r_q[k] = q[base + k*p_Nq*p_Nq];
							r_Aq[k] = 0.f;
						}
					}

					if(es==0) // fetch D to shared
						s_D[j][i] = D[j*p_Nq+i];

				}
			}
		}

		barrier(localMemFence);

		for(int k=0; k<p_Nq; ++k) {

			for(int es=0; es<p_NblockV; ++es; inner2) {
				for(int j=0; j<p_Nq; ++j; inner1) {
					for(int i=0; i<p_Nq; ++i; inner0) {
						const int e = eo + es;
						if(e<Nelements) {

							// share k-slice of q
							s_q[es][j][i] = r_q[k];

							// hide shared latency behind t-derivative
							dfloat qtk = 0.f;
							for(int n=0; n<p_Nq; ++n) {
								qtk += s_D[k][n]*r_q[n];
							}
							r_qt = qtk;

						}
					}
				}
			}

			barrier(localMemFence);

			// process k-slice (first r- and s-derivatives)
			for(int es=0; es<p_NblockV; ++es; inner2) {
				for(int j=0; j<p_Nq; ++j; inner1) {
					for(int i=0; i<p_Nq; ++i; inner0) {
						const int e = eo + es;
						if(e<Nelements) {
							const int base = elementList[e]*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

							const dfloat G00 = ggeo[base+p_G00ID*p_Np];
							const dfloat G01 = ggeo[base+p_G01ID*p_Np];
							const dfloat G02 = ggeo[base+p_G02ID*p_Np];
							const dfloat G11 = ggeo[base+p_G11ID*p_Np];
							const dfloat G12 = ggeo[base+p_G12ID*p_Np];
							const dfloat G22 = ggeo[base+p_G22ID*p_Np];
							const dfloat GwJ = ggeo[base+p_GWJID*p_Np];

							dfloat qr = 0.f, qs = 0.f;
							for(int n=0; n<p_Nq; ++n) {
								qr += s_D[i][n]*s_q[es][j][n];
								qs += s_D[j][n]*s_q[es][n][i];
							}

							// assumes w*J built into G entries
							s_tmpr[es][j][i] = G00*qr + G01*qs + G02*r_qt;
							s_tmps[es][j][i] = G01*qr + G11*qs + G12*r_qt;
							r_tmpt           = G02*qr + G12*qs + G22*r_qt;

							r_Aq[k] += GwJ*lambda*r_q[k];

#if 1
							for(int n=0; n<p_Nq; ++n) {
								r_Aq[n] += s_D[k][n]*r_tmpt;
							}
#endif
						}
					}
				}
			}

			barrier(localMemFence);

			// second derivatives
			for(int es=0; es<p_NblockV; ++es; inner2) {
				for(int j=0; j<p_Nq; ++j; inner1) {
					for(int i=0; i<p_Nq; ++i; inner0) {
						const int e = eo + es;
						if(e<Nelements) {

							dfloat Aq1 = 0.0f, Aq2 = 0.0f;

							for(int n=0; n<p_Nq; ++n) {
								Aq1 += s_D[n][i]*s_tmpr[es][j][n];
								Aq2 += s_D[n][j]*s_tmps[es][n][i];
							}
#if 1
							r_Aq[k] +=  Aq1 + Aq2;
#endif
						}
					}
				}
			}
		}

		// write result out (local node storage)
		for(int es=0; es<p_NblockV; ++es; inner2) {
			for(int j=0; j<p_Nq; ++j; inner1) {
				for(int i=0; i<p_Nq; ++i; inner0) {
					const int e = eo + es;
					if(e<Nelements) {
						int base = elementList[e]*p_Np + j*p_Nq + i;
						for(int k=0; k<p_Nq; ++k) {
							Aq[base] = r_Aq[k];
							base+=p_Nq*p_Nq;
						}
					}
				}
			}
		}
	}
} //e1a


//e1b (4d shared)
kernel void ellipticAxHex3D_e1b(const int Nelements,
                                const int * restrict elementList,
                                const dfloat * restrict ggeo,
                                const dfloat * restrict D,
                                const dfloat lambda,
                                const dfloat * restrict q,
                                dfloat * restrict Aq){

	for(int eo=0; eo<Nelements; eo+=p_NblockV; outer0) {

		shared dfloat s_tmpr[p_NblockV][p_Nq][p_Nq];
		shared dfloat s_tmps[p_NblockV][p_Nq][p_Nq];
		shared dfloat s_q[p_NblockV][p_Nq][p_Nq][p_Nq];
		shared dfloat s_Aq[p_NblockV][p_Nq][p_Nq][p_Nq];
		// in the original kernel, each point (i,j) in element es (in block eo) 
		// loads elements (i,j, 0),..,. (i,j, p_Nq)
		// we differentiate slice after slice.
	 //	shared dfloat s_q[p_NblockV][p_Nq][p_Nq];
		shared dfloat s_D[p_Nq][p_Nq];

		exclusive dfloat  r_qt, r_tmpt, emap;
//r_q[p_Nq], r_Aq[p_Nq],
		// prefetch q(i,j,:,e) to register array
		
		for(int es=0; es<p_NblockV; ++es; inner2) {
			for(int j=0; j<p_Nq; ++j; inner1) {
				for(int i=0; i<p_Nq; ++i; inner0) {
					const int e = eo + es;
					emap = elementList[e];

					if(emap<Nelements) {
						const int base = i + j*p_Nq + emap*p_Np;
						for (int k=0; k<p_Nq; k++){
							
	            s_q[es][k][j][i] = q[base + k*p_Nq*p_Nq];
							s_Aq[es][k][j][i] = 0.f;
						}
				
					

					if(es==0) // fetch D to shared
						s_D[j][i] = D[j*p_Nq+i];
				}

				}
			}
		}

		barrier(localMemFence);

		for(int k=0; k<p_Nq; ++k) {

			for(int es=0; es<p_NblockV; ++es; inner2) {
				for(int j=0; j<p_Nq; ++j; inner1) {
					for(int i=0; i<p_Nq; ++i; inner0) {
						const int e = eo + es;
						emap = elementList[e];
						if(emap<Nelements) {

							// share k-slice of q
					//		s_q[es][j][i] = r_q[k];

							// hide shared latency behind t-derivative
							dfloat qtk = 0.f;
							for(int n=0; n<p_Nq; ++n) {
								qtk += s_D[k][n]*s_q[es][n][j][i];
							}
							r_qt = qtk;

						}
					}
				}
			}

			barrier(localMemFence);

			// process k-slice (first r- and s-derivatives)
			for(int es=0; es<p_NblockV; ++es; inner2) {
				for(int j=0; j<p_Nq; ++j; inner1) {
					for(int i=0; i<p_Nq; ++i; inner0) {
						const int e = eo + es;
						emap = elementList[e];
						if(emap<Nelements) {
							const int base = emap*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

							const dfloat G00 = ggeo[base+p_G00ID*p_Np];
							const dfloat G01 = ggeo[base+p_G01ID*p_Np];
							const dfloat G02 = ggeo[base+p_G02ID*p_Np];
							const dfloat G11 = ggeo[base+p_G11ID*p_Np];
							const dfloat G12 = ggeo[base+p_G12ID*p_Np];
							const dfloat G22 = ggeo[base+p_G22ID*p_Np];
							const dfloat GwJ = ggeo[base+p_GWJID*p_Np];

							dfloat qr = 0.f, qs = 0.f;
							for(int n=0; n<p_Nq; ++n) {
								qr += s_D[i][n]*s_q[es][k][j][n];
								qs += s_D[j][n]*s_q[es][k][n][i];
							}

							// assumes w*J built into G entries
							s_tmpr[es][j][i] = G00*qr + G01*qs + G02*r_qt;
							s_tmps[es][j][i] = G01*qr + G11*qs + G12*r_qt;
							r_tmpt           = G02*qr + G12*qs + G22*r_qt;

							s_Aq[es][k][j][i] += GwJ*lambda*s_q[es][k][j][i];

#if 1
							for(int n=0; n<p_Nq; ++n) {
								s_Aq[es][n][j][i] += s_D[k][n]*r_tmpt;
							}
#endif
						}
					}
				}
			}

			barrier(localMemFence);

			// second derivatives
			for(int es=0; es<p_NblockV; ++es; inner2) {
				for(int j=0; j<p_Nq; ++j; inner1) {
					for(int i=0; i<p_Nq; ++i; inner0) {
						const int e = eo + es;
						emap = elementList[e];
						if(emap<Nelements) {

							dfloat Aq1 = 0.0f, Aq2 = 0.0f;

							for(int n=0; n<p_Nq; ++n) {
								Aq1 += s_D[n][i]*s_tmpr[es][j][n];
								Aq2 += s_D[n][j]*s_tmps[es][n][i];
							}
#if 1
							s_Aq[es][k][j][i] +=  Aq1 + Aq2;
#endif

						}
					}
				}
			}
		}//for k ()
barrier(localMemFence);
		// write result out (local node storage)
	
		for(int es=0; es<p_NblockV; ++es; inner2) {
			for(int j=0; j<p_Nq; ++j; inner1) {
				for(int i=0; i<p_Nq; ++i; inner0) {
					const int e = eo + es;
					emap = elementList[e];
					if(emap<Nelements) {
						int base;
							for (int k=0; k<p_Nq; k++){
							base = emap*p_Np +k*p_Nq*p_Nq+ j*p_Nq + i;
							Aq[base] = s_Aq[es][k][j][i];
						//	base+=p_Nq*p_Nq;
						}
						
					}
				}
			}
		}
	}
} //e1b


// e1c - like e6, just no interpolation. 2d i-j "slabs". 

kernel void ellipticAxHex3D_e1c(const int Nelements,
                                const int * restrict elementList,
                                const dfloat * restrict ggeo,
                                const dfloat * restrict D,
                                const dfloat lambda,
                                const dfloat * restrict q,
                                dfloat * restrict Aq){

for(int e=0; e<Nelements; ++e; outer0){

		shared dfloat s_tmpr[p_Nq][p_Nq];
		shared dfloat s_tmps[p_Nq][p_Nq];
		shared dfloat s_q[p_Nq][p_Nq][p_Nq];
		shared dfloat s_Aq[p_Nq][p_Nq][p_Nq];

		shared dfloat s_D[p_Nq][p_Nq];

		exclusive dfloat  r_qt, r_tmpt, emap;
//r_q[p_Nq], r_Aq[p_Nq],
		// prefetch q(i,j,:,e) to register array
		
			for(int j=0; j<p_Nq; ++j; inner1) {
				for(int i=0; i<p_Nq; ++i; inner0) {

					emap = elementList[e];

					if(emap<Nelements) {
						const int base = i + j*p_Nq + emap*p_Np;
						for (int k=0; k<p_Nq; k++){
							
	            s_q[k][j][i] = q[base + k*p_Nq*p_Nq];
							s_Aq[k][j][i] = 0.f;
						}
				
					

					if(es==0) // fetch D to shared
						s_D[j][i] = D[j*p_Nq+i];
				}

				}
			}
		

		barrier(localMemFence);

		for(int k=0; k<p_Nq; ++k) {

				for(int j=0; j<p_Nq; ++j; inner1) {
					for(int i=0; i<p_Nq; ++i; inner0) {
					
						emap = elementList[e];
						if(emap<Nelements) {

							// share k-slice of q
					//		s_q[es][j][i] = r_q[k];

							// hide shared latency behind t-derivative
							dfloat qtk = 0.f;
							for(int n=0; n<p_Nq; ++n) {
								qtk += s_D[k][n]*s_q[n][j][i];
							}
							r_qt = qtk;

						}
					}
				
			}

			barrier(localMemFence);

			// process k-slice (first r- and s-derivatives)
				for(int j=0; j<p_Nq; ++j; inner1) {
					for(int i=0; i<p_Nq; ++i; inner0) {
						
						emap = elementList[e];
						if(emap<Nelements) {
							const int base = emap*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

							const dfloat G00 = ggeo[base+p_G00ID*p_Np];
							const dfloat G01 = ggeo[base+p_G01ID*p_Np];
							const dfloat G02 = ggeo[base+p_G02ID*p_Np];
							const dfloat G11 = ggeo[base+p_G11ID*p_Np];
							const dfloat G12 = ggeo[base+p_G12ID*p_Np];
							const dfloat G22 = ggeo[base+p_G22ID*p_Np];
							const dfloat GwJ = ggeo[base+p_GWJID*p_Np];

							dfloat qr = 0.f, qs = 0.f;
							for(int n=0; n<p_Nq; ++n) {
								qr += s_D[i][n]*s_q[k][j][n];
								qs += s_D[j][n]*s_q[k][n][i];
							}

							// assumes w*J built into G entries
							s_tmpr[j][i] = G00*qr + G01*qs + G02*r_qt;
							s_tmps[j][i] = G01*qr + G11*qs + G12*r_qt;
							r_tmpt           = G02*qr + G12*qs + G22*r_qt;

							s_Aq[k][j][i] += GwJ*lambda*s_q[k][j][i];

#if 1
							for(int n=0; n<p_Nq; ++n) {
								s_Aq[n][j][i] += s_D[k][n]*r_tmpt;
							}
#endif
						}
					}
				}
			

			barrier(localMemFence);

			// second derivatives
		
				for(int j=0; j<p_Nq; ++j; inner1) {
					for(int i=0; i<p_Nq; ++i; inner0) {
				
						emap = elementList[e];
						if(emap<Nelements) {

							dfloat Aq1 = 0.0f, Aq2 = 0.0f;

							for(int n=0; n<p_Nq; ++n) {
								Aq1 += s_D[n][i]*s_tmpr[j][n];
								Aq2 += s_D[n][j]*s_tmps[n][i];
							}
#if 1
							s_Aq[k][j][i] +=  Aq1 + Aq2;
#endif

						}
					
				}
			}
		}//for k ()
barrier(localMemFence);
		// write result out (local node storage)
	
	
			for(int j=0; j<p_Nq; ++j; inner1) {
				for(int i=0; i<p_Nq; ++i; inner0) {
				
					emap = elementList[e];
					if(emap<Nelements) {
						int base;
							for (int k=0; k<p_Nq; k++){
							base = emap*p_Np +k*p_Nq*p_Nq+ j*p_Nq + i;
							Aq[base] = s_Aq[k][j][i];
						//	base+=p_Nq*p_Nq;
						}
						
					}
				}
			
		}
	}
} //e1b


/*
   I = interp;
   D = diff and interp;

   qr_{kji} =  I_{jb} D_{ia} I_{kc} q_{cba};
   qs_{kji} =  D_{jb} I_{ia} I_{kc} q_{cba};
   qt_{kji} =  I_{jb} I_{ia} D_{kc} q_{cba};

   w*J*G*grad q = WJG*[qr;qs;qt];

   lap_{cba} =
   I_{ck} I_{bj} D_{ai} qr_{kji} +
   I_{ck} D_{bj} I_{ai} qs_{kji} +
   D_{ck} I_{bj} I_{ai} qt_{kji} ;
 */

#define p_gjNp (p_gjNq*p_gjNq*p_gjNq)
#define p_gjNq2 (p_gjNq*p_gjNq)
#define p_Nq2 (p_Nq*p_Nq)

#if ((p_NblockG*p_gjNq*p_gjNq)<=32)
#define optBarrier(op)
#else
#define optBarrier(op) barrier(op)
#endif


/* note that the gjGeo must be the geometric factors at the p_gjNp integration nodes */
kernel void ellipticAxHex3D_e2(const int Nelements,
                               const dfloat * restrict gjGeo,
                               const dfloat * restrict gjD,
                               const dfloat * restrict gjI,
                               const dfloat lambda,
                               const dfloat * restrict q,
                               dfloat * restrict Aq){

	for(int e=0; e<Nelements; ++e; outer0) {

		shared dfloat s_D[p_gjNq][p_Nq];
		shared dfloat s_I[p_gjNq][p_Nq];

		exclusive dfloat r_Iq[p_gjNq], r_Dq[p_gjNq], r_lapq[p_Nq];

		shared dfloat s_Ixxq[p_Nq][p_Nq],  s_Dxxq[p_Nq][p_Nq];
		shared dfloat s_IxDq[p_Nq][p_gjNq], s_IxIq[p_Nq][p_gjNq], s_DxIq[p_Nq][p_gjNq];
		shared dfloat s_qr[p_gjNq][p_gjNq], s_qs[p_gjNq][p_gjNq], s_qt[p_gjNq][p_gjNq];
		shared dfloat s_Dqr[p_gjNq][p_Nq], s_Iqs[p_gjNq][p_Nq], s_Iqt[p_gjNq][p_Nq];

		// prefetch D and I matrices and zero register storage
		for(int b=0; b<p_gjNq; ++b; inner1) {
			for(int a=0; a<p_gjNq; ++a; inner0) {
				int t = a + b*p_gjNq;
				if(t<p_gjNq*p_Nq) {
					s_D[0][t] = gjD[t];
					s_I[0][t] = gjI[t];
				}

				for(int k=0; k<p_gjNq; ++k) {
					r_Iq[k] = 0;
					r_Dq[k] = 0;
				}

				for(int c=0; c<p_Nq; ++c) {
					r_lapq[c] = 0;
				}
			}
		}

		barrier(localMemFence);

		//  interpolate and differentiate in 't'
		for(int c=0; c<p_Nq; ++c) {
			for(int b=0; b<p_gjNq; ++b; inner1) {
				for(int a=0; a<p_gjNq; ++a; inner0) {
					if(a<p_Nq && b<p_Nq) {
						const dfloat qcba = q[e*p_Np+c*p_Nq2+b*p_Nq+a];
						for(int k=0; k<p_gjNq; ++k) {
							// I_{kc} q_{cba}
							r_Iq[k] += s_I[k][c]*qcba;
							r_Dq[k] += s_D[k][c]*qcba;
						}
					}
				}
			}
		}

		// scan through k slices
		for(int k=0; k<p_gjNq; ++k) {

			barrier(localMemFence);

			// prefetch slice
			for(int b=0; b<p_gjNq; ++b; inner1) {
				for(int a=0; a<p_gjNq; ++a; inner0) {

					if(a<p_Nq && b<p_Nq) {
						s_Ixxq[b][a] = r_Iq[k];
						s_Dxxq[b][a] = r_Dq[k];
					}
				}
			}

			barrier(localMemFence);

			// interpolate and differentiate in 'r' direction
			for(int b=0; b<p_gjNq; ++b; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {

					if(b<p_Nq) {
						dfloat IxDq= 0, IxIq = 0, DxIq = 0;

						for(int a=0; a<p_Nq; ++a) {
							IxDq += s_D[i][a]*s_Ixxq[b][a];
							IxIq += s_I[i][a]*s_Ixxq[b][a];
							DxIq += s_I[i][a]*s_Dxxq[b][a];
						}

						s_IxDq[b][i] = IxDq;
						s_IxIq[b][i] = IxIq;
						s_DxIq[b][i] = DxIq;
					}
				}
			}

			barrier(localMemFence);

			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {

					const int base = e*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;

					// assumes w*J built into G entries
					//	  const dfloat r_GwJ = gjGeo[base+p_GWJID*p_gjNp];

					const dfloat r_G00 = gjGeo[base+p_G00ID*p_gjNp];
					const dfloat r_G01 = gjGeo[base+p_G01ID*p_gjNp];
					const dfloat r_G02 = gjGeo[base+p_G02ID*p_gjNp];

					const dfloat r_G11 = gjGeo[base+p_G11ID*p_gjNp];
					const dfloat r_G12 = gjGeo[base+p_G12ID*p_gjNp];
					const dfloat r_G22 = gjGeo[base+p_G22ID*p_gjNp];

					dfloat qr = 0, qs = 0, qt = 0;

					// interpolate and differentiate in 's' direction
					for(int n=0; n<p_Nq; ++n) {
						qr += s_I[j][n]*s_IxDq[n][i];
						qs += s_D[j][n]*s_IxIq[n][i];
						qt += s_I[j][n]*s_DxIq[n][i];
					}

					// apply chain rule
					s_qr[j][i] = r_G00*qr + r_G01*qs + r_G02*qt;
					s_qs[j][i] = r_G01*qr + r_G11*qs + r_G12*qt;
					s_qt[j][i] = r_G02*qr + r_G12*qs + r_G22*qt;
				}
			}

			barrier(localMemFence);

			// transpose differentiate and interpolate in 'r'
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int a=0; a<p_gjNq; ++a; inner0) {

					if(a<p_Nq) {
						dfloat tmpr = 0, tmps = 0, tmpt = 0;
						for(int i=0; i<p_gjNq; ++i) {
							tmpr += s_D[i][a]*s_qr[j][i];
							tmps += s_I[i][a]*s_qs[j][i];
							tmpt += s_I[i][a]*s_qt[j][i];
						}

						s_Dqr[j][a] = tmpr;
						s_Iqs[j][a] = tmps;
						s_Iqt[j][a] = tmpt;
					}
				}
			}

			barrier(localMemFence);

			// transpose differentiate and interpolate in 's'
			for(int b=0; b<p_gjNq; ++b; inner1) {
				for(int a=0; a<p_gjNq; ++a; inner0) {

					if(b<p_Nq && a<p_Nq) {
						dfloat tmpr = 0, tmps = 0, tmpt = 0;
						for(int j=0; j<p_gjNq; ++j) {
							tmpr += s_I[j][b]*s_Dqr[j][a];
							tmps += s_D[j][b]*s_Iqs[j][a];
							tmpt += s_I[j][b]*s_Iqt[j][a];
						}

						// transpose differentiate and interpolate in 't'
						for(int c=0; c<p_Nq; ++c) {
							r_lapq[c] += s_I[k][c]*(tmpr+tmps);
							r_lapq[c] += s_D[k][c]*tmpt;
						}
					}
				}
			}
		}

		for(int b=0; b<p_gjNq; ++b; inner1) {
			for(int a=0; a<p_gjNq; ++a; inner0) {

				if(a<p_Nq && b<p_Nq) { // bad
					for(int c=0; c<p_Nq; ++c) {
						Aq[e*p_Np + c*p_Nq2 + b*p_Nq + a] = r_lapq[c];
					}
				}
			}
		}
	}
}

/* note that the gjGeo must be the geometric factors at the p_gjNp integration nodes */
kernel void ellipticAxHex3D_e3(const int Nelements,
                               const dfloat * restrict gjGeo,
                               const dfloat * restrict gjD,
                               const dfloat * restrict gjI,
                               const dfloat lambda,
                               const dfloat * restrict q,
                               dfloat * restrict Aq){

	for(int eo=0; eo<Nelements; eo+=p_NblockG; outer0) {

		shared dfloat s_D[p_gjNq][p_Nq];
		shared dfloat s_I[p_gjNq][p_Nq];

		exclusive dfloat r_Iq[p_gjNq], r_Dq[p_gjNq], r_lapq[p_Nq];
		//    exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22;

		shared dfloat s_Ixxq[p_NblockG][p_Nq][p_Nq],  s_Dxxq[p_NblockG][p_Nq][p_Nq];
		shared dfloat s_IxDq[p_NblockG][p_Nq][p_gjNq], s_IxIq[p_NblockG][p_Nq][p_gjNq], s_DxIq[p_NblockG][p_Nq][p_gjNq];
		shared dfloat s_qr[p_NblockG][p_gjNq][p_gjNq], s_qs[p_NblockG][p_gjNq][p_gjNq], s_qt[p_NblockG][p_gjNq][p_gjNq];
		shared dfloat s_Dqr[p_NblockG][p_gjNq][p_Nq], s_Iqs[p_NblockG][p_gjNq][p_Nq], s_Iqt[p_NblockG][p_gjNq][p_Nq];

		// prefetch D and I matrices and zero register storage
		for(int es=0; es<p_NblockG; ++es; inner2) {
			for(int b=0; b<p_gjNq; ++b; inner1) {
				for(int a=0; a<p_gjNq; ++a; inner0) {
					int t = a + b*p_gjNq + es*p_gjNq*p_gjNq;
					if(t<p_gjNq*p_Nq) {
						s_D[0][t] = gjD[t];
						s_I[0][t] = gjI[t];
					}

					for(int k=0; k<p_gjNq; ++k) {
						r_Iq[k] = 0;
						r_Dq[k] = 0;
					}

					for(int c=0; c<p_Nq; ++c) {
						r_lapq[c] = 0;
					}
				}
			}
		}

		barrier(localMemFence);

		//  interpolate and differentiate in 't'

		for(int c=0; c<p_Nq; ++c) {
			for(int es=0; es<p_NblockG; ++es; inner2) {
				for(int b=0; b<p_gjNq; ++b; inner1) {
					for(int a=0; a<p_gjNq; ++a; inner0) {
						int t = a + b*p_gjNq;
						if(t<p_Nq*p_Nq) { // a<p_Nq && b<p_Nq){
							int e = eo+es;
							if(e<Nelements) {
								const dfloat qcba = q[e*p_Np+c*p_Nq2+t];

								occaUnroll(p_gjNq)
								for(int k=0; k<p_gjNq; ++k) {
									// I_{kc} q_{cba}
									r_Iq[k] += s_I[k][c]*qcba;
									r_Dq[k] += s_D[k][c]*qcba;
								}
							}
						}
					}
				}
			}
		}


		// scan through k slices
		for(int k=0; k<p_gjNq; ++k) {

			barrier(localMemFence);

			// prefetch slice
			for(int es=0; es<p_NblockG; ++es; inner2) {
				for(int b=0; b<p_gjNq; ++b; inner1) {
					for(int a=0; a<p_gjNq; ++a; inner0) {

						int t = a+b*p_gjNq;
						if(t<p_Nq*p_Nq) {
							s_Ixxq[es][0][t] = r_Iq[k];
							s_Dxxq[es][0][t] = r_Dq[k];
						}
					}
				}
			}

			barrier(localMemFence);

			// interpolate and differentiate in 'r' direction
			for(int es=0; es<p_NblockG; ++es; inner2) {
				for(int b=0; b<p_gjNq; ++b; inner1) {
					for(int i=0; i<p_gjNq; ++i; inner0) {

						if(b<p_Nq) {
							dfloat IxDq= 0, IxIq = 0, DxIq = 0;

							occaUnroll(p_Nq)
							for(int a=0; a<p_Nq; ++a) {
								IxDq += s_D[i][a]*s_Ixxq[es][b][a];
								IxIq += s_I[i][a]*s_Ixxq[es][b][a];
								DxIq += s_I[i][a]*s_Dxxq[es][b][a];
							}

							s_IxDq[es][b][i] = IxDq;
							s_IxIq[es][b][i] = IxIq;
							s_DxIq[es][b][i] = DxIq;
						}
					}
				}
			}

			barrier(localMemFence);

			for(int es=0; es<p_NblockG; ++es; inner2) {
				for(int j=0; j<p_gjNq; ++j; inner1) {
					for(int i=0; i<p_gjNq; ++i; inner0) {

						int e = eo+es;
						if(e<Nelements) {

							dfloat qr = 0, qs = 0, qt = 0;

							// interpolate and differentiate in 's' direction
							occaUnroll(p_Nq)
							for(int n=0; n<p_Nq; ++n) {
								qr += s_I[j][n]*s_IxDq[es][n][i];
								qs += s_D[j][n]*s_IxIq[es][n][i];
								qt += s_I[j][n]*s_DxIq[es][n][i];
							}

							const int base = e*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;

							// assumes w*J built into G entries
							//	      dfloat r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
							dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22;
							r_G00 = gjGeo[base+p_G00ID*p_gjNp];
							r_G01 = gjGeo[base+p_G01ID*p_gjNp];
							r_G02 = gjGeo[base+p_G02ID*p_gjNp];

							r_G11 = gjGeo[base+p_G11ID*p_gjNp];
							r_G12 = gjGeo[base+p_G12ID*p_gjNp];
							r_G22 = gjGeo[base+p_G22ID*p_gjNp];

							// apply chain rule
							s_qr[es][j][i] = r_G00*qr + r_G01*qs + r_G02*qt;
							s_qs[es][j][i] = r_G01*qr + r_G11*qs + r_G12*qt;
							s_qt[es][j][i] = r_G02*qr + r_G12*qs + r_G22*qt;
						}
					}
				}
			}

			barrier(localMemFence);

			// transpose differentiate and interpolate in 'r'
			for(int es=0; es<p_NblockG; ++es; inner2) {
				for(int j=0; j<p_gjNq; ++j; inner1) {
					for(int a=0; a<p_gjNq; ++a; inner0) {

						if(a<p_Nq) {
							dfloat tmpr = 0, tmps = 0, tmpt = 0;
							occaUnroll(p_gjNq)
							for(int i=0; i<p_gjNq; ++i) {
								tmpr += s_D[i][a]*s_qr[es][j][i];
								tmps += s_I[i][a]*s_qs[es][j][i];
								tmpt += s_I[i][a]*s_qt[es][j][i];
							}

							s_Dqr[es][j][a] = tmpr;
							s_Iqs[es][j][a] = tmps;
							s_Iqt[es][j][a] = tmpt;
						}
					}
				}
			}

			barrier(localMemFence);

			// transpose differentiate and interpolate in 's'
			for(int es=0; es<p_NblockG; ++es; inner2) {
				for(int b=0; b<p_gjNq; ++b; inner1) {
					for(int a=0; a<p_gjNq; ++a; inner0) {
						int t = a+p_gjNq*b;
						int ta = t%p_Nq; // need to know a,b for contiguous threads
						int tb = t/p_Nq;
						if(t<p_Nq*p_Nq) {
							dfloat tmpr = 0, tmps = 0, tmpt = 0;

							occaUnroll(p_gjNq)
							for(int j=0; j<p_gjNq; ++j) {
								tmpr += s_I[j][tb]*s_Dqr[es][j][ta];
								tmps += s_D[j][tb]*s_Iqs[es][j][ta];
								tmpt += s_I[j][tb]*s_Iqt[es][j][ta];
							}

							// transpose differentiate and interpolate in 't'
							occaUnroll(p_Nq)
							for(int c=0; c<p_Nq; ++c) {
								r_lapq[c] += s_I[k][c]*(tmpr+tmps);
								r_lapq[c] += s_D[k][c]*tmpt;
							}
						}
					}
				}
			}
		}

		for(int es=0; es<p_NblockG; ++es; inner2) {
			for(int b=0; b<p_gjNq; ++b; inner1) {
				for(int a=0; a<p_gjNq; ++a; inner0) {
					int t = a+b*p_gjNq;
					if(t<p_Nq*p_Nq) {
						int e = eo+es;
						if(e<Nelements) {
							for(int c=0; c<p_Nq; ++c) {
								Aq[e*p_Np + c*p_Nq2 + t] = r_lapq[c];
							}
						}
					}
				}
			}
		}
	}
}

#define p_Nthreads  (p_NblockG*p_gjNq*p_gjNq)

#define allThreads                              \
	for(int es=0; es<p_NblockG; ++es; inner2)        \
		for(int b=0; b<p_gjNq; ++b; inner1)            \
			for(int a=0; a<p_gjNq; ++a; inner0)


#if p_gNq==8 || p_gNq==16
#define p_gjPad 1
#else
#define p_gjPad 0
#endif

#if p_Nq==8 || p_Nq==16
#define p_gllPad 1
#else
#define p_gllPad 0
#endif

#define p_gllPad 0
#define p_gjPad 0

/* note that the gjGeo must be the geometric factors at the p_gjNp integration nodes */
kernel void ellipticPartialAxHex3D_e3(const int Nelements,
                                      const int * restrict elementList,
                                      const dfloat * restrict gjGeo,
                                      const dfloat * restrict gjD,
                                      const dfloat * restrict gjI,
                                      const dfloat lambda,
                                      const dfloat * restrict q,
                                      dfloat * restrict Aq,
                                      dfloat * restrict qAq){


	for(int eo=0; eo<Nelements; eo+=p_NblockG; outer0) {

		shared dfloat s_D[p_gjNq][p_Nq+p_gllPad];
		shared dfloat s_I[p_gjNq][p_Nq+p_gllPad];

		shared dfloat s_DT[p_Nq][p_gjNq+p_gjPad];
		shared dfloat s_IT[p_Nq][p_gjNq+p_gllPad];

		exclusive dfloat r_q[p_Nq];
		exclusive dfloat r_lapq[p_Nq];

		shared dfloat s_Ixxq[p_NblockG][p_Nq][p_Nq+p_gllPad];
		shared dfloat s_Dxxq[p_NblockG][p_Nq][p_Nq+p_gllPad];
		shared dfloat s_IxDq[p_NblockG][p_Nq][p_gjNq+p_gjPad];
		shared dfloat s_IxIq[p_NblockG][p_Nq][p_gjNq+p_gjPad];
		shared dfloat s_DxIq[p_NblockG][p_Nq][p_gjNq+p_gjPad];
		shared dfloat s_qr[p_NblockG][p_gjNq][p_gjNq+p_gjPad];
		shared dfloat s_qs[p_NblockG][p_gjNq][p_gjNq+p_gjPad];
		shared dfloat s_qt[p_NblockG][p_gjNq][p_gjNq+p_gjPad];

#if 1
		shared dfloat s_Dqr[p_NblockG][p_gjNq][p_Nq+p_gllPad];
		shared dfloat s_Iqs[p_NblockG][p_gjNq][p_Nq+p_gllPad];
		shared dfloat s_Iqt[p_NblockG][p_gjNq][p_Nq+p_gllPad];
#else
#define s_Dqr s_IxDq
#define s_Iqs s_IxIq
#define s_Iqt s_DxIq
#endif

		shared dfloat s_qI[p_NblockG][p_gjNq][p_gjNq+p_gjPad];

		exclusive int emap;
		exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;

		// prefetch D and I matrices and zero register storage
		for(int es=0; es<p_NblockG; ++es; inner2) {
			for(int b=0; b<p_gjNq; ++b; inner1) {
				for(int a=0; a<p_gjNq; ++a; inner0) {
					int t = a + b*p_gjNq + es*p_gjNq*p_gjNq;

					if(t<p_gjNq*p_Nq) {
						const int tb = t/p_Nq;
						const int ta = t%p_Nq;
#if 1
						s_D[tb][ta] = gjD[t];
						s_I[tb][ta] = gjI[t];
						s_DT[ta][tb] = gjD[t];
						s_IT[ta][tb] = gjI[t];
#endif

					}

					for(int c=0; c<p_Nq; ++c) {
						r_q[c] = 0;
						r_lapq[c] = 0;
					}

					int e = eo+es;
					if(e<Nelements) {
						emap = elementList[e];

						if(a<p_Nq && b<p_Nq) {

							occaUnroll(p_Nq)
							for(int c=0; c<p_Nq; ++c) {
								r_q[c] = q[emap*p_Np+c*p_Nq2+b*p_Nq+a];
							}
						}

					}
					else
						emap = -999999;

				}
			}
		}

		// scan through k slices

		for(int k=0; k<p_gjNq; ++k) {

			optBarrier(localMemFence);

			// prefetch slice
			for(int es=0; es<p_NblockG; ++es; inner2) {
				for(int b=0; b<p_gjNq; ++b; inner1) {
					for(int a=0; a<p_gjNq; ++a; inner0) {

						if(eo+es<Nelements) {

							const int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + b*p_gjNq + a;

							r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
							r_G00 = gjGeo[base+p_G00ID*p_gjNp];
							r_G01 = gjGeo[base+p_G01ID*p_gjNp];
							r_G02 = gjGeo[base+p_G02ID*p_gjNp];

							// assumes w*J built into G entries
							//dfloat	 r_G00, r_G01, r_G02, r_G11, r_G12, r_G22;

							if(a<p_Nq && b<p_Nq) {

								dfloat Iqk = 0, Dqk = 0;

								// puts more data in flight
								for(int c=0; c<p_Nq; ++c) {
									const dfloat qcba = r_q[c];
									//		  const dfloat qcba = q[emap*p_Np+c*p_Nq2+b*p_Nq+a];
									// I_{kc} q_{cba}
#if 1
									Iqk += s_I[k][c]*qcba;
									Dqk += s_D[k][c]*qcba;
#else
									Iqk += c_I[k][c]*qcba;
									Dqk += c_D[k][c]*qcba;
#endif
								}
								s_Ixxq[es][b][a] = Iqk;
								s_Dxxq[es][b][a] = Dqk;
							}
						}
					}
				}
			}

			optBarrier(localMemFence);

			// interpolate and differentiate in 'r' direction
			for(int es=0; es<p_NblockG; ++es; inner2) {
				for(int b=0; b<p_gjNq; ++b; inner1) {
					for(int i=0; i<p_gjNq; ++i; inner0) {

						if(es+eo<Nelements) {

							if(b<p_Nq) {
								dfloat IxDq= 0, IxIq = 0, DxIq = 0;

								//		occaUnroll(p_Nq)
								for(int a=0; a<p_Nq; ++a) {
#if 1
									const dfloat Iia = s_I[i][a];
									const dfloat Dia = s_D[i][a];
									const dfloat Ixxqba = s_Ixxq[es][b][a];
									IxDq += Dia*Ixxqba;
									IxIq += Iia*Ixxqba;
									DxIq += Iia*s_Dxxq[es][b][a];
#else
									IxDq += s_DT[a][i]*s_Ixxq[es][b][a];
									IxIq += s_IT[a][i]*s_Ixxq[es][b][a];
									DxIq += s_IT[a][i]*s_Dxxq[es][b][a];
#endif
								}

								s_IxDq[es][b][i] = IxDq;
								s_IxIq[es][b][i] = IxIq;
								s_DxIq[es][b][i] = DxIq;
							}
						}
					}
				}
			}

			optBarrier(localMemFence);

			for(int es=0; es<p_NblockG; ++es; inner2) {
				for(int j=0; j<p_gjNq; ++j; inner1) {
					for(int i=0; i<p_gjNq; ++i; inner0) {

						if(eo+es<Nelements) {


							dfloat qr = 0, qs = 0, qt = 0, qI = 0;

							// interpolate and differentiate in 's' direction
							//	      occaUnroll(p_Nq)
							for(int n=0; n<p_Nq; ++n) {
#if 0
								const dfloat Ijn = s_I[j][n];
								const dfloat Djn = s_D[j][n];
								qr += Ijn*s_IxDq[es][n][i];
								qt += Ijn*s_DxIq[es][n][i];
								qI += Ijn*s_IxIq[es][n][i];
								qs += Djn*s_IxIq[es][n][i];

#else
								const dfloat Ijn = s_IT[n][j];
								const dfloat Djn = s_DT[n][j];
								const dfloat IxIqni = s_IxIq[es][n][i];
								qr += Ijn*s_IxDq[es][n][i];
								qt += Ijn*s_DxIq[es][n][i];
								qI += Ijn*IxIqni;
								qs += Djn*IxIqni;

#endif
							}

							const int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;

							r_G11 = gjGeo[base+p_G11ID*p_gjNp];
							r_G12 = gjGeo[base+p_G12ID*p_gjNp];
							r_G22 = gjGeo[base+p_G22ID*p_gjNp];

							// apply chain rule (notice the swtich of indices in i,j)
							s_qr[es][i][j] = r_G00*qr + r_G01*qs + r_G02*qt;
							s_qs[es][i][j] = r_G01*qr + r_G11*qs + r_G12*qt;
							s_qt[es][i][j] = r_G02*qr + r_G12*qs + r_G22*qt;
							s_qI[es][i][j] = r_GwJ*qI*lambda;
						}
					}
				}
			}

			optBarrier(localMemFence);

			// transpose differentiate and interpolate in 'r'
			for(int es=0; es<p_NblockG; ++es; inner2) {
				for(int j=0; j<p_gjNq; ++j; inner1) {
					for(int a=0; a<p_gjNq; ++a; inner0) {

						if(eo+es<Nelements) {
							if(a<p_Nq) {
								dfloat tmpr = 0, tmps = 0, tmpt = 0, tmpI = 0;
								//		occaUnroll(p_gjNq)
								for(int i=0; i<p_gjNq; ++i) {
#if 1
									const dfloat Iia = s_I[i][a];
									const dfloat Dia = s_D[i][a];
									tmpr += Dia*s_qr[es][i][j];
									tmps += Iia*s_qs[es][i][j];
									tmpt += Iia*s_qt[es][i][j];
									tmpI += Iia*s_qI[es][i][j];
#else
									tmpr += s_DT[a][i]*s_qr[es][i][j];
									tmps += s_IT[a][i]*s_qs[es][i][j];
									tmpt += s_IT[a][i]*s_qt[es][i][j];
									tmpI += s_IT[a][i]*s_qI[es][i][j];
#endif
								}


								s_Dqr[es][j][a] = tmpr+tmpI; // blend lambda term in here
								s_Iqs[es][j][a] = tmps;
								s_Iqt[es][j][a] = tmpt;
							}
						}
					}
				}
			}

			optBarrier(localMemFence);

			// transpose differentiate and interpolate in 's'
			for(int es=0; es<p_NblockG; ++es; inner2) {
				for(int b=0; b<p_gjNq; ++b; inner1) {
					for(int a=0; a<p_gjNq; ++a; inner0) {
						if(eo+es<Nelements) {
							if(a<p_Nq && b<p_Nq) {
								dfloat tmpr = 0, tmps = 0, tmpt = 0;

								//		occaUnroll(p_gjNq)
								for(int j=0; j<p_gjNq; ++j) {
#if 1
									const dfloat Ijb = s_I[j][b];
									const dfloat Djb = s_D[j][b];

									tmpr += Ijb*s_Dqr[es][j][a];
									tmps += Djb*s_Iqs[es][j][a];
									tmpt += Ijb*s_Iqt[es][j][a];

#else
									tmpr += s_IT[b][j]*s_Dqr[es][j][a];
									tmps += s_DT[b][j]*s_Iqs[es][j][a];
									tmpt += s_IT[b][j]*s_Iqt[es][j][a];
#endif
								}

								// transpose differentiate and interpolate in 't'
								tmpr += tmps; // blend r and s
								//		  occaUnroll(p_Nq)
								for(int c=0; c<p_Nq; ++c) {
#if 1
									r_lapq[c] += s_I[k][c]*tmpr;
									r_lapq[c] += s_D[k][c]*tmpt;
#else
									r_lapq[c] += c_I[k][c]*tmpr;
									r_lapq[c] += c_D[k][c]*tmpt;
#endif
								}
							}
						}
					}
				}
			}
		}

		optBarrier(localMemFence);

		for(int es=0; es<p_NblockG; ++es; inner2) {
			for(int b=0; b<p_gjNq; ++b; inner1) {
				for(int a=0; a<p_gjNq; ++a; inner0) {

					dfloat r_qAq = 0;

					if(a<p_Nq && b<p_Nq) {
						if(eo+es<Nelements) {
							occaUnroll(p_Nq)
							for(int c=0; c<p_Nq; ++c) {
								const int id = emap*p_Np + c*p_Nq2 + b*p_Nq + a;
								Aq[id] = r_lapq[c];
							}
						}
					}
				}
			}
		}
	}
}


/* note that the gjGeo must be the geometric factors at the p_gjNp integration nodes */
kernel void ellipticPartialAxReductionHex3D_e3(const int Nelements,
    const int * restrict elementList,
    const dfloat * restrict gjGeo,
    const dfloat * restrict gjD,
    const dfloat * restrict gjI,
    const dfloat lambda,
    const dfloat * restrict q,
    dfloat * restrict Aq,
    dfloat * restrict qAq){


	for(int eo=0; eo<Nelements; eo+=p_NblockG; outer0) {

		volatile shared dfloat s_D[p_gjNq][p_Nq+p_gllPad];
		volatile shared dfloat s_I[p_gjNq][p_Nq+p_gllPad];
#if 0
		volatile shared dfloat s_DT[p_Nq][p_gjNq];
		volatile shared dfloat s_IT[p_Nq][p_gjNq];
#endif

		exclusive dfloat r_q[p_Nq];
		exclusive dfloat r_lapq[p_Nq];

		volatile shared dfloat s_Ixxq[p_NblockG][p_Nq][p_Nq+p_gllPad];
		volatile shared dfloat s_Dxxq[p_NblockG][p_Nq][p_Nq+p_gllPad];
		volatile shared dfloat s_IxDq[p_NblockG][p_Nq][p_gjNq+p_gjPad];
		volatile shared dfloat s_IxIq[p_NblockG][p_Nq][p_gjNq+p_gjPad];
		volatile shared dfloat s_DxIq[p_NblockG][p_Nq][p_gjNq+p_gjPad];
		volatile shared dfloat s_qr[p_NblockG][p_gjNq][p_gjNq+p_gjPad];
		volatile shared dfloat s_qs[p_NblockG][p_gjNq][p_gjNq+p_gjPad];
		volatile shared dfloat s_qt[p_NblockG][p_gjNq][p_gjNq+p_gjPad];
		//    volatile shared dfloat s_Dqr[p_NblockG][p_Nq][p_gjNq], s_Iqs[p_NblockG][p_Nq][p_gjNq], s_Iqt[p_NblockG][p_Nq][p_gjNq];
#if 1
		volatile shared dfloat s_red[p_NblockG*p_gjNq*p_gjNq];
#endif
		volatile shared dfloat s_qI[p_NblockG][p_gjNq][p_gjNq+p_gjPad];

#if 1
#define s_Dqr s_IxDq
#define s_Iqs s_IxIq
#define s_Iqt s_DxIq
		//#define s_red s_qr[0][0]

#endif

		exclusive int emap, thread;
		exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;

		// prefetch D and I matrices and zero register storage
		for(int es=0; es<p_NblockG; ++es; inner2) {
			for(int b=0; b<p_gjNq; ++b; inner1) {
				for(int a=0; a<p_gjNq; ++a; inner0) {
					int t = a + b*p_gjNq + es*p_gjNq*p_gjNq;

					if(t<p_gjNq*p_Nq) {
						const int tb = t/p_Nq;
						const int ta = t%p_Nq;
						s_D[tb][ta] = gjD[t];
						s_I[tb][ta] = gjI[t];
#if 0
						s_DT[0][t] = gjD[t];
						s_IT[0][t] = gjI[t];
#endif
					}

					for(int c=0; c<p_Nq; ++c) {
						r_q[c] = 0;
						r_lapq[c] = 0;
					}

					int e = eo+es;
					if(e<Nelements) {
						emap = elementList[e];
#if 1
						if(a<p_Nq && b<p_Nq) {
							for(int c=0; c<p_Nq; ++c) {
								r_q[c] = q[emap*p_Np+c*p_Nq2+b*p_Nq+a];
							}
						}
#endif
					}
					else
						emap = -999999;

				}
			}
		}

		// scan through k slices

		//    occaUnroll(p_gjNq)
		for(int k=0; k<p_gjNq; ++k) {

			optBarrier(localMemFence);

			// prefetch slice
			for(int es=0; es<p_NblockG; ++es; inner2) {
				for(int b=0; b<p_gjNq; ++b; inner1) {
					for(int a=0; a<p_gjNq; ++a; inner0) {
						if(eo+es<Nelements) {

							// assumes w*J built into G entries
							//dfloat	 r_G00, r_G01, r_G02, r_G11, r_G12, r_G22;
							const int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + b*p_gjNq + a;

							r_GwJ = gjGeo[base+p_GWJID*p_gjNp];

							r_G00 = gjGeo[base+p_G00ID*p_gjNp];
							r_G01 = gjGeo[base+p_G01ID*p_gjNp];
							r_G02 = gjGeo[base+p_G02ID*p_gjNp];

							r_G11 = gjGeo[base+p_G11ID*p_gjNp];
							r_G12 = gjGeo[base+p_G12ID*p_gjNp];
							r_G22 = gjGeo[base+p_G22ID*p_gjNp];

							if(a<p_Nq && b<p_Nq) {

								dfloat Iqk = 0, Dqk = 0;

								// puts more data in flight
								for(int c=0; c<p_Nq; ++c) {
									const dfloat qcba = r_q[c];
									//		  const dfloat qcba = q[emap*p_Np+c*p_Nq2+b*p_Nq+a];
									// I_{kc} q_{cba}
#if 1
									Iqk += s_I[k][c]*qcba;
									Dqk += s_D[k][c]*qcba;
#else
									Iqk += c_I[k][c]*qcba;
									Dqk += c_D[k][c]*qcba;
#endif
								}
								s_Ixxq[es][b][a] = Iqk;
								s_Dxxq[es][b][a] = Dqk;
							}
						}
					}
				}
			}

			optBarrier(localMemFence);

			// interpolate and differentiate in 'r' direction
			for(int es=0; es<p_NblockG; ++es; inner2) {
				for(int b=0; b<p_gjNq; ++b; inner1) {
					for(int i=0; i<p_gjNq; ++i; inner0) {

						if(es+eo<Nelements) {

							if(b<p_Nq) {
								dfloat IxDq= 0, IxIq = 0, DxIq = 0;

								occaUnroll(p_Nq)
								for(int a=0; a<p_Nq; ++a) {
#if 1
									IxDq += s_D[i][a]*s_Ixxq[es][b][a];
									IxIq += s_I[i][a]*s_Ixxq[es][b][a];
									DxIq += s_I[i][a]*s_Dxxq[es][b][a];
#else
									IxDq += s_DT[a][i]*s_Ixxq[es][b][a];
									IxIq += s_IT[a][i]*s_Ixxq[es][b][a];
									DxIq += s_IT[a][i]*s_Dxxq[es][b][a];
#endif
								}

								s_IxDq[es][b][i] = IxDq;
								s_IxIq[es][b][i] = IxIq;
								s_DxIq[es][b][i] = DxIq;
							}
						}
					}
				}
			}

			optBarrier(localMemFence);

			for(int es=0; es<p_NblockG; ++es; inner2) {
				for(int j=0; j<p_gjNq; ++j; inner1) {
					for(int i=0; i<p_gjNq; ++i; inner0) {

						if(eo+es<Nelements) {

							dfloat qr = 0, qs = 0, qt = 0, qI = 0;

							// interpolate and differentiate in 's' direction
							occaUnroll(p_Nq)
							for(int n=0; n<p_Nq; ++n) {
#if 1
								qr += s_I[j][n]*s_IxDq[es][n][i];
								qt += s_I[j][n]*s_DxIq[es][n][i];
								qI += s_I[j][n]*s_IxIq[es][n][i];
								qs += s_D[j][n]*s_IxIq[es][n][i];

#else
								qr += s_IT[n][j]*s_IxDq[es][n][i];
								qt += s_IT[n][j]*s_DxIq[es][n][i];
								qI += s_IT[n][j]*s_IxIq[es][n][i];
								qs += s_DT[n][j]*s_IxIq[es][n][i];

#endif
							}


							// apply chain rule (notice the swtich of indices in i,j)
							s_qr[es][i][j] = r_G00*qr + r_G01*qs + r_G02*qt;
							s_qs[es][i][j] = r_G01*qr + r_G11*qs + r_G12*qt;
							s_qt[es][i][j] = r_G02*qr + r_G12*qs + r_G22*qt;
							s_qI[es][i][j] = r_GwJ*qI*lambda;
						}
					}
				}
			}

			optBarrier(localMemFence);

			// transpose differentiate and interpolate in 'r'
			for(int es=0; es<p_NblockG; ++es; inner2) {
				for(int j=0; j<p_gjNq; ++j; inner1) {
					for(int a=0; a<p_gjNq; ++a; inner0) {

						if(eo+es<Nelements) {
							if(a<p_Nq) {
								dfloat tmpr = 0, tmps = 0, tmpt = 0, tmpI = 0;
								occaUnroll(p_gjNq)
								for(int i=0; i<p_gjNq; ++i) {
#if 1
									tmpr += s_D[i][a]*s_qr[es][i][j];
									tmps += s_I[i][a]*s_qs[es][i][j];
									tmpt += s_I[i][a]*s_qt[es][i][j];
									tmpI += s_I[i][a]*s_qI[es][i][j];
#else
									tmpr += s_DT[a][i]*s_qr[es][i][j];
									tmps += s_IT[a][i]*s_qs[es][i][j];
									tmpt += s_IT[a][i]*s_qt[es][i][j];
									tmpI += s_IT[a][i]*s_qI[es][i][j];
#endif
								}

								s_Dqr[es][a][j] = tmpr+tmpI; // blend lambda term in here
								s_Iqs[es][a][j] = tmps;
								s_Iqt[es][a][j] = tmpt;
							}
						}
					}
				}
			}

			optBarrier(localMemFence);

			// transpose differentiate and interpolate in 's'
			for(int es=0; es<p_NblockG; ++es; inner2) {
				for(int b=0; b<p_gjNq; ++b; inner1) {
					for(int a=0; a<p_gjNq; ++a; inner0) {
						if(eo+es<Nelements) {
							if(a<p_Nq && b<p_Nq) {
								dfloat tmpr = 0, tmps = 0, tmpt = 0;

								occaUnroll(p_gjNq)
								for(int j=0; j<p_gjNq; ++j) {
#if 1
									tmpr += s_I[j][b]*s_Dqr[es][a][j];
									tmps += s_D[j][b]*s_Iqs[es][a][j];
									tmpt += s_I[j][b]*s_Iqt[es][a][j];
#else
									tmpr += s_IT[b][j]*s_Dqr[es][a][j];
									tmps += s_DT[b][j]*s_Iqs[es][a][j];
									tmpt += s_IT[b][j]*s_Iqt[es][a][j];
#endif
								}

								// transpose differentiate and interpolate in 't'
								tmpr += tmps; // blend r and s
								occaUnroll(p_Nq)
								for(int c=0; c<p_Nq; ++c) {
#if 1
									r_lapq[c] += s_I[k][c]*tmpr;
									r_lapq[c] += s_D[k][c]*tmpt;
#else
									r_lapq[c] += c_I[k][c]*tmpr;
									r_lapq[c] += c_D[k][c]*tmpt;
#endif
								}
							}
						}
					}
				}
			}
		}

		optBarrier(localMemFence);

		for(int es=0; es<p_NblockG; ++es; inner2) {
			for(int b=0; b<p_gjNq; ++b; inner1) {
				for(int a=0; a<p_gjNq; ++a; inner0) {

					dfloat r_qAq = 0;

					if(a<p_Nq && b<p_Nq) {
						if(eo+es<Nelements) {
							for(int c=0; c<p_Nq; ++c) {
								const int id = emap*p_Np + c*p_Nq2 + b*p_Nq + a;
								Aq[id] = r_lapq[c];
		#if 0
								r_qAq += r_q[c]*r_lapq[c]; // should buffer q ?
		#endif
								//r_qAq += q[id]*r_lapq[c]; // should buffer q ?
							}
						}
					}
#if 0
					thread =  a + b*p_gjNq + es*p_gjNq*p_gjNq;
					s_red[thread] = r_qAq;
#endif
				}
			}
		}

#if 0
		optBarrier(localMemFence);

#if (p_Nthreads>512)
		allThreads
		if(thread+512<p_Nthreads && thread<512)
			s_red[thread] += s_red[thread+512];
#endif

#if (p_Nthreads>256)
		optBarrier(localMemFence);
		allThreads
		if(thread+256<p_Nthreads && thread<256)
			s_red[thread] += s_red[thread+256];
#endif

#if (p_Nthreads>128)
		optBarrier(localMemFence);
		allThreads
		if(thread+128<p_Nthreads && thread<128)
			s_red[thread] += s_red[thread+128];
#endif

#if (p_Nthreads>64)
		optBarrier(localMemFence);
		allThreads
		if(thread+64<p_Nthreads && thread<64)
			s_red[thread] += s_red[thread+64];
#endif

#if (p_Nthreads>32)
		optBarrier(localMemFence);
		allThreads
		if(thread+32<p_Nthreads && thread<32)
			s_red[thread] += s_red[thread+32];
#endif

#if (p_Nthreads>16)
		allThreads
		if(thread+16<p_Nthreads && thread<16)
			s_red[thread] += s_red[thread+16];
#endif

#if (p_Nthreads>8)
		allThreads
		if(thread+8<p_Nthreads && thread<8)
			s_red[thread] += s_red[thread+8];
#endif

#if (p_Nthreads>4)
		allThreads
		if(thread+4<p_Nthreads && thread<4)
			s_red[thread] += s_red[thread+4];
#endif

#if (p_Nthreads>2)
		allThreads
		if(thread+2<p_Nthreads && thread<2)
			s_red[thread] += s_red[thread+2];
#endif

#if (p_Nthreads>1)
		allThreads
		if(thread+1<p_Nthreads && thread==0)
			s_red[thread] += s_red[thread+1];
#endif
		allThreads
		if(thread==0) {
			const dfloat r_qAq = s_red[0];
			atomicAdd(qAq, r_qAq);
		}
#endif
	}
#undef s_Dqr
#undef s_Iqs
#undef s_Iqt
}


/* note that the gjGeo must be the geometric factors at the p_gjNp integration nodes */
kernel void ellipticPartialAxHex3D_e5(const int Nelements,
                                      const int * restrict elementList,
                                      const dfloat * restrict gjGeo,
                                      const dfloat * restrict gjD,
                                      const dfloat * restrict gjI,
                                      const dfloat lambda,
                                      const dfloat * restrict q,
                                      dfloat * restrict Aq,
                                      dfloat * restrict qAq){


	for(int eo=0; eo<Nelements; eo+=p_NblockG; outer0) {

		volatile shared dfloat s_D[p_gjNq][p_Nq+p_gllPad];
		volatile shared dfloat s_I[p_gjNq][p_Nq+p_gllPad];

		volatile shared dfloat s_DT[p_Nq][p_gjNq+p_gjPad];
		volatile shared dfloat s_IT[p_Nq][p_gjNq+p_gllPad];

		exclusive dfloat r_q[p_Nq];
		exclusive dfloat r_lapq[p_Nq];

		volatile shared dfloat s_Ixxq[p_NblockG][p_Nq][p_Nq+p_gllPad];
		volatile shared dfloat s_Dxxq[p_NblockG][p_Nq][p_Nq+p_gllPad];
		volatile shared dfloat s_IxDq[p_NblockG][p_Nq][p_gjNq+p_gjPad];
		volatile shared dfloat s_IxIq[p_NblockG][p_Nq][p_gjNq+p_gjPad];
		volatile shared dfloat s_DxIq[p_NblockG][p_Nq][p_gjNq+p_gjPad];
		volatile shared dfloat s_qr[p_NblockG][p_gjNq][p_gjNq+p_gjPad];
		volatile shared dfloat s_qs[p_NblockG][p_gjNq][p_gjNq+p_gjPad];
		volatile shared dfloat s_qt[p_NblockG][p_gjNq][p_gjNq+p_gjPad];

		volatile shared dfloat s_Dqr[p_NblockG][p_gjNq][p_Nq+p_gllPad];
		volatile shared dfloat s_Iqs[p_NblockG][p_gjNq][p_Nq+p_gllPad];
		volatile shared dfloat s_Iqt[p_NblockG][p_gjNq][p_Nq+p_gllPad];

		volatile shared dfloat s_qI[p_NblockG][p_gjNq][p_gjNq+p_gjPad];

		exclusive int emap;
		exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;

		// prefetch D and I matrices and zero register storage
		for(int es=0; es<p_NblockG; ++es; inner2) {
			for(int b=0; b<p_gjNq; ++b; inner1) {
				for(int a=0; a<p_gjNq; ++a; inner0) {
					int t = a + b*p_gjNq + es*p_gjNq*p_gjNq;

					if(t<p_gjNq*p_Nq) {
						const int tb = t/p_Nq;
						const int ta = t%p_Nq;
#if 1
						s_D[tb][ta] = gjD[t];
						s_I[tb][ta] = gjI[t];
						s_DT[ta][tb] = gjD[t];
						s_IT[ta][tb] = gjI[t];
#endif

					}

					for(int c=0; c<p_Nq; ++c) {
						r_q[c] = 0;
						r_lapq[c] = 0;
					}

					int e = eo+es;
					if(e<Nelements) {
						emap = elementList[e];

						if(a<p_Nq && b<p_Nq) {

							occaUnroll(p_Nq)
							for(int c=0; c<p_Nq; ++c) {
								r_q[c] = q[emap*p_Np+c*p_Nq2+b*p_Nq+a];
							}
						}

					}
					else
						emap = -999999;

				}
			}
		}

		// scan through k slices
		for(int k=0; k<p_gjNq; ++k) {

			optBarrier(localMemFence);

			// prefetch slice
			for(int es=0; es<p_NblockG; ++es; inner2) {
				for(int b=0; b<p_gjNq; ++b; inner1) {
					for(int a=0; a<p_gjNq; ++a; inner0) {
						if(eo+es<Nelements) {

							// assumes w*J built into G entries
							//dfloat	 r_G00, r_G01, r_G02, r_G11, r_G12, r_G22;
							const int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + b*p_gjNq + a;

							r_GwJ = gjGeo[base+p_GWJID*p_gjNp];

							r_G00 = gjGeo[base+p_G00ID*p_gjNp];
							r_G01 = gjGeo[base+p_G01ID*p_gjNp];
							r_G02 = gjGeo[base+p_G02ID*p_gjNp];

							r_G11 = gjGeo[base+p_G11ID*p_gjNp];
							r_G12 = gjGeo[base+p_G12ID*p_gjNp];
							r_G22 = gjGeo[base+p_G22ID*p_gjNp];

							if(a<p_Nq && b<p_Nq) {

								dfloat Iqk = 0, Dqk = 0;

								// puts more data in flight
								for(int c=0; c<p_Nq; ++c) {
									const dfloat qcba = r_q[c];
									//		  const dfloat qcba = q[emap*p_Np+c*p_Nq2+b*p_Nq+a];
									// I_{kc} q_{cba}
#if 1
									Iqk += s_I[k][c]*qcba;
									Dqk += s_D[k][c]*qcba;
#else
									Iqk += c_I[k][c]*qcba;
									Dqk += c_D[k][c]*qcba;
#endif
								}
								s_Ixxq[es][b][a] = Iqk;
								s_Dxxq[es][b][a] = Dqk;
							}
						}
					}
				}
			}

			optBarrier(localMemFence);

			// interpolate and differentiate in 'r' direction
			for(int es=0; es<p_NblockG; ++es; inner2) {
				for(int j=0; j<p_gjNq; ++j; inner1) {
					for(int i=0; i<p_gjNq; ++i; inner0) {

						if(es+eo<Nelements) {

							dfloat IIIq = 0, IIDq= 0, IDIq = 0, DIIq = 0;

							for(int b=0; b<p_Nq; ++b) {
								const dfloat Ijb = s_I[j][b];
								const dfloat Djb = s_D[j][b];
								for(int a=0; a<p_Nq; ++a) {
									const dfloat qba = s_Ixxq[es][b][a];
									const dfloat Iia = s_I[i][a];
									const dfloat Dia = s_D[i][a];
									IIIq += Iia*Ijb*qba;
									IIDq += Dia*Ijb*qba;
									IDIq += Iia*Djb*qba;
									DIIq += Iia*Ijb*s_Dxxq[es][b][a];
								}
							}

							// apply chain rule (notice the swtich of indices in i,j)
							s_qr[es][i][j] = r_G00*IIDq + r_G01*IDIq + r_G02*DIIq;
							s_qs[es][i][j] = r_G01*IIDq + r_G11*IDIq + r_G12*DIIq;
							s_qt[es][i][j] = r_G02*IIDq + r_G12*IDIq + r_G22*DIIq;
							s_qI[es][i][j] = r_GwJ*IIIq*lambda;
						}
					}
				}
			}

			optBarrier(localMemFence);

			// transpose differentiate and interpolate in 'r'
			for(int es=0; es<p_NblockG; ++es; inner2) {
				for(int j=0; j<p_gjNq; ++j; inner1) {
					for(int a=0; a<p_gjNq; ++a; inner0) {

						if(eo+es<Nelements) {
							if(a<p_Nq) {
								dfloat tmpr = 0, tmps = 0, tmpt = 0, tmpI = 0;
								//		occaUnroll(p_gjNq)
								for(int i=0; i<p_gjNq; ++i) {
#if 1
									tmpr += s_D[i][a]*s_qr[es][i][j];
									tmps += s_I[i][a]*s_qs[es][i][j];
									tmpt += s_I[i][a]*s_qt[es][i][j];
									tmpI += s_I[i][a]*s_qI[es][i][j];
#else
									tmpr += s_DT[a][i]*s_qr[es][i][j];
									tmps += s_IT[a][i]*s_qs[es][i][j];
									tmpt += s_IT[a][i]*s_qt[es][i][j];
									tmpI += s_IT[a][i]*s_qI[es][i][j];
#endif
								}

								s_Dqr[es][j][a] = tmpr+tmpI; // blend lambda term in here
								s_Iqs[es][j][a] = tmps;
								s_Iqt[es][j][a] = tmpt;
							}
						}
					}
				}
			}

			optBarrier(localMemFence);

			// transpose differentiate and interpolate in 's'
			for(int es=0; es<p_NblockG; ++es; inner2) {
				for(int b=0; b<p_gjNq; ++b; inner1) {
					for(int a=0; a<p_gjNq; ++a; inner0) {
						if(eo+es<Nelements) {
							if(a<p_Nq && b<p_Nq) {
								dfloat tmpr = 0, tmps = 0, tmpt = 0;

								//		occaUnroll(p_gjNq)
								for(int j=0; j<p_gjNq; ++j) {
#if 1
									tmpr += s_I[j][b]*s_Dqr[es][j][a];
									tmps += s_D[j][b]*s_Iqs[es][j][a];
									tmpt += s_I[j][b]*s_Iqt[es][j][a];
#else
									tmpr += s_IT[b][j]*s_Dqr[es][j][a];
									tmps += s_DT[b][j]*s_Iqs[es][j][a];
									tmpt += s_IT[b][j]*s_Iqt[es][j][a];
#endif
								}

								// transpose differentiate and interpolate in 't'
								tmpr += tmps; // blend r and s
								occaUnroll(p_Nq)
								for(int c=0; c<p_Nq; ++c) {
#if 1
									r_lapq[c] += s_I[k][c]*tmpr;
									r_lapq[c] += s_D[k][c]*tmpt;
#else
									r_lapq[c] += c_I[k][c]*tmpr;
									r_lapq[c] += c_D[k][c]*tmpt;
#endif
								}
							}
						}
					}
				}
			}
		}

		optBarrier(localMemFence);

		for(int es=0; es<p_NblockG; ++es; inner2) {
			for(int b=0; b<p_gjNq; ++b; inner1) {
				for(int a=0; a<p_gjNq; ++a; inner0) {

					dfloat r_qAq = 0;

					if(a<p_Nq && b<p_Nq) {
						if(eo+es<Nelements) {
							occaUnroll(p_Nq)
							for(int c=0; c<p_Nq; ++c) {
								const int id = emap*p_Np + c*p_Nq2 + b*p_Nq + a;
								Aq[id] = r_lapq[c];
							}
						}
					}
				}
			}
		}
	}
}


kernel void ellipticPartialAxHex3D_e6(const int Nelements,
                                      const int * restrict elementList,
                                      const dfloat * restrict gjGeo,
                                      const dfloat * restrict gjD,
                                      const dfloat * restrict gjI,
                                      const dfloat lambda,
                                      dfloat * restrict q,
                                      dfloat * restrict Aq,
                                      dfloat * restrict qAq){
	//KS Nall = 64000, mesh->Np = 125 mesh->Nelements = 512
	for(int e=0; e<Nelements; ++e; outer0) {

		//KS: every thread processes one element
		// p_Nq number of points in the element
		//KS: Nggeo = 7, gjNq = 6, gjNp = 216 Nq = 5


		shared dfloat s_D[p_gjNq][p_Nq+p_gllPad];
		shared dfloat s_I[p_gjNq][p_Nq+p_gllPad];

		exclusive dfloat r_q[p_Nq];
		exclusive dfloat r_lapq[p_Nq];

		shared dfloat s_Ixxq[p_Nq][p_Nq+p_gllPad];
		shared dfloat s_Dxxq[p_Nq][p_Nq+p_gllPad];

		shared dfloat s_IxDq[p_Nq][p_gjNq+p_gjPad];
		shared dfloat s_IxIq[p_Nq][p_gjNq+p_gjPad];
		shared dfloat s_DxIq[p_Nq][p_gjNq+p_gjPad];

		shared dfloat s_qr[p_gjNq][p_gjNq+p_gjPad];
		shared dfloat s_qs[p_gjNq][p_gjNq+p_gjPad];
		shared dfloat s_qt[p_gjNq][p_gjNq+p_gjPad];

		shared dfloat s_Dqr[p_gjNq][p_Nq+p_gllPad];
		shared dfloat s_Iqs[p_gjNq][p_Nq+p_gllPad];
		shared dfloat s_Iqt[p_gjNq][p_Nq+p_gllPad];

		shared dfloat s_qI[p_gjNq][p_gjNq+p_gjPad];

		exclusive int emap, ta, tb;
		exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;
		// less registers (by half) or less shared (ny half)
		// get rid of one of the register arrryas
		// use a cube of shared
		// rewrite

		// put q in shared
		// interpolation matrix in 3 directions
		// change which D we using (larger D) gjN

		// prefetch D and I matrices and zero register storage
		for(int b=0; b<p_gjNq; ++b; inner1) {
			for(int a=0; a<p_gjNq; ++a; inner0) {
				const int t = a + p_gjNq*b;

				if(a<p_Nq && b<p_gjNq) {
					s_D[b][a] = gjD[b*p_Nq+a];
					s_I[b][a] = gjI[b*p_Nq+a];
				}

				for(int c=0; c<p_Nq; ++c) {
					//	  r_q[c] = 0;
					r_lapq[c] = 0;
				}

				emap = elementList[e];
				//Nq2 = Nq*Nq
				if(a<p_Nq && b<p_Nq) {

					occaUnroll(p_Nq)
					for(int c=0; c<p_Nq; ++c) {
						r_q[c] = q[emap*p_Np+c*p_Nq2+b*p_Nq+a];
					}                                                                                                                                                        //for c
				}                                                                                                                                                        //if
			}                                                                                                                                                        //for a
		}                                                                                                                                                        //for b

		// *************** scan through k slices
		// ==================================== prefetch first, diff in 't'
		for(int k=0; k<p_gjNq; ++k) {

			optBarrier(localMemFence);

			// prefetch slice
			for(int b=0; b<p_gjNq; ++b; inner1) {
				for(int a=0; a<p_gjNq; ++a; inner0) {

					const int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + b*p_gjNq + a;
					r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
					r_G00 = gjGeo[base+p_G00ID*p_gjNp];
					r_G01 = gjGeo[base+p_G01ID*p_gjNp];
					r_G02 = gjGeo[base+p_G02ID*p_gjNp];

					r_G11 = gjGeo[base+p_G11ID*p_gjNp];
					r_G12 = gjGeo[base+p_G12ID*p_gjNp];
					r_G22 = gjGeo[base+p_G22ID*p_gjNp];
					// assumes w*J built into G entries

					if (a<p_Nq && b<p_Nq) {

						dfloat Iqk = 0, Dqk = 0;

						// puts more data in flight
						for(int c=0; c<p_Nq; ++c) {
							const dfloat qcba = r_q[c];
							Iqk += s_I[k][c]*qcba;
							Dqk += s_D[k][c]*qcba;
						}
						s_Ixxq[b][a] = Iqk;
						s_Dxxq[b][a] = Dqk;
					}
				}
			}

			optBarrier(localMemFence);
			//=========================== r direction =========================================
			// interpolate and differentiate in 'r' direction
			for(int b=0; b<p_gjNq; ++b; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {

					if(b<p_Nq) {

						dfloat IxDq= 0, IxIq = 0, DxIq = 0;

						occaUnroll(p_Nq)
						for(int a=0; a<p_Nq; ++a) {
							const dfloat Iia = s_I[i][a];
							const dfloat Ixxqba = s_Ixxq[b][a];
							IxIq += Iia*Ixxqba;
							DxIq += Iia*s_Dxxq[b][a];
						}

						occaUnroll(p_Nq)
						for(int a=0; a<p_Nq; ++a) {
							const dfloat Dia = s_D[i][a];
							const dfloat Ixxqba = s_Ixxq[b][a];
							IxDq += Dia*Ixxqba;
						}

						s_IxDq[b][i] = IxDq;
						// this is what we want
						s_IxIq[b][i] = IxIq;
						s_DxIq[b][i] = DxIq;
					}
				}
			}

			optBarrier(localMemFence);
			//=============================== derivatives =========================================
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {

					dfloat qr = 0, qs = 0, qt = 0, qI = 0;

					// interpolate and differentiate in 's' direction
					occaUnroll(p_Nq)
					for(int b=0; b<p_Nq; ++b) {
						const dfloat Ijn = s_I[j][b];
						// qr = dq/dr, qt = dq/dt and qI = dq/dI
						qr += Ijn*s_IxDq[b][i];
						qt += Ijn*s_DxIq[b][i];
						qI += Ijn*s_IxIq[b][i];
					}

					occaUnroll(p_Nq)
					//qs = dq/ds
					for(int b=0; b<p_Nq; ++b) {
						const dfloat Djn = s_D[j][b];
						qs += Djn*s_IxIq[b][i];
					}

					// apply chain rule (notice the swtich of indices in i,j)
					s_qr[i][j] = r_G00*qr + r_G01*qs + r_G02*qt;
					s_qs[i][j] = r_G01*qr + r_G11*qs + r_G12*qt;
					s_qt[i][j] = r_G02*qr + r_G12*qs + r_G22*qt;
					// qI needed because of interpolation (?)
					s_qI[i][j] = r_GwJ*qI*lambda;
				}                                                                                                                                                        // for i
			}                                                                                                                                                        // for j
			// =============================== transpose differentiate ==============================
			optBarrier(localMemFence);

			// transpose differentiate and interpolate in 'r'
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int a=0; a<p_gjNq; ++a; inner0) {

					if(a<p_Nq) {
						dfloat tmpr = 0, tmps = 0, tmpt = 0, tmpI = 0;
						occaUnroll(p_gjNq)
						for(int i=0; i<p_gjNq; ++i) {
							const dfloat Iia = s_I[i][a];
							tmps += Iia*s_qs[i][j];
							tmpt += Iia*s_qt[i][j];
							tmpI += Iia*s_qI[i][j];
						}

						occaUnroll(p_gjNq)
						for(int i=0; i<p_gjNq; ++i) {
							const dfloat Dia = s_D[i][a];
							tmpr += Dia*s_qr[i][j];
						}

						s_Dqr[j][a] = tmpr+tmpI;                                                                                                                                                         // blend lambda term in here
						s_Iqs[j][a] = tmps;
						s_Iqt[j][a] = tmpt;
					}
				}
			}

			optBarrier(localMemFence);

			// transpose differentiate and interpolate in 's'
			for(int b=0; b<p_gjNq; ++b; inner1) {
				for(int a=0; a<p_gjNq; ++a; inner0) {
					if(a<p_Nq && b<p_Nq) {
						dfloat tmpr = 0, tmps = 0, tmpt = 0;

						occaUnroll(p_gjNq)
						for(int j=0; j<p_gjNq; ++j) {
							const dfloat Ijb = s_I[j][b];

							tmpr += Ijb*s_Dqr[j][a];
							tmpt += Ijb*s_Iqt[j][a];
						}


						occaUnroll(p_gjNq)
						for(int j=0; j<p_gjNq; ++j) {
							const dfloat Djb = s_D[j][b];

							tmps += Djb*s_Iqs[j][a];
						}

						// transpose differentiate and interpolate in 't'
						tmpr += tmps;                                                                                                                                                         // blend r and s
						occaUnroll(p_Nq)
						for(int c=0; c<p_Nq; ++c) {
							r_lapq[c] += s_I[k][c]*tmpr + s_D[k][c]*tmpt;
						}
					}
				}
			}
		}                                                                                                                                                        // this is FOR k

		//    optBarrier(localMemFence);

		for(int b=0; b<p_gjNq; ++b; inner1) {
			for(int a=0; a<p_gjNq; ++a; inner0) {

				dfloat r_qAq = 0;

				if(a<p_Nq && b<p_Nq) {
					occaUnroll(p_Nq)
					for(int c=0; c<p_Nq; ++c) {
						const int id = emap*p_Np + c*p_Nq2 + b*p_Nq + a;
						Aq[id] = r_lapq[c];
					}
				}
			}
		}
	}
}



kernel void ellipticPartialAxHex3D_e6a(const int Nelements,
                                       const int * restrict elementList,
                                       const dfloat * restrict gjGeo,
                                       const dfloat * restrict gjD,
                                       const dfloat * restrict gjI,
                                       const dfloat   lambda,
                                       const dfloat * restrict q,
                                       dfloat * restrict Aq,
                                       const dfloat * restrict qAq){


	for(int e=0;e<Nelements;++e;outer0){

		shared dfloat s_D[p_gjNq][p_gjNq];
		shared dfloat s_I[p_gjNq][p_Nq+p_gllPad];

		exclusive dfloat r_lapq[p_gjNq];

		shared dfloat s_qr[p_gjNq][p_gjNq+p_gjPad];
		shared dfloat s_qs[p_gjNq][p_gjNq+p_gjPad];

		shared dfloat s_tmpq[p_gjNq][p_gjNq][p_gjNq];

		exclusive int emap;
		exclusive dfloat r_qt;

		// prefetch D and I matrices and zero register storage
		for(int b=0;b<p_gjNq;++b;inner1){
			for(int a=0;a<p_gjNq;++a;inner0){

				emap = elementList[e];

				const int t = a + p_gjNq*b;

				s_D[b][a] = gjD[b*p_gjNq+a];

				if(a<p_Nq && b<p_gjNq)
					s_I[b][a] = gjI[b*p_Nq+a];

				if(a<p_Nq && b<p_Nq){
					// prefetch q(a,b,:) to registers
					occaUnroll(p_Nq)
					for(int c=0;c<p_Nq;++c){
						r_lapq[c] = q[emap*p_Np+c*p_Nq2+b*p_Nq+a];
					}
				}
			}
		}

		barrier(localMemFence);

		for(int b=0;b<p_gjNq;++b;inner1){
			for(int a=0;a<p_gjNq;++a;inner0){

				if(a<p_Nq && b<p_Nq){

					occaUnroll(p_Nq)
					for(int k=0;k<p_gjNq;++k){
						dfloat tmp = 0;

						occaUnroll(p_Nq)
						for(int c=0;c<p_Nq;++c){
							tmp += s_I[k][c]*r_lapq[c];
						}

						s_tmpq[k][b][a] = tmp;
					}
				}
				occaUnroll(p_gjNq)
				for(int k=0;k<p_gjNq;++k){
					r_lapq[k] = 0;
				}
			}
		}

		// scan through k slices
		// interpolate to GJ in each 'r' and 's' direction
		occaUnroll(p_gjNq)
		for(int k=0;k<p_gjNq;++k){

			barrier(localMemFence);

			for(int b=0;b<p_gjNq;++b;inner1){
				for(int i=0;i<p_gjNq;++i;inner0){
					dfloat tmp = 0;

					if(b<p_Nq){
						occaUnroll(p_Nq)
						for(int a=0;a<p_Nq;++a){
							tmp += s_I[i][a]*s_tmpq[k][b][a];
						}
					}
					s_qr[b][i] = tmp;
				}
			}

			barrier(localMemFence);

			for(int j=0;j<p_gjNq;++j;inner1){
				for(int i=0;i<p_gjNq;++i;inner0){

					dfloat tmp = 0;

					occaUnroll(p_Nq)
					for(int b=0;b<p_Nq;++b){
						tmp += s_I[j][b]*s_qr[b][i];
					}

					s_tmpq[k][j][i] = tmp;
				}
			}
		}

		occaUnroll(p_gjNq)
		for(int k=0;k<p_gjNq;++k){

			barrier(localMemFence);

			for(int j=0;j<p_gjNq;++j;inner1){
				for(int i=0;i<p_gjNq;++i;inner0){

					const int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					const dfloat r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
					const dfloat r_G00 = gjGeo[base+p_G00ID*p_gjNp];
					const dfloat r_G01 = gjGeo[base+p_G01ID*p_gjNp];
					const dfloat r_G02 = gjGeo[base+p_G02ID*p_gjNp];

					const dfloat r_G11 = gjGeo[base+p_G11ID*p_gjNp];
					const dfloat r_G12 = gjGeo[base+p_G12ID*p_gjNp];
					const dfloat r_G22 = gjGeo[base+p_G22ID*p_gjNp];

					// differentiate
					dfloat qr = 0, qs = 0, qt = 0;
					occaUnroll(p_gjNq)
					for(int n=0;n<p_gjNq;++n){
						qr += s_D[i][n]*s_tmpq[k][j][n];
						qs += s_D[j][n]*s_tmpq[k][n][i];
						qt += s_D[k][n]*s_tmpq[n][j][i];
					}

					// apply chain rule (notice the swtich of indices in i,j)
					s_qr[j][i] = r_G00*qr + r_G01*qs + r_G02*qt;
					s_qs[j][i] = r_G01*qr + r_G11*qs + r_G12*qt;
					r_qt = r_G02*qr + r_G12*qs + r_G22*qt;

					r_lapq[k] += lambda*r_GwJ*s_tmpq[k][j][i];

#if 0
					occaUnroll(p_gjNq)
					for(int n=0;n<p_gjNq;++n){
						r_lapq[n] += s_D[k][n]*r_qt;
					}
#endif
				}
			}

			barrier(localMemFence);

			// weak diff
			for(int j=0;j<p_gjNq;++j;inner1){
				for(int i=0;i<p_gjNq;++i;inner0){
					dfloat lapqr = 0, lapqs = 0;

					occaUnroll(p_gjNq)
					for(int n=0;n<p_gjNq;++n){
						lapqr += s_D[n][i]*s_qr[j][n];
						lapqs += s_D[n][j]*s_qs[n][i];
						r_lapq[n] += s_D[k][n]*r_qt;
					}

					r_lapq[k] += lapqr + lapqs;
				}
			}
		}

		// now interpolate back in 't'
		occaUnroll(p_Nq)
		for(int c=0;c<p_Nq;++c){

			barrier(localMemFence);

			for(int j=0;j<p_gjNq;++j;inner1){
				for(int i=0;i<p_gjNq;++i;inner0){
					dfloat tmp = 0;

					occaUnroll(p_gjNq)
					for(int k=0;k<p_gjNq;++k){
						tmp += s_I[k][c]*r_lapq[k];
					}

					s_tmpq[c][j][i] = tmp;
				}
			}

			barrier(localMemFence);

			for(int b=0;b<p_gjNq;++b;inner1){
				for(int i=0;i<p_gjNq;++i;inner0){
					if(b<p_Nq){
						dfloat tmp = 0;

						occaUnroll(p_gjNq)
						for(int j=0;j<p_gjNq;++j){
							tmp += s_I[j][b]*s_tmpq[c][j][i];
						}

						s_qr[b][i] = tmp;
					}
				}
			}

			barrier(localMemFence);

			for(int b=0;b<p_gjNq;++b;inner1){
				for(int a=0;a<p_gjNq;++a;inner0){
					const int t = a + b*p_gjNq;
					if(t<p_Nq*p_Nq){
						const int ta = t%p_Nq;
						const int tb = t/p_Nq;

						dfloat tmp = 0;

						occaUnroll(p_gjNq)
						for(int i=0;i<p_gjNq;++i){
							tmp += s_I[i][ta]*s_qr[tb][i];
						}

						const int id = emap*p_Np + c*p_Nq2 + tb*p_Nq + ta;
						Aq[id] = tmp;
					}
				}
			}
		}
	}
}



kernel void ellipticPartialAxHex3D_e6b(const int Nelements,
                                       const int * restrict elementList,
                                       const dfloat * restrict gjGeo,
                                       const dfloat * restrict gjD,
                                       const dfloat * restrict gjI,
                                       const dfloat   lambda,
                                       const dfloat * restrict q,
                                       dfloat * restrict Aq,
                                       const dfloat * restrict qAq){


	for(int e=0;e<Nelements;++e;outer0){

		shared dfloat s_D[p_gjNq][p_gjNq];
		shared dfloat s_I[p_gjNq][p_Nq+p_gllPad];

		exclusive dfloat r_lapq[p_gjNq];
		exclusive dfloat r_tmpq[p_gjNq];

		shared dfloat s_tmpq[p_gjNq][p_gjNq];

		shared dfloat s_qr[p_gjNq][p_gjNq+p_gjPad];
		shared dfloat s_qs[p_gjNq][p_gjNq+p_gjPad];

		exclusive int emap;
		exclusive dfloat r_qt;

		// prefetch D and I matrices and zero register storage
		for(int b=0;b<p_gjNq;++b;inner1){
			for(int a=0;a<p_gjNq;++a;inner0){

				emap = elementList[e];

				const int t = a + p_gjNq*b;

				s_D[b][a] = gjD[b*p_gjNq+a];

				if(a<p_Nq && b<p_gjNq)
					s_I[b][a] = gjI[b*p_Nq+a];

#if 0
				if(a<p_Nq && b<p_Nq){
					// prefetch q(a,b,:) to registers
					occaUnroll(p_Nq)
					for(int c=0;c<p_Nq;++c){
						r_lapq[c] = q[emap*p_Np+c*p_Nq2+b*p_Nq+a];
					}
				}
#endif
			}
		}

		occaUnroll(p_Nq)
		for(int k=0;k<p_gjNq;++k){

			barrier(localMemFence);

			for(int b=0;b<p_gjNq;++b;inner1){
				for(int a=0;a<p_gjNq;++a;inner0){

					dfloat tmp = 0;

					if(a<p_Nq && b<p_Nq){
						occaUnroll(p_Nq)
						for(int c=0;c<p_Nq;++c){

							tmp += s_I[k][c]*q[emap*p_Np+c*p_Nq2+b*p_Nq+a]; // r_lapq[c];
						}
					}

					s_tmpq[b][a] = tmp;
				}
			}

			barrier(localMemFence);

			for(int b=0;b<p_gjNq;++b;inner1){
				for(int i=0;i<p_gjNq;++i;inner0){
					dfloat tmp = 0;

					if(b<p_Nq){
						occaUnroll(p_Nq)
						for(int a=0;a<p_Nq;++a){
							tmp += s_I[i][a]*s_tmpq[b][a];
						}
					}

					s_qr[b][i] = tmp;
				}
			}

			barrier(localMemFence);

			for(int j=0;j<p_gjNq;++j;inner1){
				for(int i=0;i<p_gjNq;++i;inner0){

					dfloat tmp = 0;

					occaUnroll(p_Nq)
					for(int b=0;b<p_Nq;++b){
						tmp += s_I[j][b]*s_qr[b][i];
					}

					r_tmpq[k] = tmp;
				}
			}
		}

		for(int j=0;j<p_gjNq;++j;inner1)
			for(int i=0;i<p_gjNq;++i;inner0)
				for(int k=0;k<p_gjNq;++k)
					r_lapq[k] = 0;

		occaUnroll(p_gjNq)
		for(int k=0;k<p_gjNq;++k){

			barrier(localMemFence);

			for(int j=0;j<p_gjNq;++j;inner1)
				for(int i=0;i<p_gjNq;++i;inner0)
					s_tmpq[j][i] = r_tmpq[k];

			barrier(localMemFence);

			for(int j=0;j<p_gjNq;++j;inner1){
				for(int i=0;i<p_gjNq;++i;inner0){

					const int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					const dfloat r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
					const dfloat r_G00 = gjGeo[base+p_G00ID*p_gjNp];
					const dfloat r_G01 = gjGeo[base+p_G01ID*p_gjNp];
					const dfloat r_G02 = gjGeo[base+p_G02ID*p_gjNp];

					const dfloat r_G11 = gjGeo[base+p_G11ID*p_gjNp];
					const dfloat r_G12 = gjGeo[base+p_G12ID*p_gjNp];
					const dfloat r_G22 = gjGeo[base+p_G22ID*p_gjNp];

					// differentiate
					dfloat qr = 0, qs = 0, qt = 0;
					occaUnroll(p_gjNq)
					for(int n=0;n<p_gjNq;++n){
						qr += s_D[i][n]*s_tmpq[j][n];
						qs += s_D[j][n]*s_tmpq[n][i];
						qt += s_D[k][n]*r_tmpq[n];
					}

					// apply chain rule (notice the swtich of indices in i,j)
					s_qr[j][i] = r_G00*qr + r_G01*qs + r_G02*qt;
					s_qs[j][i] = r_G01*qr + r_G11*qs + r_G12*qt;
					r_qt = r_G02*qr + r_G12*qs + r_G22*qt;

					r_lapq[k] += lambda*r_GwJ*r_tmpq[k];
				}
			}

			barrier(localMemFence);

			// weak diff
			for(int j=0;j<p_gjNq;++j;inner1){
				for(int i=0;i<p_gjNq;++i;inner0){
					dfloat lapqr = 0, lapqs = 0;

					occaUnroll(p_gjNq)
					for(int n=0;n<p_gjNq;++n){
						lapqr += s_D[n][i]*s_qr[j][n];
						lapqs += s_D[n][j]*s_qs[n][i];
					}
					occaUnroll(p_gjNq)
					for(int n=0;n<p_gjNq;++n){
						r_lapq[n] += s_D[k][n]*r_qt;
					}

					r_lapq[k] += lapqr + lapqs;
				}
			}
		}

		// now interpolate back in 't'
		occaUnroll(p_Nq)
		for(int c=0;c<p_Nq;++c){

			barrier(localMemFence);

			for(int j=0;j<p_gjNq;++j;inner1){
				for(int i=0;i<p_gjNq;++i;inner0){
					dfloat tmp = 0;

					occaUnroll(p_gjNq)
					for(int k=0;k<p_gjNq;++k){
						tmp += s_I[k][c]*r_lapq[k];
					}

					s_tmpq[j][i] = tmp;
				}
			}

			barrier(localMemFence);

			for(int b=0;b<p_gjNq;++b;inner1){
				for(int i=0;i<p_gjNq;++i;inner0){
					if(b<p_Nq){
						dfloat tmp = 0;

						occaUnroll(p_gjNq)
						for(int j=0;j<p_gjNq;++j){
							tmp += s_I[j][b]*s_tmpq[j][i];
						}

						s_qr[b][i] = tmp;
					}
				}
			}

			barrier(localMemFence);

			for(int b=0;b<p_gjNq;++b;inner1){
				for(int a=0;a<p_gjNq;++a;inner0){
					const int t = a + b*p_gjNq;
					if(t<p_Nq2){
						const int ta = t%p_Nq;
						const int tb = t/p_Nq;
						dfloat tmp = 0;

						occaUnroll(p_gjNq)
						for(int i=0;i<p_gjNq;++i){
							tmp += s_I[i][ta]*s_qr[tb][i];
						}

						const int id = emap*p_Np + c*p_Nq2 + tb*p_Nq + ta;
						Aq[id] = tmp;
					}
				}
			}
		}
	}
}



kernel void ellipticPartialAxHex3D_e7(const int Nelements,
                                      const int * restrict elementList,
                                      const dfloat * restrict gjGeo,
                                      const dfloat * restrict gjD,
                                      const dfloat * restrict gjI,
                                      const dfloat lambda,
                                      const dfloat * restrict q,
                                      dfloat * restrict gradq,
                                      dfloat * restrict Aq){

	// split into gradient then divergence to reduce register and shared memory pressure

	// gradient
	for(int e=0; e<Nelements; ++e; outer0) {

		shared dfloat s_D[p_gjNq][p_Nq+p_gllPad];
		shared dfloat s_I[p_gjNq][p_Nq+p_gllPad];

		exclusive dfloat r_q[p_Nq];

		shared dfloat s_Ixxq[p_Nq][p_Nq+p_gllPad];
		shared dfloat s_Dxxq[p_Nq][p_Nq+p_gllPad];

		shared dfloat s_IxDq[p_Nq][p_gjNq+p_gjPad];
		shared dfloat s_IxIq[p_Nq][p_gjNq+p_gjPad];
		shared dfloat s_DxIq[p_Nq][p_gjNq+p_gjPad];

		exclusive int emap;
		exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;

		// prefetch D and I matrices and zero register storage
		for(int b=0; b<p_gjNq; ++b; inner1) {
			for(int a=0; a<p_gjNq; ++a; inner0) {
				const int t = a + p_gjNq*b;

				if(a<p_Nq && b<p_gjNq) {
					s_D[b][a] = gjD[b*p_Nq+a];
					s_I[b][a] = gjI[b*p_Nq+a];
				}

				emap = elementList[e];

				if(a<p_Nq && b<p_Nq) {

					occaUnroll(p_Nq)
					for(int c=0; c<p_Nq; ++c) {
						r_q[c] = q[emap*p_Np+c*p_Nq2+b*p_Nq+a];
					}
				}
			}
		}

		// scan through k slices

		for(int k=0; k<p_gjNq; ++k) {

			optBarrier(localMemFence);

			// prefetch slice
			for(int b=0; b<p_gjNq; ++b; inner1) {
				for(int a=0; a<p_gjNq; ++a; inner0) {

					const int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + b*p_gjNq + a;
					r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
					r_G00 = gjGeo[base+p_G00ID*p_gjNp];
					r_G01 = gjGeo[base+p_G01ID*p_gjNp];
					r_G02 = gjGeo[base+p_G02ID*p_gjNp];

					r_G11 = gjGeo[base+p_G11ID*p_gjNp];
					r_G12 = gjGeo[base+p_G12ID*p_gjNp];
					r_G22 = gjGeo[base+p_G22ID*p_gjNp];
					// assumes w*J built into G entries

					if(a<p_Nq && b<p_Nq) {

						dfloat Iqk = 0, Dqk = 0;

						occaUnroll(p_Nq)
						for(int c=0; c<p_Nq; ++c) {
							const dfloat qcba = r_q[c];
							Iqk += s_I[k][c]*qcba;
							Dqk += s_D[k][c]*qcba;
						}
						s_Ixxq[b][a] = Iqk;
						s_Dxxq[b][a] = Dqk;
					}
				}
			}

			optBarrier(localMemFence);

			// interpolate and differentiate in 'r' direction
			for(int b=0; b<p_gjNq; ++b; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {

					if(b<p_Nq) {

						dfloat IxDq= 0, IxIq = 0, DxIq = 0;

						occaUnroll(p_Nq)
						for(int a=0; a<p_Nq; ++a) {
							const dfloat Iia = s_I[i][a];
							const dfloat Dia = s_D[i][a];
							const dfloat Ixxqba = s_Ixxq[b][a];
							IxDq += Dia*Ixxqba;
							IxIq += Iia*Ixxqba;
							DxIq += Iia*s_Dxxq[b][a];
						}

						s_IxDq[b][i] = IxDq;
						s_IxIq[b][i] = IxIq;
						s_DxIq[b][i] = DxIq;
					}
				}
			}

			optBarrier(localMemFence);

			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {

					dfloat qr = 0, qs = 0, qt = 0, qI = 0;

					// interpolate and differentiate in 's' direction
					occaUnroll(p_Nq)
					for(int n=0; n<p_Nq; ++n) {
						const dfloat Ijn = s_I[j][n];
						const dfloat Djn = s_D[j][n];
						qr += Ijn*s_IxDq[n][i];
						qt += Ijn*s_DxIq[n][i];
						qI += Ijn*s_IxIq[n][i];
						qs += Djn*s_IxIq[n][i];
					}

					// apply chain rule (notice the swtich of indices in i,j)
					// should bundle these
					const int base = e*p_gjNp*4 + 4*k*p_gjNq*p_gjNq + j*p_gjNq + i;
					gradq[base+0*p_gjNq2] = r_G00*qr + r_G01*qs + r_G02*qt;
					gradq[base+1*p_gjNq2] = r_G01*qr + r_G11*qs + r_G12*qt;
					gradq[base+2*p_gjNq2] = r_G02*qr + r_G12*qs + r_G22*qt;
					gradq[base+3*p_gjNq2] = r_GwJ*qI*lambda;
				}
			}
		}
	}

	// divergence
	for(int e=0; e<Nelements; ++e; outer0) {

		shared dfloat s_D[p_gjNq][p_Nq+p_gllPad];
		shared dfloat s_I[p_gjNq][p_Nq+p_gllPad];

		exclusive dfloat r_lapq[p_Nq];

		shared dfloat s_qtmp[p_gjNq][p_gjNq+p_gjPad];

		shared dfloat s_Dqr[p_gjNq][p_Nq+p_gllPad];
		shared dfloat s_Iqs[p_gjNq][p_Nq+p_gllPad];
		shared dfloat s_Iqt[p_gjNq][p_Nq+p_gllPad];

		exclusive int emap;

		for(int b=0; b<p_gjNq; ++b; inner1) {
			for(int a=0; a<p_gjNq; ++a; inner0) {
				if(a<p_Nq && b<p_gjNq) {
					s_D[b][a] = gjD[b*p_Nq+a];
					s_I[b][a] = gjI[b*p_Nq+a];
				}
			}

			for(int c=0; c<p_Nq; ++c) {
				r_lapq[c] = 0.f;
			}

			emap = elementList[e];
		}

		for(int k=0; k<p_gjNq; ++k) {

			// 1.
			optBarrier(localMemFence);

			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					// should bundle these
					const int base = e*p_gjNp*4 + 4*k*p_gjNq*p_gjNq + j*p_gjNq + i;
					s_qtmp[i][j] = gradq[base+0*p_gjNq2];
				}
			}

			optBarrier(localMemFence);

			// transpose differentiate and interpolate in 'r'
			for(int a=0; a<p_gjNq; ++a; inner1) {
				for(int j=0; j<p_gjNq; ++j; inner0) {

					if(a<p_Nq) {
						dfloat tmpr = 0;
						occaUnroll(p_gjNq)
						for(int i=0; i<p_gjNq; ++i) {
							const dfloat Dia = s_D[i][a];
							tmpr += Dia*s_qtmp[i][j];
						}

						s_Dqr[j][a] = tmpr;
					}
				}
			}

			// 2.
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					// should bundle these
					const int base = e*p_gjNp*4 + 4*k*p_gjNq*p_gjNq + j*p_gjNq + i;
					s_qtmp[i][j] = gradq[base+1*p_gjNq2];
				}
			}

			optBarrier(localMemFence);

			// transpose differentiate and interpolate in 'r'
			for(int a=0; a<p_gjNq; ++a; inner1) {
				for(int j=0; j<p_gjNq; ++j; inner0) {

					if(a<p_Nq) {
						dfloat tmps = 0;
						occaUnroll(p_gjNq)
						for(int i=0; i<p_gjNq; ++i) {
							const dfloat Iia = s_I[i][a];
							tmps += Iia*s_qtmp[i][j];
						}

						s_Iqs[j][a] = tmps;
					}
				}
			}

			optBarrier(localMemFence);

			// 3.
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					// should bundle these
					const int base = e*p_gjNp*4 + 4*k*p_gjNq*p_gjNq + j*p_gjNq + i;
					s_qtmp[i][j] = gradq[base+2*p_gjNq2];
				}
			}

			optBarrier(localMemFence);

			// transpose differentiate and interpolate in 'r'
			for(int a=0; a<p_gjNq; ++a; inner1) {
				for(int j=0; j<p_gjNq; ++j; inner0) {

					if(a<p_Nq) {
						dfloat tmpt = 0;
						occaUnroll(p_gjNq)
						for(int i=0; i<p_gjNq; ++i) {
							const dfloat Iia = s_I[i][a];
							tmpt += Iia*s_qtmp[i][j];
						}

						s_Iqt[j][a] = tmpt;
					}
				}
			}


			optBarrier(localMemFence);

			// 4.
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					// should bundle these
					const int base = e*p_gjNp*4 + 4*k*p_gjNq*p_gjNq + j*p_gjNq + i;
					s_qtmp[i][j] = gradq[base+3*p_gjNq2];
				}
			}

			optBarrier(localMemFence);

			// transpose differentiate and interpolate in 'r'
			for(int a=0; a<p_gjNq; ++a; inner1) {
				for(int j=0; j<p_gjNq; ++j; inner0) {

					if(a<p_Nq) {
						dfloat tmpI = 0;
						occaUnroll(p_gjNq)
						for(int i=0; i<p_gjNq; ++i) {
							const dfloat Iia = s_I[i][a];
							tmpI += Iia*s_qtmp[i][j];
						}

						s_Dqr[j][a] += tmpI;                                                                                                                                                         // blend lambda term in here
					}
				}
			}


			optBarrier(localMemFence);

			// transpose differentiate and interpolate in 's'
			for(int b=0; b<p_gjNq; ++b; inner1) {
				for(int a=0; a<p_gjNq; ++a; inner0) {
					if(a<p_Nq && b<p_Nq) {
						dfloat tmpr = 0, tmps = 0, tmpt = 0;

						occaUnroll(p_gjNq)
						for(int j=0; j<p_gjNq; ++j) {
							const dfloat Ijb = s_I[j][b];
							const dfloat Djb = s_D[j][b];

							tmpr += Ijb*s_Dqr[j][a];
							tmps += Djb*s_Iqs[j][a];
							tmpt += Ijb*s_Iqt[j][a];
						}

						// transpose differentiate and interpolate in 't'
						tmpr += tmps;                                                                                                                                                         // blend r and s
						occaUnroll(p_Nq)
						for(int c=0; c<p_Nq; ++c) {
							r_lapq[c] += s_I[k][c]*tmpr;
							r_lapq[c] += s_D[k][c]*tmpt;
						}
					}
				}
			}
		}

		//    optBarrier(localMemFence);

		for(int b=0; b<p_gjNq; ++b; inner1) {
			for(int a=0; a<p_gjNq; ++a; inner0) {

				if(a<p_Nq && b<p_Nq) {
					occaUnroll(p_Nq)
					for(int c=0; c<p_Nq; ++c) {
						const int id = emap*p_Np + c*p_Nq2 + b*p_Nq + a;
						Aq[id] = r_lapq[c];
					}
				}
			}
		}
	}
}

// ONLY CPU

kernel void ellipticPartialAxHex3D_e8(const int Nelements,
                                      const int * restrict elementList,
                                      const dfloat * restrict gjGeo,
                                      const dfloat * restrict gjD,
                                      const dfloat * restrict gjI,
                                      const dfloat lambda,
                                      dfloat * restrict q,
                                      dfloat * restrict Aq,
                                      dfloat * restrict qAq){

	dfloat s_D[p_gjNq][p_Nq+p_gllPad];
	dfloat s_I[p_gjNq][p_Nq+p_gllPad];

	for(int b=0; b<p_gjNq; ++b) {
		for(int a=0; a<p_Nq; ++a) {
			s_D[b][a] = gjD[b*p_Nq+a];
			s_I[b][a] = gjI[b*p_Nq+a];
		}
	}

	dfloat r_q[p_Nq][p_Nq][p_Nq];
	dfloat r_lapq[p_Nq][p_Nq][p_Nq];

	dfloat s_Ixxq[p_Nq][p_Nq+p_gllPad];
	dfloat s_Dxxq[p_Nq][p_Nq+p_gllPad];

	dfloat s_IxDq[p_Nq][p_gjNq+p_gjPad];
	dfloat s_IxIq[p_Nq][p_gjNq+p_gjPad];
	dfloat s_DxIq[p_Nq][p_gjNq+p_gjPad];

	dfloat s_qr[p_gjNq][p_gjNq+p_gjPad];
	dfloat s_qs[p_gjNq][p_gjNq+p_gjPad];
	dfloat s_qt[p_gjNq][p_gjNq+p_gjPad];

	dfloat s_Dqr[p_gjNq][p_Nq+p_gllPad];
	dfloat s_Iqs[p_gjNq][p_Nq+p_gllPad];
	dfloat s_Iqt[p_gjNq][p_Nq+p_gllPad];

	dfloat s_qI[p_gjNq][p_gjNq+p_gjPad];

	for(int e=0; e<Nelements; ++e) {

		const int emap = elementList[e];

		// prefetch D and I matrices and zero register storage
		for(int c=0; c<p_Nq; ++c) {
			for(int b=0; b<p_Nq; ++b) {
				for(int a=0; a<p_Nq; ++a) {
					r_lapq[c][b][a] = 0;
					r_q[c][b][a] = q[emap*p_Np+c*p_Nq2+b*p_Nq+a];
				}
			}
		}

		// scan through k slices

		for(int k=0; k<p_gjNq; ++k) {

			// prefetch slice
			for(int b=0; b<p_Nq; ++b) {
				for(int a=0; a<p_Nq; ++a) {

					// assumes w*J built into G entries

					dfloat Iqk = 0, Dqk = 0;

					// puts more data in flight
					for(int c=0; c<p_Nq; ++c) {
						const dfloat qcba =  r_q[c][b][a];
						Iqk += s_I[k][c]*qcba;
						Dqk += s_D[k][c]*qcba;
					}
					s_Ixxq[b][a] = Iqk;
					s_Dxxq[b][a] = Dqk;
				}
			}

			// interpolate and differentiate in 'r' direction
			for(int b=0; b<p_Nq; ++b) {
				for(int i=0; i<p_gjNq; ++i) {

					dfloat IxDq= 0, IxIq = 0, DxIq = 0;

					for(int a=0; a<p_Nq; ++a) {
						const dfloat Iia = s_I[i][a];
						const dfloat Ixxqba = s_Ixxq[b][a];
						IxIq += Iia*Ixxqba;
						DxIq += Iia*s_Dxxq[b][a];
					}

					for(int a=0; a<p_Nq; ++a) {
						const dfloat Dia = s_D[i][a];
						const dfloat Ixxqba = s_Ixxq[b][a];
						IxDq += Dia*Ixxqba;
					}

					s_IxDq[b][i] = IxDq;
					s_IxIq[b][i] = IxIq;
					s_DxIq[b][i] = DxIq;
				}
			}

			for(int j=0; j<p_gjNq; ++j) {
				for(int i=0; i<p_gjNq; ++i) {

					dfloat qr = 0, qs = 0, qt = 0, qI = 0;

					// interpolate and differentiate in 's' direction
					for(int b=0; b<p_Nq; ++b) {
						const dfloat Ijn = s_I[j][b];
						qr += Ijn*s_IxDq[b][i];
						qt += Ijn*s_DxIq[b][i];
						qI += Ijn*s_IxIq[b][i];
					}

					for(int b=0; b<p_Nq; ++b) {
						const dfloat Djn = s_D[j][b];
						qs += Djn*s_IxIq[b][i];
					}

					const int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					const dfloat r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
					const dfloat r_G00 = gjGeo[base+p_G00ID*p_gjNp];
					const dfloat r_G01 = gjGeo[base+p_G01ID*p_gjNp];
					const dfloat r_G02 = gjGeo[base+p_G02ID*p_gjNp];

					const dfloat r_G11 = gjGeo[base+p_G11ID*p_gjNp];
					const dfloat r_G12 = gjGeo[base+p_G12ID*p_gjNp];
					const dfloat r_G22 = gjGeo[base+p_G22ID*p_gjNp];

					// apply chain rule (notice the swtich of indices in i,j)
					s_qr[i][j] = r_G00*qr + r_G01*qs + r_G02*qt;
					s_qs[i][j] = r_G01*qr + r_G11*qs + r_G12*qt;
					s_qt[i][j] = r_G02*qr + r_G12*qs + r_G22*qt;
					s_qI[i][j] = r_GwJ*qI*lambda;
				}
			}

			// transpose differentiate and interpolate in 'r'
			for(int j=0; j<p_gjNq; ++j) {
				for(int a=0; a<p_Nq; ++a) {

					dfloat tmpr = 0, tmps = 0, tmpt = 0, tmpI = 0;

					for(int i=0; i<p_gjNq; ++i) {
						const dfloat Iia = s_I[i][a];
						tmps += Iia*s_qs[i][j];
						tmpt += Iia*s_qt[i][j];
						tmpI += Iia*s_qI[i][j];
					}

					for(int i=0; i<p_gjNq; ++i) {
						const dfloat Dia = s_D[i][a];
						tmpr += Dia*s_qr[i][j];
					}

					s_Dqr[j][a] = tmpr+tmpI; // blend lambda term in here
					s_Iqs[j][a] = tmps;
					s_Iqt[j][a] = tmpt;
				}
			}

			// transpose differentiate and interpolate in 's'
			for(int b=0; b<p_Nq; ++b) {
				for(int a=0; a<p_Nq; ++a) {

					dfloat tmpr = 0, tmps = 0, tmpt = 0;

					for(int j=0; j<p_gjNq; ++j) {
						const dfloat Ijb = s_I[j][b];

						tmpr += Ijb*s_Dqr[j][a];
						tmpt += Ijb*s_Iqt[j][a];
					}

					for(int j=0; j<p_gjNq; ++j) {
						const dfloat Djb = s_D[j][b];

						tmps += Djb*s_Iqs[j][a];
					}

					// transpose differentiate and interpolate in 't'
					tmpr += tmps; // blend r and s

					for(int c=0; c<p_Nq; ++c) {
						r_lapq[c][b][a] += s_I[k][c]*tmpr + s_D[k][c]*tmpt;
					}
				}
			}
		}

		for(int c=0; c<p_Nq; ++c) {
			for(int b=0; b<p_Nq; ++b) {
				for(int a=0; a<p_Nq; ++a) {
					const int id = emap*p_Np + c*p_Nq2 + b*p_Nq + a;
					Aq[id] = r_lapq[c][b][a];
				}
			}
		}
	}
}


// THIS KERNEL only works on elements with size x*y*z <=1024

// Note: gjD is gjNq x gjNq


kernel void ellipticPartialAxHex3D_e9(const int Nelements,
                                      const int * restrict elementList,
                                      const dfloat * restrict gjGeo,
                                      const dfloat * restrict gllD,
                                      const dfloat * restrict gjI,
                                      const dfloat lambda,
                                      dfloat * restrict q,
                                      dfloat * restrict Ixq,
                                      dfloat * restrict Aq
                                     ){


	// load q into shared first
	//kernel 1 - interpolate to gj hex
	for(int e=0; e<Nelements; ++e; outer0) {
		exclusive int emap;
		exclusive dfloat r_res;
		shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		shared dfloat s_gsI[p_gjNq][p_Nq];

		for(int c=0; c<p_gjNq; ++c; inner2) {
			for(int b=0; b<p_gjNq; ++b; inner1) {
				for(int a=0; a<p_gjNq; ++a; inner0) {
					r_res =0.0f;
					if (c == 0 && a<p_Nq && b<p_gjNq) {
						s_gsI[b][a] = gjI[b*p_Nq+a];
					}
					emap = elementList[e];
					int t = a + b*p_gjNq + c*p_gjNq2;
					if (t<p_Np) {
						int ta = t%p_Nq;
						int tb = (t/p_Nq)%p_Nq;
						int tc = t/p_Nq2;
						s_q[tc][tb][ta] = q[emap*p_Np+t];
					}//if
				}//for a
			}// for b
		}//for c
		//synch threads
		barrier(localMemFence);
		//============== interpolate in 3 dir ========================
		// r --> s --> t
		// rrrrrrr
		for(int c=0; c<p_gjNq; ++c; inner2) {
			for(int b=0; b<p_gjNq; ++b; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					dfloat Iq = 0.0f;
					if (c<p_Nq && b<p_Nq){
						occaUnroll(p_Nq)
						for(int n=0; n<p_Nq; ++n) {
							Iq += s_gsI[i][n]*s_q[c][b][n];
						}
					}
					r_res = Iq;			a
				}
			}
		}

		barrier(localMemFence);

		for(int c=0; c<p_gjNq; ++c; inner2) {
			for(int b=0; b<p_gjNq; ++b; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					s_q[c][b][i] = r_res;
				}
			}
		}
		barrier(localMemFence);

		for(int c=0; c<p_gjNq; ++c; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					dfloat Iq = 0.0f;
					if(c<p_Nq) {
						occaUnroll(p_Nq)
						for(int n=0; n<p_Nq; ++n) {
							Iq += s_gsI[j][n]*s_q[c][n][i];
						}
					}
					r_res = Iq;
				}
			}
		}
		barrier(localMemFence);



		for(int c=0; c<p_gjNq; ++c; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					s_q[c][j][i] = r_res;
				}
			}
		}
		barrier(localMemFence);

		// t direction

		for(int k=0; k<p_gjNq; ++k; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					dfloat Iq = 0.0f;
					occaUnroll(p_Nq)
					for(int n=0; n<p_Nq; ++n) {
						Iq += s_gsI[k][n]*s_q[n][j][i];
					}
					//	r_res = Iq;
					//		s_q[k][j][i] = Iq;
					emap = elementList[e];
					const int id = emap*p_gjNp + k*p_gjNq*p_gjNq+ j*p_gjNq + i;
					Ixq[id] = Iq;
					//s_q[k][j][i];
				}
			}
		}
	}// for e

	// at this point q is interpolated in all 3 dim.
	// ------------KERNEL 2 -------------->

	// kernel 2 differentiate on gj hex
	for(int e=0; e<Nelements; ++e; outer0) {
		shared dfloat s_gjD[p_gjNq][p_gjNq];
		//	shared dfloat s_gllD[p_gjNq][p_Nq];
		shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		exclusive dfloat r_qr, r_qs, r_qt, r_tmp;
		exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;
		exclusive int emap;

		for(int k=0; k<p_gjNq; ++k; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					// D to shared, q to shared,
					if (k==0 ) {
						s_gjD[j][i] = gllD[j*p_gjNq+i];
					}
					emap = elementList[e];
					int t = i + j*p_gjNq + k*p_gjNq2;
					s_q[k][j][i] = Ixq[emap*p_gjNp+t];
				}//for i
			}//for j
		}//for k
		barrier(localMemFence);

		for(int k=0; k<p_gjNq; ++k; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					//load geofactors for my (k,j,i)
					//		emap = elementList[e];
					const int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					//geofactors for k j i thread
					r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
					r_G00 = gjGeo[base+p_G00ID*p_gjNp];
					r_G01 = gjGeo[base+p_G01ID*p_gjNp];
					r_G02 = gjGeo[base+p_G02ID*p_gjNp];

					r_G11 = gjGeo[base+p_G11ID*p_gjNp];
					r_G12 = gjGeo[base+p_G12ID*p_gjNp];
					r_G22 = gjGeo[base+p_G22ID*p_gjNp];
					// now, put together dq/dr, qq/ds, dq/dt and dq/dI

					dfloat dr = 0.0f;
					dfloat ds = 0.0f;
					dfloat dt = 0.0f;
					occaUnroll(p_gjNq)
					for (int n = 0; n<p_gjNq; ++n) {
						dr += s_gjD[i][n] * s_q[k][j][n];
						ds += s_gjD[j][n]*s_q[k][n][i];
						dt += s_gjD[k][n]*s_q[n][j][i];
					}
					r_qr = r_G00*dr + r_G01*ds + r_G02*dt;
					r_qs = r_G01*dr + r_G11*ds + r_G12*dt;
					r_qt = r_G02*dr + r_G12*ds + r_G22*dt;

					r_tmp = r_GwJ*s_q[k][j][i]*lambda;
				}
			}
		}
		barrier(localMemFence);
		// Multiply by D^T, size p_Nq x p_gjNq
		// D size p_gjNq x p_Nq

		// r direction
		for(int k=0; k<p_gjNq; ++k; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					s_q[k][j][i] = r_qr;
				}
			}
		}
		barrier(localMemFence);

		for(int k=0; k<p_gjNq; ++k; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					dfloat tmp = 0.f;
					occaUnroll(p_gjNq)
					for(int m=0; m<p_gjNq; ++m) {
						tmp += s_gjD[m][i]*s_q[k][j][m];
					}
					r_tmp +=tmp;
				}
			}
		}
		barrier(localMemFence);

		//s direction

		for(int k=0; k<p_gjNq; ++k; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					s_q[k][j][i] = r_qs;
				}
			}
		}
		barrier(localMemFence);
		for(int k=0; k<p_gjNq; ++k; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					dfloat tmp = 0.f;
					occaUnroll(p_gjNq)
					for(int m=0; m<p_gjNq; ++m) {
						tmp += s_gjD[m][j]*s_q[k][m][i];
					}
					r_tmp +=tmp;
				}
			}
		}
		barrier(localMemFence);
		//t direction

		for(int k=0; k<p_gjNq; ++k; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					s_q[k][j][i] = r_qt;
				}
			}
		}
		barrier(localMemFence);
		for(int k=0; k<p_gjNq; ++k; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					dfloat tmp = 0.f;
					occaUnroll(p_gjNq)
					for(int m=0; m<p_gjNq; ++m) {
						tmp += s_gjD[m][k]*s_q[m][j][i];
					}
					r_tmp +=tmp;
					int base = emap*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					Ixq[base] = r_tmp;
				}
			}
		}
	}//for e

	//-------------------- kernel 3 interpolate back to gll hex ------------------->

	for(int e=0; e<Nelements; ++e; outer0) {
		// read q

		shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		shared dfloat s_I[p_gjNq][p_Nq];
		exclusive dfloat r_res = 0.0f, r_Aq=0.0f;
		int emap;
		for(int k=0; k<p_gjNq; ++k; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {

					int base = k*p_gjNq*p_gjNq + j*p_gjNq + i;
					emap =elementList[e];
					s_q[k][j][i] = Ixq[emap*p_gjNp+base];
					if(i<p_Nq &&  k == 0 && j<p_gjNq) {
						s_I[j][i] = gjI[j*p_Nq+i];
					}
				}
			}
		}
		barrier(localMemFence);


		// t first
		for(int c=0; c<p_gjNq; ++c; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					dfloat Iq = 0.0f;
					if(c<p_Nq){
						occaUnroll(p_gjNq)
						for(int m=0; m<p_gjNq; ++m) {
							// k--> c
							Iq += s_I[m][c]*s_q[m][j][i];
						}
					}
					r_res = Iq;
				}
			}
		}

		barrier(localMemFence);

		for(int c=0; c<p_gjNq; ++c; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					s_q[c][j][i] = r_res;
				}
			}
		}




		// r direction
		barrier(localMemFence);

		for(int c=0; c<p_gjNq; ++c; inner2) {
			for(int b=0; b<p_gjNq; ++b; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					if(c<p_Nq && b<p_Nq){
						dfloat Iq = 0.0f;
						occaUnroll(p_gjNq)
						for(int m=0; m<p_gjNq; ++m) {
							Iq += s_I[m][b]*s_q[c][m][i];
						}
						r_res = Iq;
					}
				}
			}
		}
		barrier(localMemFence);

		for(int c=0; c<p_gjNq; ++c; inner2) {
			for(int b=0; b<p_gjNq; ++b; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					s_q[c][b][i]= r_res;
				}
			}
		}
		barrier(localMemFence);

		for(int c=0; c<p_gjNq; ++c; inner2) {
			for(int b=0; b<p_gjNq; ++b; inner1) {
				for(int a=0; a<p_gjNq; ++a; inner0) {
					if (c<p_Nq && b<p_Nq && a< p_Nq){
						dfloat Iq = 0.0f;
						occaUnroll(p_gjNq)
						for(int m=0; m<p_gjNq; ++m) {
							Iq += s_I[m][a]*s_q[c][b][m];
						}
						emap = elementList[e];
						int base = emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a;
						Aq[base] = Iq;
					}
				}
			}
		}
	}//e
} //kernel e9


#define gjCubeThreads(c,b,a)			\
  barrier(localMemFence);			\
  for(int c=0;c<p_gjNq;++c;inner2)		\
    for(int b=0;b<p_gjNq;++b;inner1)		\
      for(int a=0;a<p_gjNq;++a;inner0)


// e10 is the same as e9, just less barriers
kernel void ellipticPartialAxHex3D_e10(const int Nelements,
                                       const int * restrict elementList,
                                       const dfloat * restrict gjGeo,
                                       const dfloat * restrict gllD,
                                       const dfloat * restrict gjI,
                                       const dfloat lambda,
                                       dfloat * restrict q,
                                       dfloat * restrict Ixq,
                                       dfloat * restrict Aq
                                      ){


	// load q into shared first
	//kernel 1 - interpolate to gj hex
	for(int e=0; e<Nelements; ++e; outer0) {
		exclusive int emap;
		//	exclusive dfloat r_res;
		shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		shared dfloat s_q2[p_gjNq][p_gjNq][p_gjNq];
		shared dfloat s_gsI[p_gjNq][p_Nq];

		for(int c=0; c<p_gjNq; ++c; inner2) {
			for(int b=0; b<p_gjNq; ++b; inner1) {
				for(int a=0; a<p_gjNq; ++a; inner0) {
					//		r_res =0.0f;
					if (c == 0 && a<p_Nq && b<p_gjNq) {
						s_gsI[b][a] = gjI[b*p_Nq+a];
					}
					emap = elementList[e];
					int t = a + b*p_gjNq + c*p_gjNq2;
					if (t<p_Np) {
						int ta = t%p_Nq;
						int tb = (t/p_Nq)%p_Nq;
						int tc = t/p_Nq2;
						s_q[tc][tb][ta] = q[emap*p_Np+t];
					}//if
				}//for a
			}// for b
		}//for c
		//synch threads
		barrier(localMemFence);
		//============== interpolate in 3 dir ========================
		// r --> s --> t
		// rrrrrrr
		for(int c=0; c<p_gjNq; ++c; inner2) {
			for(int b=0; b<p_gjNq; ++b; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					//		dfloat Iq = 0.0f;
					s_q2[c][b][i] = 0.0f;
					if (c<p_Nq && b<p_Nq){
						occaUnroll(p_Nq)
						for(int n=0; n<p_Nq; ++n) {
							s_q2[c][b][i] += s_gsI[i][n]*s_q[c][b][n];
						}
					}
					//			r_res = Iq;
					//		s_q2[c][b][i] = Iq;
				}
			}
		}

		barrier(localMemFence);


		for(int c=0; c<p_gjNq; ++c; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					//	dfloat Iq = 0.0f;
					s_q[c][j][i] = 0.0f;
					if(c<p_Nq) {
						occaUnroll(p_Nq)
						for(int n=0; n<p_Nq; ++n) {
							s_q[c][j][i] += s_gsI[j][n]*s_q2[c][n][i];
						}
					}
					//		r_res = Iq;
					//		s_q[c][j][i] = Iq;
				}
			}
		}
		barrier(localMemFence);



		// t direction

		for(int k=0; k<p_gjNq; ++k; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					//	dfloat Iq = 0.0f;
					s_q2[k][j][i] =0.0f;
					occaUnroll(p_Nq)
					for(int n=0; n<p_Nq; ++n) {
						s_q2[k][j][i] += s_gsI[k][n]*s_q[n][j][i];
					}
					//	r_res = Iq;
					//		s_q[k][j][i] = Iq;
					emap = elementList[e];
					const int id = emap*p_gjNp + k*p_gjNq*p_gjNq+ j*p_gjNq + i;
					Ixq[id] = s_q2[k][j][i];
					//s_q[k][j][i];
				}
			}
		}
	}// for e

	// at this point q is interpolated in all 3 dim.
	// ------------KERNEL 2 -------------->

	// kernel 2 differentiate on gj hex
	for(int e=0; e<Nelements; ++e; outer0) {
		shared dfloat s_gjD[p_gjNq][p_gjNq];
		//	shared dfloat s_gllD[p_gjNq][p_Nq];
		shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		shared dfloat s_q2[p_gjNq][p_gjNq][p_gjNq];
		shared dfloat s_q3[p_gjNq][p_gjNq][p_gjNq];
		exclusive dfloat r_qr, r_qs, r_qt, r_tmp;
		exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;
		exclusive int emap;

		for(int k=0; k<p_gjNq; ++k; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					// D to shared, q to shared,
					if (k==0 ) {
						s_gjD[j][i] = gllD[j*p_gjNq+i];
					}
					emap = elementList[e];
					int t = i + j*p_gjNq + k*p_gjNq2;
					s_q[k][j][i] = Ixq[emap*p_gjNp+t];

				}//for i
			}//for j
		}//for k
		barrier(localMemFence);

		for(int k=0; k<p_gjNq; ++k; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					//load geofactors for my (k,j,i)
					//		emap = elementList[e];
					const int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					//geofactors for k j i thread
					r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
					r_G00 = gjGeo[base+p_G00ID*p_gjNp];
					r_G01 = gjGeo[base+p_G01ID*p_gjNp];
					r_G02 = gjGeo[base+p_G02ID*p_gjNp];

					r_G11 = gjGeo[base+p_G11ID*p_gjNp];
					r_G12 = gjGeo[base+p_G12ID*p_gjNp];
					r_G22 = gjGeo[base+p_G22ID*p_gjNp];
					// now, put together dq/dr, qq/ds, dq/dt and dq/dI

					dfloat dr = 0.0f;
					dfloat ds = 0.0f;
					dfloat dt = 0.0f;
					occaUnroll(p_gjNq)
					for (int n = 0; n<p_gjNq; ++n) {
						dr += s_gjD[i][n] * s_q[k][j][n];
						ds += s_gjD[j][n] *s_q[k][n][i];
						dt += s_gjD[k][n] *s_q[n][j][i];
					}
					r_qr = r_G00*dr + r_G01*ds + r_G02*dt;
					r_qs = r_G01*dr + r_G11*ds + r_G12*dt;
					r_qt = r_G02*dr + r_G12*ds + r_G22*dt;

					r_tmp = r_GwJ*s_q[k][j][i]*lambda;

					//int base = emap*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					//		Ixq[base] = s_q[i][j][k];
					//		s_q2[k][j][i] = ds;
				}
			}
		}
		barrier(localMemFence);
		// Multiply by D^T, size p_Nq x p_gjNq
		// D size p_gjNq x p_Nq

		// r direction
		for(int k=0; k<p_gjNq; ++k; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					s_q[k][j][i] = r_qr;
					s_q2[k][j][i] = r_qs;
					s_q3[k][j][i] = r_qt;


				}
			}
		}
		barrier(localMemFence);

		for(int k=0; k<p_gjNq; ++k; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					dfloat tmp = 0.f;
					occaUnroll(p_gjNq)
					for(int m=0; m<p_gjNq; ++m) {
						tmp += s_gjD[m][i]*s_q[k][j][m];
						tmp += s_gjD[m][j]*s_q2[k][m][i];
						tmp += s_gjD[m][k]*s_q3[m][j][i];
					}
					r_tmp +=tmp;
					int base = emap*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					Ixq[base] = r_tmp;
				}
			}
		}
	}//for e

	//-------------------- kernel 3 interpolate back to gll hex ------------------->

	for(int e=0; e<Nelements; ++e; outer0) {
		// read q

		shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		shared dfloat s_I[p_gjNq][p_Nq];
		exclusive dfloat r_res = 0.0f, r_Aq=0.0f;
		int emap;
		for(int k=0; k<p_gjNq; ++k; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {

					int base = k*p_gjNq*p_gjNq + j*p_gjNq + i;
					emap =elementList[e];
					s_q[k][j][i] = Ixq[emap*p_gjNp+base];
					if(i<p_Nq &&  k == 0 && j<p_gjNq) {
						s_I[j][i] = gjI[j*p_Nq+i];
					}
				}
			}
		}
		barrier(localMemFence);


		// t first
		for(int c=0; c<p_gjNq; ++c; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					dfloat Iq = 0.0f;
					if(c<p_Nq){
						occaUnroll(p_gjNq)
						for(int m=0; m<p_gjNq; ++m) {
							// k--> c
							Iq += s_I[m][c]*s_q[m][j][i];
						}
					}
					r_res = Iq;
				}
			}
		}

		barrier(localMemFence);

		for(int c=0; c<p_gjNq; ++c; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					s_q[c][j][i] = r_res;
				}
			}
		}




		// r direction
		barrier(localMemFence);

		for(int c=0; c<p_gjNq; ++c; inner2) {
			for(int b=0; b<p_gjNq; ++b; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					if(c<p_Nq && b<p_Nq){
						dfloat Iq = 0.0f;
						occaUnroll(p_gjNq)
						for(int m=0; m<p_gjNq; ++m) {
							Iq += s_I[m][b]*s_q[c][m][i];
						}
						r_res = Iq;
					}
				}
			}
		}
		barrier(localMemFence);

		for(int c=0; c<p_gjNq; ++c; inner2) {
			for(int b=0; b<p_gjNq; ++b; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					s_q[c][b][i]= r_res;
				}
			}
		}
		barrier(localMemFence);

		for(int c=0; c<p_gjNq; ++c; inner2) {
			for(int b=0; b<p_gjNq; ++b; inner1) {
				for(int a=0; a<p_gjNq; ++a; inner0) {
					if (c<p_Nq && b<p_Nq && a< p_Nq){
						dfloat Iq = 0.0f;
						occaUnroll(p_gjNq)
						for(int m=0; m<p_gjNq; ++m) {
							Iq += s_I[m][a]*s_q[c][b][m];
						}
						emap = elementList[e];
						int base = emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a;
						Aq[base] = Iq;
					}
				}
			}
		}
	}//e
} //kernel e10

//kernel e11 --> NO REGISTERS2SHARED and no REGISTERS2GLOBAL transfers


// e10 is the same as e9, just less barriers
kernel void ellipticPartialAxHex3D_e11(const int Nelements,
                                       const int * restrict elementList,
                                       const dfloat * restrict gjGeo,
                                       const dfloat * restrict gllD,
                                       const dfloat * restrict gjI,
                                       const dfloat lambda,
                                       dfloat * restrict q,
                                       dfloat * restrict Ixq,
                                       dfloat * restrict Aq
                                      ){


	// load q into shared first
	//kernel 1 - interpolate to gj hex
	for(int e=0; e<Nelements; ++e; outer0) {
		//	exclusive int emap;
		//	exclusive dfloat r_res;
		shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		shared dfloat s_q2[p_gjNq][p_gjNq][p_gjNq];
		shared dfloat s_gsI[p_gjNq][p_Nq];

		for(int c=0; c<p_gjNq; ++c; inner2) {
			for(int b=0; b<p_gjNq; ++b; inner1) {
				for(int a=0; a<p_gjNq; ++a; inner0) {
					//		r_res =0.0f;
					if (c == 0 && a<p_Nq && b<p_gjNq) {
						s_gsI[b][a] = gjI[b*p_Nq+a];
					}
					int emap = elementList[e];
					int t = a + b*p_gjNq + c*p_gjNq2;
					if (t<p_Np) {
						int ta = t%p_Nq;
						int tb = (t/p_Nq)%p_Nq;
						int tc = t/p_Nq2;
						s_q[tc][tb][ta] = q[emap*p_Np+t];
					}//if
				}//for a
			}// for b
		}//for c
		//synch threads
		barrier(localMemFence);
		//============== interpolate in 3 dir ========================
		// r --> s --> t
		// rrrrrrr
		for(int c=0; c<p_gjNq; ++c; inner2) {
			for(int b=0; b<p_gjNq; ++b; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					//		dfloat Iq = 0.0f;
					s_q2[c][b][i] = 0.0f;
					if (c<p_Nq && b<p_Nq){
						occaUnroll(p_Nq)
						for(int n=0; n<p_Nq; ++n) {
							s_q2[c][b][i] += s_gsI[i][n]*s_q[c][b][n];
						}
					}

				}
			}
		}

		barrier(localMemFence);


		for(int c=0; c<p_gjNq; ++c; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					//	dfloat Iq = 0.0f;
					s_q[c][j][i] = 0.0f;
					if(c<p_Nq) {
						occaUnroll(p_Nq)
						for(int n=0; n<p_Nq; ++n) {
							s_q[c][j][i] += s_gsI[j][n]*s_q2[c][n][i];
						}
					}

				}
			}
		}
		barrier(localMemFence);



		// t direction

		for(int k=0; k<p_gjNq; ++k; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					//	dfloat Iq = 0.0f;
					s_q2[k][j][i] =0.0f;
					occaUnroll(p_Nq)
					for(int n=0; n<p_Nq; ++n) {
						s_q2[k][j][i] += s_gsI[k][n]*s_q[n][j][i];
					}
					//	r_res = Iq;
					//		s_q[k][j][i] = Iq;
					int emap = elementList[e];
					const int id = emap*p_gjNp + k*p_gjNq*p_gjNq+ j*p_gjNq + i;
					Ixq[id] = s_q2[k][j][i];
					//s_q[k][j][i];
				}
			}
		}
	}// for e

	// at this point q is interpolated in all 3 dim.
	// ------------KERNEL 2 -------------->

	// kernel 2 differentiate on gj hex
	for(int e=0; e<Nelements; ++e; outer0) {
		shared dfloat s_gjD[p_gjNq][p_gjNq];
		//	shared dfloat s_gllD[p_gjNq][p_Nq];
		shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		shared dfloat s_q1[p_gjNq][p_gjNq][p_gjNq];
		shared dfloat s_q2[p_gjNq][p_gjNq][p_gjNq];
		shared dfloat s_q3[p_gjNq][p_gjNq][p_gjNq];
		shared dfloat s_i4[p_gjNq][p_gjNq][p_gjNq];
		//	exclusive dfloat r_qr, r_qs, r_qt, r_tmp;
		//		exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;
		//		exclusive int emap;

		for(int k=0; k<p_gjNq; ++k; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					// D to shared, q to shared,
					if (k==0 ) {
						s_gjD[j][i] = gllD[j*p_gjNq+i];
					}
					int emap = elementList[e];
					int t = i + j*p_gjNq + k*p_gjNq2;
					s_q[k][j][i] = Ixq[emap*p_gjNp+t];

				}//for i
			}//for j
		}//for k
		barrier(localMemFence);

		for(int k=0; k<p_gjNq; ++k; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					//load geofactors for my (k,j,i)
					dfloat qr, qs, qt, tmp;
					dfloat G00, G01, G02, G11, G12, G22, GwJ;
					int emap;

					const int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					//geofactors for k j i thread
					GwJ = gjGeo[base+p_GWJID*p_gjNp];
					G00 = gjGeo[base+p_G00ID*p_gjNp];
					G01 = gjGeo[base+p_G01ID*p_gjNp];
					G02 = gjGeo[base+p_G02ID*p_gjNp];

					G11 = gjGeo[base+p_G11ID*p_gjNp];
					G12 = gjGeo[base+p_G12ID*p_gjNp];
					G22 = gjGeo[base+p_G22ID*p_gjNp];
					// now, put together dq/dr, qq/ds, dq/dt and dq/dI

					dfloat dr = 0.0f;
					dfloat ds = 0.0f;
					dfloat dt = 0.0f;
					occaUnroll(p_gjNq)
					for (int n = 0; n<p_gjNq; ++n) {
						dr += s_gjD[i][n] * s_q[k][j][n];
						ds += s_gjD[j][n] *s_q[k][n][i];
						dt += s_gjD[k][n] *s_q[n][j][i];
					}
					qr = G00*dr + G01*ds + G02*dt;
					qs = G01*dr + G11*ds + G12*dt;
					qt = G02*dr + G12*ds + G22*dt;

					tmp = GwJ*s_q[k][j][i]*lambda;

					s_q1[k][j][i] = qr;
					s_q2[k][j][i] = qs;
					s_q3[k][j][i] = qt;
					s_i4[k][j][i] = tmp;



				}
			}
		}
		barrier(localMemFence);
		// Multiply by D^T, size p_Nq x p_gjNq
		// D size p_gjNq x p_Nq



		for(int k=0; k<p_gjNq; ++k; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					dfloat tmp = 0.f;
					occaUnroll(p_gjNq)
					for(int m=0; m<p_gjNq; ++m) {
						tmp += s_gjD[m][i]*s_q1[k][j][m];
						tmp += s_gjD[m][j]*s_q2[k][m][i];
						tmp += s_gjD[m][k]*s_q3[m][j][i];
					}
					s_i4[k][j][i]+=tmp;
					int emap = elementList[e];
					int base = emap*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					Ixq[base] =	s_i4[k][j][i];
				}
			}
		}
	}//for e

	//-------------------- kernel 3 interpolate back to gll hex ------------------->

	for(int e=0; e<Nelements; ++e; outer0) {
		// read q

		shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		shared dfloat s_q2[p_gjNq][p_gjNq][p_gjNq];
		shared dfloat s_I[p_gjNq][p_Nq];
		//	exclusive dfloat r_res = 0.0f, r_Aq=0.0f;
		//	int emap;
		for(int k=0; k<p_gjNq; ++k; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {

					int base = k*p_gjNq*p_gjNq + j*p_gjNq + i;
					int emap =elementList[e];
					s_q[k][j][i] = Ixq[emap*p_gjNp+base];
					if(i<p_Nq &&  k == 0 && j<p_gjNq) {
						s_I[j][i] = gjI[j*p_Nq+i];
					}
				}
			}
		}
		barrier(localMemFence);


		// t first
		for(int c=0; c<p_gjNq; ++c; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					dfloat Iq = 0.0f;
					if(c<p_Nq){
						occaUnroll(p_gjNq)
						for(int m=0; m<p_gjNq; ++m) {
							// k--> c
							Iq += s_I[m][c]*s_q[m][j][i];
						}
					}
					//r_res = Iq;
					s_q2[c][j][i] = Iq;

				}
			}
		}






		// r direction
		barrier(localMemFence);

		for(int c=0; c<p_gjNq; ++c; inner2) {
			for(int b=0; b<p_gjNq; ++b; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					if(c<p_Nq && b<p_Nq){
						dfloat Iq = 0.0f;
						occaUnroll(p_gjNq)
						for(int m=0; m<p_gjNq; ++m) {
							Iq += s_I[m][b]*s_q2[c][m][i];
						}

						s_q[c][b][i] = Iq;
					}
				}
			}
		}
		barrier(localMemFence);




		for(int c=0; c<p_gjNq; ++c; inner2) {
			for(int b=0; b<p_gjNq; ++b; inner1) {
				for(int a=0; a<p_gjNq; ++a; inner0) {
					if (c<p_Nq && b<p_Nq && a< p_Nq){
						dfloat Iq = 0.0f;
						occaUnroll(p_gjNq)
						for(int m=0; m<p_gjNq; ++m) {
							Iq += s_I[m][a]*s_q[c][b][m];
						}
						int emap = elementList[e];
						int base = emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a;
						Aq[base] = Iq;
					}
				}
			}
		}
	}//e
} //kernel e11

// kernel e12 is a ONE KERNEL version of e11

kernel void ellipticPartialAxHex3D_e12(const int Nelements,
                                       const int * restrict elementList,
                                       const dfloat * restrict gjGeo,
                                       const dfloat * restrict gllD,
                                       const dfloat * restrict gjI,
                                       const dfloat lambda,
                                       dfloat * restrict q,
                                       dfloat * restrict Ixq,
                                       dfloat * restrict Aq
                                      ){


	// load q into shared first
	//kernel 1 - interpolate to gj hex
	for(int e=0; e<Nelements; ++e; outer0) {
		//	exclusive int emap;
		//	exclusive dfloat r_res;
		shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];

		shared dfloat s_q1[p_gjNq][p_gjNq][p_gjNq];
		shared dfloat s_q2[p_gjNq][p_gjNq][p_gjNq];
		shared dfloat s_q3[p_gjNq][p_gjNq][p_gjNq];
		shared dfloat s_i4[p_gjNq][p_gjNq][p_gjNq];

		shared dfloat s_gjD[p_gjNq][p_gjNq];
		shared dfloat s_gsI[p_gjNq][p_Nq];

		for(int c=0; c<p_gjNq; ++c; inner2) {
			for(int b=0; b<p_gjNq; ++b; inner1) {
				for(int a=0; a<p_gjNq; ++a; inner0) {
					//		r_res =0.0f;
					if (c == 0 && a<p_Nq && b<p_gjNq) {
						s_gsI[b][a] = gjI[b*p_Nq+a];
					}
					if (c==0 ) {
						s_gjD[b][a] = gllD[b*p_gjNq+a];
					}

					int emap = elementList[e];
					int t = a + b*p_gjNq + c*p_gjNq2;
					if (t<p_Np) {
						int ta = t%p_Nq;
						int tb = (t/p_Nq)%p_Nq;
						int tc = t/p_Nq2;
						s_q2[tc][tb][ta] = q[emap*p_Np+t];
					}//if
				}//for a
			}// for b
		}//for c
		//synch threads
		barrier(localMemFence);
		//============== interpolate in 3 dir ========================
		// r --> s --> t
		// rrrrrrr
		for(int c=0; c<p_gjNq; ++c; inner2) {
			for(int b=0; b<p_gjNq; ++b; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					//		dfloat Iq = 0.0f;
					s_q[c][b][i] = 0.0f;
					if (c<p_Nq && b<p_Nq){
						occaUnroll(p_Nq)
						for(int n=0; n<p_Nq; ++n) {
							s_q[c][b][i] += s_gsI[i][n]*s_q2[c][b][n];
						}
					}

				}
			}
		}

		barrier(localMemFence);


		for(int c=0; c<p_gjNq; ++c; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					//	dfloat Iq = 0.0f;
					s_q2[c][j][i] = 0.0f;
					if(c<p_Nq) {
						occaUnroll(p_Nq)
						for(int n=0; n<p_Nq; ++n) {
							s_q2[c][j][i] += s_gsI[j][n]*s_q[c][n][i];
						}
					}

				}
			}
		}
		barrier(localMemFence);



		// t direction

		for(int k=0; k<p_gjNq; ++k; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					//	dfloat Iq = 0.0f;
					s_q[k][j][i] =0.0f;
					occaUnroll(p_Nq)
					for(int n=0; n<p_Nq; ++n) {
						s_q[k][j][i] += s_gsI[k][n]*s_q2[n][j][i];
					}
				}
			}
		}


		// at this point q is interpolated in all 3 dim.
		// ------------KERNEL 2 -------------->

		barrier(localMemFence);

		for(int k=0; k<p_gjNq; ++k; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					//load geofactors for my (k,j,i)
					dfloat qr, qs, qt, tmp;
					dfloat G00, G01, G02, G11, G12, G22, GwJ;
					int emap;

					const int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					//geofactors for k j i thread
					GwJ = gjGeo[base+p_GWJID*p_gjNp];
					G00 = gjGeo[base+p_G00ID*p_gjNp];
					G01 = gjGeo[base+p_G01ID*p_gjNp];
					G02 = gjGeo[base+p_G02ID*p_gjNp];

					G11 = gjGeo[base+p_G11ID*p_gjNp];
					G12 = gjGeo[base+p_G12ID*p_gjNp];
					G22 = gjGeo[base+p_G22ID*p_gjNp];
					// now, put together dq/dr, qq/ds, dq/dt and dq/dI

					dfloat dr = 0.0f;
					dfloat ds = 0.0f;
					dfloat dt = 0.0f;
					occaUnroll(p_gjNq)
					for (int n = 0; n<p_gjNq; ++n) {
						dr += s_gjD[i][n] * s_q[k][j][n];
						ds += s_gjD[j][n] * s_q[k][n][i];
						dt += s_gjD[k][n] * s_q[n][j][i];
					}
					qr = G00*dr + G01*ds + G02*dt;
					qs = G01*dr + G11*ds + G12*dt;
					qt = G02*dr + G12*ds + G22*dt;

					tmp = GwJ*s_q[k][j][i]*lambda;

					s_q1[k][j][i] = qr;
					s_q2[k][j][i] = qs;
					s_q3[k][j][i] = qt;
					s_i4[k][j][i] = tmp;



				}
			}
		}
		barrier(localMemFence);
		// Multiply by D^T, size p_Nq x p_gjNq
		// D size p_gjNq x p_Nq



		for(int k=0; k<p_gjNq; ++k; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					dfloat tmp = 0.f;
					occaUnroll(p_gjNq)
					for(int m=0; m<p_gjNq; ++m) {
						tmp += s_gjD[m][i]*s_q1[k][j][m];
						tmp += s_gjD[m][j]*s_q2[k][m][i];
						tmp += s_gjD[m][k]*s_q3[m][j][i];
					}
					s_i4[k][j][i]+=tmp;

					s_q[k][j][i] =	s_i4[k][j][i];
				}
			}
		}

		barrier(localMemFence);


		// t first
		for(int c=0; c<p_gjNq; ++c; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					dfloat Iq = 0.0f;
					if(c<p_Nq){
						occaUnroll(p_gjNq)
						for(int m=0; m<p_gjNq; ++m) {
							// k--> c
							Iq += s_gsI[m][c]*s_q[m][j][i];
						}
					}
					//r_res = Iq;
					s_q2[c][j][i] = Iq;

				}
			}
		}






		// r direction
		barrier(localMemFence);

		for(int c=0; c<p_gjNq; ++c; inner2) {
			for(int b=0; b<p_gjNq; ++b; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					if(c<p_Nq && b<p_Nq){
						dfloat Iq = 0.0f;
						occaUnroll(p_gjNq)
						for(int m=0; m<p_gjNq; ++m) {
							Iq += s_gsI[m][b]*s_q2[c][m][i];
						}

						s_q[c][b][i] = Iq;
					}
				}
			}
		}
		barrier(localMemFence);




		for(int c=0; c<p_gjNq; ++c; inner2) {
			for(int b=0; b<p_gjNq; ++b; inner1) {
				for(int a=0; a<p_gjNq; ++a; inner0) {
					if (c<p_Nq && b<p_Nq && a< p_Nq){
						dfloat Iq = 0.0f;
						occaUnroll(p_gjNq)
						for(int m=0; m<p_gjNq; ++m) {
							Iq += s_gsI[m][a]*s_q[c][b][m];
						}
						int emap = elementList[e];
						int base = emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a;
						Aq[base] = Iq;
					}
				}
			}
		}
	}//e
} //kernel e12



//e6c is a version of e6 just no exclusive variables

kernel void ellipticPartialAxHex3D_e6c(const int Nelements,
                                       const int * restrict elementList,
                                       const dfloat * restrict gjGeo,
                                       const dfloat * restrict gjD,
                                       const dfloat * restrict gjI,
                                       const dfloat lambda,
                                       dfloat * restrict q,
                                       dfloat * restrict Aq,
                                       dfloat * restrict qAq){
	//KS Nall = 64000, mesh->Np = 125 mesh->Nelements = 512
	for(int e=0; e<Nelements; ++e; outer0) {

		//KS: every thread processes one element
		// p_Nq number of points in the element
		//KS: Nggeo = 7, gjNq = 6, gjNp = 216 Nq = 5


		shared dfloat s_D[p_gjNq][p_Nq+p_gllPad];
		shared dfloat s_I[p_gjNq][p_Nq+p_gllPad];

		shared dfloat s_q[p_gjNq][p_gjNq][p_Nq];
		shared dfloat s_lapq[p_gjNq][p_gjNq][p_Nq];

		shared dfloat s_Ixxq[p_Nq][p_Nq+p_gllPad];
		shared dfloat s_Dxxq[p_Nq][p_Nq+p_gllPad];

		shared dfloat s_IxDq[p_Nq][p_gjNq+p_gjPad];
		shared dfloat s_IxIq[p_Nq][p_gjNq+p_gjPad];
		shared dfloat s_DxIq[p_Nq][p_gjNq+p_gjPad];

		shared dfloat s_qr[p_gjNq][p_gjNq+p_gjPad];
		shared dfloat s_qs[p_gjNq][p_gjNq+p_gjPad];
		shared dfloat s_qt[p_gjNq][p_gjNq+p_gjPad];

		shared dfloat s_Dqr[p_gjNq][p_Nq+p_gllPad];
		shared dfloat s_Iqs[p_gjNq][p_Nq+p_gllPad];
		shared dfloat s_Iqt[p_gjNq][p_Nq+p_gllPad];

		shared dfloat s_qI[p_gjNq][p_gjNq+p_gjPad];

		//	exclusive int emap, ta, tb;
		exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;
		// less registers (by half) or less shared (ny half)
		// get rid of one of the register arrryas
		// use a cube of shared
		// rewrite

		// put q in shared
		// interpolation matrix in 3 directions
		// change which D we using (larger D) gjN

		// prefetch D and I matrices and zero register storage
		for(int b=0; b<p_gjNq; ++b; inner1) {
			for(int a=0; a<p_gjNq; ++a; inner0) {
				const int t = a + p_gjNq*b;

				if(a<p_Nq && b<p_gjNq) {
					s_D[b][a] = gjD[b*p_Nq+a];
					s_I[b][a] = gjI[b*p_Nq+a];
				}

				for(int c=0; c<p_Nq; ++c) {
					//	  r_q[c] = 0;
					s_lapq[b][a][c] = 0;
				}

				int emap = elementList[e];
				//Nq2 = Nq*Nq
				if(a<p_Nq && b<p_Nq) {

					occaUnroll(p_Nq)
					for(int c=0; c<p_Nq; ++c) {
						s_q[b][a][c] = q[emap*p_Np+c*p_Nq2+b*p_Nq+a];
					}                                                                                                                                                        //for c
				}                                                                                                                                                        //if
			}                                                                                                                                                        //for a
		}                                                                                                                                                        //for b

		// *************** scan through k slices
		// ==================================== prefetch first, diff in 't'
		for(int k=0; k<p_gjNq; ++k) {

			optBarrier(localMemFence);

			// prefetch slice
			for(int b=0; b<p_gjNq; ++b; inner1) {
				for(int a=0; a<p_gjNq; ++a; inner0) {
					int emap = elementList[e];
					int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + b*p_gjNq + a;
					r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
					r_G00 = gjGeo[base+p_G00ID*p_gjNp];
					r_G01 = gjGeo[base+p_G01ID*p_gjNp];
					r_G02 = gjGeo[base+p_G02ID*p_gjNp];

					r_G11 = gjGeo[base+p_G11ID*p_gjNp];
					r_G12 = gjGeo[base+p_G12ID*p_gjNp];
					r_G22 = gjGeo[base+p_G22ID*p_gjNp];

					// assumes w*J built into G entries

					if (a<p_Nq && b<p_Nq) {

						dfloat Iqk = 0, Dqk = 0;

						// puts more data in flight
						for(int c=0; c<p_Nq; ++c) {
							const dfloat qcba = s_q[b][a][c];
							Iqk += s_I[k][c]*qcba;
							Dqk += s_D[k][c]*qcba;
						}
						s_Ixxq[b][a] = Iqk;
						s_Dxxq[b][a] = Dqk;
					}
				}
			}

			optBarrier(localMemFence);
			//=========================== r direction =========================================
			// interpolate and differentiate in 'r' direction
			for(int b=0; b<p_gjNq; ++b; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {

					if(b<p_Nq) {

						dfloat IxDq= 0, IxIq = 0, DxIq = 0;

						occaUnroll(p_Nq)
						for(int a=0; a<p_Nq; ++a) {
							const dfloat Iia = s_I[i][a];
							const dfloat Ixxqba = s_Ixxq[b][a];
							IxIq += Iia*Ixxqba;
							DxIq += Iia*s_Dxxq[b][a];
						}

						occaUnroll(p_Nq)
						for(int a=0; a<p_Nq; ++a) {
							const dfloat Dia = s_D[i][a];
							const dfloat Ixxqba = s_Ixxq[b][a];
							IxDq += Dia*Ixxqba;
						}

						s_IxDq[b][i] = IxDq;
						// this is what we want
						s_IxIq[b][i] = IxIq;
						s_DxIq[b][i] = DxIq;
					}
				}
			}

			optBarrier(localMemFence);
			//=============================== derivatives =========================================
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {

					dfloat qr = 0, qs = 0, qt = 0, qI = 0;

					// interpolate and differentiate in 's' direction
					occaUnroll(p_Nq)
					for(int b=0; b<p_Nq; ++b) {
						const dfloat Ijn = s_I[j][b];
						// qr = dq/dr, qt = dq/dt and qI = dq/dI
						qr += Ijn*s_IxDq[b][i];
						qt += Ijn*s_DxIq[b][i];
						qI += Ijn*s_IxIq[b][i];
					}

					occaUnroll(p_Nq)
					//qs = dq/ds
					for(int b=0; b<p_Nq; ++b) {
						const dfloat Djn = s_D[j][b];
						qs += Djn*s_IxIq[b][i];
					}

					// apply chain rule (notice the swtich of indices in i,j)

					//	dfloat G00, G01, G02, G11, G12, G22, GwJ;


					s_qr[i][j] = r_G00*qr + r_G01*qs + r_G02*qt;
					s_qs[i][j] = r_G01*qr + r_G11*qs + r_G12*qt;
					s_qt[i][j] = r_G02*qr + r_G12*qs + r_G22*qt;
					// qI needed because of interpolation (?)
					s_qI[i][j] = r_GwJ*qI*lambda;
				}                                                                                                                                                        // for i
			}                                                                                                                                                        // for j
			// =============================== transpose differentiate ==============================
			optBarrier(localMemFence);

			// transpose differentiate and interpolate in 'r'
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int a=0; a<p_gjNq; ++a; inner0) {

					if(a<p_Nq) {
						dfloat tmpr = 0, tmps = 0, tmpt = 0, tmpI = 0;
						occaUnroll(p_gjNq)
						for(int i=0; i<p_gjNq; ++i) {
							const dfloat Iia = s_I[i][a];
							tmps += Iia*s_qs[i][j];
							tmpt += Iia*s_qt[i][j];
							tmpI += Iia*s_qI[i][j];
						}

						occaUnroll(p_gjNq)
						for(int i=0; i<p_gjNq; ++i) {
							const dfloat Dia = s_D[i][a];
							tmpr += Dia*s_qr[i][j];
						}

						s_Dqr[j][a] = tmpr+tmpI;                                                                                                                                                         // blend lambda term in here
						s_Iqs[j][a] = tmps;
						s_Iqt[j][a] = tmpt;
					}
				}
			}

			optBarrier(localMemFence);

			// transpose differentiate and interpolate in 's'
			for(int b=0; b<p_gjNq; ++b; inner1) {
				for(int a=0; a<p_gjNq; ++a; inner0) {
					if(a<p_Nq && b<p_Nq) {
						dfloat tmpr = 0, tmps = 0, tmpt = 0;

						occaUnroll(p_gjNq)
						for(int j=0; j<p_gjNq; ++j) {
							const dfloat Ijb = s_I[j][b];

							tmpr += Ijb*s_Dqr[j][a];
							tmpt += Ijb*s_Iqt[j][a];
						}


						occaUnroll(p_gjNq)
						for(int j=0; j<p_gjNq; ++j) {
							const dfloat Djb = s_D[j][b];

							tmps += Djb*s_Iqs[j][a];
						}

						// transpose differentiate and interpolate in 't'
						tmpr += tmps;                                                                                                                                                         // blend r and s
						occaUnroll(p_Nq)
						for(int c=0; c<p_Nq; ++c) {
							s_lapq[b][a][c] += s_I[k][c]*tmpr + s_D[k][c]*tmpt;
						}
					}
				}
			}
		}  // k                                                                                                                                                      // this is FOR k

		optBarrier(localMemFence);

		for(int b=0; b<p_gjNq; ++b; inner1) {
			for(int a=0; a<p_gjNq; ++a; inner0) {

				dfloat r_qAq = 0;

				if(a<p_Nq && b<p_Nq) {
					occaUnroll(p_Nq)
					for(int c=0; c<p_Nq; ++c) {
						int emap = elementList[e];
						const int id = emap*p_Np + c*p_Nq2 + b*p_Nq + a;
						Aq[id] = s_lapq[b][a][c];
					}
				}
			}
		}
	}
}//e6c






// e10 is an optimized version of e9 - WITH as little memFences as possible.
// written by Kasia, Aug 10 2017
/*
kernel void ellipticPartialAxHex3D_10( const int Nelements,
                                      const int * restrict elementList,
                                      const dfloat * restrict gjGeo,
                                      const dfloat * restrict gjD,
                                      const dfloat * restrict gjI,
                                      const dfloat * restrict gllD,
                                      const dfloat lambda,
                                      dfloat * restrict q,
                                      dfloat * restrict Ixq,
                                      dfloat * restrict Aq,
                                      float * restrict qAq

)
{

// ---- KERNEL 1 ---- INTERPOLATE

//load to shared first
for(int e=0; e<Nelements; ++e; outer0) {
	exclusive int emap;
	exclusive dfloat r_res;
	shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
	shared dfloat s_I[p_gjNq][p_Nq];
		for(int c=0; c<p_Nq; ++c; inner2) {
			for(int b=0; b<p_Nq; ++b; inner1) {
				for(int i=0; i<p_Nq; ++i; inner0) {
		}}}
	
// prefetch to shared

}
}



kernel void ellipticPartialAxHex3D_cube1(const int Nelements,
					 const int * restrict elementList,
					 const dfloat * restrict gjGeo,
					 const dfloat * restrict gjD,
					 const dfloat * restrict gjI,
					 const dfloat   lambda,
					 const dfloat * restrict q,
					 dfloat * restrict Aq,
					 dfloat * restrict qtmp){


  for(int e=0;e<Nelements;++e;outer0){

    shared dfloat s_gjD[p_gjNq][p_gjNq];
    shared dfloat s_I[p_gjNq][p_Nq];

    shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];

    exclusive int emap;
    exclusive dfloat r_resr, r_ress, r_rest, r_resI;

    // prefetch D and I matrices and zero register storage
    gjCubeThreads(c,b,a){
      const int t = a + p_gjNq*b + p_gjNq2*c;

      if(t<p_gjNq*p_gjNq)
	s_gjD[0][t] = gjD[t];
      if(t<p_Nq*p_gjNq)
	s_I[0][t] = gjI[t];

      emap = elementList[e];

      if(t<p_Np){
	const int ta = t%p_Nq;
	const int tb = (t/p_Nq)%p_Nq;
	const int tc = t/(p_Nq*p_Nq);
	s_q[tc][tb][ta] = q[emap*p_Np+t];
      }
    }

    gjCubeThreads(c,b,i){
      if(b<p_Nq && c<p_Nq){
	dfloat tmp = 0;
	occaUnroll(p_Nq)
	  for(int a=0;a<p_Nq;++a) // transform in 'a'
	    tmp += s_I[i][a]*s_q[c][b][a];
	r_resr = tmp;
      }
    }

    gjCubeThreads(c,b,i)
      s_q[c][b][i] = r_resr;

    gjCubeThreads(c,j,i){
      if(c<p_Nq){
	dfloat tmp = 0;
	occaUnroll(p_Nq)
	  for(int b=0;b<p_Nq;++b) // transform in 'b'
	    tmp += s_I[j][b]*s_q[c][b][i];
	r_ress = tmp;
      }
    }

    gjCubeThreads(c,j,i)
      s_q[c][j][i] = r_ress;

    gjCubeThreads(k,j,i){
      dfloat tmp = 0;
      occaUnroll(p_Nq)
	for(int c=0;c<p_Nq;++c) // transform in 'c'
	  tmp += s_I[k][c]*s_q[c][j][i];
      r_rest = tmp;
    }

    gjCubeThreads(k,j,i)
      s_q[k][j][i] = r_rest;

    gjCubeThreads(k,j,i){
      const int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
      const dfloat r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
      const dfloat r_G00 = gjGeo[base+p_G00ID*p_gjNp];
      const dfloat r_G01 = gjGeo[base+p_G01ID*p_gjNp];
      const dfloat r_G02 = gjGeo[base+p_G02ID*p_gjNp];

      const dfloat r_G11 = gjGeo[base+p_G11ID*p_gjNp];
      const dfloat r_G12 = gjGeo[base+p_G12ID*p_gjNp];
      const dfloat r_G22 = gjGeo[base+p_G22ID*p_gjNp];

      dfloat qr = 0, qs = 0, qt = 0;

      occaUnroll(p_gjNq)
	for(int n=0;n<p_gjNq;++n){
	  qr += s_gjD[i][n]*s_q[k][j][n];
	  qs += s_gjD[j][n]*s_q[k][n][i];
	  qt += s_gjD[k][n]*s_q[n][j][i];
	}

      // apply chain rule (notice the swtich of indices in i,j)
      r_resr = r_G00*qr + r_G01*qs + r_G02*qt;
      r_ress = r_G01*qr + r_G11*qs + r_G12*qt;
      r_rest = r_G02*qr + r_G12*qs + r_G22*qt;
      r_resI = r_GwJ*s_q[k][j][i]*lambda;
    }

    // compute 'r' weak derivative of resr
    gjCubeThreads(k,j,i)
      s_q[k][j][i] = r_resr;

    gjCubeThreads(k,j,i){
      dfloat tmp = 0;
      occaUnroll(p_gjNq)
	for(int n=0;n<p_gjNq;++n)
	  tmp += s_gjD[n][i]*s_q[k][j][n]; // transpose(D)
      r_resI += tmp;
    }

    // compute 's' weak derivative of resr
    gjCubeThreads(k,j,i)
      s_q[k][j][i] = r_ress;

    gjCubeThreads(k,j,i){
      dfloat tmp = 0;
      occaUnroll(p_gjNq)
	for(int n=0;n<p_gjNq;++n)
	  tmp += s_gjD[n][j]*s_q[k][n][i]; // transpose(D)
      r_resI += tmp;
    }

    // compute 't' weak derivative of resr
    gjCubeThreads(k,j,i)
      s_q[k][j][i] = r_rest;

    gjCubeThreads(k,j,i){ // notice swapped
      dfloat tmp = 0;
      occaUnroll(p_gjNq)
	for(int n=0;n<p_gjNq;++n)
	  tmp += s_gjD[n][k]*s_q[n][j][i]; // transpose(D)
      r_resI += tmp;
    }

    // NOW REVERSE: transform back in 't'
    gjCubeThreads(k,j,i)
      s_q[k][j][i] = r_resI;

    gjCubeThreads(c,j,i){
      dfloat tmp = 0;
      if(c<p_Nq){
	occaUnroll(p_gjNq)
	  for(int n=0;n<p_gjNq;++n)
	    tmp += s_I[n][c]*s_q[n][j][i];
      }
      r_rest = tmp;
    }

    // transform back in 's'
    gjCubeThreads(c,j,i)
      s_q[c][j][i] = r_rest;

    gjCubeThreads(c,b,i){
      dfloat tmp = 0;
      if(c<p_Nq && b<p_Nq){
	occaUnroll(p_gjNq)
	  for(int n=0;n<p_gjNq;++n)
	    tmp += s_I[n][b]*s_q[c][n][i];
      }
      r_ress = tmp;
    }

    // transform back in 'r'
    gjCubeThreads(c,b,i)
      s_q[c][b][i] = r_ress;

    gjCubeThreads(c,b,a){
      if(a<p_Nq && b<p_Nq && c<p_Nq){
	dfloat tmp = 0;
	occaUnroll(p_gjNq)
	  for(int n=0;n<p_gjNq;++n)
	    tmp += s_I[n][a]*s_q[c][b][n];
	// could store in s_q again
	const int id = emap*p_Np + c*p_Nq2 + b*p_Nq + a;
	Aq[id] = tmp;
      }
    }
  }
}
#endif



// Version of Kasia kernel
kernel void ellipticPartialAxHex3D_cube2(const int Nelements,
					 const int * restrict elementList,
					 const dfloat * restrict gjGeo,
					 const dfloat * restrict gjD,
					 const dfloat * restrict gjI,
					 const dfloat   lambda,
					 const dfloat * restrict q,
					 dfloat * restrict Aq,
					 dfloat * restrict tmpq){


  // interpolate to GJ nodes
  for(int e=0;e<Nelements;++e;outer0){

    shared dfloat s_I[p_gjNq][p_Nq];
    shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];

    exclusive int emap;
    exclusive dfloat r_resr, r_ress, r_rest, r_resI;

    // prefetch D and I matrices and zero register storage
    gjCubeThreads(c,b,a){
      const int t = a + p_gjNq*b + p_gjNq2*c;

      if(t<p_Nq*p_gjNq)
	s_I[0][t] = gjI[t];

      emap = elementList[e];

      if(t<p_Np){
	const int ta = t%p_Nq;
	const int tb = (t/p_Nq)%p_Nq;
	const int tc = t/(p_Nq*p_Nq);
	s_q[tc][tb][ta] = q[emap*p_Np+t];
      }
    }

    gjCubeThreads(c,b,i){
      if(b<p_Nq && c<p_Nq){
	dfloat tmp = 0;
	occaUnroll(p_Nq)
	  for(int a=0;a<p_Nq;++a) // transform in 'a'
	    tmp += s_I[i][a]*s_q[c][b][a];
	r_resr = tmp;
      }
    }

    gjCubeThreads(c,b,i)
      s_q[c][b][i] = r_resr;

    gjCubeThreads(c,j,i){
      if(c<p_Nq){
	dfloat tmp = 0;
	occaUnroll(p_Nq)
	  for(int b=0;b<p_Nq;++b) // transform in 'b'
	    tmp += s_I[j][b]*s_q[c][b][i];
	r_ress = tmp;
      }
    }

    gjCubeThreads(c,j,i)
      s_q[c][j][i] = r_ress;

    gjCubeThreads(k,j,i){
      dfloat tmp = 0;
      occaUnroll(p_Nq)
	for(int c=0;c<p_Nq;++c) // transform in 'c'
	  tmp += s_I[k][c]*s_q[c][j][i];

      tmpq[emap*p_gjNp + k*p_gjNq2 + j*p_gjNq + i] = tmp;
    }
  }

  // perform differentiation
  for(int e=0;e<Nelements;++e;outer0){

    shared dfloat s_gjD[p_gjNq][p_gjNq];
    shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];

    exclusive int emap;
    exclusive dfloat r_resr, r_ress, r_rest, r_resI;

    // prefetch D and I matrices and zero register storage
    gjCubeThreads(k,j,i){
      const int t = i + p_gjNq*j + p_gjNq2*k;

      if(t<p_gjNq*p_gjNq)
	s_gjD[0][t] = gjD[t];

      emap = elementList[e];

      s_q[k][j][i] = tmpq[emap*p_gjNp+k*p_gjNq2+j*p_gjNq+i];
    }

    gjCubeThreads(k,j,i){
      const int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
      const dfloat r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
      const dfloat r_G00 = gjGeo[base+p_G00ID*p_gjNp];
      const dfloat r_G01 = gjGeo[base+p_G01ID*p_gjNp];
      const dfloat r_G02 = gjGeo[base+p_G02ID*p_gjNp];

      const dfloat r_G11 = gjGeo[base+p_G11ID*p_gjNp];
      const dfloat r_G12 = gjGeo[base+p_G12ID*p_gjNp];
      const dfloat r_G22 = gjGeo[base+p_G22ID*p_gjNp];

      dfloat qr = 0, qs = 0, qt = 0;

      occaUnroll(p_gjNq)
	for(int n=0;n<p_gjNq;++n){
	  qr += s_gjD[i][n]*s_q[k][j][n];
	  qs += s_gjD[j][n]*s_q[k][n][i];
	  qt += s_gjD[k][n]*s_q[n][j][i];
	}

      // apply chain rule (notice the swtich of indices in i,j)
      r_resr = r_G00*qr + r_G01*qs + r_G02*qt;
      r_ress = r_G01*qr + r_G11*qs + r_G12*qt;
      r_rest = r_G02*qr + r_G12*qs + r_G22*qt;
      r_resI = r_GwJ*s_q[k][j][i]*lambda;
    }

    // compute 'r' weak derivative of resr
    gjCubeThreads(k,j,i)
      s_q[k][j][i] = r_resr;

    gjCubeThreads(k,j,i){
      dfloat tmp = 0;
      occaUnroll(p_gjNq)
	for(int n=0;n<p_gjNq;++n)
	  tmp += s_gjD[n][i]*s_q[k][j][n]; // transpose(D)
      r_resI += tmp;
    }

    // compute 's' weak derivative of resr
    gjCubeThreads(k,j,i)
      s_q[k][j][i] = r_ress;

    gjCubeThreads(k,j,i){
      dfloat tmp = 0;
      occaUnroll(p_gjNq)
	for(int n=0;n<p_gjNq;++n)
	  tmp += s_gjD[n][j]*s_q[k][n][i]; // transpose(D)
      r_resI += tmp;
    }

    // compute 't' weak derivative of resr
    gjCubeThreads(k,j,i)
      s_q[k][j][i] = r_rest;

    gjCubeThreads(k,j,i){ // notice swapped
      dfloat tmp = 0;
      occaUnroll(p_gjNq)
	for(int n=0;n<p_gjNq;++n)
	  tmp += s_gjD[n][k]*s_q[n][j][i]; // transpose(D)
      r_resI += tmp;

      tmpq[emap*p_gjNp+k*p_gjNq2+j*p_gjNq+i] = r_resI;
    }
  }

  // interpolate back
  for(int e=0;e<Nelements;++e;outer0){

    shared dfloat s_I[p_gjNq][p_Nq];
    shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];

    exclusive int emap;
    exclusive dfloat r_ress, r_rest, r_resI;

    // NOW REVERSE: transform back in 't'
    gjCubeThreads(k,j,i){
      const int t = i + p_gjNq*j + p_gjNq2*k;
      if(t<p_Nq*p_gjNq)

      emap = elementList[e];
      s_q[k][j][i] = tmpq[emap*p_gjNp+t];
    }

    gjCubeThreads(c,j,i){
      dfloat tmp = 0;
      if(c<p_Nq){
	occaUnroll(p_gjNq)
	  for(int n=0;n<p_gjNq;++n)
	    tmp += s_I[n][c]*s_q[n][j][i];
      }
      r_rest = tmp;
    }

    // transform back in 's'
    gjCubeThreads(c,j,i)
      s_q[c][j][i] = r_rest;

    gjCubeThreads(c,b,i){
      dfloat tmp = 0;
      if(c<p_Nq && b<p_Nq){
	occaUnroll(p_gjNq)
	  for(int n=0;n<p_gjNq;++n)
	    tmp += s_I[n][b]*s_q[c][n][i];
      }
      r_ress = tmp;
    }

    // transform back in 'r'
    gjCubeThreads(c,b,i)
      s_q[c][b][i] = r_ress;

    gjCubeThreads(c,b,a){
      if(a<p_Nq && b<p_Nq && c<p_Nq){
	dfloat tmp = 0;
	occaUnroll(p_gjNq)
	  for(int n=0;n<p_gjNq;++n)
	    tmp += s_I[n][a]*s_q[c][b][n];
	// could store in s_q again
	const int id = emap*p_Np + c*p_Nq2 + b*p_Nq + a;
	Aq[id] = tmp;
      }
    }
  }
}*/

