/*

The MIT License (MIT)

Copyright (c) 2017 Tim Warburton, Noel Chalmers, Jesse Chan, Ali Karakus

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/


// v0: basic version
kernel void ellipticPartialAxBBTet3D_v0(const dlong Nelements,
					const int elementOffset,
					const dfloat * restrict sgeo,   // surface geofacs
					const int * restrict faceNodes, // volume node indices of surface nodes
					const dfloat * restrict vgeo,   // volume geofacs (drdx, ...)
					const int * restrict D0ids,     // sparse D matrices
					const int * restrict D1ids,
					const int * restrict D2ids,
					const int * restrict D3ids,
					const dfloat * restrict Dvals,    
					const dfloat * restrict LIFT,   // dense lift matrix
					const dfloat * restrict MM,     // dense mass matrix
					const dfloat lambda,
					const dfloat * restrict q,
					dfloat * restrict Aq){
  
  for(dlong e=0;e<Nelements;++e;outer0){
    
    shared dfloat s_q[p_Np], s_qx[p_Np], s_qy[p_Np], s_qz[p_Np], s_flux[p_Nfaces*p_Nfp];
    exclusive dfloat r_Aq;
    
    // prefetch q for element e
    for(int n=0;n<p_Np;++n;inner0){
      s_q[n] = q[n+e*p_Np];
    }
    
    barrier(localMemFence);

    // grad
    for(int n=0;n<p_Np;++n;inner0){     // for all nodes in this element
      
      // prefetch geometric factors (constant on triangle)
      const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
      const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
      const dfloat drdz = vgeo[e*p_Nvgeo + p_RZID];
      const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
      const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];
      const dfloat dsdz = vgeo[e*p_Nvgeo + p_SZID];
      const dfloat dtdx = vgeo[e*p_Nvgeo + p_TXID];
      const dfloat dtdy = vgeo[e*p_Nvgeo + p_TYID];
      const dfloat dtdz = vgeo[e*p_Nvgeo + p_TZID];
      
      // compute 'r', 's',  and 't' derivatives of (q_m) at node n
      const int D0i1 = D0ids[n];
      const int D1i1 = D1ids[n];
      const int D2i1 = D2ids[n];
      const int D3i1 = D3ids[n];
      const dfloat Dval1 = Dvals[n];
      
      const int D0i2 = D0ids[n+p_Np];
      const int D1i2 = D1ids[n+p_Np];
      const int D2i2 = D2ids[n+p_Np];
      const int D3i2 = D3ids[n+p_Np];
      const dfloat Dval2 = Dvals[n+p_Np];
      
      const int D0i3 = D0ids[n+2*p_Np];
      const int D1i3 = D1ids[n+2*p_Np];
      const int D2i3 = D2ids[n+2*p_Np];
      const int D3i3 = D3ids[n+2*p_Np];    
      const dfloat Dval3 = Dvals[n+2*p_Np];
      
      const int D0i4 = D0ids[n+3*p_Np];
      const int D1i4 = D1ids[n+3*p_Np];
      const int D2i4 = D2ids[n+3*p_Np];
      const int D3i4 = D3ids[n+3*p_Np];    
      const dfloat Dval4 = Dvals[n+3*p_Np];
      
      const dfloat dqdr = .5f*(Dval1*(s_q[D1i1] - s_q[D0i1]) +
			       Dval2*(s_q[D1i2] - s_q[D0i2]) +
			       Dval3*(s_q[D1i3] - s_q[D0i3]) +
			       Dval4*(s_q[D1i4] - s_q[D0i4]));
      const dfloat dqds = .5f*(Dval1*(s_q[D2i1] - s_q[D0i1]) +
			       Dval2*(s_q[D2i2] - s_q[D0i2]) +
			       Dval3*(s_q[D2i3] - s_q[D0i3]) +
			       Dval4*(s_q[D2i4] - s_q[D0i4]));
      const dfloat dqdt = .5f*(Dval1*(s_q[D3i1] - s_q[D0i1]) +
			       Dval2*(s_q[D3i2] - s_q[D0i2]) +
			       Dval3*(s_q[D3i3] - s_q[D0i3]) +
			       Dval4*(s_q[D3i4] - s_q[D0i4]));
      
      // chain rule
      s_qx[n] = drdx*dqdr + dsdx*dqds + dtdx*dqdt;
      s_qy[n] = drdy*dqdr + dsdy*dqds + dtdy*dqdt;
      s_qz[n] = drdz*dqdr + dsdz*dqds + dtdz*dqdt;
      
      // mass term
      r_Aq = lambda*s_q[n];
    }

    barrier(localMemFence);
    
    for(int n=0;n<p_Np;++n;inner0){     // for all nodes in this element
      
      int m=n;
      while(m<p_Nfp*p_Nfaces){
	const int f = m/p_Nfp;
	const dlong sid = e*p_Nfaces*p_Nsgeo+f*p_Nsgeo;
	const int nid = faceNodes[m];
	const dfloat nx = sgeo[sid + p_NXID];
	const dfloat ny = sgeo[sid + p_NYID];
	const dfloat nz = sgeo[sid + p_NZID];
	const dfloat sJ = sgeo[sid + p_SJID];
	const dfloat invJ = sgeo[sid+p_IJID];
	const dfloat flux = invJ*sJ*(nx*s_qx[nid] + ny*s_qy[nid] + nz*s_qz[nid]);
	s_flux[m] = flux;
	m+=p_Np;
      }
    }
    
    barrier(localMemFence);

    // lift nx*qx+ny*qy+nz*qz
    // (doing this since we have Np threads)
    // yuck - this costs Np*Nfp*Nfaces
    for(int n=0;n<p_Np;++n;inner0){     // for all nodes in this element

      // 2 flops per 2 loads from L1+shared (=> 1 TFLOPS/s assuming perfect caching)
      occaUnroll(p_Nfp*p_Nfaces)
	for(int m=0;m<p_Nfp*p_Nfaces;++m){
	  r_Aq += LIFT[n+m*p_Np]*s_flux[m];
	}

      // div
      // double check this is ok
      // prefetch geometric factors (constant on triangle)
      const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
      const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
      const dfloat drdz = vgeo[e*p_Nvgeo + p_RZID];
      const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
      const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];
      const dfloat dsdz = vgeo[e*p_Nvgeo + p_SZID];
      const dfloat dtdx = vgeo[e*p_Nvgeo + p_TXID];
      const dfloat dtdy = vgeo[e*p_Nvgeo + p_TYID];
      const dfloat dtdz = vgeo[e*p_Nvgeo + p_TZID];
      
      const dfloat tmpr = drdx*s_qx[n] + drdy*s_qy[n] + drdz*s_qz[n];
      const dfloat tmps = dsdx*s_qx[n] + dsdy*s_qy[n] + dsdz*s_qz[n];
      const dfloat tmpt = dtdx*s_qx[n] + dtdy*s_qy[n] + dtdz*s_qz[n];

      s_qx[n] = tmpr;
      s_qy[n] = tmps;
      s_qz[n] = tmpt;
    }

    barrier(localMemFence);

    for(int n=0;n<p_Np;++n;inner0){     // for all nodes in this element

      // double check this is ok

      // compute 'r', 's',  and 't' derivatives of (q_m) at node n
      const int D0i1 = D0ids[n];
      const int D1i1 = D1ids[n];
      const int D2i1 = D2ids[n];
      const int D3i1 = D3ids[n];
      const dfloat Dval1 = Dvals[n];
      
      const int D0i2 = D0ids[n+p_Np];
      const int D1i2 = D1ids[n+p_Np];
      const int D2i2 = D2ids[n+p_Np];
      const int D3i2 = D3ids[n+p_Np];
      const dfloat Dval2 = Dvals[n+p_Np];
      
      const int D0i3 = D0ids[n+2*p_Np];
      const int D1i3 = D1ids[n+2*p_Np];
      const int D2i3 = D2ids[n+2*p_Np];
      const int D3i3 = D3ids[n+2*p_Np];    
      const dfloat Dval3 = Dvals[n+2*p_Np];
      
      const int D0i4 = D0ids[n+3*p_Np];
      const int D1i4 = D1ids[n+3*p_Np];
      const int D2i4 = D2ids[n+3*p_Np];
      const int D3i4 = D3ids[n+3*p_Np];    
      const dfloat Dval4 = Dvals[n+3*p_Np];
      
      const dfloat dqrdr = .5f*(Dval1*(s_qx[D1i1] - s_qx[D0i1]) +
				Dval2*(s_qx[D1i2] - s_qx[D0i2]) +
				Dval3*(s_qx[D1i3] - s_qx[D0i3]) +
				Dval4*(s_qx[D1i4] - s_qx[D0i4]));
      const dfloat dqsds = .5f*(Dval1*(s_qy[D2i1] - s_qy[D0i1]) +
				Dval2*(s_qy[D2i2] - s_qy[D0i2]) +
				Dval3*(s_qy[D2i3] - s_qy[D0i3]) +
				Dval4*(s_qy[D2i4] - s_qy[D0i4]));
      const dfloat dqtdt = .5f*(Dval1*(s_qz[D3i1] - s_qz[D0i1]) +
				Dval2*(s_qz[D3i2] - s_qz[D0i2]) +
				Dval3*(s_qz[D3i3] - s_qz[D0i3]) +
				Dval4*(s_qz[D3i4] - s_qz[D0i4]));
      
      // note sign change
      s_q[n] = r_Aq - (dqrdr + dqsds + dqtdt);
    }

    barrier(localMemFence);
    
    for(int n=0;n<p_Np;++n;inner0){     // for all nodes in this element
      
      // multiply by mass matrix
      const dfloat J = vgeo[e*p_Nvgeo + p_JID];    
      dfloat res = 0;
      
      // M*(lambda*q -(laplace q) + lift*(n.grad q))
      // 2 shared memory/L1 reads per 2 flops (=> 1 TFLOPS/s assuming perfect caching)
      occaUnroll(p_Np)
	for(int m=0;m<p_Np;++m){
	  res += MM[n+m*p_Np]*s_q[m];
	}
      
      Aq[n+e*p_Np] = J*res;
    }
  }
}

// v1: multiple outputs
kernel void ellipticPartialAxBBTet3D_v1(const dlong Nelements,
					const int elementOffset,
					const dfloat * restrict sgeo,   // surface geofacs
					const int * restrict faceNodes, // volume node indices of surface nodes
					const dfloat * restrict vgeo,   // volume geofacs (drdx, ...)
					const int * restrict D0ids,     // sparse D matrices
					const int * restrict D1ids,
					const int * restrict D2ids,
					const int * restrict D3ids,
					const dfloat * restrict Dvals,    
					const dfloat * restrict LIFT,   // dense lift matrix
					const dfloat * restrict MM,     // dense mass matrix
					const dfloat lambda,
					const dfloat * restrict q,
					dfloat * restrict Aq){
  
  for(dlong eo=0;eo<Nelements;eo+=p_Ne;outer0){
    
    shared dfloat s_q[p_Ne][p_Np], s_qx[p_Ne][p_Np], s_qy[p_Ne][p_Np], s_qz[p_Ne][p_Np], s_flux[p_Ne][p_Nfaces*p_Nfp];
    exclusive dfloat r_Aq[p_Ne];
    
    // prefetch q for element e
    for(int n=0;n<p_Np;++n;inner0){
      
      occaUnroll(p_Ne)
	for(int et=0;et<p_Ne;++et){
	  const int e = eo + et;
	  if(e<Nelements)
	    s_q[et][n] = q[n+e*p_Np];
	}
    }
    
    barrier(localMemFence);

    // grad
    for(int n=0;n<p_Np;++n;inner0){     // for all nodes in this element
      
      // compute 'r', 's',  and 't' derivatives of (q_m) at node n
      const int D0i1 = D0ids[n];
      const int D1i1 = D1ids[n];
      const int D2i1 = D2ids[n];
      const int D3i1 = D3ids[n];
      const dfloat Dval1 = Dvals[n];
      
      const int D0i2 = D0ids[n+p_Np];
      const int D1i2 = D1ids[n+p_Np];
      const int D2i2 = D2ids[n+p_Np];
      const int D3i2 = D3ids[n+p_Np];
      const dfloat Dval2 = Dvals[n+p_Np];
      
      const int D0i3 = D0ids[n+2*p_Np];
      const int D1i3 = D1ids[n+2*p_Np];
      const int D2i3 = D2ids[n+2*p_Np];
      const int D3i3 = D3ids[n+2*p_Np];    
      const dfloat Dval3 = Dvals[n+2*p_Np];
      
      const int D0i4 = D0ids[n+3*p_Np];
      const int D1i4 = D1ids[n+3*p_Np];
      const int D2i4 = D2ids[n+3*p_Np];
      const int D3i4 = D3ids[n+3*p_Np];    
      const dfloat Dval4 = Dvals[n+3*p_Np];

      occaUnroll(p_Ne)
	for(int et=0;et<p_Ne;++et){
	  const int e = eo + et;
	  if(e<Nelements){

	    // prefetch geometric factors (constant on triangle)
	    const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
	    const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
	    const dfloat drdz = vgeo[e*p_Nvgeo + p_RZID];
	    const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
	    const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];
	    const dfloat dsdz = vgeo[e*p_Nvgeo + p_SZID];
	    const dfloat dtdx = vgeo[e*p_Nvgeo + p_TXID];
	    const dfloat dtdy = vgeo[e*p_Nvgeo + p_TYID];
	    const dfloat dtdz = vgeo[e*p_Nvgeo + p_TZID];

	    
	    const dfloat dqdr = .5f*(Dval1*(s_q[et][D1i1] - s_q[et][D0i1]) +
				     Dval2*(s_q[et][D1i2] - s_q[et][D0i2]) +
				     Dval3*(s_q[et][D1i3] - s_q[et][D0i3]) +
				     Dval4*(s_q[et][D1i4] - s_q[et][D0i4]));
	    const dfloat dqds = .5f*(Dval1*(s_q[et][D2i1] - s_q[et][D0i1]) +
				     Dval2*(s_q[et][D2i2] - s_q[et][D0i2]) +
				     Dval3*(s_q[et][D2i3] - s_q[et][D0i3]) +
				     Dval4*(s_q[et][D2i4] - s_q[et][D0i4]));
	    const dfloat dqdt = .5f*(Dval1*(s_q[et][D3i1] - s_q[et][D0i1]) +
				     Dval2*(s_q[et][D3i2] - s_q[et][D0i2]) +
				     Dval3*(s_q[et][D3i3] - s_q[et][D0i3]) +
				     Dval4*(s_q[et][D3i4] - s_q[et][D0i4]));
	    
	    // chain rule
	    s_qx[et][n] = drdx*dqdr + dsdx*dqds + dtdx*dqdt;
	    s_qy[et][n] = drdy*dqdr + dsdy*dqds + dtdy*dqdt;
	    s_qz[et][n] = drdz*dqdr + dsdz*dqds + dtdz*dqdt;
      
	    // mass term
	    r_Aq[et] = lambda*s_q[et][n];
	  }
	}
    }
    
    barrier(localMemFence);
    
    // surface flux terms
    for(int n=0;n<p_Np;++n;inner0){     // for all nodes in this element
      
      occaUnroll(p_Ne)
	for(int et=0;et<p_Ne;++et){
	  const int e = eo + et;
	  if(e<Nelements){
	    int m=n;
	    while(m<p_Nfp*p_Nfaces){
	      const int f = m/p_Nfp;
	      const dlong sid = e*p_Nfaces*p_Nsgeo+f*p_Nsgeo;
	      const int nid = faceNodes[m];
	      const dfloat nx = sgeo[sid + p_NXID];
	      const dfloat ny = sgeo[sid + p_NYID];
	      const dfloat nz = sgeo[sid + p_NZID];
	      const dfloat sJ = sgeo[sid + p_SJID];
	      const dfloat invJ = sgeo[sid+p_IJID];
	      const dfloat flux = invJ*sJ*(nx*s_qx[et][nid] + ny*s_qy[et][nid] + nz*s_qz[et][nid]);
	      s_flux[et][m] = flux;
	      m+=p_Np;
	    }
	  }
	}
    }
    
    barrier(localMemFence);

    // lift nx*qx+ny*qy+nz*qz
    // (doing this since we have Np threads)
    // yuck - this costs Np*Nfp*Nfaces
    for(int n=0;n<p_Np;++n;inner0){     // for all nodes in this element

      occaUnroll(p_Nfp*p_Nfaces)
	for(int m=0;m<p_Nfp*p_Nfaces;++m){
	  const dfloat LIFTnm = LIFT[n+m*p_Np];
	  
	  // 2 flops per 1 loads from L1+shared (=> 3.37 TFLOPS/s assuming perfect caching)
	  occaUnroll(p_Ne)
	    for(int et=0;et<p_Ne;++et){
	      r_Aq[et] += LIFTnm*s_flux[et][m];
	    }
	}
      
      occaUnroll(p_Ne)
	for(int et=0;et<p_Ne;++et){
	  const int e = eo + et;
	  if(e<Nelements){

	    // div
	    // double check this is ok
	    // prefetch geometric factors (constant on triangle)
	    const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
	    const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
	    const dfloat drdz = vgeo[e*p_Nvgeo + p_RZID];
	    const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
	    const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];
	    const dfloat dsdz = vgeo[e*p_Nvgeo + p_SZID];
	    const dfloat dtdx = vgeo[e*p_Nvgeo + p_TXID];
	    const dfloat dtdy = vgeo[e*p_Nvgeo + p_TYID];
	    const dfloat dtdz = vgeo[e*p_Nvgeo + p_TZID];
	    
	    const dfloat tmpr = drdx*s_qx[et][n] + drdy*s_qy[et][n] + drdz*s_qz[et][n];
	    const dfloat tmps = dsdx*s_qx[et][n] + dsdy*s_qy[et][n] + dsdz*s_qz[et][n];
	    const dfloat tmpt = dtdx*s_qx[et][n] + dtdy*s_qy[et][n] + dtdz*s_qz[et][n];
	    
	    s_qx[et][n] = tmpr;
	    s_qy[et][n] = tmps;
	    s_qz[et][n] = tmpt;
	  }
	}
    }

    barrier(localMemFence);

    for(int n=0;n<p_Np;++n;inner0){     // for all nodes in this element

      // double check this is ok

      // compute 'r', 's',  and 't' derivatives of (q_m) at node n
      const int D0i1 = D0ids[n];
      const int D1i1 = D1ids[n];
      const int D2i1 = D2ids[n];
      const int D3i1 = D3ids[n];
      const dfloat Dval1 = Dvals[n];
      
      const int D0i2 = D0ids[n+p_Np];
      const int D1i2 = D1ids[n+p_Np];
      const int D2i2 = D2ids[n+p_Np];
      const int D3i2 = D3ids[n+p_Np];
      const dfloat Dval2 = Dvals[n+p_Np];
      
      const int D0i3 = D0ids[n+2*p_Np];
      const int D1i3 = D1ids[n+2*p_Np];
      const int D2i3 = D2ids[n+2*p_Np];
      const int D3i3 = D3ids[n+2*p_Np];    
      const dfloat Dval3 = Dvals[n+2*p_Np];
      
      const int D0i4 = D0ids[n+3*p_Np];
      const int D1i4 = D1ids[n+3*p_Np];
      const int D2i4 = D2ids[n+3*p_Np];
      const int D3i4 = D3ids[n+3*p_Np];    
      const dfloat Dval4 = Dvals[n+3*p_Np];

      occaUnroll(p_Ne)
	for(int et=0;et<p_Ne;++et){
	    
	  const dfloat dqrdr = .5f*(Dval1*(s_qx[et][D1i1] - s_qx[et][D0i1]) +
				    Dval2*(s_qx[et][D1i2] - s_qx[et][D0i2]) +
				    Dval3*(s_qx[et][D1i3] - s_qx[et][D0i3]) +
				    Dval4*(s_qx[et][D1i4] - s_qx[et][D0i4]));
	  const dfloat dqsds = .5f*(Dval1*(s_qy[et][D2i1] - s_qy[et][D0i1]) +
				    Dval2*(s_qy[et][D2i2] - s_qy[et][D0i2]) +
				    Dval3*(s_qy[et][D2i3] - s_qy[et][D0i3]) +
				    Dval4*(s_qy[et][D2i4] - s_qy[et][D0i4]));
	  const dfloat dqtdt = .5f*(Dval1*(s_qz[et][D3i1] - s_qz[et][D0i1]) +
				    Dval2*(s_qz[et][D3i2] - s_qz[et][D0i2]) +
				    Dval3*(s_qz[et][D3i3] - s_qz[et][D0i3]) +
				    Dval4*(s_qz[et][D3i4] - s_qz[et][D0i4]));
	  
	  // note sign change
	  s_q[et][n] = r_Aq[et] - (dqrdr + dqsds + dqtdt);
	}
    }
    

    barrier(localMemFence);
    
    for(int n=0;n<p_Np;++n;inner0){     // for all nodes in this element
      
      // multiply by mass matrix
      occaUnroll(p_Ne)
	for(int et=0;et<p_Ne;++et)
	  r_Aq[et] = 0;
      
      // M*(lambda*q -(laplace q) + lift*(n.grad q))
      occaUnroll(p_Np)
	for(int m=0;m<p_Np;++m){
	  const dfloat MMnm = MM[n+m*p_Np];

	  // 2 flops per 1 shared memory/L1 reads  (=> 3.37 TFLOPS/s assuming perfect caching)
	  occaUnroll(p_Ne)
	    for(int et=0;et<p_Ne;++et){
	      r_Aq[et] += MMnm*s_q[et][m];
	    }
	}
      
      occaUnroll(p_Ne)
	for(int et=0;et<p_Ne;++et){
	  
	  const int e = eo + et;
	  if(e<Nelements){
	    const dfloat J = vgeo[e*p_Nvgeo + p_JID];    
	    
	    Aq[n+e*p_Np] = J*r_Aq[et];
	  }
	}
    }
  }
}


// v2: multiple outputs & SIMD cramming
kernel void ellipticPartialAxBBTet3D_v2(const dlong Nelements,
					const int elementOffset,
					const dfloat * restrict sgeo,   // surface geofacs
					const int * restrict faceNodes, // volume node indices of surface nodes
					const dfloat * restrict vgeo,   // volume geofacs (drdx, ...)
					const int * restrict D0ids,     // sparse D matrices
					const int * restrict D1ids,
					const int * restrict D2ids,
					const int * restrict D3ids,
					const dfloat * restrict Dvals,    
					const dfloat * restrict LIFT,   // dense lift matrix
					const dfloat * restrict MM,     // dense mass matrix
					const dfloat lambda,
					const dfloat * restrict q,
					dfloat * restrict Aq){
  
  for(dlong eo=0;eo<Nelements;eo+=p_Ne*p_Nb;outer0){
    
    shared dfloat s_q[p_Ne][p_Nb][p_Np];
    shared dfloat s_qx[p_Ne][p_Nb][p_Np], s_qy[p_Ne][p_Nb][p_Np], s_qz[p_Ne][p_Nb][p_Np], s_flux[p_Ne][p_Nb][p_Nfaces*p_Nfp];
    exclusive dfloat r_Aq[p_Ne];
    
    // prefetch q for element e
    for(int b=0;b<p_Nb;++b;inner1){
      for(int n=0;n<p_Np;++n;inner0){
	
	occaUnroll(p_Ne)
	  for(int et=0;et<p_Ne;++et){
	    const int e = eo + b + p_Nb*et;
	    if(e<Nelements)
	      s_q[et][b][n] = q[n+e*p_Np];
	  }
      }
    }

    barrier(localMemFence);

    // grad
    for(int b=0;b<p_Nb;++b;inner1){
      for(int n=0;n<p_Np;++n;inner0){     // for all nodes in this element
	
	// compute 'r', 's',  and 't' derivatives of (q_m) at node n
	const int D0i1 = D0ids[n];
	const int D1i1 = D1ids[n];
	const int D2i1 = D2ids[n];
	const int D3i1 = D3ids[n];
	const dfloat Dval1 = Dvals[n];
      
	const int D0i2 = D0ids[n+p_Np];
	const int D1i2 = D1ids[n+p_Np];
	const int D2i2 = D2ids[n+p_Np];
	const int D3i2 = D3ids[n+p_Np];
	const dfloat Dval2 = Dvals[n+p_Np];
	
	const int D0i3 = D0ids[n+2*p_Np];
	const int D1i3 = D1ids[n+2*p_Np];
	const int D2i3 = D2ids[n+2*p_Np];
	const int D3i3 = D3ids[n+2*p_Np];    
	const dfloat Dval3 = Dvals[n+2*p_Np];
	
	const int D0i4 = D0ids[n+3*p_Np];
	const int D1i4 = D1ids[n+3*p_Np];
	const int D2i4 = D2ids[n+3*p_Np];
	const int D3i4 = D3ids[n+3*p_Np];    
	const dfloat Dval4 = Dvals[n+3*p_Np];
	
	occaUnroll(p_Ne)
	  for(int et=0;et<p_Ne;++et){
	    const int e = eo + b + p_Nb*et;
	    if(e<Nelements){
	      
	      // prefetch geometric factors (constant on triangle)
	      const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
	      const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
	      const dfloat drdz = vgeo[e*p_Nvgeo + p_RZID];
	      const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
	      const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];
	      const dfloat dsdz = vgeo[e*p_Nvgeo + p_SZID];
	      const dfloat dtdx = vgeo[e*p_Nvgeo + p_TXID];
	      const dfloat dtdy = vgeo[e*p_Nvgeo + p_TYID];
	      const dfloat dtdz = vgeo[e*p_Nvgeo + p_TZID];
	      
	      
	      const dfloat dqdr = .5f*(Dval1*(s_q[et][b][D1i1] - s_q[et][b][D0i1]) +
				       Dval2*(s_q[et][b][D1i2] - s_q[et][b][D0i2]) +
				       Dval3*(s_q[et][b][D1i3] - s_q[et][b][D0i3]) +
				       Dval4*(s_q[et][b][D1i4] - s_q[et][b][D0i4]));
	      const dfloat dqds = .5f*(Dval1*(s_q[et][b][D2i1] - s_q[et][b][D0i1]) +
				       Dval2*(s_q[et][b][D2i2] - s_q[et][b][D0i2]) +
				       Dval3*(s_q[et][b][D2i3] - s_q[et][b][D0i3]) +
				       Dval4*(s_q[et][b][D2i4] - s_q[et][b][D0i4]));
	      const dfloat dqdt = .5f*(Dval1*(s_q[et][b][D3i1] - s_q[et][b][D0i1]) +
				       Dval2*(s_q[et][b][D3i2] - s_q[et][b][D0i2]) +
				       Dval3*(s_q[et][b][D3i3] - s_q[et][b][D0i3]) +
				       Dval4*(s_q[et][b][D3i4] - s_q[et][b][D0i4]));
	      
	    // chain rule
	      s_qx[et][b][n] = drdx*dqdr + dsdx*dqds + dtdx*dqdt;
	      s_qy[et][b][n] = drdy*dqdr + dsdy*dqds + dtdy*dqdt;
	      s_qz[et][b][n] = drdz*dqdr + dsdz*dqds + dtdz*dqdt;
	      
	      // mass term
	      r_Aq[et] = lambda*s_q[et][b][n];
	    }
	  }
      }
    }

    barrier(localMemFence);
    
    // surface flux terms
    for(int b=0;b<p_Nb;++b;inner1){
      for(int n=0;n<p_Np;++n;inner0){     // for all nodes in this element
	
	occaUnroll(p_Ne)
	  for(int et=0;et<p_Ne;++et){
	    const int e = eo + b + p_Nb*et;
	    if(e<Nelements){
	      int m=n;
	      while(m<p_Nfp*p_Nfaces){
		const int f = m/p_Nfp;
		const dlong sid = e*p_Nfaces*p_Nsgeo+f*p_Nsgeo;
		const int nid = faceNodes[m];
		const dfloat nx = sgeo[sid + p_NXID];
		const dfloat ny = sgeo[sid + p_NYID];
		const dfloat nz = sgeo[sid + p_NZID];
		const dfloat sJ = sgeo[sid + p_SJID];
		const dfloat invJ = sgeo[sid+p_IJID];
		const dfloat flux = invJ*sJ*(nx*s_qx[et][b][nid] + ny*s_qy[et][b][nid] + nz*s_qz[et][b][nid]);
		s_flux[et][b][m] = flux;
		m+=p_Np;
	      }
	    }
	  }
      }
    }
    
    barrier(localMemFence);

    // lift nx*qx+ny*qy+nz*qz
    // (doing this since we have Np threads)
    // yuck - this costs Np*Nfp*Nfaces
    for(int b=0;b<p_Nb;++b;inner1){
      for(int n=0;n<p_Np;++n;inner0){     // for all nodes in this element
	
	occaUnroll(p_Nfp*p_Nfaces)
	  for(int m=0;m<p_Nfp*p_Nfaces;++m){
	    const dfloat LIFTnm = LIFT[n+m*p_Np];
	    
	    // 2 flops per 1 loads from L1+shared (=> 3.37 TFLOPS/s assuming perfect caching)
	    occaUnroll(p_Ne)
	      for(int et=0;et<p_Ne;++et){
		r_Aq[et] += LIFTnm*s_flux[et][b][m];
	      }
	  }
	
	occaUnroll(p_Ne)
	  for(int et=0;et<p_Ne;++et){
	    const int e = eo + b + p_Nb*et;
	    if(e<Nelements){
	      
	      // div
	      // double check this is ok
	      // prefetch geometric factors (constant on triangle)
	      const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
	      const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
	      const dfloat drdz = vgeo[e*p_Nvgeo + p_RZID];
	      const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
	      const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];
	      const dfloat dsdz = vgeo[e*p_Nvgeo + p_SZID];
	      const dfloat dtdx = vgeo[e*p_Nvgeo + p_TXID];
	      const dfloat dtdy = vgeo[e*p_Nvgeo + p_TYID];
	      const dfloat dtdz = vgeo[e*p_Nvgeo + p_TZID];
	    
	      const dfloat tmpr = drdx*s_qx[et][b][n] + drdy*s_qy[et][b][n] + drdz*s_qz[et][b][n];
	      const dfloat tmps = dsdx*s_qx[et][b][n] + dsdy*s_qy[et][b][n] + dsdz*s_qz[et][b][n];
	      const dfloat tmpt = dtdx*s_qx[et][b][n] + dtdy*s_qy[et][b][n] + dtdz*s_qz[et][b][n];
	      
	      s_qx[et][b][n] = tmpr;
	      s_qy[et][b][n] = tmps;
	      s_qz[et][b][n] = tmpt;
	    }
	  }
      }
    }

    barrier(localMemFence);

    for(int b=0;b<p_Nb;++b;inner1){
      for(int n=0;n<p_Np;++n;inner0){     // for all nodes in this element
	
	// double check this is ok
	
	// compute 'r', 's',  and 't' derivatives of (q_m) at node n
	const int D0i1 = D0ids[n];
	const int D1i1 = D1ids[n];
	const int D2i1 = D2ids[n];
	const int D3i1 = D3ids[n];
	const dfloat Dval1 = Dvals[n];
	
	const int D0i2 = D0ids[n+p_Np];
	const int D1i2 = D1ids[n+p_Np];
	const int D2i2 = D2ids[n+p_Np];
	const int D3i2 = D3ids[n+p_Np];
	const dfloat Dval2 = Dvals[n+p_Np];
	
	const int D0i3 = D0ids[n+2*p_Np];
	const int D1i3 = D1ids[n+2*p_Np];
	const int D2i3 = D2ids[n+2*p_Np];
	const int D3i3 = D3ids[n+2*p_Np];    
	const dfloat Dval3 = Dvals[n+2*p_Np];
	
	const int D0i4 = D0ids[n+3*p_Np];
	const int D1i4 = D1ids[n+3*p_Np];
	const int D2i4 = D2ids[n+3*p_Np];
	const int D3i4 = D3ids[n+3*p_Np];    
	const dfloat Dval4 = Dvals[n+3*p_Np];
	
	occaUnroll(p_Ne)
	  for(int et=0;et<p_Ne;++et){
	    
	    const dfloat dqrdr = .5f*(Dval1*(s_qx[et][b][D1i1] - s_qx[et][b][D0i1]) +
				      Dval2*(s_qx[et][b][D1i2] - s_qx[et][b][D0i2]) +
				      Dval3*(s_qx[et][b][D1i3] - s_qx[et][b][D0i3]) +
				      Dval4*(s_qx[et][b][D1i4] - s_qx[et][b][D0i4]));
	    const dfloat dqsds = .5f*(Dval1*(s_qy[et][b][D2i1] - s_qy[et][b][D0i1]) +
				      Dval2*(s_qy[et][b][D2i2] - s_qy[et][b][D0i2]) +
				      Dval3*(s_qy[et][b][D2i3] - s_qy[et][b][D0i3]) +
				      Dval4*(s_qy[et][b][D2i4] - s_qy[et][b][D0i4]));
	    const dfloat dqtdt = .5f*(Dval1*(s_qz[et][b][D3i1] - s_qz[et][b][D0i1]) +
				      Dval2*(s_qz[et][b][D3i2] - s_qz[et][b][D0i2]) +
				      Dval3*(s_qz[et][b][D3i3] - s_qz[et][b][D0i3]) +
				      Dval4*(s_qz[et][b][D3i4] - s_qz[et][b][D0i4]));
	    
	    // note sign change
	    s_q[et][b][n] = r_Aq[et] - (dqrdr + dqsds + dqtdt);
	  }
      }
    }
    

    barrier(localMemFence);
    
    for(int b=0;b<p_Nb;++b;inner1){
      for(int n=0;n<p_Np;++n;inner0){     // for all nodes in this element
	
	// multiply by mass matrix
	occaUnroll(p_Ne)
	  for(int et=0;et<p_Ne;++et)
	    r_Aq[et] = 0;
	
	// M*(lambda*q -(laplace q) + lift*(n.grad q))
	occaUnroll(p_Np)
	  for(int m=0;m<p_Np;++m){
	    const dfloat MMnm = MM[n+m*p_Np];
	    
	    // 2 flops per 1 shared memory/L1 reads  (=> 3.37 TFLOPS/s assuming perfect caching)
	    occaUnroll(p_Ne)
	      for(int et=0;et<p_Ne;++et){
		r_Aq[et] += MMnm*s_q[et][b][m];
	      }
	  }
	
	occaUnroll(p_Ne)
	  for(int et=0;et<p_Ne;++et){
	    
	    const int e = eo + b + p_Nb*et;
	    if(e<Nelements){
	      const dfloat J = vgeo[e*p_Nvgeo + p_JID];    
	      
	      Aq[n+e*p_Np] = J*r_Aq[et];
	    }
	  }
      }
    }
  }
}


// v3: single fetch BB derivative info
kernel void ellipticPartialAxBBTet3D_v3(const dlong Nelements,
					const int elementOffset,
					const dfloat * restrict sgeo,   // surface geofacs
					const int * restrict faceNodes, // volume node indices of surface nodes
					const dfloat * restrict vgeo,   // volume geofacs (drdx, ...)
					const int * restrict D0ids,     // sparse D matrices
					const int * restrict D1ids,
					const int * restrict D2ids,
					const int * restrict D3ids,
					const dfloat * restrict Dvals,    
					const dfloat * restrict LIFT,   // dense lift matrix
					const dfloat * restrict MM,     // dense mass matrix
					const dfloat lambda,
					const dfloat * restrict q,
					dfloat * restrict Aq){
  
  for(dlong eo=0;eo<Nelements;eo+=p_Ne*p_Nb;outer0){
    
    shared dfloat s_q[p_Ne][p_Nb][p_Np];
    shared dfloat s_qx[p_Ne][p_Nb][p_Np], s_qy[p_Ne][p_Nb][p_Np], s_qz[p_Ne][p_Nb][p_Np], s_flux[p_Ne][p_Nb][p_Nfaces*p_Nfp];
    exclusive dfloat r_Aq[p_Ne];

    int r_D0i1, r_D1i1, r_D2i1, r_D3i1;
    int r_D0i2, r_D1i2, r_D2i2, r_D3i2;
    int r_D0i3, r_D1i3, r_D2i3, r_D3i3;
    int r_D0i4, r_D1i4, r_D2i4, r_D3i4;

    dfloat r_Dval1, r_Dval2, r_Dval3, r_Dval4;
		     
    // prefetch q for element e
    for(int b=0;b<p_Nb;++b;inner1){
      for(int n=0;n<p_Np;++n;inner0){
	
	occaUnroll(p_Ne)
	  for(int et=0;et<p_Ne;++et){
	    const int e = eo + b + p_Nb*et;
	    if(e<Nelements)
	      s_q[et][b][n] = q[n+e*p_Np];
	  }
      }
    }

    barrier(localMemFence);

    // grad
    for(int b=0;b<p_Nb;++b;inner1){
      for(int n=0;n<p_Np;++n;inner0){     // for all nodes in this element
	
	// compute 'r', 's',  and 't' derivatives of (q_m) at node n
	r_D0i1 = D0ids[n];
	r_D1i1 = D1ids[n];
	r_D2i1 = D2ids[n];
	r_D3i1 = D3ids[n];
	r_Dval1 = Dvals[n];
      	       
	r_D0i2 = D0ids[n+p_Np];
	r_D1i2 = D1ids[n+p_Np];
	r_D2i2 = D2ids[n+p_Np];
	r_D3i2 = D3ids[n+p_Np];
	r_Dval2 = Dvals[n+p_Np];
		 
	r_D0i3 = D0ids[n+2*p_Np];
	r_D1i3 = D1ids[n+2*p_Np];
	r_D2i3 = D2ids[n+2*p_Np];
	r_D3i3 = D3ids[n+2*p_Np];    
	r_Dval3 = Dvals[n+2*p_Np];
		 
	r_D0i4 = D0ids[n+3*p_Np];
	r_D1i4 = D1ids[n+3*p_Np];
	r_D2i4 = D2ids[n+3*p_Np];
	r_D3i4 = D3ids[n+3*p_Np];    
	r_Dval4 = Dvals[n+3*p_Np];
	
	occaUnroll(p_Ne)
	  for(int et=0;et<p_Ne;++et){
	    const int e = eo + b + p_Nb*et;
	    if(e<Nelements){
	      
	      // prefetch geometric factors (constant on triangle)
	      const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
	      const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
	      const dfloat drdz = vgeo[e*p_Nvgeo + p_RZID];
	      const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
	      const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];
	      const dfloat dsdz = vgeo[e*p_Nvgeo + p_SZID];
	      const dfloat dtdx = vgeo[e*p_Nvgeo + p_TXID];
	      const dfloat dtdy = vgeo[e*p_Nvgeo + p_TYID];
	      const dfloat dtdz = vgeo[e*p_Nvgeo + p_TZID];
	      
	      
	      const dfloat dqdr = .5f*(r_Dval1*(s_q[et][b][r_D1i1] - s_q[et][b][r_D0i1]) +
				       r_Dval2*(s_q[et][b][r_D1i2] - s_q[et][b][r_D0i2]) +
				       r_Dval3*(s_q[et][b][r_D1i3] - s_q[et][b][r_D0i3]) +
				       r_Dval4*(s_q[et][b][r_D1i4] - s_q[et][b][r_D0i4]));
	      const dfloat dqds = .5f*(r_Dval1*(s_q[et][b][r_D2i1] - s_q[et][b][r_D0i1]) +
				       r_Dval2*(s_q[et][b][r_D2i2] - s_q[et][b][r_D0i2]) +
				       r_Dval3*(s_q[et][b][r_D2i3] - s_q[et][b][r_D0i3]) +
				       r_Dval4*(s_q[et][b][r_D2i4] - s_q[et][b][r_D0i4]));
	      const dfloat dqdt = .5f*(r_Dval1*(s_q[et][b][r_D3i1] - s_q[et][b][r_D0i1]) +
				       r_Dval2*(s_q[et][b][r_D3i2] - s_q[et][b][r_D0i2]) +
				       r_Dval3*(s_q[et][b][r_D3i3] - s_q[et][b][r_D0i3]) +
				       r_Dval4*(s_q[et][b][r_D3i4] - s_q[et][b][r_D0i4]));
	      
	    // chain rule
	      s_qx[et][b][n] = drdx*dqdr + dsdx*dqds + dtdx*dqdt;
	      s_qy[et][b][n] = drdy*dqdr + dsdy*dqds + dtdy*dqdt;
	      s_qz[et][b][n] = drdz*dqdr + dsdz*dqds + dtdz*dqdt;
	      
	      // mass term
	      r_Aq[et] = lambda*s_q[et][b][n];
	    }
	  }
      }
    }

    barrier(localMemFence);
    
    // surface flux terms
    for(int b=0;b<p_Nb;++b;inner1){
      for(int n=0;n<p_Np;++n;inner0){     // for all nodes in this element
	
	occaUnroll(p_Ne)
	  for(int et=0;et<p_Ne;++et){
	    const int e = eo + b + p_Nb*et;
	    if(e<Nelements){
	      int m=n;
	      while(m<p_Nfp*p_Nfaces){
		const int f = m/p_Nfp;
		const dlong sid = e*p_Nfaces*p_Nsgeo+f*p_Nsgeo;
		const int nid = faceNodes[m];
		const dfloat nx = sgeo[sid + p_NXID];
		const dfloat ny = sgeo[sid + p_NYID];
		const dfloat nz = sgeo[sid + p_NZID];
		const dfloat sJ = sgeo[sid + p_SJID];
		const dfloat invJ = sgeo[sid+p_IJID];
		const dfloat flux = invJ*sJ*(nx*s_qx[et][b][nid] + ny*s_qy[et][b][nid] + nz*s_qz[et][b][nid]);
		s_flux[et][b][m] = flux;
		m+=p_Np;
	      }
	    }
	  }
      }
    }
    
    barrier(localMemFence);

    // lift nx*qx+ny*qy+nz*qz
    // (doing this since we have Np threads)
    // yuck - this costs Np*Nfp*Nfaces
    for(int b=0;b<p_Nb;++b;inner1){
      for(int n=0;n<p_Np;++n;inner0){     // for all nodes in this element
	
	occaUnroll(p_Nfp*p_Nfaces)
	  for(int m=0;m<p_Nfp*p_Nfaces;++m){
	    const dfloat LIFTnm = LIFT[n+m*p_Np];
	    
	    // 2 flops per 1 loads from L1+shared (=> 3.37 TFLOPS/s assuming perfect caching)
	    occaUnroll(p_Ne)
	      for(int et=0;et<p_Ne;++et){
		r_Aq[et] += LIFTnm*s_flux[et][b][m];
	      }
	  }
	
	occaUnroll(p_Ne)
	  for(int et=0;et<p_Ne;++et){
	    const int e = eo + b + p_Nb*et;
	    if(e<Nelements){
	      
	      // div
	      // double check this is ok
	      // prefetch geometric factors (constant on triangle)
	      const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
	      const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
	      const dfloat drdz = vgeo[e*p_Nvgeo + p_RZID];
	      const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
	      const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];
	      const dfloat dsdz = vgeo[e*p_Nvgeo + p_SZID];
	      const dfloat dtdx = vgeo[e*p_Nvgeo + p_TXID];
	      const dfloat dtdy = vgeo[e*p_Nvgeo + p_TYID];
	      const dfloat dtdz = vgeo[e*p_Nvgeo + p_TZID];
	    
	      const dfloat tmpr = drdx*s_qx[et][b][n] + drdy*s_qy[et][b][n] + drdz*s_qz[et][b][n];
	      const dfloat tmps = dsdx*s_qx[et][b][n] + dsdy*s_qy[et][b][n] + dsdz*s_qz[et][b][n];
	      const dfloat tmpt = dtdx*s_qx[et][b][n] + dtdy*s_qy[et][b][n] + dtdz*s_qz[et][b][n];
	      
	      s_qx[et][b][n] = tmpr;
	      s_qy[et][b][n] = tmps;
	      s_qz[et][b][n] = tmpt;
	    }
	  }
      }
    }

    barrier(localMemFence);

    for(int b=0;b<p_Nb;++b;inner1){
      for(int n=0;n<p_Np;++n;inner0){     // for all nodes in this element
	
	// compute 'r', 's',  and 't' derivatives of (q_m) at node n
	occaUnroll(p_Ne)
	  for(int et=0;et<p_Ne;++et){
	    
	    const dfloat dqrdr = .5f*(r_Dval1*(s_qx[et][b][r_D1i1] - s_qx[et][b][r_D0i1]) +
				      r_Dval2*(s_qx[et][b][r_D1i2] - s_qx[et][b][r_D0i2]) +
				      r_Dval3*(s_qx[et][b][r_D1i3] - s_qx[et][b][r_D0i3]) +
				      r_Dval4*(s_qx[et][b][r_D1i4] - s_qx[et][b][r_D0i4]));
	    const dfloat dqsds = .5f*(r_Dval1*(s_qy[et][b][r_D2i1] - s_qy[et][b][r_D0i1]) +
				      r_Dval2*(s_qy[et][b][r_D2i2] - s_qy[et][b][r_D0i2]) +
				      r_Dval3*(s_qy[et][b][r_D2i3] - s_qy[et][b][r_D0i3]) +
				      r_Dval4*(s_qy[et][b][r_D2i4] - s_qy[et][b][r_D0i4]));
	    const dfloat dqtdt = .5f*(r_Dval1*(s_qz[et][b][r_D3i1] - s_qz[et][b][r_D0i1]) +
				      r_Dval2*(s_qz[et][b][r_D3i2] - s_qz[et][b][r_D0i2]) +
				      r_Dval3*(s_qz[et][b][r_D3i3] - s_qz[et][b][r_D0i3]) +
				      r_Dval4*(s_qz[et][b][r_D3i4] - s_qz[et][b][r_D0i4]));
	    
	    // note sign change
	    s_q[et][b][n] = r_Aq[et] - (dqrdr + dqsds + dqtdt);
	  }
      }
    }
    

    barrier(localMemFence);
    
    for(int b=0;b<p_Nb;++b;inner1){
      for(int n=0;n<p_Np;++n;inner0){     // for all nodes in this element
	
	// multiply by mass matrix
	occaUnroll(p_Ne)
	  for(int et=0;et<p_Ne;++et)
	    r_Aq[et] = 0;
	
	// M*(lambda*q -(laplace q) + lift*(n.grad q))
	occaUnroll(p_Np)
	  for(int m=0;m<p_Np;++m){
	    const dfloat MMnm = MM[n+m*p_Np];
	    
	    // 2 flops per 1 shared memory/L1 reads  (=> 3.37 TFLOPS/s assuming perfect caching)
	    occaUnroll(p_Ne)
	      for(int et=0;et<p_Ne;++et){
		r_Aq[et] += MMnm*s_q[et][b][m];
	      }
	  }
	
	occaUnroll(p_Ne)
	  for(int et=0;et<p_Ne;++et){
	    
	    const int e = eo + b + p_Nb*et;
	    if(e<Nelements){
	      const dfloat J = vgeo[e*p_Nvgeo + p_JID];    
	      
	      Aq[n+e*p_Np] = J*r_Aq[et];
	    }
	  }
      }
    }
  }
}


// v4: simd
kernel void ellipticPartialAxBBTet3D_v4(const dlong Nelements,
					const int elementOffset,
					const dfloat * restrict sgeo,   // surface geofacs
					const int * restrict faceNodes, // volume node indices of surface nodes
					const dfloat * restrict vgeo,   // volume geofacs (drdx, ...)
					const int * restrict D0ids,     // sparse D matrices
					const int * restrict D1ids,
					const int * restrict D2ids,
					const int * restrict D3ids,
					const dfloat * restrict Dvals,    
					const dfloat * restrict LIFT,   // dense lift matrix
					const dfloat * restrict MM,     // dense mass matrix
					const dfloat lambda,
					const dfloat * restrict q,
					dfloat * restrict Aq){

#define p_Nsimd 32
  
  for(dlong eo=0;eo<Nelements;eo+=p_Ne*p_Nb;outer0){
    
    volatile shared dfloat s_q[p_Ne][p_Nb][p_Np];
    volatile shared dfloat s_qx[p_Ne][p_Nb][p_Np], s_qy[p_Ne][p_Nb][p_Np], s_qz[p_Ne][p_Nb][p_Np], s_flux[p_Ne][p_Nb][p_Nfaces*p_Nfp];
    
    // prefetch q for element e
    for(int b=0;b<p_Nb;++b;inner1){
      for(int s=0;s<p_Nsimd;++s;inner0){
	
	occaUnroll(p_Ne)
	  for(int et=0;et<p_Ne;++et){
	    const int e = eo + b + p_Nb*et;
	    if(e<Nelements){
	      occaUnroll(p_Nsimd)
		for(int n=s;n<p_Np;n+=p_Nsimd){
		  
		  s_q[et][b][n] = q[n+e*p_Np];
		}
	    }
	  }

	occaUnroll(p_Nsimd)
	  for(int n=s;n<p_Np;n+=p_Nsimd){
	    
	    // compute 'r', 's',  and 't' derivatives of (q_m) at node n
	    const int D0i1 = D0ids[n];
	    const int D1i1 = D1ids[n];
	    const int D2i1 = D2ids[n];
	    const int D3i1 = D3ids[n];
	    const dfloat Dval1 = Dvals[n];
	    
	    const int D0i2 = D0ids[n+p_Np];
	    const int D1i2 = D1ids[n+p_Np];
	    const int D2i2 = D2ids[n+p_Np];
	    const int D3i2 = D3ids[n+p_Np];
	    const dfloat Dval2 = Dvals[n+p_Np];
	    
	    const int D0i3 = D0ids[n+2*p_Np];
	    const int D1i3 = D1ids[n+2*p_Np];
	    const int D2i3 = D2ids[n+2*p_Np];
	    const int D3i3 = D3ids[n+2*p_Np];    
	    const dfloat Dval3 = Dvals[n+2*p_Np];
	    
	    const int D0i4 = D0ids[n+3*p_Np];
	    const int D1i4 = D1ids[n+3*p_Np];
	    const int D2i4 = D2ids[n+3*p_Np];
	    const int D3i4 = D3ids[n+3*p_Np];    
	    const dfloat Dval4 = Dvals[n+3*p_Np];
	    
	    occaUnroll(p_Ne)
	      for(int et=0;et<p_Ne;++et){
		const int e = eo + b + p_Nb*et;
		if(e<Nelements){
		  
		  // prefetch geometric factors (constant on triangle)
		  const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
		  const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
		  const dfloat drdz = vgeo[e*p_Nvgeo + p_RZID];
		  const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
		  const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];
		  const dfloat dsdz = vgeo[e*p_Nvgeo + p_SZID];
		  const dfloat dtdx = vgeo[e*p_Nvgeo + p_TXID];
		  const dfloat dtdy = vgeo[e*p_Nvgeo + p_TYID];
		  const dfloat dtdz = vgeo[e*p_Nvgeo + p_TZID];
		  
		  
		  const dfloat dqdr = .5f*(Dval1*(s_q[et][b][D1i1] - s_q[et][b][D0i1]) +
					   Dval2*(s_q[et][b][D1i2] - s_q[et][b][D0i2]) +
					   Dval3*(s_q[et][b][D1i3] - s_q[et][b][D0i3]) +
					   Dval4*(s_q[et][b][D1i4] - s_q[et][b][D0i4]));
		  const dfloat dqds = .5f*(Dval1*(s_q[et][b][D2i1] - s_q[et][b][D0i1]) +
					   Dval2*(s_q[et][b][D2i2] - s_q[et][b][D0i2]) +
					   Dval3*(s_q[et][b][D2i3] - s_q[et][b][D0i3]) +
					   Dval4*(s_q[et][b][D2i4] - s_q[et][b][D0i4]));
		  const dfloat dqdt = .5f*(Dval1*(s_q[et][b][D3i1] - s_q[et][b][D0i1]) +
					   Dval2*(s_q[et][b][D3i2] - s_q[et][b][D0i2]) +
					   Dval3*(s_q[et][b][D3i3] - s_q[et][b][D0i3]) +
					   Dval4*(s_q[et][b][D3i4] - s_q[et][b][D0i4]));
		  
		  // chain rule
		  s_qx[et][b][n] = drdx*dqdr + dsdx*dqds + dtdx*dqdt;
		  s_qy[et][b][n] = drdy*dqdr + dsdy*dqds + dtdy*dqdt;
		  s_qz[et][b][n] = drdz*dqdr + dsdz*dqds + dtdz*dqdt;
		  
		}
	      }
	  }
	
	occaUnroll(p_Ne)
	  for(int et=0;et<p_Ne;++et){
	    const int e = eo + b + p_Nb*et;
	    if(e<Nelements){
	      int m=s;
	      while(m<p_Nfp*p_Nfaces){
		const int f = m/p_Nfp;
		const dlong sid = e*p_Nfaces*p_Nsgeo+f*p_Nsgeo;
		const int nid = faceNodes[m];
		const dfloat nx = sgeo[sid + p_NXID];
		const dfloat ny = sgeo[sid + p_NYID];
		const dfloat nz = sgeo[sid + p_NZID];
		const dfloat sJ = sgeo[sid + p_SJID];
		const dfloat invJ = sgeo[sid+p_IJID];
		const dfloat flux = invJ*sJ*(nx*s_qx[et][b][nid] + ny*s_qy[et][b][nid] + nz*s_qz[et][b][nid]);
		s_flux[et][b][m] = flux;
		m+=p_Nsimd;
	      }
	    }
	  }

	occaUnroll(p_Nsimd)
	  for(int n=s;n<p_Np;n+=p_Nsimd){
	    dfloat r_Aq[p_Ne];
	    
	    occaUnroll(p_Ne)
	      for(int et=0;et<p_Ne;++et)
		r_Aq[et] = 0;
	      
	    occaUnroll(p_Nfp*p_Nfaces)
	      for(int m=0;m<p_Nfp*p_Nfaces;++m){
		const dfloat LIFTnm = LIFT[n+m*p_Np];
		
		// 2 flops per 1 loads from L1+shared (=> 3.37 TFLOPS/s assuming perfect caching)
		occaUnroll(p_Ne)
		  for(int et=0;et<p_Ne;++et){
		    r_Aq[et] += LIFTnm*s_flux[et][b][m];
		  }
	      }
	    
	    // start building Aq
	    occaUnroll(p_Ne)
	      for(int et=0;et<p_Ne;++et) {
		s_q[et][b][n] = lambda*s_q[et][b][n]  + r_Aq[et];
		
		const int e = eo + b + p_Nb*et;
		
		if(e<Nelements){
		  
		  const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
		  const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
		  const dfloat drdz = vgeo[e*p_Nvgeo + p_RZID];
		  const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
		  const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];
		  const dfloat dsdz = vgeo[e*p_Nvgeo + p_SZID];
		  const dfloat dtdx = vgeo[e*p_Nvgeo + p_TXID];
		  const dfloat dtdy = vgeo[e*p_Nvgeo + p_TYID];
		  const dfloat dtdz = vgeo[e*p_Nvgeo + p_TZID];
		  
		  const dfloat tmpr = drdx*s_qx[et][b][n] + drdy*s_qy[et][b][n] + drdz*s_qz[et][b][n];
		  const dfloat tmps = dsdx*s_qx[et][b][n] + dsdy*s_qy[et][b][n] + dsdz*s_qz[et][b][n];
		  const dfloat tmpt = dtdx*s_qx[et][b][n] + dtdy*s_qy[et][b][n] + dtdz*s_qz[et][b][n];
		  
		  s_qx[et][b][n] = tmpr;
		  s_qy[et][b][n] = tmps;
		  s_qz[et][b][n] = tmpt;
		}
	    }
	  }

	occaUnroll(p_Nsimd)
	  for(int n=s;n<p_Np;n+=p_Nsimd){
	    
	    const int D0i1 = D0ids[n];
	    const int D1i1 = D1ids[n];
	    const int D2i1 = D2ids[n];
	    const int D3i1 = D3ids[n];
	    const dfloat Dval1 = Dvals[n];
	    
	    const int D0i2 = D0ids[n+p_Np];
	    const int D1i2 = D1ids[n+p_Np];
	    const int D2i2 = D2ids[n+p_Np];
	    const int D3i2 = D3ids[n+p_Np];
	    const dfloat Dval2 = Dvals[n+p_Np];
	    
	    const int D0i3 = D0ids[n+2*p_Np];
	    const int D1i3 = D1ids[n+2*p_Np];
	    const int D2i3 = D2ids[n+2*p_Np];
	    const int D3i3 = D3ids[n+2*p_Np];    
	    const dfloat Dval3 = Dvals[n+2*p_Np];
	    
	    const int D0i4 = D0ids[n+3*p_Np];
	    const int D1i4 = D1ids[n+3*p_Np];
	    const int D2i4 = D2ids[n+3*p_Np];
	    const int D3i4 = D3ids[n+3*p_Np];    
	    const dfloat Dval4 = Dvals[n+3*p_Np];
	    
	    occaUnroll(p_Ne)
	      for(int et=0;et<p_Ne;++et){
		
		const dfloat dqrdr = .5f*(Dval1*(s_qx[et][b][D1i1] - s_qx[et][b][D0i1]) +
					  Dval2*(s_qx[et][b][D1i2] - s_qx[et][b][D0i2]) +
					  Dval3*(s_qx[et][b][D1i3] - s_qx[et][b][D0i3]) +
					  Dval4*(s_qx[et][b][D1i4] - s_qx[et][b][D0i4]));
		const dfloat dqsds = .5f*(Dval1*(s_qy[et][b][D2i1] - s_qy[et][b][D0i1]) +
					  Dval2*(s_qy[et][b][D2i2] - s_qy[et][b][D0i2]) +
					  Dval3*(s_qy[et][b][D2i3] - s_qy[et][b][D0i3]) +
					  Dval4*(s_qy[et][b][D2i4] - s_qy[et][b][D0i4]));
		const dfloat dqtdt = .5f*(Dval1*(s_qz[et][b][D3i1] - s_qz[et][b][D0i1]) +
					  Dval2*(s_qz[et][b][D3i2] - s_qz[et][b][D0i2]) +
					  Dval3*(s_qz[et][b][D3i3] - s_qz[et][b][D0i3]) +
					  Dval4*(s_qz[et][b][D3i4] - s_qz[et][b][D0i4]));
		
		// note sign change
		s_q[et][b][n] -= (dqrdr + dqsds + dqtdt);
	      }
	  }
	
	occaUnroll(p_Nsimd)
	  for(int n=s;n<p_Np;n+=p_Nsimd){
	    dfloat r_Aq[p_Ne];
	    
	    // multiply by mass matrix
	    occaUnroll(p_Ne)
	      for(int et=0;et<p_Ne;++et)
		r_Aq[et] = 0;
	    
	    // M*(lambda*q -(laplace q) + lift*(n.grad q))
	    occaUnroll(p_Np)
	      for(int m=0;m<p_Np;++m){
		const dfloat MMnm = MM[n+m*p_Np];
		
		// 2 flops per 1 shared memory/L1 reads  (=> 3.37 TFLOPS/s assuming perfect caching)
		occaUnroll(p_Ne)
		  for(int et=0;et<p_Ne;++et){
		    r_Aq[et] += MMnm*s_q[et][b][m];
		  }
	      }
	    
	    occaUnroll(p_Ne)
	      for(int et=0;et<p_Ne;++et){
		
		const int e = eo + b + p_Nb*et;
		if(e<Nelements){
		  const dfloat J = vgeo[e*p_Nvgeo + p_JID];    
		  
		  Aq[n+e*p_Np] = J*r_Aq[et];
		}
	      }
	  }
      }
    }
  }
}

// need to reuse shared memory more than once... (halfNp)


// v5: reuse shared twice
kernel void ellipticPartialAxBBTet3D_v5(const dlong Nelements,
					const int elementOffset,
					const dfloat * restrict sgeo,   // surface geofacs
					const int * restrict faceNodes, // volume node indices of surface nodes
					const dfloat * restrict vgeo,   // volume geofacs (drdx, ...)
					const int * restrict D0ids,     // sparse D matrices
					const int * restrict D1ids,
					const int * restrict D2ids,
					const int * restrict D3ids,
					const dfloat * restrict Dvals,    
					const dfloat * restrict LIFT,   // dense lift matrix
					const dfloat * restrict MM,     // dense mass matrix
					const dfloat lambda,
					const dfloat * restrict q,
					dfloat * restrict Aq){
  
  for(dlong eo=0;eo<Nelements;eo+=p_Ne*p_Nb;outer0){
    
    shared dfloat s_q[p_Ne][p_Nb][p_Np];
    shared dfloat s_qx[p_Ne][p_Nb][p_Np], s_qy[p_Ne][p_Nb][p_Np], s_qz[p_Ne][p_Nb][p_Np], s_flux[p_Ne][p_Nb][p_Nfaces*p_Nfp];
    dfloat r_Aq[2][p_Ne];
    
    // prefetch q for element e
    for(int b=0;b<p_Nb;++b;inner1){
      for(int hn=0;hn<p_halfNp;++hn;inner0){

	occaUnroll(p_Ne)
	  for(int et=0;et<p_Ne;++et){
	    const int e = eo + b + p_Nb*et;
	    if(e<Nelements){
	      s_q[et][b][hn] = q[hn+e*p_Np];
	      s_q[et][b][hn+p_halfNp] = q[hn+p_halfNp+e*p_Np];
	    }
	  }
      }
    }

    barrier(localMemFence);

    // grad
    for(int b=0;b<p_Nb;++b;inner1){
      for(int hn=0;hn<p_halfNp;++hn;inner0){     // for all nodes in this element

	occaUnroll(2)
	for(int n=hn;n<p_Np;n+=p_halfNp){
	  // compute 'r', 's',  and 't' derivatives of (q_m) at node n
	  const int D0i1 = D0ids[n];
	  const int D1i1 = D1ids[n];
	  const int D2i1 = D2ids[n];
	  const int D3i1 = D3ids[n];
	  const dfloat Dval1 = Dvals[n];
	  
	  const int D0i2 = D0ids[n+p_Np];
	  const int D1i2 = D1ids[n+p_Np];
	  const int D2i2 = D2ids[n+p_Np];
	  const int D3i2 = D3ids[n+p_Np];
	  const dfloat Dval2 = Dvals[n+p_Np];
	  
	  const int D0i3 = D0ids[n+2*p_Np];
	  const int D1i3 = D1ids[n+2*p_Np];
	  const int D2i3 = D2ids[n+2*p_Np];
	  const int D3i3 = D3ids[n+2*p_Np];    
	  const dfloat Dval3 = Dvals[n+2*p_Np];
	  
	  const int D0i4 = D0ids[n+3*p_Np];
	  const int D1i4 = D1ids[n+3*p_Np];
	  const int D2i4 = D2ids[n+3*p_Np];
	  const int D3i4 = D3ids[n+3*p_Np];    
	  const dfloat Dval4 = Dvals[n+3*p_Np];
	  
	  occaUnroll(p_Ne)
	    for(int et=0;et<p_Ne;++et){
	      const int e = eo + b + p_Nb*et;
	      if(e<Nelements){
		
		// prefetch geometric factors (constant on triangle)
		const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
		const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
		const dfloat drdz = vgeo[e*p_Nvgeo + p_RZID];
		const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
		const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];
		const dfloat dsdz = vgeo[e*p_Nvgeo + p_SZID];
		const dfloat dtdx = vgeo[e*p_Nvgeo + p_TXID];
		const dfloat dtdy = vgeo[e*p_Nvgeo + p_TYID];
		const dfloat dtdz = vgeo[e*p_Nvgeo + p_TZID];
		
		
		const dfloat dqdr = .5f*(Dval1*(s_q[et][b][D1i1] - s_q[et][b][D0i1]) +
					 Dval2*(s_q[et][b][D1i2] - s_q[et][b][D0i2]) +
					 Dval3*(s_q[et][b][D1i3] - s_q[et][b][D0i3]) +
					 Dval4*(s_q[et][b][D1i4] - s_q[et][b][D0i4]));
		const dfloat dqds = .5f*(Dval1*(s_q[et][b][D2i1] - s_q[et][b][D0i1]) +
					 Dval2*(s_q[et][b][D2i2] - s_q[et][b][D0i2]) +
					 Dval3*(s_q[et][b][D2i3] - s_q[et][b][D0i3]) +
					 Dval4*(s_q[et][b][D2i4] - s_q[et][b][D0i4]));
		const dfloat dqdt = .5f*(Dval1*(s_q[et][b][D3i1] - s_q[et][b][D0i1]) +
					 Dval2*(s_q[et][b][D3i2] - s_q[et][b][D0i2]) +
					 Dval3*(s_q[et][b][D3i3] - s_q[et][b][D0i3]) +
					 Dval4*(s_q[et][b][D3i4] - s_q[et][b][D0i4]));
	      
		// chain rule
		s_qx[et][b][n] = drdx*dqdr + dsdx*dqds + dtdx*dqdt;
		s_qy[et][b][n] = drdy*dqdr + dsdy*dqds + dtdy*dqdt;
		s_qz[et][b][n] = drdz*dqdr + dsdz*dqds + dtdz*dqdt;
		
		// mass term
		r_Aq[n/p_halfNp][et] = lambda*s_q[et][b][n];
	      }
	    }
	}
      }
    }

    barrier(localMemFence);
    
    // surface flux terms
    for(int b=0;b<p_Nb;++b;inner1){
      for(int hn=0;hn<p_halfNp;++hn;inner0){     // for all nodes in this element
	
	occaUnroll(p_Ne)
	  for(int et=0;et<p_Ne;++et){
	    const int e = eo + b + p_Nb*et;
	    if(e<Nelements){
	      int m=hn;
	      while(m<p_Nfp*p_Nfaces){
		const int f = m/p_Nfp;
		const dlong sid = e*p_Nfaces*p_Nsgeo+f*p_Nsgeo;
		const int nid = faceNodes[m];
		const dfloat nx = sgeo[sid + p_NXID];
		const dfloat ny = sgeo[sid + p_NYID];
		const dfloat nz = sgeo[sid + p_NZID];
		const dfloat sJ = sgeo[sid + p_SJID];
		const dfloat invJ = sgeo[sid+p_IJID];
		const dfloat flux = invJ*sJ*(nx*s_qx[et][b][nid] + ny*s_qy[et][b][nid] + nz*s_qz[et][b][nid]);
		s_flux[et][b][m] = flux;
		m+=p_halfNp;
	      }
	    }
	  }
      }
    }
    
    barrier(localMemFence);

    // lift nx*qx+ny*qy+nz*qz
    // (doing this since we have Np threads)
    // yuck - this costs Np*Nfp*Nfaces
    for(int b=0;b<p_Nb;++b;inner1){
      for(int hn=0;hn<p_halfNp;++hn;inner0){     // for all nodes in this element

#if 1
	occaUnroll(p_Nfp*p_Nfaces)
	  //	  occaUnroll(p_Nfaces)
	  for(int m=0;m<p_Nfp*p_Nfaces;++m){
	    const dfloat LIFTnm0 = LIFT[hn+m*p_Np];
	    const dfloat LIFTnm1 = LIFT[hn+p_halfNp+m*p_Np];
	    
	    // 2 flops per 1 loads from L1+shared (=> 3.37 TFLOPS/s assuming perfect caching)
	    occaUnroll(p_Ne)
	      for(int et=0;et<p_Ne;++et){
		const dfloat flux = s_flux[et][b][m];
		r_Aq[0][et] += LIFTnm0*flux;
		r_Aq[1][et] += LIFTnm1*flux;
	      }
	  }
#endif
	
	occaUnroll(p_Ne)
	  for(int et=0;et<p_Ne;++et){
	    const int e = eo + b + p_Nb*et;
	    if(e<Nelements){
	      
	      // div
	      // double check this is ok
	      // prefetch geometric factors (constant on triangle)
	      const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
	      const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
	      const dfloat drdz = vgeo[e*p_Nvgeo + p_RZID];
	      const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
	      const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];
	      const dfloat dsdz = vgeo[e*p_Nvgeo + p_SZID];
	      const dfloat dtdx = vgeo[e*p_Nvgeo + p_TXID];
	      const dfloat dtdy = vgeo[e*p_Nvgeo + p_TYID];
	      const dfloat dtdz = vgeo[e*p_Nvgeo + p_TZID];

	      for(int n=hn;n<p_Np;n+=p_halfNp){
		const dfloat tmpr = drdx*s_qx[et][b][n] + drdy*s_qy[et][b][n] + drdz*s_qz[et][b][n];
		const dfloat tmps = dsdx*s_qx[et][b][n] + dsdy*s_qy[et][b][n] + dsdz*s_qz[et][b][n];
		const dfloat tmpt = dtdx*s_qx[et][b][n] + dtdy*s_qy[et][b][n] + dtdz*s_qz[et][b][n];
		
		s_qx[et][b][n] = tmpr;
		s_qy[et][b][n] = tmps;
		s_qz[et][b][n] = tmpt;
	      }
	    }
	  }
      }
    }

    barrier(localMemFence);

    for(int b=0;b<p_Nb;++b;inner1){
      for(int hn=0;hn<p_halfNp;++hn;inner0){     // for all nodes in this element

	occaUnroll(2)
	for(int n=hn;n<p_Np;n+=p_halfNp){
	  // compute 'r', 's',  and 't' derivatives of (q_m) at node n
	  const int D0i1 = D0ids[n];
	  const int D1i1 = D1ids[n];
	  const int D2i1 = D2ids[n];
	  const int D3i1 = D3ids[n];
	  const dfloat Dval1 = Dvals[n];
	  
	  const int D0i2 = D0ids[n+p_Np];
	  const int D1i2 = D1ids[n+p_Np];
	  const int D2i2 = D2ids[n+p_Np];
	  const int D3i2 = D3ids[n+p_Np];
	  const dfloat Dval2 = Dvals[n+p_Np];
	  
	  const int D0i3 = D0ids[n+2*p_Np];
	  const int D1i3 = D1ids[n+2*p_Np];
	  const int D2i3 = D2ids[n+2*p_Np];
	  const int D3i3 = D3ids[n+2*p_Np];    
	  const dfloat Dval3 = Dvals[n+2*p_Np];
	  
	  const int D0i4 = D0ids[n+3*p_Np];
	  const int D1i4 = D1ids[n+3*p_Np];
	  const int D2i4 = D2ids[n+3*p_Np];
	  const int D3i4 = D3ids[n+3*p_Np];    
	  const dfloat Dval4 = Dvals[n+3*p_Np];
	  
	  occaUnroll(p_Ne)
	    for(int et=0;et<p_Ne;++et){
	      
	      const dfloat dqrdr = .5f*(Dval1*(s_qx[et][b][D1i1] - s_qx[et][b][D0i1]) +
					Dval2*(s_qx[et][b][D1i2] - s_qx[et][b][D0i2]) +
					Dval3*(s_qx[et][b][D1i3] - s_qx[et][b][D0i3]) +
					Dval4*(s_qx[et][b][D1i4] - s_qx[et][b][D0i4]));
	      const dfloat dqsds = .5f*(Dval1*(s_qy[et][b][D2i1] - s_qy[et][b][D0i1]) +
					Dval2*(s_qy[et][b][D2i2] - s_qy[et][b][D0i2]) +
					Dval3*(s_qy[et][b][D2i3] - s_qy[et][b][D0i3]) +
					Dval4*(s_qy[et][b][D2i4] - s_qy[et][b][D0i4]));
	      const dfloat dqtdt = .5f*(Dval1*(s_qz[et][b][D3i1] - s_qz[et][b][D0i1]) +
					Dval2*(s_qz[et][b][D3i2] - s_qz[et][b][D0i2]) +
					Dval3*(s_qz[et][b][D3i3] - s_qz[et][b][D0i3]) +
					Dval4*(s_qz[et][b][D3i4] - s_qz[et][b][D0i4]));
	      
	      // note sign change
	      s_q[et][b][n] = r_Aq[n/p_halfNp][et] - (dqrdr + dqsds + dqtdt);
	    }
	}
      }
    }
    

    barrier(localMemFence);
    
    for(int b=0;b<p_Nb;++b;inner1){
      for(int hn=0;hn<p_halfNp;++hn;inner0){     // for all nodes in this element
	
	// multiply by mass matrix
	occaUnroll(p_Ne)
	  for(int et=0;et<p_Ne;++et){
	    r_Aq[0][et] = 0;
	    r_Aq[1][et] = 0;
	  }

#if 1
	// M*(lambda*q -(laplace q) + lift*(n.grad q))
	occaUnroll(p_Np)
	  for(int m=0;m<p_Np;++m){
	    const dfloat MMnm0 = MM[hn+m*p_Np];
	    const dfloat MMnm1 = MM[hn+p_halfNp+m*p_Np];
	    
	    // 2 flops per 1 shared memory/L1 reads  (=> 3.37 TFLOPS/s assuming perfect caching)
	    occaUnroll(p_Ne)
	      for(int et=0;et<p_Ne;++et){
		const dfloat qm = s_q[et][b][m];
		r_Aq[0][et] += MMnm0*qm;
		r_Aq[1][et] += MMnm1*qm;
	      }
	  }
#endif
	
	occaUnroll(p_Ne)
	  for(int et=0;et<p_Ne;++et){
	    
	    const int e = eo + b + p_Nb*et;
	    if(e<Nelements){
	      const dfloat J = vgeo[e*p_Nvgeo + p_JID];    
	      
	      Aq[hn+e*p_Np]          = J*r_Aq[0][et];
	      Aq[hn+p_halfNp+e*p_Np] = J*r_Aq[1][et];
	    }
	  }
      }
    }
  }
}
