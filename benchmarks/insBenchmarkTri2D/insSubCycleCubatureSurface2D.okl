/*

The MIT License (MIT)

Copyright (c) 2017 Tim Warburton, Noel Chalmers, Jesse Chan, Ali Karakus

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/


kernel void insSubCycleCubatureSurface2D_v0(
              int Nelements,
              dfloat * sgeo,
              dfloat * intInterpT, // interpolate to integration nodes
              dfloat * intLIFTT, // lift from integration to interpolation nodes
              int   * vmapM,
              int   * vmapP,
              int   * EToB,
              dfloat time,
              dfloat * intx, // integration nodes
              dfloat * inty,
              dfloat * U,
              dfloat * V,
              dfloat * Ud,
              dfloat * Vd,
              dfloat * rhsU,
              dfloat * rhsV){
  // for all elements
  for(int e=0;e<Nelements;++e;outer0){

    shared dfloat s_iFluxU[p_intNfpNfaces];
    shared dfloat s_iFluxV[p_intNfpNfaces];

    for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 

      if(e<Nelements){
        if(n<(p_Nfaces*p_intNfp)){

          int face = n/p_intNfp; // find face that owns this integration node

          // load surface geofactors for this face
          int sid    = p_Nsgeo*(e*p_Nfaces+face);
          dfloat nx   = sgeo[sid+p_NXID];
          dfloat ny   = sgeo[sid+p_NYID];
          dfloat sJ   = sgeo[sid+p_SJID];
          dfloat invJ = sgeo[sid+p_IJID];

          dfloat iUM  = 0.f, iVM  = 0.f;
          dfloat iUP  = 0.f, iVP  = 0.f;
          dfloat iUdM = 0.f, iVdM = 0.f;
          dfloat iUdP = 0.f, iVdP = 0.f;

          // local block interpolation (face nodes to integration nodes)
          //occaUnroll(p_Nfp)
    for(int m=0;m<p_Nfp;++m){
      dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];

      int id  = e*p_Nfp*p_Nfaces + face*p_Nfp + m;
      int idM = vmapM[id];
      int idP = vmapP[id];
      //
      iUM  += iInm*U[idM];
      iVM  += iInm*V[idM];
      iUdM += iInm*Ud[idM];
      iVdM += iInm*Vd[idM];

      iUP  += iInm*U[idP];
      iVP  += iInm*V[idP];
      iUdP += iInm*Ud[idP];
      iVdP += iInm*Vd[idP];
    }

          // apply boundary conditions
          int bc = EToB[face+p_Nfaces*e];

          if(bc>0){
            insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, iUdM,iVdM, &iUdP, &iVdP);
          }


          // Find max normal velocity on the face
          dfloat unm   = occaFabs(nx*iUM + ny*iVM);
          dfloat unp   = occaFabs(nx*iUP + ny*iVP);    
          dfloat unmax = (unm > unp) ? unm : unp;

          // evaluate "flux" terms: LLF
          dfloat sc = invJ * sJ ;

          s_iFluxU[n] = sc*(.5f*(nx*(iUP*iUdP + iUM*iUdM) 
         +ny*(iVP*iUdP + iVM*iUdM) 
         +unmax*(iUdM-iUdP) ));

          s_iFluxV[n] = sc*(.5f*(nx*(iUP*iVdP + iUM*iVdM) 
         + ny*(iVP*iVdP + iVM*iVdM) 
         + unmax*(iVdM-iVdP) ));
        }
      }
    }

    barrier(localMemFence);

    // lift from surface integration to volume nodes
    for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
      if(e<Nelements){
        if(n<p_Np){
          int id = n + p_Np*e;
          // prefetch volume rhs
          dfloat rhsu = rhsU[id];
          dfloat rhsv = rhsV[id];

          //occaUnroll(p_intNfpNfaces)
          for(int m=0;m<p_intNfpNfaces;++m){
      // RefMassMatrix^{-1}*cInterp^t*cWeight
            dfloat L = intLIFTT[n+m*p_Np];

            rhsu += L*s_iFluxU[m];
            rhsv += L*s_iFluxV[m];
          }

          rhsU[id] = rhsu;  // 
          rhsV[id] = rhsv;  //  
        }
      }
    }
  }
}




// Add shared memory for global read
kernel void insSubCycleCubatureSurface2D_v1(
              int Nelements,
              dfloat * sgeo,
              dfloat * intInterpT, // interpolate to integration nodes
              dfloat * intLIFTT, // lift from integration to interpolation nodes
              int   * vmapM,
              int   * vmapP,
              int   * EToB,
              dfloat time,
              dfloat * intx, // integration nodes
              dfloat * inty,
              dfloat * U,
              dfloat * V,
              dfloat * Ud,
              dfloat * Vd,
              dfloat * rhsU,
              dfloat * rhsV){
  // for all elements
  for(int e=0;e<Nelements;++e;outer0){

    // shared storage for flux terms
    shared dfloat s_UM[p_NfacesNfp];
    shared dfloat s_VM[p_NfacesNfp];
    shared dfloat s_UP[p_NfacesNfp];
    shared dfloat s_VP[p_NfacesNfp];

    shared dfloat s_UdM[p_NfacesNfp];
    shared dfloat s_VdM[p_NfacesNfp];
    shared dfloat s_UdP[p_NfacesNfp];
    shared dfloat s_VdP[p_NfacesNfp];

    shared dfloat s_iFluxU[p_intNfpNfaces];
    shared dfloat s_iFluxV[p_intNfpNfaces];


    for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
      if(e<Nelements){
        if(n<(p_Nfaces*p_Nfp)){
          // indices of negative and positive traces of face node
          int id  = e*p_Nfp*p_Nfaces + n;

          int idM = vmapM[id];
          int idP = vmapP[id];

          if(idP<0) idP = idM;
    // load negative and positive trace node values of velocity
    s_UM[n] = U[idM];
    s_VM[n] = V[idM];
    s_UP[n] = U[idP];
    s_VP[n] = V[idP];

    s_UdM[n] = Ud[idM];
    s_VdM[n] = Vd[idM];
    s_UdP[n] = Ud[idP];
    s_VdP[n] = Vd[idP];

  }
      }
    }

    barrier(localMemFence);

  
    for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 

      if(e<Nelements){
  if(n<(p_Nfaces*p_intNfp)){

    int face = n/p_intNfp; // find face that owns this integration node

    // load surface geofactors for this face
    int sid    = p_Nsgeo*(e*p_Nfaces+face);
    dfloat nx   = sgeo[sid+p_NXID];
    dfloat ny   = sgeo[sid+p_NYID];
    dfloat sJ   = sgeo[sid+p_SJID];
    dfloat invJ = sgeo[sid+p_IJID];

    dfloat iUM  = 0.f, iVM  = 0.f;
    dfloat iUP  = 0.f, iVP  = 0.f;
    dfloat iUdM = 0.f, iVdM = 0.f;
    dfloat iUdP = 0.f, iVdP = 0.f;

    // local block interpolation (face nodes to integration nodes)
    //occaUnroll(p_Nfp)
    for(int m=0;m<p_Nfp;++m){
      dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
      int fm = face*p_Nfp+m;

      iUM  += iInm*s_UM[fm];
      iVM  += iInm*s_VM[fm];
      iUdM += iInm*s_UdM[fm];
      iVdM += iInm*s_VdM[fm];

      iUP  += iInm*s_UP[fm];
      iVP  += iInm*s_VP[fm];
      iUdP += iInm*s_UdP[fm];
      iVdP += iInm*s_VdP[fm];
    }

    // apply boundary conditions
    int bc = EToB[face+p_Nfaces*e];

    if(bc>0){
      insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, iUdM,iVdM, &iUdP, &iVdP);
    }


    // Find max normal velocity on the face
    dfloat unm   = occaFabs(nx*iUM + ny*iVM);
    dfloat unp   = occaFabs(nx*iUP + ny*iVP);    
    dfloat unmax = (unm > unp) ? unm : unp;

    // evaluate "flux" terms: LLF
    dfloat sc = invJ * sJ ;

    s_iFluxU[n] = sc*(.5f*(nx*(iUP*iUdP + iUM*iUdM) 
         +ny*(iVP*iUdP + iVM*iUdM) 
         +unmax*(iUdM-iUdP) ));

    s_iFluxV[n] = sc*(.5f*(nx*(iUP*iVdP + iUM*iVdM) 
         + ny*(iVP*iVdP + iVM*iVdM) 
         + unmax*(iVdM-iVdP) ));
  }
      }
    }

    barrier(localMemFence);

    // lift from surface integration to volume nodes
    for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
      if(e<Nelements){
  if(n<p_Np){
    int id = n + p_Np*e;
    // prefetch volume rhs
    dfloat rhsu = 0.f;
    dfloat rhsv = 0.f;

    //occaUnroll(p_intNfpNfaces)
    for(int m=0;m<p_intNfpNfaces;++m){
            // RefMassMatrix^{-1}*cInterp^t*cWeight
      dfloat L = intLIFTT[n+m*p_Np];

      rhsu += L*s_iFluxU[m];
      rhsv += L*s_iFluxV[m];
    }

    rhsU[id] = rhsu;  // 
    rhsV[id] = rhsv;  //  
  }
      }
    }
  }
}



// Add const and loop unrolling
kernel void insSubCycleCubatureSurface2D_v2(
              const int Nelements,
              const dfloat * restrict sgeo,
              const dfloat * restrict intInterpT, // interpolate to integration nodes
              const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
              const int   * restrict vmapM,
              const int   * restrict vmapP,
              const int   * restrict EToB,
              const dfloat time,
              const dfloat * restrict intx, // integration nodes
              const dfloat * restrict inty,
              const dfloat * restrict U,
              const dfloat * restrict V,
              const dfloat * restrict Ud,
              const dfloat * restrict Vd,
              dfloat * restrict rhsU,
              dfloat * restrict rhsV){
  // for all elements
  for(int e=0;e<Nelements;++e;outer0){

    // shared storage for flux terms
    shared dfloat s_UM[p_NfacesNfp];
    shared dfloat s_VM[p_NfacesNfp];
    shared dfloat s_UP[p_NfacesNfp];
    shared dfloat s_VP[p_NfacesNfp];

    shared dfloat s_UdM[p_NfacesNfp];
    shared dfloat s_VdM[p_NfacesNfp];
    shared dfloat s_UdP[p_NfacesNfp];
    shared dfloat s_VdP[p_NfacesNfp];

    shared dfloat s_iFluxU[p_intNfpNfaces];
    shared dfloat s_iFluxV[p_intNfpNfaces];

    //


    for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
      if(e<Nelements){
        if(n<(p_Nfaces*p_Nfp)){
          // indices of negative and positive traces of face node
          const int id  = e*p_Nfp*p_Nfaces + n;

          int idM = vmapM[id];
          int idP = vmapP[id];

          if(idP<0) idP = idM;
    // load negative and positive trace node values of velocity
    s_UM[n] = U[idM];
    s_VM[n] = V[idM];
    s_UP[n] = U[idP];
    s_VP[n] = V[idP];

    s_UdM[n] = Ud[idM];
    s_VdM[n] = Vd[idM];
    s_UdP[n] = Ud[idP];
    s_VdP[n] = Vd[idP];

  }
      }
    }

    barrier(localMemFence);

  
    for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 

      if(e<Nelements){
  if(n<(p_Nfaces*p_intNfp)){

    const int face = n/p_intNfp; // find face that owns this integration node

    // load surface geofactors for this face
    const int sid    = p_Nsgeo*(e*p_Nfaces+face);
    const dfloat nx   = sgeo[sid+p_NXID];
    const dfloat ny   = sgeo[sid+p_NYID];
    const dfloat sJ   = sgeo[sid+p_SJID];
    const dfloat invJ = sgeo[sid+p_IJID];

    dfloat iUM  = 0.f, iVM  = 0.f;
    dfloat iUP  = 0.f, iVP  = 0.f;
    dfloat iUdM = 0.f, iVdM = 0.f;
    dfloat iUdP = 0.f, iVdP = 0.f;

    // local block interpolation (face nodes to integration nodes)
    occaUnroll(p_Nfp)
      for(int m=0;m<p_Nfp;++m){
        const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
        const int fm = face*p_Nfp+m;

        iUM  += iInm*s_UM[fm];
        iVM  += iInm*s_VM[fm];
        iUdM += iInm*s_UdM[fm];
        iVdM += iInm*s_VdM[fm];

        iUP  += iInm*s_UP[fm];
        iVP  += iInm*s_VP[fm];
        iUdP += iInm*s_UdP[fm];
        iVdP += iInm*s_VdP[fm];
      }

    // apply boundary conditions
    const int bc = EToB[face+p_Nfaces*e];

    if(bc>0){
      insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, iUdM,iVdM, &iUdP, &iVdP);
    }


    // Find max normal velocity on the face
    const dfloat unm   = occaFabs(nx*iUM + ny*iVM);
    const dfloat unp   = occaFabs(nx*iUP + ny*iVP);    
    const dfloat unmax = (unm > unp) ? unm : unp;

    // evaluate "flux" terms: LLF
    const dfloat sc = invJ * sJ ;

    s_iFluxU[n] = sc*(.5f*(nx*(iUP*iUdP + iUM*iUdM) 
         +ny*(iVP*iUdP + iVM*iUdM) 
         +unmax*(iUdM-iUdP) ));

    s_iFluxV[n] = sc*(.5f*(nx*(iUP*iVdP + iUM*iVdM) 
         + ny*(iVP*iVdP + iVM*iVdM) 
         + unmax*(iVdM-iVdP) ));
  }
      }
    }

    barrier(localMemFence);

    // lift from surface integration to volume nodes
    for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
      if(e<Nelements){
  if(n<p_Np){
    const int id = n + p_Np*e;
    // prefetch volume rhs
    dfloat rhsu = 0.f;
    dfloat rhsv = 0.f;

    occaUnroll(p_intNfpNfaces)
            for(int m=0;m<p_intNfpNfaces;++m){
        // RefMassMatrix^{-1}*cInterp^t*cWeight
              const dfloat L = intLIFTT[n+m*p_Np];

              rhsu += L*s_iFluxU[m];
              rhsv += L*s_iFluxV[m];
            }

    rhsU[id] += rhsu;  // 
    rhsV[id] += rhsv;  //  
  }
      }
    }
  }
}






// Add multiple element per threadblock 
kernel void insSubCycleCubatureSurface2D_v3(const int Nelements,
              const dfloat * restrict sgeo,
              const dfloat * restrict intInterpT, // interpolate to integration nodes
              const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
              const int   * restrict vmapM,
              const int   * restrict vmapP,
              const int   * restrict EToB,
              const dfloat time,
              const dfloat * restrict intx, // integration nodes
              const dfloat * restrict inty,
              const dfloat * restrict U,
              const dfloat * restrict V,
              const dfloat * restrict Ud,
              const dfloat * restrict Vd,
              dfloat * restrict rhsU,
              dfloat * restrict rhsV){
  // for all elements
  for(int eo=0;eo<Nelements;eo+=p_cubNblockS;outer0){

    // shared storage for flux terms
    shared dfloat s_UM[p_cubNblockS][p_NfacesNfp];
    shared dfloat s_VM[p_cubNblockS][p_NfacesNfp];
    shared dfloat s_UP[p_cubNblockS][p_NfacesNfp];
    shared dfloat s_VP[p_cubNblockS][p_NfacesNfp];

    shared dfloat s_UdM[p_cubNblockS][p_NfacesNfp];
    shared dfloat s_VdM[p_cubNblockS][p_NfacesNfp];
    shared dfloat s_UdP[p_cubNblockS][p_NfacesNfp];
    shared dfloat s_VdP[p_cubNblockS][p_NfacesNfp];

    shared dfloat s_iFluxU[p_cubNblockS][p_intNfpNfaces];
    shared dfloat s_iFluxV[p_cubNblockS][p_intNfpNfaces];

    // for all face nodes of all elements
    for(int es=0;es<p_cubNblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){

  int e = eo + es;

  if(e<Nelements){
    if(n<(p_Nfaces*p_Nfp)){
      // indices of negative and positive traces of face node
      const int id  = e*p_Nfp*p_Nfaces + n;

      int idM = vmapM[id];
      int idP = vmapP[id];

      if(idP<0) idP = idM;
      // load negative and positive trace node values of velocity
      s_UM[es][n] = U[idM];
      s_VM[es][n] = V[idM];
      s_UP[es][n] = U[idP];
      s_VP[es][n] = V[idP];

      s_UdM[es][n] = Ud[idM];
      s_VdM[es][n] = Vd[idM];
      s_UdP[es][n] = Ud[idP];
      s_VdP[es][n] = Vd[idP];

    }
  }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(int es=0;es<p_cubNblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 

  int e = eo + es;

  if(e<Nelements){
    if(n<(p_Nfaces*p_intNfp)){

      const int face = n/p_intNfp; // find face that owns this integration node

      // load surface geofactors for this face
      const int sid    = p_Nsgeo*(e*p_Nfaces+face);
      const dfloat nx   = sgeo[sid+p_NXID];
      const dfloat ny   = sgeo[sid+p_NYID];
      const dfloat sJ   = sgeo[sid+p_SJID];
      const dfloat invJ = sgeo[sid+p_IJID];

      dfloat iUM  = 0.f, iVM  = 0.f;
      dfloat iUP  = 0.f, iVP  = 0.f;
      dfloat iUdM = 0.f, iVdM = 0.f;
      dfloat iUdP = 0.f, iVdP = 0.f;

      // local block interpolation (face nodes to integration nodes)
      occaUnroll(p_Nfp)
        for(int m=0;m<p_Nfp;++m){
    const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
    const int fm = face*p_Nfp+m;

    iUM  += iInm*s_UM[es][fm];
    iVM  += iInm*s_VM[es][fm];
    iUdM += iInm*s_UdM[es][fm];
    iVdM += iInm*s_VdM[es][fm];

    iUP  += iInm*s_UP[es][fm];
    iVP  += iInm*s_VP[es][fm];
    iUdP += iInm*s_UdP[es][fm];
    iVdP += iInm*s_VdP[es][fm];
        }

      // apply boundary conditions
      int bc = EToB[face+p_Nfaces*e];

      if(bc>0){
        insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, iUdM,iVdM, &iUdP, &iVdP);
      }


      // Find max normal velocity on the face
      dfloat unm   = occaFabs(nx*iUM + ny*iVM);
      dfloat unp   = occaFabs(nx*iUP + ny*iVP);    
      dfloat unmax = (unm > unp) ? unm : unp;

      // evaluate "flux" terms: LLF
      const dfloat sc = invJ * sJ ;

      s_iFluxU[es][n] = sc*(.5f*(nx*(iUP*iUdP + iUM*iUdM) 
               +ny*(iVP*iUdP + iVM*iUdM) 
               +unmax*(iUdM-iUdP) ));

      s_iFluxV[es][n] = sc*(.5f*(nx*(iUP*iVdP + iUM*iVdM) 
               + ny*(iVP*iVdP + iVM*iVdM) 
               + unmax*(iVdM-iVdP) ));
    }
  }
      }
    }

    barrier(localMemFence);

    // lift from surface integration to volume nodes
    for(int es=0;es<p_cubNblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){

        const int e = eo + es;

        if(e<Nelements){
          if(n<p_Np){
            int id = n + p_Np*e;
            // prefetch volume rhs
            dfloat rhsu = rhsU[id];
            dfloat rhsv = rhsV[id];

            occaUnroll(p_intNfpNfaces)
            for(int m=0;m<p_intNfpNfaces;++m){
              // RefMassMatrix^{-1}*cInterp^t*cWeight
              const dfloat L = intLIFTT[n+m*p_Np];

              rhsu += L*s_iFluxU[es][m];
              rhsv += L*s_iFluxV[es][m];
            }

            rhsU[id] = rhsu;  // 
            rhsV[id] = rhsv;  //  
          }
        }
      }
    }
  }

}





// Use less shared memory by factor 2
kernel void insSubCycleCubatureSurface2D_v4(const int Nelements,
                                            const dfloat * restrict sgeo,
                                            const dfloat * restrict intInterpT, // interpolate to integration nodes
                                            const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
                                            const int   * restrict vmapM,
                                            const int   * restrict vmapP,
                                            const int   * restrict EToB,
                                            const dfloat time,
                                            const dfloat * restrict intx, // integration nodes
                                            const dfloat * restrict inty,
                                            const dfloat * restrict U,
                                            const dfloat * restrict V,
                                            const dfloat * restrict Ud,
                                            const dfloat * restrict Vd,
                                            dfloat * restrict rhsU,
                                            dfloat * restrict rhsV){
  // for all elements
  for(int eo=0;eo<Nelements;eo+=p_cubNblockS;outer0){

    // shared storage for flux terms
    shared dfloat s_U[p_cubNblockS][p_intNfpNfaces];
    shared dfloat s_V[p_cubNblockS][p_intNfpNfaces];
    shared dfloat s_Ud[p_cubNblockS][p_NfacesNfp];
    shared dfloat s_Vd[p_cubNblockS][p_NfacesNfp];

   #define s_iFluxU s_U
   #define s_iFluxV s_V
  
    exclusive dfloat r_iUM,  r_iUP;
    exclusive dfloat r_iVM,  r_iVP;
    exclusive dfloat r_iUdM, r_iUdP;
    exclusive dfloat r_iVdM, r_iVdP;

    // Loop for minus traces //
    // for all face nodes of all elements
    for(int es=0;es<p_cubNblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        const int e = eo + es;
        if(e<Nelements){
          if(n<(p_Nfaces*p_Nfp)){
            // indices of negative and positive traces of face node
            const int id  = e*p_Nfp*p_Nfaces + n;
            const int idM = vmapM[id];

            // load negative and positive trace node values of velocity
            s_U[es][n] = U[idM];
            s_V[es][n] = V[idM];
            s_Ud[es][n] = Ud[idM];
            s_Vd[es][n] = Vd[idM];
          }
        }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(int es=0;es<p_cubNblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
        const int e = eo + es;
        if(e<Nelements){
          if(n<(p_Nfaces*p_intNfp)){
            const int face = n/p_intNfp; // find face that owns this integration node

            r_iUM  = 0.f;
            r_iVM  = 0.f;
            r_iUdM = 0.f;
            r_iVdM = 0.f;

            // local block interpolation (face nodes to integration nodes)
            occaUnroll(p_Nfp)
              for(int m=0;m<p_Nfp;++m){
                const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
                const int fm = face*p_Nfp+m;

                r_iUM  += iInm*s_U[es][fm];
                r_iVM  += iInm*s_V[es][fm];
                r_iUdM += iInm*s_Ud[es][fm];
                r_iVdM += iInm*s_Vd[es][fm];
              }
          }
        }
      }
    }
    barrier(localMemFence);

    // Loop for positive traces 
    // for all face nodes of all elements
    for(int es=0;es<p_cubNblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        const int e = eo + es;
        if(e<Nelements){
          if(n<(p_Nfaces*p_Nfp)){
            // indices of negative and positive traces of face node
            const int id  = e*p_Nfp*p_Nfaces + n;
            const int idP = vmapP[id];

            // load negative and positive trace node values of velocity
            s_U[es][n] = U[idP];
            s_V[es][n] = V[idP];
            s_Ud[es][n] = Ud[idP];
            s_Vd[es][n] = Vd[idP];
          }
        }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(int es=0;es<p_cubNblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
        const int e = eo + es;
        if(e<Nelements){
          if(n<(p_Nfaces*p_intNfp)){
            const int face = n/p_intNfp; // find face that owns this integration node

            r_iUP  = 0.f;
            r_iVP  = 0.f;
            r_iUdP = 0.f;
            r_iVdP = 0.f;

            // local block interpolation (face nodes to integration nodes)
            occaUnroll(p_Nfp)
              for(int m=0;m<p_Nfp;++m){
                const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
                const int fm = face*p_Nfp+m;

                r_iUP  += iInm*s_U[es][fm];
                r_iVP  += iInm*s_V[es][fm];
                r_iUdP += iInm*s_Ud[es][fm];
                r_iVdP += iInm*s_Vd[es][fm];
              }
          }
        }
      }
    }
    barrier(localMemFence);


    // Use traces to compuite and store flux 
    for(int es=0;es<p_cubNblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
        const int e = eo + es;
        if(e<Nelements){
          if(n<(p_Nfaces*p_intNfp)){
            const int face = n/p_intNfp; // find face that owns this integration node

            // load surface geofactors for this face
            const int sid    = p_Nsgeo*(e*p_Nfaces+face);
            const dfloat nx   = sgeo[sid+p_NXID];
            const dfloat ny   = sgeo[sid+p_NYID];
            const dfloat sJ   = sgeo[sid+p_SJID];
            const dfloat invJ = sgeo[sid+p_IJID];

            // apply boundary conditions
            const int bc = EToB[face+p_Nfaces*e];
            if(bc>0){
              insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, r_iUdM,r_iVdM, &r_iUdP, &r_iVdP);
            }

            // Find max normal velocity on the face
            const dfloat unm   = occaFabs(nx*r_iUM + ny*r_iVM);
            const dfloat unp   = occaFabs(nx*r_iUP + ny*r_iVP);    
            const dfloat unmax = (unm > unp) ? unm : unp;

            // evaluate "flux" terms: LLF
            const dfloat sc = 0.5f*invJ*sJ ;

            // bad notation here //
            s_iFluxU[es][n] = sc*(nx*(r_iUP*r_iUdP + r_iUM*r_iUdM) 
                             +ny*(r_iVP*r_iUdP + r_iVM*r_iUdM) 
                             +unmax*(r_iUdM-r_iUdP));

            s_iFluxV[es][n] = sc*(nx*(r_iUP*r_iVdP + r_iUM*r_iVdM) 
                            + ny*(r_iVP*r_iVdP + r_iVM*r_iVdM) 
                            + unmax*(r_iVdM-r_iVdP));
          }
        }
      }
    }

    barrier(localMemFence);

    // lift from surface integration to volume nodes
    for(int es=0;es<p_cubNblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        const int e = eo + es;
        if(e<Nelements){
          if(n<p_Np){
            const int id = n + p_Np*e;
            // prefetch volume rhs
            dfloat rhsu = rhsU[id];
            dfloat rhsv = rhsV[id];

            occaUnroll(p_intNfpNfaces)
              for(int m=0;m<p_intNfpNfaces;++m){
                const dfloat L = intLIFTT[n+m*p_Np];
                rhsu += L*s_U[es][m];
                rhsv += L*s_V[es][m];
              }

            rhsU[id] = rhsu;
            rhsV[id] = rhsv; 
          }
        }
      }
    }


  #undef s_iFluxU
  #undef s_iFluxV   
  }
}





// Use less shared memory by factor 4
kernel void insSubCycleCubatureSurface2D_v5(const int Nelements,
                                            const dfloat * restrict sgeo,
                                            const dfloat * restrict intInterpT, // interpolate to integration nodes
                                            const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
                                            const int   * restrict vmapM,
                                            const int   * restrict vmapP,
                                            const int   * restrict EToB,
                                            const dfloat time,
                                            const dfloat * restrict intx, // integration nodes
                                            const dfloat * restrict inty,
                                            const dfloat * restrict U,
                                            const dfloat * restrict V,
                                            const dfloat * restrict Ud,
                                            const dfloat * restrict Vd,
                                            dfloat * restrict rhsU,
                                            dfloat * restrict rhsV){
  // for all elements
  for(int eo=0;eo<Nelements;eo+=p_cubNblockS;outer0){

    // shared storage for flux terms
    shared dfloat s_U[p_cubNblockS][p_intNfpNfaces];
    shared dfloat s_V[p_cubNblockS][p_intNfpNfaces];
    
    #define s_iFluxU s_U
    #define s_iFluxV s_V
  
    exclusive dfloat r_iUM,  r_iUP;
    exclusive dfloat r_iVM,  r_iVP;
    exclusive dfloat r_iUdM, r_iUdP;
    exclusive dfloat r_iVdM, r_iVdP;

    exclusive int idM, idP; 

    //Loop for minus traces //
    // for all face nodes of all elements
    for(int es=0;es<p_cubNblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        const int e = eo + es;
        if(e<Nelements){
          if(n<(p_Nfaces*p_Nfp)){
            // indices of negative and positive traces of face node
            const int id  = e*p_Nfp*p_Nfaces + n;
            idM = vmapM[id];
            // load negative and positive trace node values of velocity
            s_U[es][n] = U[idM];
            s_V[es][n] = V[idM];
          }
        }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(int es=0;es<p_cubNblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
        const int e = eo + es;
        if(e<Nelements){
          if(n<(p_Nfaces*p_intNfp)){
            const int face = n/p_intNfp; // find face that owns this integration node
            r_iUM  = 0.f;
            r_iVM  = 0.f;        
            // local block interpolation (face nodes to integration nodes)
            occaUnroll(p_Nfp)
              for(int m=0;m<p_Nfp;++m){
                const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
                const int fm = face*p_Nfp+m;
                r_iUM  += iInm*s_U[es][fm];
                r_iVM  += iInm*s_V[es][fm];
              }
          }
        }
      }
    }
    barrier(localMemFence);



    //Loop for minus traces //
    // for all face nodes of all elements
    for(int es=0;es<p_cubNblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        const int e = eo + es;
        if(e<Nelements){
          if(n<(p_Nfaces*p_Nfp)){
            // load negative and positive trace node values of velocity
            s_U[es][n] = Ud[idM];
            s_V[es][n] = Vd[idM];
          }
        }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(int es=0;es<p_cubNblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
        const int e = eo + es;
        if(e<Nelements){
          if(n<(p_Nfaces*p_intNfp)){
            const int face = n/p_intNfp; // find face that owns this integration node
            r_iUdM = 0.f;
            r_iVdM = 0.f;
            // local block interpolation (face nodes to integration nodes)
            occaUnroll(p_Nfp)
              for(int m=0;m<p_Nfp;++m){
                const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
                const int fm = face*p_Nfp+m;
                r_iUdM += iInm*s_U[es][fm];
                r_iVdM += iInm*s_V[es][fm];
              }
          }
        }
      }
    }

    barrier(localMemFence);

    // Loop for positive traces //
    // for all face nodes of all elements
    for(int es=0;es<p_cubNblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        const int e = eo + es;
        if(e<Nelements){
          if(n<(p_Nfaces*p_Nfp)){
            // indices of negative and positive traces of face node
            const int id  = e*p_Nfp*p_Nfaces + n;
            idP = vmapP[id];

            // load negative and positive trace node values of velocity
            s_U[es][n] = U[idP];
            s_V[es][n] = V[idP];
          }
        }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(int es=0;es<p_cubNblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
        const int e = eo + es;
        if(e<Nelements){
          if(n<(p_Nfaces*p_intNfp)){
            const int face = n/p_intNfp; // find face that owns this integration node

            r_iUP  = 0.f;
            r_iVP  = 0.f;
            
            // local block interpolation (face nodes to integration nodes)
            occaUnroll(p_Nfp)
              for(int m=0;m<p_Nfp;++m){
                const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
                const int fm = face*p_Nfp+m;
                r_iUP  += iInm*s_U[es][fm];
                r_iVP  += iInm*s_V[es][fm];
              }
          }
        }
      }
    }

     barrier(localMemFence);

    // Loop for positive traces //
    // for all face nodes of all elements
    for(int es=0;es<p_cubNblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        const int e = eo + es;
        if(e<Nelements){
          if(n<(p_Nfaces*p_Nfp)){
            s_U[es][n] = Ud[idP];
            s_V[es][n] = Vd[idP];
          }
        }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(int es=0;es<p_cubNblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
        const int e = eo + es;
        if(e<Nelements){
          if(n<(p_Nfaces*p_intNfp)){
            const int face = n/p_intNfp; // find face that owns this integration node
            r_iUdP = 0.f;
            r_iVdP = 0.f;

            // local block interpolation (face nodes to integration nodes)
            occaUnroll(p_Nfp)
              for(int m=0;m<p_Nfp;++m){
                const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
                const int fm = face*p_Nfp+m;
                r_iUdP += iInm*s_U[es][fm];
                r_iVdP += iInm*s_V[es][fm];
              }
          }
        }
      }
    }


    barrier(localMemFence);


    // Use traces to compuite and store flux //
    for(int es=0;es<p_cubNblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
        const int e = eo + es;
        if(e<Nelements){
          if(n<(p_Nfaces*p_intNfp)){
            const int face = n/p_intNfp; // find face that owns this integration node

            // load surface geofactors for this face
            const int sid    = p_Nsgeo*(e*p_Nfaces+face);
            const dfloat nx   = sgeo[sid+p_NXID];
            const dfloat ny   = sgeo[sid+p_NYID];
            const dfloat sJ   = sgeo[sid+p_SJID];
            const dfloat invJ = sgeo[sid+p_IJID];

            // apply boundary conditions
            const int bc = EToB[face+p_Nfaces*e];
            if(bc>0){
              insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, r_iUdM,r_iVdM, &r_iUdP, &r_iVdP);
            }

            // Find max normal velocity on the face
            const dfloat unm   = occaFabs(nx*r_iUM + ny*r_iVM);
            const dfloat unp   = occaFabs(nx*r_iUP + ny*r_iVP);    
            const dfloat unmax = (unm > unp) ? unm : unp;

            // evaluate "flux" terms: LLF
            const dfloat sc = 0.5f*invJ*sJ ;

            // bad notation here //
            s_iFluxU[es][n] = sc*(nx*(r_iUP*r_iUdP + r_iUM*r_iUdM) 
                             +ny*(r_iVP*r_iUdP + r_iVM*r_iUdM) 
                             +unmax*(r_iUdM-r_iUdP));

            s_iFluxV[es][n] = sc*(nx*(r_iUP*r_iVdP + r_iUM*r_iVdM) 
                            + ny*(r_iVP*r_iVdP + r_iVM*r_iVdM) 
                            + unmax*(r_iVdM-r_iVdP));
          }
        }
      }
    }

    barrier(localMemFence);

    // lift from surface integration to volume nodes
    for(int es=0;es<p_cubNblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        const int e = eo + es;
        if(e<Nelements){
          if(n<p_Np){
            const int id = n + p_Np*e;
            // prefetch volume rhs
            dfloat rhsu = rhsU[id];
            dfloat rhsv = rhsV[id];

            occaUnroll(p_intNfpNfaces)
              for(int m=0;m<p_intNfpNfaces;++m){
                const dfloat L = intLIFTT[n+m*p_Np];
                rhsu += L*s_U[es][m];
                rhsv += L*s_V[es][m];
              }

            rhsU[id] = rhsu;
            rhsV[id] = rhsv; 
          }
        }
      }
    }


  #undef s_iFluxU
  #undef s_iFluxV   
  }
}





// Multiple nodes per thread// use less shared memory by factor 4 
kernel void insSubCycleCubatureSurface2D_v6(const int Nelements,
              const dfloat * restrict sgeo,
              const dfloat * restrict intInterpT, // interpolate to integration nodes
              const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
              const int   * restrict vmapM,
              const int   * restrict vmapP,
              const int   * restrict EToB,
              const dfloat time,
              const dfloat * restrict intx, // integration nodes
              const dfloat * restrict inty,
              const dfloat * restrict U,
              const dfloat * restrict V,
              const dfloat * restrict Ud,
              const dfloat * restrict Vd,
              dfloat * restrict rhsU,
              dfloat * restrict rhsV){
  // for all elements
  for(int eo=0;eo<Nelements;eo+=(p_cubNblockS*p_Nnodes);outer0){

    // shared storage 
    shared dfloat s_U[p_Nnodes][p_cubNblockS][p_intNfpNfaces];
    shared dfloat s_V[p_Nnodes][p_cubNblockS][p_intNfpNfaces];
   
    #define s_iFluxU s_U // Reuse shared memory arrays
    #define s_iFluxV s_V

    exclusive dfloat r_iUM[p_Nnodes],  r_iUP[p_Nnodes];
    exclusive dfloat r_iVM[p_Nnodes],  r_iVP[p_Nnodes];
    exclusive dfloat r_iUdM[p_Nnodes], r_iUdP[p_Nnodes];
    exclusive dfloat r_iVdM[p_Nnodes], r_iVdP[p_Nnodes];

     exclusive int idM[p_Nnodes], idP[p_Nnodes];
    exclusive int face;

    // Loop for minus traces
    // for all face nodes of all elements
    for(int es=0;es<p_cubNblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        if(n<(p_Nfaces*p_Nfp)){
          occaUnroll(p_Nnodes)
          for (int em=0;em<p_Nnodes;++em){
            const int e = em*p_cubNblockS + es + eo;
            if (e<Nelements) {
              // indices of negative and positive traces of face node
              const int id  = e*p_Nfp*p_Nfaces + n;
              idM[em] = vmapM[id];
              idP[em] = vmapP[id];

              // load negative and positive trace node values of velocity
              s_U[em][es][n] = U[idM[em]];
              s_V[em][es][n] = U[idP[em]];              
            }
          }
        }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(int es=0;es<p_cubNblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
        if(n<(p_Nfaces*p_intNfp)){
          face = n/p_intNfp; // find face that owns this integration node

          occaUnroll(p_Nnodes)
          for (int em=0;em<p_Nnodes;++em){
            r_iUM[em]  = 0.f;
            r_iUP[em]  = 0.f;
          }

          // local block interpolation (face nodes to integration nodes)
          occaUnroll(p_Nfp)
          for(int m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            const int fm = face*p_Nfp+m;

            occaUnroll(p_Nnodes)
            for (int em=0;em<p_Nnodes;++em){
              r_iUM[em]  += iInm*s_U[em][es][fm];
              r_iUP[em]  += iInm*s_V[em][es][fm];
            }
          }
        }
      }
    }
    barrier(localMemFence);

    // for all face nodes of all elements
    for(int es=0;es<p_cubNblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        if(n<(p_Nfaces*p_Nfp)){
          occaUnroll(p_Nnodes)
          for (int em=0;em<p_Nnodes;++em){
            const int e = em*p_cubNblockS + es + eo;
            if (e<Nelements) {
              // load negative and positive trace node values of advection field
              s_U[em][es][n] = Ud[idM[em]];
              s_V[em][es][n] = Ud[idP[em]];              
            }
          }
        }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(int es=0;es<p_cubNblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
        if(n<(p_Nfaces*p_intNfp)){
          occaUnroll(p_Nnodes)
          for (int em=0;em<p_Nnodes;++em){
            r_iUdM[em]  = 0.f;
            r_iUdP[em]  = 0.f;
          }

          // local block interpolation (face nodes to integration nodes)
          occaUnroll(p_Nfp)
          for(int m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            const int fm = face*p_Nfp+m;

            occaUnroll(p_Nnodes)
            for (int em=0;em<p_Nnodes;++em){
              r_iUdM[em]  += iInm*s_U[em][es][fm];
              r_iUdP[em]  += iInm*s_V[em][es][fm];
            }
          }
        }
      }
    }
    barrier(localMemFence);

      // Loop for positive traces
    // for all face nodes of all elements
    for(int es=0;es<p_cubNblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        if(n<(p_Nfaces*p_Nfp)){
          occaUnroll(p_Nnodes)
          for (int em=0;em<p_Nnodes;++em){
            const int e = em*p_cubNblockS + es + eo;
            if (e<Nelements) {
              // load negative and positive trace node values of velocity
              s_U[em][es][n] = V[idM[em]];
              s_V[em][es][n] = V[idP[em]];              
            }
          }
        }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(int es=0;es<p_cubNblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
        if(n<(p_Nfaces*p_intNfp)){
          occaUnroll(p_Nnodes)
          for (int em=0;em<p_Nnodes;++em){
            r_iVM[em]  = 0.f;
            r_iVP[em]  = 0.f;
          }

          // local block interpolation (face nodes to integration nodes)
          occaUnroll(p_Nfp)
          for(int m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            const int fm = face*p_Nfp+m;

            occaUnroll(p_Nnodes)
            for (int em=0;em<p_Nnodes;++em){
              r_iVM[em]  += iInm*s_U[em][es][fm];
              r_iVP[em]  += iInm*s_V[em][es][fm];
            }
          }
        }
      }
    }
    barrier(localMemFence);

    // for all face nodes of all elements
    for(int es=0;es<p_cubNblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        if(n<(p_Nfaces*p_Nfp)){
          occaUnroll(p_Nnodes)
          for (int em=0;em<p_Nnodes;++em){
            const int e = em*p_cubNblockS + es + eo;
            if (e<Nelements) {
              // load negative and positive trace node values of advection field
              s_U[em][es][n] = Vd[idM[em]];
              s_V[em][es][n] = Vd[idP[em]];              
            }
          }
        }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(int es=0;es<p_cubNblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
        if(n<(p_Nfaces*p_intNfp)){
          occaUnroll(p_Nnodes)
          for (int em=0;em<p_Nnodes;++em){
            r_iVdM[em]  = 0.f;
            r_iVdP[em]  = 0.f;
          }

          // local block interpolation (face nodes to integration nodes)
          occaUnroll(p_Nfp)
          for(int m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            const int fm = face*p_Nfp+m;

            occaUnroll(p_Nnodes)
            for (int em=0;em<p_Nnodes;++em){
              r_iVdM[em]  += iInm*s_U[em][es][fm];
              r_iVdP[em]  += iInm*s_V[em][es][fm];
            }
          }
        }
      }
    }
    barrier(localMemFence);

    // Use traces to compuite and store flux
    for(int es=0;es<p_cubNblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
        occaUnroll(p_Nnodes)
        for (int em=0;em<p_Nnodes;++em){
          const int e = em*p_cubNblockS + es + eo;
          if((e<Nelements)&&(n<(p_Nfaces*p_intNfp))){
            // load surface geofactors for this face
            const int sid    = p_Nsgeo*(e*p_Nfaces+face);
            const dfloat nx   = sgeo[sid+p_NXID];
            const dfloat ny   = sgeo[sid+p_NYID];
            const dfloat sJ   = sgeo[sid+p_SJID];
            const dfloat invJ = sgeo[sid+p_IJID];

            // apply boundary conditions
            const int bc = EToB[face+p_Nfaces*e];
            if(bc>0){
              insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, r_iUdM[em],r_iVdM[em], &(r_iUdP[em]), &(r_iVdP[em]));
            }

            // Find max normal velocity on the face
            const dfloat unm   = occaFabs(nx*r_iUM[em] + ny*r_iVM[em]);
            const dfloat unp   = occaFabs(nx*r_iUP[em] + ny*r_iVP[em]);    
            const dfloat unmax = (unm > unp) ? unm : unp;

            // evaluate "flux" terms: LLF
            const dfloat sc = 0.5f*invJ*sJ;

            // bad notation here //
            s_iFluxU[em][es][n] = sc*(nx*(r_iUP[em]*r_iUdP[em] + r_iUM[em]*r_iUdM[em]) 
                                +ny*(r_iVP[em]*r_iUdP[em] + r_iVM[em]*r_iUdM[em]) 
                                +unmax*(r_iUdM[em]-r_iUdP[em]));

            s_iFluxV[em][es][n] = sc*(nx*(r_iUP[em]*r_iVdP[em] + r_iUM[em]*r_iVdM[em]) 
                               + ny*(r_iVP[em]*r_iVdP[em] + r_iVM[em]*r_iVdM[em]) 
                               + unmax*(r_iVdM[em]-r_iVdP[em]));
          }
        }
      }
    }

    barrier(localMemFence);

    // lift from surface integration to volume nodes
    for(int es=0;es<p_cubNblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        if(n<p_Np){
          occaUnroll(p_Nnodes)
          for (int em=0;em<p_Nnodes;++em){
            const int e = em*p_cubNblockS + es + eo;
            if(e<Nelements) {
              const int id = n + p_Np*e;
              // prefemch volume rhs
              r_iUM[em] = rhsU[id];
              r_iVM[em] = rhsV[id];
            }
          }

          occaUnroll(p_intNfpNfaces)
          for(int m=0;m<p_intNfpNfaces;++m){
            const dfloat L = intLIFTT[n+m*p_Np];

            occaUnroll(p_Nnodes)
            for (int em=0;em<p_Nnodes;++em){
              r_iUM[em] += L*s_U[em][es][m];
              r_iVM[em] += L*s_V[em][es][m];
            }
          }

          occaUnroll(p_Nnodes)
          for (int em=0;em<p_Nnodes;++em){
            const int e = em*p_cubNblockS + es + eo;
            if(e<Nelements) {
              const int id = n + p_Np*e;
              // prefemch volume rhs
              rhsU[id] = r_iUM[em];
              rhsV[id] = r_iVM[em];
            }
          }
        }
      }
    }
  #undef s_iFluxU
  #undef s_iFluxV  
  }
}




/*
// Base implementation
kernel void insSubCycleCubatureSurface2D_v0(int Nelements,
                                            dfloat * sgeo,
                                            dfloat * intInterpT, // interpolate to integration nodes
                                            dfloat * intLIFTT, // lift from integration to interpolation nodes
                                            int   * vmapM,
                                            int   * vmapP,
                                            int   * EToB,
                                            dfloat time,
                                            dfloat * intx, // integration nodes
                                            dfloat * inty,
                                            dfloat * U,
                                            dfloat * V,
                                            dfloat * Ud,
                                            dfloat * Vd,
                                            dfloat * rhsU,
                                            dfloat * rhsV){
  // for all elements
  for(int e=0;e<Nelements;++e;outer0){

    shared dfloat s_iFluxU[p_intNfpNfaces];
    shared dfloat s_iFluxV[p_intNfpNfaces];

    for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){

      if(e<Nelements){
        if(n<(p_Nfaces*p_intNfp)){

          int face = n/p_intNfp; // find face that owns this integration node

          // load surface geofactors for this face
          int sid    = p_Nsgeo*(e*p_Nfaces+face);
          dfloat nx   = sgeo[sid+p_NXID];
          dfloat ny   = sgeo[sid+p_NYID];
          dfloat sJ   = sgeo[sid+p_SJID];
          dfloat invJ = sgeo[sid+p_IJID];

          dfloat iUM  = 0.f, iVM  = 0.f;
          dfloat iUP  = 0.f, iVP  = 0.f;
          dfloat iUdM = 0.f, iVdM = 0.f;
          dfloat iUdP = 0.f, iVdP = 0.f;

          // local block interpolation (face nodes to integration nodes)
          for(int m=0;m<p_Nfp;++m){
            dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];

            int id  = e*p_Nfp*p_Nfaces + face*p_Nfp + m;
            int idM = vmapM[id];
            int idP = vmapP[id];

            iUM  += iInm*U[idM];
            iVM  += iInm*V[idM];
            iUdM += iInm*Ud[idM];
            iVdM += iInm*Vd[idM];

            iUP  += iInm*U[idP];
            iVP  += iInm*V[idP];
            iUdP += iInm*Ud[idP];
            iVdP += iInm*Vd[idP];
          }

          // apply boundary conditions
          int bc = EToB[face+p_Nfaces*e];
          if(bc>0){
            insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, iUdM,iVdM, &iUdP, &iVdP);
          }

          // Find max normal velocity on the face
          dfloat unm   = occaFabs(nx*iUM + ny*iVM);
          dfloat unp   = occaFabs(nx*iUP + ny*iVP);
          dfloat unmax = (unm > unp) ? unm : unp;

          // evaluate "flux" terms: LLF
          dfloat sc = 0.5f*invJ*sJ ;

          s_iFluxU[n] = sc*(nx*(iUP*iUdP + iUM*iUdM)
                           +ny*(iVP*iUdP + iVM*iUdM)
                           +unmax*(iUdM-iUdP));

          s_iFluxV[n] = sc*(nx*(iUP*iVdP + iUM*iVdM)
                          + ny*(iVP*iVdP + iVM*iVdM)
                          + unmax*(iVdM-iVdP));
        }
      }
    }

    barrier(localMemFence);

    // lift from surface integration to volume nodes
    for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
      if(e<Nelements){
        if(n<p_Np){
          int id = n + p_Np*e;
          // prefetch volume rhs
          dfloat rhsu = rhsU[id];
          dfloat rhsv = rhsV[id];

          for(int m=0;m<p_intNfpNfaces;++m){
            dfloat L = intLIFTT[n+m*p_Np];
            rhsu += L*s_iFluxU[m];
            rhsv += L*s_iFluxV[m];
          }

          rhsU[id] = rhsu;
          rhsV[id] = rhsv;
        }
      }
    }
  }
}


// resrict and const
kernel void insSubCycleCubatureSurface2D_v1(const int Nelements,
                                            const dfloat * restrict sgeo,
                                            const dfloat * restrict intInterpT, // interpolate to integration nodes
                                            const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
                                            const int   * restrict vmapM,
                                            const int   * restrict vmapP,
                                            const int   * restrict EToB,
                                            const dfloat time,
                                            const dfloat * restrict intx, // integration nodes
                                            const dfloat * restrict inty,
                                            const dfloat * restrict U,
                                            const dfloat * restrict V,
                                            const dfloat * restrict Ud,
                                            const dfloat * restrict Vd,
                                            dfloat * restrict rhsU,
                                            dfloat * restrict rhsV){
  // for all elements
  for(int e=0;e<Nelements;++e;outer0){

    shared dfloat s_iFluxU[p_intNfpNfaces];
    shared dfloat s_iFluxV[p_intNfpNfaces];

    for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
      if(e<Nelements){
        if(n<(p_Nfaces*p_intNfp)){

          const int face = n/p_intNfp; // find face that owns this integration node

          // load surface geofactors for this face
          const int sid    = p_Nsgeo*(e*p_Nfaces+face);
          const dfloat nx   = sgeo[sid+p_NXID];
          const dfloat ny   = sgeo[sid+p_NYID];
          const dfloat sJ   = sgeo[sid+p_SJID];
          const dfloat invJ = sgeo[sid+p_IJID];

          dfloat iUM  = 0.f, iVM  = 0.f;
          dfloat iUP  = 0.f, iVP  = 0.f;
          dfloat iUdM = 0.f, iVdM = 0.f;
          dfloat iUdP = 0.f, iVdP = 0.f;

          // local block interpolation (face nodes to integration nodes)
          for(int m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];

            const int id  = e*p_Nfp*p_Nfaces + face*p_Nfp + m;
            const int idM = vmapM[id];
            const int idP = vmapP[id];

            iUM  += iInm*U[idM];
            iVM  += iInm*V[idM];
            iUdM += iInm*Ud[idM];
            iVdM += iInm*Vd[idM];

            iUP  += iInm*U[idP];
            iVP  += iInm*V[idP];
            iUdP += iInm*Ud[idP];
            iVdP += iInm*Vd[idP];
          }

          // apply boundary conditions
          const int bc = EToB[face+p_Nfaces*e];
          if(bc>0){
            insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, iUdM,iVdM, &iUdP, &iVdP);
          }

          // Find max normal velocity on the face
          const dfloat unm   = occaFabs(nx*iUM + ny*iVM);
          const dfloat unp   = occaFabs(nx*iUP + ny*iVP);
          const dfloat unmax = (unm > unp) ? unm : unp;

          // evaluate "flux" terms: LLF
          const dfloat sc = 0.5f*invJ*sJ ;

          s_iFluxU[n] = sc*(nx*(iUP*iUdP + iUM*iUdM)
                           +ny*(iVP*iUdP + iVM*iUdM)
                           +unmax*(iUdM-iUdP));

          s_iFluxV[n] = sc*(nx*(iUP*iVdP + iUM*iVdM)
                          + ny*(iVP*iVdP + iVM*iVdM)
                          + unmax*(iVdM-iVdP));
        }
      }
    }

    barrier(localMemFence);

    // lift from surface integration to volume nodes
    for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
      if(e<Nelements){
        if(n<p_Np){
          const int id = n + p_Np*e;
          // prefetch volume rhs
          dfloat rhsu = rhsU[id];
          dfloat rhsv = rhsV[id];

          for(int m=0;m<p_intNfpNfaces;++m){
            const dfloat L = intLIFTT[n+m*p_Np];
            rhsu += L*s_iFluxU[m];
            rhsv += L*s_iFluxV[m];
          }

          rhsU[id] = rhsu;
          rhsV[id] = rhsv;
        }
      }
    }
  }
}

// shared memory
kernel void insSubCycleCubatureSurface2D_v2(const int Nelements,
                                            const dfloat * restrict sgeo,
                                            const dfloat * restrict intInterpT, // interpolate to integration nodes
                                            const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
                                            const int   * restrict vmapM,
                                            const int   * restrict vmapP,
                                            const int   * restrict EToB,
                                            const dfloat time,
                                            const dfloat * restrict intx, // integration nodes
                                            const dfloat * restrict inty,
                                            const dfloat * restrict U,
                                            const dfloat * restrict V,
                                            const dfloat * restrict Ud,
                                            const dfloat * restrict Vd,
                                            dfloat * restrict rhsU,
                                            dfloat * restrict rhsV){
  // for all elements
  for(int e=0;e<Nelements;++e;outer0){

    // shared storage for flux terms
    shared dfloat s_UM[p_NfacesNfp];
    shared dfloat s_VM[p_NfacesNfp];
    shared dfloat s_UP[p_NfacesNfp];
    shared dfloat s_VP[p_NfacesNfp];

    shared dfloat s_UdM[p_NfacesNfp];
    shared dfloat s_VdM[p_NfacesNfp];
    shared dfloat s_UdP[p_NfacesNfp];
    shared dfloat s_VdP[p_NfacesNfp];

    shared dfloat s_iFluxU[p_intNfpNfaces];
    shared dfloat s_iFluxV[p_intNfpNfaces];

    for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
      if(e<Nelements){
        if(n<(p_Nfaces*p_Nfp)){
          // indices of negative and positive traces of face node
          const int id  = e*p_Nfp*p_Nfaces + n;

          const int idM = vmapM[id];
          const int idP = vmapP[id];

          // load negative and positive trace node values of velocity
          s_UM[n] = U[idM];
          s_VM[n] = V[idM];
          s_UP[n] = U[idP];
          s_VP[n] = V[idP];

          s_UdM[n] = Ud[idM];
          s_VdM[n] = Vd[idM];
          s_UdP[n] = Ud[idP];
          s_VdP[n] = Vd[idP];

        }
      }
    }

    barrier(localMemFence);


    for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
      if(e<Nelements){
        if(n<(p_Nfaces*p_intNfp)){
          const int face = n/p_intNfp; // find face that owns this integration node

          // load surface geofactors for this face
          const int sid    = p_Nsgeo*(e*p_Nfaces+face);
          const dfloat nx   = sgeo[sid+p_NXID];
          const dfloat ny   = sgeo[sid+p_NYID];
          const dfloat sJ   = sgeo[sid+p_SJID];
          const dfloat invJ = sgeo[sid+p_IJID];

          dfloat iUM  = 0.f, iVM  = 0.f;
          dfloat iUP  = 0.f, iVP  = 0.f;
          dfloat iUdM = 0.f, iVdM = 0.f;
          dfloat iUdP = 0.f, iVdP = 0.f;

          // local block interpolation (face nodes to integration nodes)
          for(int m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            const int fm = face*p_Nfp+m;

            iUM  += iInm*s_UM[fm];
            iVM  += iInm*s_VM[fm];
            iUdM += iInm*s_UdM[fm];
            iVdM += iInm*s_VdM[fm];

            iUP  += iInm*s_UP[fm];
            iVP  += iInm*s_VP[fm];
            iUdP += iInm*s_UdP[fm];
            iVdP += iInm*s_VdP[fm];
          }

          // apply boundary conditions
          const int bc = EToB[face+p_Nfaces*e];
          if(bc>0){
            insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, iUdM,iVdM, &iUdP, &iVdP);
          }

          // Find max normal velocity on the face
          const dfloat unm   = occaFabs(nx*iUM + ny*iVM);
          const dfloat unp   = occaFabs(nx*iUP + ny*iVP);
          const dfloat unmax = (unm > unp) ? unm : unp;

          // evaluate "flux" terms: LLF
          const dfloat sc = 0.5f*invJ*sJ ;

          s_iFluxU[n] = sc*(nx*(iUP*iUdP + iUM*iUdM)
                           +ny*(iVP*iUdP + iVM*iUdM)
                           +unmax*(iUdM-iUdP));

          s_iFluxV[n] = sc*(nx*(iUP*iVdP + iUM*iVdM)
                          + ny*(iVP*iVdP + iVM*iVdM)
                          + unmax*(iVdM-iVdP));
        }
      }
    }

    barrier(localMemFence);

    // lift from surface integration to volume nodes
    for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
      if(e<Nelements){
        if(n<p_Np){
          const int id = n + p_Np*e;
          // prefetch volume rhs
          dfloat rhsu = rhsU[id];
          dfloat rhsv = rhsV[id];

          for(int m=0;m<p_intNfpNfaces;++m){
            const dfloat L = intLIFTT[n+m*p_Np];
            rhsu += L*s_iFluxU[m];
            rhsv += L*s_iFluxV[m];
          }

          rhsU[id] = rhsu;
          rhsV[id] = rhsv;
        }
      }
    }
  }
}

// loop unrolling
kernel void insSubCycleCubatureSurface2D_v3(const int Nelements,
                                            const dfloat * restrict sgeo,
                                            const dfloat * restrict intInterpT, // interpolate to integration nodes
                                            const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
                                            const int   * restrict vmapM,
                                            const int   * restrict vmapP,
                                            const int   * restrict EToB,
                                            const dfloat time,
                                            const dfloat * restrict intx, // integration nodes
                                            const dfloat * restrict inty,
                                            const dfloat * restrict U,
                                            const dfloat * restrict V,
                                            const dfloat * restrict Ud,
                                            const dfloat * restrict Vd,
                                            dfloat * restrict rhsU,
                                            dfloat * restrict rhsV){
  // for all elements
  for(int e=0;e<Nelements;++e;outer0){

    // shared storage for flux terms
    shared dfloat s_UM[p_NfacesNfp];
    shared dfloat s_VM[p_NfacesNfp];
    shared dfloat s_UP[p_NfacesNfp];
    shared dfloat s_VP[p_NfacesNfp];

    shared dfloat s_UdM[p_NfacesNfp];
    shared dfloat s_VdM[p_NfacesNfp];
    shared dfloat s_UdP[p_NfacesNfp];
    shared dfloat s_VdP[p_NfacesNfp];

    shared dfloat s_iFluxU[p_intNfpNfaces];
    shared dfloat s_iFluxV[p_intNfpNfaces];

    for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
      if(e<Nelements){
        if(n<(p_Nfaces*p_Nfp)){
          // indices of negative and positive traces of face node
          const int id  = e*p_Nfp*p_Nfaces + n;

          const int idM = vmapM[id];
          const int idP = vmapP[id];

          // load negative and positive trace node values of velocity
          s_UM[n] = U[idM];
          s_VM[n] = V[idM];
          s_UP[n] = U[idP];
          s_VP[n] = V[idP];

          s_UdM[n] = Ud[idM];
          s_VdM[n] = Vd[idM];
          s_UdP[n] = Ud[idP];
          s_VdP[n] = Vd[idP];

        }
      }
    }

    barrier(localMemFence);


    for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
      if(e<Nelements){
        if(n<(p_Nfaces*p_intNfp)){
          const int face = n/p_intNfp; // find face that owns this integration node

          // load surface geofactors for this face
          const int sid    = p_Nsgeo*(e*p_Nfaces+face);
          const dfloat nx   = sgeo[sid+p_NXID];
          const dfloat ny   = sgeo[sid+p_NYID];
          const dfloat sJ   = sgeo[sid+p_SJID];
          const dfloat invJ = sgeo[sid+p_IJID];

          dfloat iUM  = 0.f, iVM  = 0.f;
          dfloat iUP  = 0.f, iVP  = 0.f;
          dfloat iUdM = 0.f, iVdM = 0.f;
          dfloat iUdP = 0.f, iVdP = 0.f;

          // local block interpolation (face nodes to integration nodes)
          occaUnroll(p_Nfp)
          for(int m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            const int fm = face*p_Nfp+m;

            iUM  += iInm*s_UM[fm];
            iVM  += iInm*s_VM[fm];
            iUdM += iInm*s_UdM[fm];
            iVdM += iInm*s_VdM[fm];

            iUP  += iInm*s_UP[fm];
            iVP  += iInm*s_VP[fm];
            iUdP += iInm*s_UdP[fm];
            iVdP += iInm*s_VdP[fm];
          }

          // apply boundary conditions
          const int bc = EToB[face+p_Nfaces*e];
          if(bc>0){
            insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, iUdM,iVdM, &iUdP, &iVdP);
          }

          // Find max normal velocity on the face
          const dfloat unm   = occaFabs(nx*iUM + ny*iVM);
          const dfloat unp   = occaFabs(nx*iUP + ny*iVP);
          const dfloat unmax = (unm > unp) ? unm : unp;

          // evaluate "flux" terms: LLF
          const dfloat sc = 0.5f*invJ*sJ ;

          s_iFluxU[n] = sc*(nx*(iUP*iUdP + iUM*iUdM)
                           +ny*(iVP*iUdP + iVM*iUdM)
                           +unmax*(iUdM-iUdP));

          s_iFluxV[n] = sc*(nx*(iUP*iVdP + iUM*iVdM)
                          + ny*(iVP*iVdP + iVM*iVdM)
                          + unmax*(iVdM-iVdP));
        }
      }
    }

    barrier(localMemFence);

    // lift from surface integration to volume nodes
    for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
      if(e<Nelements){
        if(n<p_Np){
          const int id = n + p_Np*e;
          // prefetch volume rhs
          dfloat rhsu = rhsU[id];
          dfloat rhsv = rhsV[id];

          occaUnroll(p_intNfpNfaces)
          for(int m=0;m<p_intNfpNfaces;++m){
            const dfloat L = intLIFTT[n+m*p_Np];
            rhsu += L*s_iFluxU[m];
            rhsv += L*s_iFluxV[m];
          }

          rhsU[id] = rhsu;
          rhsV[id] = rhsv;
        }
      }
    }
  }
}


// multiple elements per block
kernel void insSubCycleCubatureSurface2D_v4(const int Nelements,
                                            const dfloat * restrict sgeo,
                                            const dfloat * restrict intInterpT, // interpolate to integration nodes
                                            const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
                                            const int   * restrict vmapM,
                                            const int   * restrict vmapP,
                                            const int   * restrict EToB,
                                            const dfloat time,
                                            const dfloat * restrict intx, // integration nodes
                                            const dfloat * restrict inty,
                                            const dfloat * restrict U,
                                            const dfloat * restrict V,
                                            const dfloat * restrict Ud,
                                            const dfloat * restrict Vd,
                                            dfloat * restrict rhsU,
                                            dfloat * restrict rhsV){
  // for all elements
  for(int eo=0;eo<Nelements;eo+=p_NblockS;outer0){

    // shared storage for fields and reused for flux terms
    shared dfloat s_U[p_NblockS][p_intNfpNfaces];
    shared dfloat s_V[p_NblockS][p_intNfpNfaces];

    exclusive dfloat r_iUM , r_iUP ;
    exclusive dfloat r_iVM , r_iVP ;
    exclusive dfloat r_iUdM, r_iUdP;
    exclusive dfloat r_iVdM, r_iVdP;

    exclusive int idM, idP;
    exclusive int face;

    // Loop for minus traces 
    // for all face nodes of all elements
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        const int e = es + eo;
        if((n<(p_Nfaces*p_Nfp))&&(e<Nelements)) {
          // indices of negative and positive traces of face node
          const int id  = e*p_Nfp*p_Nfaces + n;
          idM = vmapM[id];
          idP = vmapP[id];

          // load negative and positive trace node values of velocity
          s_U[es][n] = U[idM];
          s_V[es][n] = U[idP];
        }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        if(n<(p_Nfaces*p_intNfp)){
          face = n/p_intNfp; // find face that owns this integration node
          r_iUM  = 0.f;
          r_iUP  = 0.f;

          // local block interpolation (face nodes to integration nodes)
          occaUnroll(p_Nfp)
          for(int m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            const int fm = face*p_Nfp+m;
            r_iUM  += iInm*s_U[es][fm];
            r_iUP  += iInm*s_V[es][fm];
          }
        }
      }
    }
    barrier(localMemFence);

    // for all face nodes of all elements
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        const int e = es + eo;
        if((n<(p_Nfaces*p_Nfp))&&(e<Nelements)) {
          // load negative and positive trace node values of advection field
          s_U[es][n] = Ud[idM];
          s_V[es][n] = Ud[idP];
        }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        if(n<(p_Nfaces*p_intNfp)){
          r_iUdM  = 0.f;
          r_iUdP  = 0.f;

          // local block interpolation (face nodes to integration nodes)
          occaUnroll(p_Nfp)
          for(int m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            const int fm = face*p_Nfp+m;
            r_iUdM  += iInm*s_U[es][fm];
            r_iUdP  += iInm*s_V[es][fm];
          }
        }
      }
    }
    barrier(localMemFence);

    //////////////////////////////////////////////////////

    // Loop for positive traces 
    // for all face nodes of all elements
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        const int e = es + eo;
        if((n<(p_Nfaces*p_Nfp))&&(e<Nelements)) {
          // load negative and positive trace node values of velocity
          s_U[es][n] = V[idM];
          s_V[es][n] = V[idP];
        }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        if(n<(p_Nfaces*p_intNfp)){
          r_iVM  = 0.f;
          r_iVP  = 0.f;

          // local block interpolation (face nodes to integration nodes)
          occaUnroll(p_Nfp)
          for(int m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            const int fm = face*p_Nfp+m;
            r_iVM  += iInm*s_U[es][fm];
            r_iVP  += iInm*s_V[es][fm];
          }
        }
      }
    }
    barrier(localMemFence);

    // for all face nodes of all elements
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        const int e = es + eo;
        if((n<(p_Nfaces*p_Nfp))&&(e<Nelements)) {
          // load negative and positive trace node values of advection field
          s_U[es][n] = Vd[idM];
          s_V[es][n] = Vd[idP];
        }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        if(n<(p_Nfaces*p_intNfp)){
          r_iVdM  = 0.f;
          r_iVdP  = 0.f;

          // local block interpolation (face nodes to integration nodes)
          occaUnroll(p_Nfp)
          for(int m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            const int fm = face*p_Nfp+m;
            r_iVdM  += iInm*s_U[es][fm];
            r_iVdP  += iInm*s_V[es][fm];
          }
        }
      }
    }
    barrier(localMemFence);

    // Use traces to compuite and store flux 
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        const int e = es + eo;
        if((e<Nelements)&&(n<(p_Nfaces*p_intNfp))){
          // load surface geofactors for this face
          const int sid    = p_Nsgeo*(e*p_Nfaces+face);
          const dfloat nx   = sgeo[sid+p_NXID];
          const dfloat ny   = sgeo[sid+p_NYID];
          const dfloat sJ   = sgeo[sid+p_SJID];
          const dfloat invJ = sgeo[sid+p_IJID];

          // apply boundary conditions
          const int bc = EToB[face+p_Nfaces*e];
          if(bc>0){
            insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, r_iUdM,r_iVdM, &(r_iUdP), &(r_iVdP));
          }

          // Find max normal velocity on the face
          const dfloat unm   = occaFabs(nx*r_iUM + ny*r_iVM);
          const dfloat unp   = occaFabs(nx*r_iUP + ny*r_iVP);
          const dfloat unmax = (unm > unp) ? unm : unp;

          // evaluate "flux" terms: LLF
          const dfloat sc = 0.5f*invJ*sJ;

          // bad notation here //
          s_U[es][n] = sc*(nx*(r_iUP*r_iUdP + r_iUM*r_iUdM)
                         + ny*(r_iVP*r_iUdP + r_iVM*r_iUdM)
                         + unmax*(r_iUdM-r_iUdP));

          s_V[es][n] = sc*(nx*(r_iUP*r_iVdP + r_iUM*r_iVdM)
                         + ny*(r_iVP*r_iVdP + r_iVM*r_iVdM)
                         + unmax*(r_iVdM-r_iVdP));
        }
      }
    }

    barrier(localMemFence);

    // lift from surface integration to volume nodes
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        if(n<p_Np){
          const int e = es + eo;
          if(e<Nelements) {
            const int id = n + p_Np*e;
            // prefetch volume rhs
            r_iUM = rhsU[id];
            r_iVM = rhsV[id];


            occaUnroll(p_intNfpNfaces)
            for(int m=0;m<p_intNfpNfaces;++m){
              const dfloat L = intLIFTT[n+m*p_Np];
              r_iUM += L*s_U[es][m];
              r_iVM += L*s_V[es][m];
            }

            rhsU[id] = r_iUM;
            rhsV[id] = r_iVM;
          }
        }
      }
    }
  }
}


// Based on v4 multiple elements per node
kernel void insSubCycleCubatureSurface2D_v5(const int Nelements,
                                            const dfloat * restrict sgeo,
                                            const dfloat * restrict intInterpT, // interpolate to integration nodes
                                            const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
                                            const int   * restrict vmapM,
                                            const int   * restrict vmapP,
                                            const int   * restrict EToB,
                                            const dfloat time,
                                            const dfloat * restrict intx, // integration nodes
                                            const dfloat * restrict inty,
                                            const dfloat * restrict U,
                                            const dfloat * restrict V,
                                            const dfloat * restrict Ud,
                                            const dfloat * restrict Vd,
                                            dfloat * restrict rhsU,
                                            dfloat * restrict rhsV){
  // for all elements
  for(int eo=0;eo<Nelements;eo+=p_NblockS*p_Nnodes;outer0){

    // shared storage for fields and reused for flux terms
    shared dfloat s_U[p_Nnodes][p_NblockS][p_intNfpNfaces];
    shared dfloat s_V[p_Nnodes][p_NblockS][p_intNfpNfaces];

    exclusive dfloat r_iUM [p_Nnodes], r_iUP [p_Nnodes];
    exclusive dfloat r_iVM [p_Nnodes], r_iVP [p_Nnodes];
    exclusive dfloat r_iUdM[p_Nnodes], r_iUdP[p_Nnodes];
    exclusive dfloat r_iVdM[p_Nnodes], r_iVdP[p_Nnodes];

    exclusive int idM[p_Nnodes], idP[p_Nnodes];
    exclusive int face;

    // Loop for minus traces 
    // for all face nodes of all elements
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        if(n<(p_Nfaces*p_Nfp)){
          occaUnroll(p_Nnodes)
          for (int et=0;et<p_Nnodes;++et){
            const int e = et*p_NblockS + es + eo;
            if (e<Nelements) {
              // indices of negative and positive traces of face node
              const int id  = e*p_Nfp*p_Nfaces + n;
              idM[et] = vmapM[id];
              idP[et] = vmapP[id];

              // load negative and positive trace node values of velocity
              s_U[et][es][n] = U[idM[et]];
              s_V[et][es][n] = U[idP[et]];
            }
          }
        }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        if(n<(p_Nfaces*p_intNfp)){
          face = n/p_intNfp; // find face that owns this integration node

          occaUnroll(p_Nnodes)
          for (int et=0;et<p_Nnodes;++et){
            r_iUM[et]  = 0.f;
            r_iUP[et]  = 0.f;
          }

          // local block interpolation (face nodes to integration nodes)
          occaUnroll(p_Nfp)
          for(int m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            const int fm = face*p_Nfp+m;

            occaUnroll(p_Nnodes)
            for (int et=0;et<p_Nnodes;++et){
              r_iUM[et]  += iInm*s_U[et][es][fm];
              r_iUP[et]  += iInm*s_V[et][es][fm];
            }
          }
        }
      }
    }
    barrier(localMemFence);

    // for all face nodes of all elements
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        if(n<(p_Nfaces*p_Nfp)){
          occaUnroll(p_Nnodes)
          for (int et=0;et<p_Nnodes;++et){
            const int e = et*p_NblockS + es + eo;
            if (e<Nelements) {
              // load negative and positive trace node values of advection field
              s_U[et][es][n] = Ud[idM[et]];
              s_V[et][es][n] = Ud[idP[et]];
            }
          }
        }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        if(n<(p_Nfaces*p_intNfp)){
          occaUnroll(p_Nnodes)
          for (int et=0;et<p_Nnodes;++et){
            r_iUdM[et]  = 0.f;
            r_iUdP[et]  = 0.f;
          }

          // local block interpolation (face nodes to integration nodes)
          occaUnroll(p_Nfp)
          for(int m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            const int fm = face*p_Nfp+m;

            occaUnroll(p_Nnodes)
            for (int et=0;et<p_Nnodes;++et){
              r_iUdM[et]  += iInm*s_U[et][es][fm];
              r_iUdP[et]  += iInm*s_V[et][es][fm];
            }
          }
        }
      }
    }
    barrier(localMemFence);

    //////////////////////////////////////////////////////

    // Loop for positive traces 
    // for all face nodes of all elements
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        if(n<(p_Nfaces*p_Nfp)){
          occaUnroll(p_Nnodes)
          for (int et=0;et<p_Nnodes;++et){
            const int e = et*p_NblockS + es + eo;
            if (e<Nelements) {
              // load negative and positive trace node values of velocity
              s_U[et][es][n] = V[idM[et]];
              s_V[et][es][n] = V[idP[et]];
            }
          }
        }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        if(n<(p_Nfaces*p_intNfp)){
          occaUnroll(p_Nnodes)
          for (int et=0;et<p_Nnodes;++et){
            r_iVM[et]  = 0.f;
            r_iVP[et]  = 0.f;
          }

          // local block interpolation (face nodes to integration nodes)
          occaUnroll(p_Nfp)
          for(int m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            const int fm = face*p_Nfp+m;

            occaUnroll(p_Nnodes)
            for (int et=0;et<p_Nnodes;++et){
              r_iVM[et]  += iInm*s_U[et][es][fm];
              r_iVP[et]  += iInm*s_V[et][es][fm];
            }
          }
        }
      }
    }
    barrier(localMemFence);

    // for all face nodes of all elements
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        if(n<(p_Nfaces*p_Nfp)){
          occaUnroll(p_Nnodes)
          for (int et=0;et<p_Nnodes;++et){
            const int e = et*p_NblockS + es + eo;
            if (e<Nelements) {
              // load negative and positive trace node values of advection field
              s_U[et][es][n] = Vd[idM[et]];
              s_V[et][es][n] = Vd[idP[et]];
            }
          }
        }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        if(n<(p_Nfaces*p_intNfp)){
          occaUnroll(p_Nnodes)
          for (int et=0;et<p_Nnodes;++et){
            r_iVdM[et]  = 0.f;
            r_iVdP[et]  = 0.f;
          }

          // local block interpolation (face nodes to integration nodes)
          occaUnroll(p_Nfp)
          for(int m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            const int fm = face*p_Nfp+m;

            occaUnroll(p_Nnodes)
            for (int et=0;et<p_Nnodes;++et){
              r_iVdM[et]  += iInm*s_U[et][es][fm];
              r_iVdP[et]  += iInm*s_V[et][es][fm];
            }
          }
        }
      }
    }
    barrier(localMemFence);

    // Use traces to compuite and store flux 
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        occaUnroll(p_Nnodes)
        for (int et=0;et<p_Nnodes;++et){
          const int e = et*p_NblockS + es + eo;
          if((e<Nelements)&&(n<(p_Nfaces*p_intNfp))){
            // load surface geofactors for this face
            const int sid    = p_Nsgeo*(e*p_Nfaces+face);
            const dfloat nx   = sgeo[sid+p_NXID];
            const dfloat ny   = sgeo[sid+p_NYID];
            const dfloat sJ   = sgeo[sid+p_SJID];
            const dfloat invJ = sgeo[sid+p_IJID];

            // apply boundary conditions
            const int bc = EToB[face+p_Nfaces*e];
            if(bc>0){
              insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, r_iUdM[et],r_iVdM[et], &(r_iUdP[et]), &(r_iVdP[et]));
            }

            // Find max normal velocity on the face
            const dfloat unm   = occaFabs(nx*r_iUM[et] + ny*r_iVM[et]);
            const dfloat unp   = occaFabs(nx*r_iUP[et] + ny*r_iVP[et]);
            const dfloat unmax = (unm > unp) ? unm : unp;

            // evaluate "flux" terms: LLF
            const dfloat sc = 0.5f*invJ*sJ;

            // bad notation here //
            s_U[et][es][n] = sc*(nx*(r_iUP[et]*r_iUdP[et] + r_iUM[et]*r_iUdM[et])
                                +ny*(r_iVP[et]*r_iUdP[et] + r_iVM[et]*r_iUdM[et])
                                +unmax*(r_iUdM[et]-r_iUdP[et]));

            s_V[et][es][n] = sc*(nx*(r_iUP[et]*r_iVdP[et] + r_iUM[et]*r_iVdM[et])
                               + ny*(r_iVP[et]*r_iVdP[et] + r_iVM[et]*r_iVdM[et])
                               + unmax*(r_iVdM[et]-r_iVdP[et]));
          }
        }
      }
    }

    barrier(localMemFence);

    // lift from surface integration to volume nodes
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        if(n<p_Np){
          occaUnroll(p_Nnodes)
          for (int et=0;et<p_Nnodes;++et){
            const int e = et*p_NblockS + es + eo;
            if(e<Nelements) {
              const int id = n + p_Np*e;
              // prefetch volume rhs
              r_iUM[et] = rhsU[id];
              r_iVM[et] = rhsV[id];
            }
          }

          occaUnroll(p_intNfpNfaces)
          for(int m=0;m<p_intNfpNfaces;++m){
            const dfloat L = intLIFTT[n+m*p_Np];

            occaUnroll(p_Nnodes)
            for (int et=0;et<p_Nnodes;++et){
              r_iUM[et] += L*s_U[et][es][m];
              r_iVM[et] += L*s_V[et][es][m];
            }
          }

          occaUnroll(p_Nnodes)
          for (int et=0;et<p_Nnodes;++et){
            const int e = et*p_NblockS + es + eo;
            if(e<Nelements) {
              const int id = n + p_Np*e;
              // prefetch volume rhs
              rhsU[id] = r_iUM[et];
              rhsV[id] = r_iVM[et];
            }
          }
        }
      }
    }
  }
}


/*
// Multiple element per threadblock,
kernel void insSubCycleCubatureSurface2D_v4(const int Nelements,
                                            const dfloat * restrict sgeo,
                                            const dfloat * restrict intInterpT, // interpolate to integration nodes
                                            const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
                                            const int   * restrict vmapM,
                                            const int   * restrict vmapP,
                                            const int   * restrict EToB,
                                            const dfloat time,
                                            const dfloat * restrict intx, // integration nodes
                                            const dfloat * restrict inty,
                                            const dfloat * restrict U,
                                            const dfloat * restrict V,
                                            const dfloat * restrict Ud,
                                            const dfloat * restrict Vd,
                                            dfloat * restrict rhsU,
                                            dfloat * restrict rhsV){
  // for all elements
  for(int eo=0;eo<Nelements;eo+=p_NblockS;outer0){

    // shared storage for flux terms
    shared dfloat s_UM[p_NblockS][p_NfacesNfp];
    shared dfloat s_VM[p_NblockS][p_NfacesNfp];
    shared dfloat s_UP[p_NblockS][p_NfacesNfp];
    shared dfloat s_VP[p_NblockS][p_NfacesNfp];

    shared dfloat s_UdM[p_NblockS][p_NfacesNfp];
    shared dfloat s_VdM[p_NblockS][p_NfacesNfp];
    shared dfloat s_UdP[p_NblockS][p_NfacesNfp];
    shared dfloat s_VdP[p_NblockS][p_NfacesNfp];

    shared dfloat s_iFluxU[p_NblockS][p_intNfpNfaces];
    shared dfloat s_iFluxV[p_NblockS][p_intNfpNfaces];

    // for all face nodes of all elements
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        const int e = eo + es;
        if(e<Nelements){
          if(n<(p_Nfaces*p_Nfp)){
            // indices of negative and positive traces of face node
            const int id  = e*p_Nfp*p_Nfaces + n;

            const int idM = vmapM[id];
            const int idP = vmapP[id];

            // load negative and positive trace node values of velocity
            s_UM[es][n] = U[idM];
            s_VM[es][n] = V[idM];
            s_UP[es][n] = U[idP];
            s_VP[es][n] = V[idP];

            s_UdM[es][n] = Ud[idM];
            s_VdM[es][n] = Vd[idM];
            s_UdP[es][n] = Ud[idP];
            s_VdP[es][n] = Vd[idP];
          }
        }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        const int e = eo + es;
        if(e<Nelements){
          if(n<(p_Nfaces*p_intNfp)){

            const int face = n/p_intNfp; // find face that owns this integration node

            // load surface geofactors for this face
            const int sid    = p_Nsgeo*(e*p_Nfaces+face);
            const dfloat nx   = sgeo[sid+p_NXID];
            const dfloat ny   = sgeo[sid+p_NYID];
            const dfloat sJ   = sgeo[sid+p_SJID];
            const dfloat invJ = sgeo[sid+p_IJID];

            dfloat iUM  = 0.f, iVM  = 0.f;
            dfloat iUP  = 0.f, iVP  = 0.f;
            dfloat iUdM = 0.f, iVdM = 0.f;
            dfloat iUdP = 0.f, iVdP = 0.f;

            // local block interpolation (face nodes to integration nodes)
            occaUnroll(p_Nfp)
              for(int m=0;m<p_Nfp;++m){
                const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
                const int fm = face*p_Nfp+m;

                iUM  += iInm*s_UM[es][fm];
                iVM  += iInm*s_VM[es][fm];
                iUdM += iInm*s_UdM[es][fm];
                iVdM += iInm*s_VdM[es][fm];

                iUP  += iInm*s_UP[es][fm];
                iVP  += iInm*s_VP[es][fm];
                iUdP += iInm*s_UdP[es][fm];
                iVdP += iInm*s_VdP[es][fm];
              }

            // apply boundary conditions
            const int bc = EToB[face+p_Nfaces*e];
            if(bc>0){
              insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, iUdM,iVdM, &iUdP, &iVdP);
            }


            // Find max normal velocity on the face
            const dfloat unm   = occaFabs(nx*iUM + ny*iVM);
            const dfloat unp   = occaFabs(nx*iUP + ny*iVP);
            const dfloat unmax = (unm > unp) ? unm : unp;

            // evaluate "flux" terms: LLF
            const dfloat sc = 0.5f*invJ*sJ ;

            s_iFluxU[es][n] = sc*(nx*(iUP*iUdP + iUM*iUdM)
                             +ny*(iVP*iUdP + iVM*iUdM)
                             +unmax*(iUdM-iUdP));

            s_iFluxV[es][n] = sc*(nx*(iUP*iVdP + iUM*iVdM)
                            + ny*(iVP*iVdP + iVM*iVdM)
                            + unmax*(iVdM-iVdP));
          }
        }
      }
    }

    barrier(localMemFence);

    // lift from surface integration to volume nodes
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        const int e = eo + es;
        if(e<Nelements){
          if(n<p_Np){
            const int id = n + p_Np*e;
            // prefetch volume rhs
            dfloat rhsu = rhsU[id];
            dfloat rhsv = rhsV[id];

            occaUnroll(p_intNfpNfaces)
              for(int m=0;m<p_intNfpNfaces;++m){
                const dfloat L = intLIFTT[n+m*p_Np];
                rhsu += L*s_iFluxU[es][m];
                rhsv += L*s_iFluxV[es][m];
              }

            rhsU[id] = rhsu;
            rhsV[id] = rhsv;
          }
        }
      }
    }
  }
}



// restict to p_Np threads
kernel void insSubCycleCubatureSurface2D_v5(const int Nelements,
                                            const dfloat * restrict sgeo,
                                            const dfloat * restrict intInterpT, // interpolate to integration nodes
                                            const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
                                            const int   * restrict vmapM,
                                            const int   * restrict vmapP,
                                            const int   * restrict EToB,
                                            const dfloat time,
                                            const dfloat * restrict intx, // integration nodes
                                            const dfloat * restrict inty,
                                            const dfloat * restrict U,
                                            const dfloat * restrict V,
                                            const dfloat * restrict Ud,
                                            const dfloat * restrict Vd,
                                            dfloat * restrict rhsU,
                                            dfloat * restrict rhsV){
  // for all elements
  for(int eo=0;eo<Nelements;eo+=p_NblockS;outer0){

    // shared storage for flux terms
    shared dfloat s_UM[p_NblockS][p_NfacesNfp];
    shared dfloat s_VM[p_NblockS][p_NfacesNfp];
    shared dfloat s_UP[p_NblockS][p_NfacesNfp];
    shared dfloat s_VP[p_NblockS][p_NfacesNfp];

    shared dfloat s_UdM[p_NblockS][p_NfacesNfp];
    shared dfloat s_VdM[p_NblockS][p_NfacesNfp];
    shared dfloat s_UdP[p_NblockS][p_NfacesNfp];
    shared dfloat s_VdP[p_NblockS][p_NfacesNfp];

    shared dfloat s_iFluxU[p_NblockS][p_intNfpNfaces];
    shared dfloat s_iFluxV[p_NblockS][p_intNfpNfaces];

    // for all face nodes of all elements
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_Np;++n;inner0){
        const int e = eo + es;

        if(e<Nelements){
          for(int m=n;m<p_Nfaces*p_Nfp;m+=p_Np){
            // indices of negative and positive traces of face node
            const int id  = e*p_Nfp*p_Nfaces + m;

            const int idM = vmapM[id];
            const int idP = vmapP[id];

            // load negative and positive trace node values of velocity
            s_UM[es][m] = U[idM];
            s_VM[es][m] = V[idM];
            s_UP[es][m] = U[idP];
            s_VP[es][m] = V[idP];

            s_UdM[es][m] = Ud[idM];
            s_VdM[es][m] = Vd[idM];
            s_UdP[es][m] = Ud[idP];
            s_VdP[es][m] = Vd[idP];
          }
        }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_Np;++n;inner0){
        const int e = eo + es;

        if(e<Nelements){
          for(int m=n;m<p_Nfaces*p_intNfp;m+=p_Np){
            const int face = m/p_intNfp; // find face that owns this integration node

            // load surface geofactors for this face
            const int sid    = p_Nsgeo*(e*p_Nfaces+face);
            const dfloat nx   = sgeo[sid+p_NXID];
            const dfloat ny   = sgeo[sid+p_NYID];
            const dfloat sJ   = sgeo[sid+p_SJID];
            const dfloat invJ = sgeo[sid+p_IJID];

            dfloat iUM  = 0.f, iVM  = 0.f;
            dfloat iUP  = 0.f, iVP  = 0.f;
            dfloat iUdM = 0.f, iVdM = 0.f;
            dfloat iUdP = 0.f, iVdP = 0.f;

            // local block interpolation (face nodes to integration nodes)
            occaUnroll(p_Nfp)
              for(int k=0;k<p_Nfp;++k){
                const dfloat iInm = intInterpT[m+k*p_Nfaces*p_intNfp];
                const int fm = face*p_Nfp+k;

                iUM  += iInm*s_UM[es][fm];
                iVM  += iInm*s_VM[es][fm];
                iUdM += iInm*s_UdM[es][fm];
                iVdM += iInm*s_VdM[es][fm];

                iUP  += iInm*s_UP[es][fm];
                iVP  += iInm*s_VP[es][fm];
                iUdP += iInm*s_UdP[es][fm];
                iVdP += iInm*s_VdP[es][fm];
              }

            // apply boundary conditions
            const int bc = EToB[face+p_Nfaces*e];
            if(bc>0){
              insAdvectionBoundaryConditions2D(bc,time, intx[m+e*p_Nfaces*p_intNfp], inty[m+e*p_Nfaces*p_intNfp], nx, ny, iUdM,iVdM, &iUdP, &iVdP);
            }

            // Find max normal velocity on the face
            const dfloat unm   = occaFabs(nx*iUM + ny*iVM);
            const dfloat unp   = occaFabs(nx*iUP + ny*iVP);
            const dfloat unmax = (unm > unp) ? unm : unp;

            // evaluate "flux" terms: LLF
            const dfloat sc = 0.5f*invJ*sJ ;

            s_iFluxU[es][m] = sc*(nx*(iUP*iUdP + iUM*iUdM)
                             +ny*(iVP*iUdP + iVM*iUdM)
                             +unmax*(iUdM-iUdP));

            s_iFluxV[es][m] = sc*(nx*(iUP*iVdP + iUM*iVdM)
                            + ny*(iVP*iVdP + iVM*iVdM)
                            + unmax*(iVdM-iVdP));
          }
        }
      }
    }

    barrier(localMemFence);

    // lift from surface integration to volume nodes
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_Np;++n;inner0){
        const int e = eo + es;
        if(e<Nelements){
          const int id = n + p_Np*e;
          // prefetch volume rhs
          dfloat rhsu = rhsU[id];
          dfloat rhsv = rhsV[id];

          occaUnroll(p_intNfpNfaces)
            for(int m=0;m<p_intNfpNfaces;++m){
              const dfloat L = intLIFTT[n+m*p_Np];
              rhsu += L*s_iFluxU[es][m];
              rhsv += L*s_iFluxV[es][m];
            }

          rhsU[id] = rhsu;
          rhsV[id] = rhsv;
        }
      }
    }
  }
}

//shared geofacts
kernel void insSubCycleCubatureSurface2D_v6(const int Nelements,
                                            const dfloat * restrict sgeo,
                                            const dfloat * restrict intInterpT, // interpolate to integration nodes
                                            const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
                                            const int   * restrict vmapM,
                                            const int   * restrict vmapP,
                                            const int   * restrict EToB,
                                            const dfloat time,
                                            const dfloat * restrict intx, // integration nodes
                                            const dfloat * restrict inty,
                                            const dfloat * restrict U,
                                            const dfloat * restrict V,
                                            const dfloat * restrict Ud,
                                            const dfloat * restrict Vd,
                                            dfloat * restrict rhsU,
                                            dfloat * restrict rhsV){
  // for all elements
  for(int eo=0;eo<Nelements;eo+=p_NblockS;outer0){

    // shared storage for flux terms
    shared dfloat s_UM[p_NblockS][p_NfacesNfp];
    shared dfloat s_VM[p_NblockS][p_NfacesNfp];
    shared dfloat s_UP[p_NblockS][p_NfacesNfp];
    shared dfloat s_VP[p_NblockS][p_NfacesNfp];

    shared dfloat s_UdM[p_NblockS][p_NfacesNfp];
    shared dfloat s_VdM[p_NblockS][p_NfacesNfp];
    shared dfloat s_UdP[p_NblockS][p_NfacesNfp];
    shared dfloat s_VdP[p_NblockS][p_NfacesNfp];

    shared dfloat s_iFluxU[p_NblockS][p_intNfpNfaces];
    shared dfloat s_iFluxV[p_NblockS][p_intNfpNfaces];

    shared dfloat s_sgeo[p_NblockS][p_Nfaces][p_Nsgeo];

    for (int es=0;es<p_NblockS;++es;inner1){
      for (int n=0;n<p_Np;++n;inner0) { //all faces*facenodes on this element
        int k = n + p_Np*es;
        while(k<p_NblockS*p_Nfaces*p_Nsgeo){
          const int id = eo*p_Nfaces*p_Nsgeo + k;
          s_sgeo[0][0][k] = sgeo[id];
          k+=p_Np*p_NblockS;
        }

        const int e = eo + es;

        if(e<Nelements){
          for(int m=n;m<p_Nfaces*p_Nfp;m+=p_Np){
            // indices of negative and positive traces of face node
            const int id  = e*p_Nfp*p_Nfaces + m;

            const int idM = vmapM[id];
            const int idP = vmapP[id];

            // load negative and positive trace node values of velocity
            s_UM[es][m] = U[idM];
            s_VM[es][m] = V[idM];
            s_UP[es][m] = U[idP];
            s_VP[es][m] = V[idP];

            s_UdM[es][m] = Ud[idM];
            s_VdM[es][m] = Vd[idM];
            s_UdP[es][m] = Ud[idP];
            s_VdP[es][m] = Vd[idP];
          }
        }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_Np;++n;inner0){
        const int e = eo + es;

        if(e<Nelements){
          for(int m=n;m<p_Nfaces*p_intNfp;m+=p_Np){
            const int face = m/p_intNfp; // find face that owns this integration node

            // load surface geofactors for this face
            const dfloat nx   = s_sgeo[es][face][p_NXID];
            const dfloat ny   = s_sgeo[es][face][p_NYID];
            const dfloat sJ   = s_sgeo[es][face][p_SJID];
            const dfloat invJ = s_sgeo[es][face][p_IJID];

            dfloat iUM  = 0.f, iVM  = 0.f;
            dfloat iUP  = 0.f, iVP  = 0.f;
            dfloat iUdM = 0.f, iVdM = 0.f;
            dfloat iUdP = 0.f, iVdP = 0.f;

            // local block interpolation (face nodes to integration nodes)
            occaUnroll(p_Nfp)
              for(int k=0;k<p_Nfp;++k){
                const dfloat iInm = intInterpT[m+k*p_Nfaces*p_intNfp];
                const int fm = face*p_Nfp+k;

                iUM  += iInm*s_UM[es][fm];
                iVM  += iInm*s_VM[es][fm];
                iUdM += iInm*s_UdM[es][fm];
                iVdM += iInm*s_VdM[es][fm];

                iUP  += iInm*s_UP[es][fm];
                iVP  += iInm*s_VP[es][fm];
                iUdP += iInm*s_UdP[es][fm];
                iVdP += iInm*s_VdP[es][fm];
              }

            // apply boundary conditions
            const int bc = EToB[face+p_Nfaces*e];
            if(bc>0){
              insAdvectionBoundaryConditions2D(bc,time, intx[m+e*p_Nfaces*p_intNfp], inty[m+e*p_Nfaces*p_intNfp], nx, ny, iUdM,iVdM, &iUdP, &iVdP);
            }

            // Find max normal velocity on the face
            const dfloat unm   = occaFabs(nx*iUM + ny*iVM);
            const dfloat unp   = occaFabs(nx*iUP + ny*iVP);
            const dfloat unmax = (unm > unp) ? unm : unp;

            // evaluate "flux" terms: LLF
            const dfloat sc = 0.5f*invJ*sJ ;

            s_iFluxU[es][m] = sc*(nx*(iUP*iUdP + iUM*iUdM)
                             +ny*(iVP*iUdP + iVM*iUdM)
                             +unmax*(iUdM-iUdP));

            s_iFluxV[es][m] = sc*(nx*(iUP*iVdP + iUM*iVdM)
                            + ny*(iVP*iVdP + iVM*iVdM)
                            + unmax*(iVdM-iVdP));
          }
        }
      }
    }

    barrier(localMemFence);

    // lift from surface integration to volume nodes
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_Np;++n;inner0){
        const int e = eo + es;
        if(e<Nelements){
          const int id = n + p_Np*e;
          // prefetch volume rhs
          dfloat rhsu = rhsU[id];
          dfloat rhsv = rhsV[id];

          occaUnroll(p_intNfpNfaces)
            for(int m=0;m<p_intNfpNfaces;++m){
              const dfloat L = intLIFTT[n+m*p_Np];
              rhsu += L*s_iFluxU[es][m];
              rhsv += L*s_iFluxV[es][m];
            }

          rhsU[id] = rhsu;
          rhsV[id] = rhsv;
        }
      }
    }
  }
}

// multiple elements per node
kernel void insSubCycleCubatureSurface2D_v7(const int Nelements,
                                            const dfloat * restrict sgeo,
                                            const dfloat * restrict intInterpT, // interpolate to integration nodes
                                            const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
                                            const int   * restrict vmapM,
                                            const int   * restrict vmapP,
                                            const int   * restrict EToB,
                                            const dfloat time,
                                            const dfloat * restrict intx, // integration nodes
                                            const dfloat * restrict inty,
                                            const dfloat * restrict U,
                                            const dfloat * restrict V,
                                            const dfloat * restrict Ud,
                                            const dfloat * restrict Vd,
                                            dfloat * restrict rhsU,
                                            dfloat * restrict rhsV){
  // for all elements
  for(int eo=0;eo<Nelements;eo+=p_NblockS*p_Nnodes;outer0){

    // shared storage for flux terms
    shared dfloat s_UM[p_Nnodes][p_NblockS][p_NfacesNfp];
    shared dfloat s_VM[p_Nnodes][p_NblockS][p_NfacesNfp];
    shared dfloat s_UP[p_Nnodes][p_NblockS][p_NfacesNfp];
    shared dfloat s_VP[p_Nnodes][p_NblockS][p_NfacesNfp];

    shared dfloat s_UdM[p_Nnodes][p_NblockS][p_NfacesNfp];
    shared dfloat s_VdM[p_Nnodes][p_NblockS][p_NfacesNfp];
    shared dfloat s_UdP[p_Nnodes][p_NblockS][p_NfacesNfp];
    shared dfloat s_VdP[p_Nnodes][p_NblockS][p_NfacesNfp];

    shared dfloat s_iFluxU[p_Nnodes][p_NblockS][p_intNfpNfaces];
    shared dfloat s_iFluxV[p_Nnodes][p_NblockS][p_intNfpNfaces];

    shared dfloat s_sgeo[p_Nnodes][p_NblockS][p_Nfaces][p_Nsgeo];

    for (int es=0;es<p_NblockS;++es;inner1){
      for (int n=0;n<p_Np;++n;inner0) { //all faces*facenodes on this element
        int m = n + p_Np*es;
        while(m<p_Nnodes*p_NblockS*p_Nfaces*p_Nsgeo){
          const int id = eo*p_Nfaces*p_Nsgeo + m;
          s_sgeo[0][0][0][m] = sgeo[id];
          m+=p_Np*p_NblockS;
        }

        occaUnroll(p_Nnodes)
        for (int et=0;et<p_Nnodes;++et){
          const int e = et*p_NblockS + es + eo;
          if(e<Nelements){
            for(int m=n;m<p_Nfaces*p_Nfp;m+=p_Np){
              // indices of negative and positive traces of face node
              const int id  = e*p_Nfp*p_Nfaces + m;

              const int idM = vmapM[id];
              const int idP = vmapP[id];

              // load negative and positive trace node values of velocity
              s_UM[et][es][m] = U[idM];
              s_VM[et][es][m] = V[idM];
              s_UP[et][es][m] = U[idP];
              s_VP[et][es][m] = V[idP];

              s_UdM[et][es][m] = Ud[idM];
              s_VdM[et][es][m] = Vd[idM];
              s_UdP[et][es][m] = Ud[idP];
              s_VdP[et][es][m] = Vd[idP];
            }
          }
        }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_Np;++n;inner0){

        dfloat iUM [p_Nnodes], iVM [p_Nnodes];
        dfloat iUP [p_Nnodes], iVP [p_Nnodes];
        dfloat iUdM[p_Nnodes], iVdM[p_Nnodes];
        dfloat iUdP[p_Nnodes], iVdP[p_Nnodes];

        for(int m=n;m<p_Nfaces*p_intNfp;m+=p_Np){

          occaUnroll(p_Nnodes)
          for (int et=0;et<p_Nnodes;++et){
            iUM [et] = 0.f, iVM [et] = 0.f;
            iUP [et] = 0.f, iVP [et] = 0.f;
            iUdM[et] = 0.f, iVdM[et] = 0.f;
            iUdP[et] = 0.f, iVdP[et] = 0.f;
          }

          const int face = m/p_intNfp; // find face that owns this integration node
          // local block interpolation (face nodes to integration nodes)
          occaUnroll(p_Nfp)
            for(int k=0;k<p_Nfp;++k){
              const dfloat iInm = intInterpT[m+k*p_Nfaces*p_intNfp];
              const int fm = face*p_Nfp+k;

              occaUnroll(p_Nnodes)
              for (int et=0;et<p_Nnodes;++et){

                iUM [et] += iInm* s_UM[et][es][fm];
                iVM [et] += iInm* s_VM[et][es][fm];
                iUdM[et] += iInm*s_UdM[et][es][fm];
                iVdM[et] += iInm*s_VdM[et][es][fm];

                iUP [et] += iInm* s_UP[et][es][fm];
                iVP [et] += iInm* s_VP[et][es][fm];
                iUdP[et] += iInm*s_UdP[et][es][fm];
                iVdP[et] += iInm*s_VdP[et][es][fm];
              }
            }

          occaUnroll(p_Nnodes)
          for (int et=0;et<p_Nnodes;++et){
            const int e = et*p_NblockS + es + eo;
            if (e<Nelements) {
              // load surface geofactors for this face
              const dfloat nx   = s_sgeo[et][es][face][p_NXID];
              const dfloat ny   = s_sgeo[et][es][face][p_NYID];
              const dfloat sJ   = s_sgeo[et][es][face][p_SJID];
              const dfloat invJ = s_sgeo[et][es][face][p_IJID];

              // apply boundary conditions
              const int bc = EToB[face+p_Nfaces*e];
              if(bc>0){
                insAdvectionBoundaryConditions2D(bc,time, intx[m+e*p_Nfaces*p_intNfp], inty[m+e*p_Nfaces*p_intNfp], nx, ny, iUdM[et],iVdM[et], &(iUdP[et]), &(iVdP[et]));
              }

              // Find max normal velocity on the face
              const dfloat unm   = occaFabs(nx*iUM[et]+ ny*iVM[et]);
              const dfloat unp   = occaFabs(nx*iUP[et]+ ny*iVP[et]);
              const dfloat unmax = (unm > unp) ? unm : unp;

              // evaluate "flux" terms: LLF
              const dfloat sc = 0.5f*invJ*sJ ;

              s_iFluxU[et][es][m] = sc*(nx*(iUP[et]*iUdP[et] + iUM[et]*iUdM[et])
                                   +ny*(iVP[et]*iUdP[et] + iVM[et]*iUdM[et])
                                   +unmax*(iUdM[et]-iUdP[et]));

              s_iFluxV[et][es][m] = sc*(nx*(iUP[et]*iVdP[et] + iUM[et]*iVdM[et])
                                  + ny*(iVP[et]*iVdP[et] + iVM[et]*iVdM[et])
                                  + unmax*(iVdM[et]-iVdP[et]));
            }
          }
        }
      }
    }

    barrier(localMemFence);

    // lift from surface integration to volume nodes
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_Np;++n;inner0){

        dfloat rhsu[p_Nnodes];
        dfloat rhsv[p_Nnodes];

        occaUnroll(p_Nnodes)
        for (int et=0;et<p_Nnodes;++et){
          rhsu[et] = 0;
          rhsv[et] = 0;
        }

        occaUnroll(p_intNfpNfaces)
          for(int m=0;m<p_intNfpNfaces;++m){
            const dfloat L = intLIFTT[n+m*p_Np];
            occaUnroll(p_Nnodes)
            for (int et=0;et<p_Nnodes;++et){
              rhsu[et] += L*s_iFluxU[et][es][m];
              rhsv[et] += L*s_iFluxV[et][es][m];
            }
          }

        occaUnroll(p_Nnodes)
        for (int et=0;et<p_Nnodes;++et){
          const int e = et*p_NblockS + es + eo;
          if(e<Nelements){
            const int id = n + p_Np*e;
            rhsU[id] += rhsu[et];
            rhsV[id] += rhsv[et];
          }
        }
      }
    }
  }
}

// interp in shared
kernel void insSubCycleCubatureSurface2D_v8(const int Nelements,
                                            const dfloat * restrict sgeo,
                                            const dfloat * restrict intInterpT, // interpolate to integration nodes
                                            const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
                                            const int   * restrict vmapM,
                                            const int   * restrict vmapP,
                                            const int   * restrict EToB,
                                            const dfloat time,
                                            const dfloat * restrict intx, // integration nodes
                                            const dfloat * restrict inty,
                                            const dfloat * restrict U,
                                            const dfloat * restrict V,
                                            const dfloat * restrict Ud,
                                            const dfloat * restrict Vd,
                                            dfloat * restrict rhsU,
                                            dfloat * restrict rhsV){
  // for all elements
  for(int eo=0;eo<Nelements;eo+=p_NblockS*p_Nnodes;outer0){

    // shared storage for flux terms
    shared dfloat s_UM[p_Nnodes][p_NblockS][p_NfacesNfp];
    shared dfloat s_VM[p_Nnodes][p_NblockS][p_NfacesNfp];
    shared dfloat s_UP[p_Nnodes][p_NblockS][p_NfacesNfp];
    shared dfloat s_VP[p_Nnodes][p_NblockS][p_NfacesNfp];

    shared dfloat s_UdM[p_Nnodes][p_NblockS][p_NfacesNfp];
    shared dfloat s_VdM[p_Nnodes][p_NblockS][p_NfacesNfp];
    shared dfloat s_UdP[p_Nnodes][p_NblockS][p_NfacesNfp];
    shared dfloat s_VdP[p_Nnodes][p_NblockS][p_NfacesNfp];

    shared dfloat s_iFluxU[p_Nnodes][p_NblockS][p_intNfpNfaces];
    shared dfloat s_iFluxV[p_Nnodes][p_NblockS][p_intNfpNfaces];

    shared dfloat s_sgeo[p_Nnodes][p_NblockS][p_Nfaces][p_Nsgeo];
    shared dfloat s_intInterpT[p_Nfaces*p_intNfp*p_Nfp];


    for (int es=0;es<p_NblockS;++es;inner1){
      for (int n=0;n<p_Np;++n;inner0) { //all faces*facenodes on this element
        int m = n + p_Np*es;
        while(m<p_Nnodes*p_NblockS*p_Nfaces*p_Nsgeo){
          const int id = eo*p_Nfaces*p_Nsgeo + m;
          s_sgeo[0][0][0][m] = sgeo[id];
          m+=p_Np*p_NblockS;
        }

        if (es==0) {
          for(int m=n;m<p_Nfaces*p_Nfp*p_Nfp;m+=p_Np){
            s_intInterpT[m] = intInterpT[m];
          }
        }

        occaUnroll(p_Nnodes)
        for (int et=0;et<p_Nnodes;++et){
          const int e = et*p_NblockS + es + eo;
          if(e<Nelements){
            for(int m=n;m<p_Nfaces*p_Nfp;m+=p_Np){
              // indices of negative and positive traces of face node
              const int id  = e*p_Nfp*p_Nfaces + m;

              const int idM = vmapM[id];
              const int idP = vmapP[id];

              // load negative and positive trace node values of velocity
              s_UM[et][es][m] = U[idM];
              s_VM[et][es][m] = V[idM];
              s_UP[et][es][m] = U[idP];
              s_VP[et][es][m] = V[idP];

              s_UdM[et][es][m] = Ud[idM];
              s_VdM[et][es][m] = Vd[idM];
              s_UdP[et][es][m] = Ud[idP];
              s_VdP[et][es][m] = Vd[idP];
            }
          }
        }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_Np;++n;inner0){

        dfloat iUM [p_Nnodes], iVM [p_Nnodes];
        dfloat iUP [p_Nnodes], iVP [p_Nnodes];
        dfloat iUdM[p_Nnodes], iVdM[p_Nnodes];
        dfloat iUdP[p_Nnodes], iVdP[p_Nnodes];

        for(int m=n;m<p_Nfaces*p_intNfp;m+=p_Np){

          occaUnroll(p_Nnodes)
          for (int et=0;et<p_Nnodes;++et){
            iUM [et] = 0.f, iVM [et] = 0.f;
            iUP [et] = 0.f, iVP [et] = 0.f;
            iUdM[et] = 0.f, iVdM[et] = 0.f;
            iUdP[et] = 0.f, iVdP[et] = 0.f;
          }

          const int face = m/p_intNfp; // find face that owns this integration node
          // local block interpolation (face nodes to integration nodes)
          occaUnroll(p_Nfp)
            for(int k=0;k<p_Nfp;++k){
              const dfloat iInm = s_intInterpT[m+k*p_Nfaces*p_intNfp];
              const int fm = face*p_Nfp+k;

              occaUnroll(p_Nnodes)
              for (int et=0;et<p_Nnodes;++et){

                iUM [et] += iInm* s_UM[et][es][fm];
                iVM [et] += iInm* s_VM[et][es][fm];
                iUdM[et] += iInm*s_UdM[et][es][fm];
                iVdM[et] += iInm*s_VdM[et][es][fm];

                iUP [et] += iInm* s_UP[et][es][fm];
                iVP [et] += iInm* s_VP[et][es][fm];
                iUdP[et] += iInm*s_UdP[et][es][fm];
                iVdP[et] += iInm*s_VdP[et][es][fm];
              }
            }

          occaUnroll(p_Nnodes)
          for (int et=0;et<p_Nnodes;++et){
            const int e = et*p_NblockS + es + eo;
            if (e<Nelements) {
              // load surface geofactors for this face
              const dfloat nx   = s_sgeo[et][es][face][p_NXID];
              const dfloat ny   = s_sgeo[et][es][face][p_NYID];
              const dfloat sJ   = s_sgeo[et][es][face][p_SJID];
              const dfloat invJ = s_sgeo[et][es][face][p_IJID];

              // apply boundary conditions
              const int bc = EToB[face+p_Nfaces*e];
              if(bc>0){
                insAdvectionBoundaryConditions2D(bc,time, intx[m+e*p_Nfaces*p_intNfp], inty[m+e*p_Nfaces*p_intNfp], nx, ny, iUdM[et],iVdM[et], &(iUdP[et]), &(iVdP[et]));
              }

              // Find max normal velocity on the face
              const dfloat unm   = occaFabs(nx*iUM[et]+ ny*iVM[et]);
              const dfloat unp   = occaFabs(nx*iUP[et]+ ny*iVP[et]);
              const dfloat unmax = (unm > unp) ? unm : unp;

              // evaluate "flux" terms: LLF
              const dfloat sc = 0.5f*invJ*sJ ;

              s_iFluxU[et][es][m] = sc*(nx*(iUP[et]*iUdP[et] + iUM[et]*iUdM[et])
                                   +ny*(iVP[et]*iUdP[et] + iVM[et]*iUdM[et])
                                   +unmax*(iUdM[et]-iUdP[et]));

              s_iFluxV[et][es][m] = sc*(nx*(iUP[et]*iVdP[et] + iUM[et]*iVdM[et])
                                  + ny*(iVP[et]*iVdP[et] + iVM[et]*iVdM[et])
                                  + unmax*(iVdM[et]-iVdP[et]));
            }
          }
        }
      }
    }

    barrier(localMemFence);

    // lift from surface integration to volume nodes
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_Np;++n;inner0){

        dfloat rhsu[p_Nnodes];
        dfloat rhsv[p_Nnodes];

        occaUnroll(p_Nnodes)
        for (int et=0;et<p_Nnodes;++et){
          rhsu[et] = 0;
          rhsv[et] = 0;
        }

        occaUnroll(p_intNfpNfaces)
          for(int m=0;m<p_intNfpNfaces;++m){
            const dfloat L = intLIFTT[n+m*p_Np];
            occaUnroll(p_Nnodes)
            for (int et=0;et<p_Nnodes;++et){
              rhsu[et] += L*s_iFluxU[et][es][m];
              rhsv[et] += L*s_iFluxV[et][es][m];
            }
          }

        occaUnroll(p_Nnodes)
        for (int et=0;et<p_Nnodes;++et){
          const int e = et*p_NblockS + es + eo;
          if(e<Nelements){
            const int id = n + p_Np*e;
            rhsU[id] += rhsu[et];
            rhsV[id] += rhsv[et];
          }
        }
      }
    }
  }
}

// Based on v4. Assume trace buffers are pre-built
kernel void insSubCycleCubatureSurface2D_v2(const int Nelements,
                                            const dfloat * restrict sgeo,
                                            const dfloat * restrict intInterpT, // interpolate to integration nodes
                                            const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
                                            const int   * restrict vmapM,
                                            const int   * restrict vmapP,
                                            const int   * restrict EToB,
                                            const dfloat time,
                                            const dfloat * restrict intx, // integration nodes
                                            const dfloat * restrict inty,
                                            const dfloat * restrict fU,
                                            const dfloat * restrict fV,
                                            const dfloat * restrict fUd,
                                            const dfloat * restrict fVd,
                                            dfloat * restrict rhsU,
                                            dfloat * restrict rhsV){
  // for all elements
  for(int eo=0;eo<Nelements;eo+=p_NblockS;outer0){

    shared dfloat s_iFluxU[p_NblockS][p_intNfpNfaces];
    shared dfloat s_iFluxV[p_NblockS][p_intNfpNfaces];

    // get surface integration nodes and compute flux
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        const int e = eo + es;
        if(e<Nelements){
          if(n<(p_Nfaces*p_intNfp)){

            const int face = n/p_intNfp; // find face that owns this integration node

            // load surface geofactors for this face
            const int sid    = p_Nsgeo*(e*p_Nfaces+face);
            const dfloat nx   = sgeo[sid+p_NXID];
            const dfloat ny   = sgeo[sid+p_NYID];
            const dfloat sJ   = sgeo[sid+p_SJID];
            const dfloat invJ = sgeo[sid+p_IJID];

            const int idM  = e*p_intNfp*p_Nfaces + n;
            const int idP  = idM;

            const dfloat iUM  = fU[idM];
            const dfloat iUP  = fU[idP];
            const dfloat iUdM = fUd[idM];
            const dfloat iUdP = fUd[idP];

            const dfloat iVM  = fV[idM];
            const dfloat iVP  = fV[idP];
            const dfloat iVdM = fVd[idM];
            const dfloat iVdP = fVd[idP];

            // apply boundary conditions
            const int bc = EToB[face+p_Nfaces*e];
            //if(bc>0){
            //  insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, iUdM,iVdM, &iUdP, &iVdP);
            //}

            // Find max normal velocity on the face
            const dfloat unm   = occaFabs(nx*iUM + ny*iVM);
            const dfloat unp   = occaFabs(nx*iUP + ny*iVP);
            const dfloat unmax = (unm > unp) ? unm : unp;

            // evaluate "flux" terms: LLF
            const dfloat sc = 0.5f*invJ*sJ ;

            s_iFluxU[es][n] = sc*(nx*(iUP*iUdP + iUM*iUdM)
                             +ny*(iVP*iUdP + iVM*iUdM)
                             +unmax*(iUdM-iUdP));

            s_iFluxV[es][n] = sc*(nx*(iUP*iVdP + iUM*iVdM)
                            + ny*(iVP*iVdP + iVM*iVdM)
                            + unmax*(iVdM-iVdP));
          }
        }
      }
    }

    barrier(localMemFence);

    // lift from surface integration to volume nodes
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        const int e = eo + es;
        if(e<Nelements){
          if(n<p_Np){
            const int id = n + p_Np*e;
            // prefetch volume rhs
            dfloat rhsu = rhsU[id];
            dfloat rhsv = rhsV[id];

            occaUnroll(p_intNfpNfaces)
              for(int m=0;m<p_intNfpNfaces;++m){
                const dfloat L = intLIFTT[n+m*p_Np];
                rhsu += L*s_iFluxU[es][m];
                rhsv += L*s_iFluxV[es][m];
              }

            rhsU[id] = rhsu;
            rhsV[id] = rhsv;
          }
        }
      }
    }
  }
}
*/
