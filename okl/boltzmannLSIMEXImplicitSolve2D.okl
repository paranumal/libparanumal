
#define DENSITY_SHIFT 0


@kernel void boltzmannLSIMEXImplicitSolve2D(const int Nelements,
                           @restrict const  int *  elementIds,
                           const dfloat dt, 
                           const dfloat akk,
                           @restrict const  dfloat  *  cubInterpT,
                           @restrict const  dfloat  *  cubProjectT,
                           @restrict const  dfloat *  qex,
                                 @restrict dfloat *  qim){

for(int es=0;es<Nelements;++es;@outer(0)){
    for(int n=0;n<p_Np;++n;@inner(0)){

    const int e = elementIds[es];
    const int id = p_Nfields*(e*p_Np + n);

    dfloat N4=0.0,  N5 = 0.0,  N6=0.0;

    dfloat qex1 = qex[id+0];
    dfloat qex2 = qex[id+1];
    dfloat qex3 = qex[id+2];
    dfloat qex4 = qex[id+3];
    dfloat qex5 = qex[id+4];
    dfloat qex6 = qex[id+5];       

    // First iteration, Qim = Qex; 
    dfloat qim4 = qex4;
    dfloat qim5 = qex5;
    dfloat qim6 = qex6; 
   
    dfloat  iqex1 = 1.f/qex1;
    // Hold the constant part of nonlinear function
    dfloat N4c = -(qex2*qex3*iqex1 );
    dfloat N5c = -p_invsqrt2*( qex2*qex2*iqex1 );
    dfloat N6c = -p_invsqrt2*( qex3*qex3*iqex1 );
      //         
      if(akk>0){ // No need to solve, just update
        dfloat cc  = akk * dt * p_tauInv;
        dfloat icc = 1.0f/(cc+1.0f); 
        //N(Y)
        N4 = -cc*( qim4 + N4c);
        N5 = -cc*( qim5 + N5c);
        N6 = -cc*( qim6 + N6c);
        // z0 = y + akk*dt*N(Y);
        qim4 = qex4 +  N4 ;
        qim5 = qex5 +  N5 ;
        qim6 = qex6 +  N6 ;
        // N(z0)
        N4 = -cc*( qim4 + N4c);
        N5 = -cc*( qim5 + N5c);
        N6 = -cc*( qim6 + N6c);
        //Update Qim = Qim + (I-akk*dt*del(N)/del(Qim) )^-1 * ( Qex-Qim + N(Qim) )
        // Qim += icc*(y-z+akk*dt*N(z0) )
        qim4 += (qex4 - qim4  + N4)*icc;
        qim5 += (qex5 - qim5  + N5)*icc;
        qim6 += (qex6 - qim6  + N6)*icc;
    }

    N4 = -p_tauInv*( qim4 + N4c );
    N5 = -p_tauInv*( qim5 + N5c );
    N6 = -p_tauInv*( qim6 + N6c );
    
    // do not update q1 ,q2 ,q3 
    qim[id+0] =  0. ;
    qim[id+1] =  0. ;
    qim[id+2] =  0. ;  
    qim[id+3] =  N4 ;
    qim[id+4] =  N5 ;
    qim[id+5] =  N6 ;  
    
    }
}
  

}


@kernel void boltzmannLSIMEXImplicitSolveCub2D(const int Nelements,
                          @restrict const  int *  elementIds,
                          const dfloat dt, 
                          const dfloat akk,
                          @restrict const  dfloat *  cubInterpT,
                          @restrict const  dfloat *  cubProjectT,
                          @restrict const  dfloat *  qe,
                                @restrict dfloat *  q){ 

  for(int eo=0;eo<Nelements;eo+=p_NblockCub;@outer(0)){  // for all elements

    // @shared memory for q at nodes
    @shared dfloat s_qE[p_NblockCub][p_Nfields][p_Np];
    // sub-group of p_Np cubature node interpolants of N4,N5,N6
    @shared dfloat s_cubN4[p_NblockCub][p_cubNp];
    @shared dfloat s_cubN5[p_NblockCub][p_cubNp];
    @shared dfloat s_cubN6[p_NblockCub][p_cubNp];

    @exclusive int   e;  
    //
    @exclusive dfloat N4c, N5c, N6c;
    //
    @exclusive dfloat qim4 =0.f, qim5 = 0.f, qim6=0.f ;  
    @exclusive dfloat qex4 =0.f, qex5 = 0.f, qex6=0.f ; 

    // prefetch q to @shared
    for(int es=0;es<p_NblockCub;++es;@inner(1)){
      for(int n=0;n<p_maxCubNodes;++n;@inner(0)){    
       int et = eo+es; // element in block
        if(et<Nelements){
        e = elementIds[et];
          if(n<p_Np){   
            const int id = p_Nfields*(e*p_Np + n);
            for(int fld=0; fld<p_Nfields;++fld){
             s_qE[es][fld][n] = qe[id+fld];
            } 
          } 
        }
       }
     }
    
    // make sure all node data is loaded into @shared
    @barrier("local");

    // interpolate q to cubature
    for(int es=0;es<p_NblockCub;++es;@inner(1)){
      for(int n=0;n<p_maxCubNodes;++n;@inner(0)){

        int et = eo+es; // element in block
        if(et<Nelements){
          if(n<p_cubNp){
            dfloat qe1=0.f , qe2 =0.f , qe3 =0.f ;
            dfloat qe4=0.f , qe5 =0.f , qe6 =0.f ;

            #pragma unroll p_Np
            for(int m=0;m<p_Np;++m){

              const dfloat Icn  = cubInterpT[m*p_cubNp+n];
              //
              qe1 += Icn*s_qE[es][0][m];
              qe2 += Icn*s_qE[es][1][m];
              qe3 += Icn*s_qE[es][2][m];
              qe4 += Icn*s_qE[es][3][m];
              qe5 += Icn*s_qE[es][4][m];
              qe6 += Icn*s_qE[es][5][m];
            }
        
        dfloat  iqe1 = 1.f/qe1;
   
        // Hold the constant part of nonlinear function
         N4c = -(qe2*qe3*iqe1 );
         N5c = -p_invsqrt2*( qe2*qe2*iqe1 );
         N6c = -p_invsqrt2*( qe3*qe3*iqe1 );      
         //
         qex4 = qe4;
         qex5 = qe5;
         qex6 = qe6;
         //
         qim4 = qe4;
         qim5 = qe5;
         qim6 = qe6; 

        }
     }
    }
  }

    // make sure all node data is loaded into @shared
    @barrier("local");  
      // partial projection to nodes from cubature-sub-group
    for(int es=0;es<p_NblockCub;++es;@inner(1)){
    for(int n=0;n<p_maxCubNodes;++n;@inner(0)){
      int et = eo+es; // element in block
      if(et<Nelements){
        if(n<p_cubNp){
          if(akk>0){    
            dfloat cc  = akk * dt * p_tauInv;
            dfloat icc = 1.0f/(cc+1.0f); 
            //N(Y)
            dfloat N4 = -cc*( qim4 + N4c);
            dfloat N5 = -cc*( qim5 + N5c);
            dfloat N6 = -cc*( qim6 + N6c);
            // z0 = y + akk*dt*N(Y);
            qim4 = qex4 +  N4 ;
            qim5 = qex5 +  N5 ;
            qim6 = qex6 +  N6 ;

            // akk*dt*N(z0)
            N4 = -cc*( qim4 + N4c);
            N5 = -cc*( qim5 + N5c);
            N6 = -cc*( qim6 + N6c);
            //Update Qim = Qim + (I-akk*dt*del(N)/del(Qim) )^-1 * ( Qex-Qim + N(Qim) )
            // Qim += icc*(y-z+akk*dt*N(z0) )
            qim4 += (qex4 - qim4  + N4)*icc;
            qim5 += (qex5 - qim5  + N5)*icc;
            qim6 += (qex6 - qim6  + N6)*icc;
            }
            // BGK relaxation approximation to the Boltzmann collision operator
            s_cubN4[es][n] = -p_tauInv*(qim4 + N4c);
            s_cubN5[es][n] = -p_tauInv*(qim5 + N5c);
            s_cubN6[es][n] = -p_tauInv*(qim6 + N6c);
        }
      }
    }
      }
      
      // make sure all cubature node data is loaded into @shared
    @barrier("local");
      
      // partial projection to nodes from cubature-sub-group
  for(int es=0;es<p_NblockCub;++es;@inner(1)){
    for(int n=0;n<p_maxCubNodes;++n;@inner(0)){
      int et = eo+es; // element in block
      if(et<Nelements){
        if(n<p_Np){
      // use temporaries for part sums for N4,N5,N6 because of @exclusives
        dfloat N4 = 0.f, N5 = 0.f, N6 = 0.f;
        for(int i=0;i<p_cubNp;++i){
          const dfloat Pnc  = cubProjectT[i*p_Np+n];
          N4 += Pnc*s_cubN4[es][i];
          N5 += Pnc*s_cubN5[es][i];
          N6 += Pnc*s_cubN6[es][i];
        }

      const int id = p_Nfields*(e*p_Np + n);
                  
        // do not update q1 ,q2 ,q3 
        q[id+0] =  0. ;
        q[id+1] =  0. ;
        q[id+2] =  0. ;  
        q[id+3] =  N4 ;
        q[id+4] =  N5 ;
        q[id+5] =  N6 ;  
          
        }
      }
    }
      }
  }
}




@kernel void boltzmannLSIMEXPmlImplicitSolveCub2D(const int pmlNelements,
                                                  @restrict const  int *  pmlElementIds,
                                                  @restrict const  int *  pmlIds,
                                                  const dfloat dt, 
                                                  const dfloat akk,
                                                  @restrict const  dfloat *  cubInterpT,
                                                  @restrict const  dfloat *  cubProjectT,
                                                  @restrict const  dfloat *  pmlSigmaX,
                                                  @restrict const  dfloat *  pmlSigmaY, 
                                                  @restrict const  dfloat *  q,
                                                  @restrict const  dfloat *  pmlqx,
                                                  @restrict const  dfloat *  pmlqy,
                                                        @restrict dfloat *  rhsq,
                                                        @restrict dfloat *  rhsqx,
                                                        @restrict dfloat *  rhsqy,                                                           
                                                        @restrict dfloat *  qZ){ 

  for(int eo=0;eo<pmlNelements;eo+=p_NblockCub;@outer(0)){  // for all elements

    // @shared memory for q at nodes
    @shared dfloat s_q[p_NblockCub][p_Nfields][p_Np];
    @shared dfloat s_qx[p_NblockCub][p_Nfields][p_Np];
    @shared dfloat s_qy[p_NblockCub][p_Nfields][p_Np];
    // sub-group of p_Np cubature node interpolants of N4,N5,N6
    @shared dfloat s_cubN4[p_NblockCub][p_cubNp];
    @shared dfloat s_cubN5[p_NblockCub][p_cubNp];
    @shared dfloat s_cubN6[p_NblockCub][p_cubNp];

    @shared dfloat s_cubqx[p_NblockCub][p_Nfields][p_cubNp];
    @shared dfloat s_cubqy[p_NblockCub][p_Nfields][p_cubNp];

    @exclusive int   e, pmlId;  
  
    for(int es=0;es<p_NblockCub;++es;@inner(1)){
      for(int n=0;n<p_maxCubNodes;++n;@inner(0)){      
        int et = eo+es; // element in block
        if(et<pmlNelements){
            e     = pmlElementIds[et];
            pmlId = pmlIds[et];
            
            if(n<p_Np){
              const int id  = p_Nfields*(e*p_Np + n);
              const int pid = p_Nfields*(pmlId*p_Np + n);         
              #pragma unroll p_Nfields
              for(int fld=0; fld<p_Nfields;++fld){
                s_q[es][fld][n]   = q[id +fld];
                s_qx[es][fld][n]  = pmlqx[pid+fld];
                s_qy[es][fld][n]  = pmlqy[pid+fld];
              }
            }
         }
       }
    }
    
    // make sure all node data is loaded into @shared
    @barrier("local");

    // interpolate q to cubature
    for(int es=0;es<p_NblockCub;++es;@inner(1)){
      for(int n=0;n<p_maxCubNodes;++n;@inner(0)){
        int et = eo+es; // element in block
        if(et<pmlNelements){
          if(n<p_cubNp){
            dfloat r_q[p_Nfields];
            dfloat r_qx[p_Nfields];
            dfloat r_qy[p_Nfields];

            #pragma unroll p_Nfields
            for(int fld=0; fld<p_Nfields ; fld++){
              r_q[fld]  = 0.f;
              r_qx[fld] = 0.f;
              r_qy[fld] = 0.f;
            }

            #pragma unroll p_Np
            for(int m=0;m<p_Np;++m){
              const dfloat Icn  = cubInterpT[m*p_cubNp+n];   
              #pragma unroll p_Nfields
              for(int fld=0; fld<p_Nfields;++fld){
                r_q[fld]  += Icn*s_q[es][fld][m];
                r_qx[fld] += Icn*s_qx[es][fld][m];
                r_qy[fld] += Icn*s_qy[es][fld][m];
              }
            }

            // Prefetch sigma
            const dfloat sigmaxe = pmlSigmaX[pmlId*p_cubNp+n];
            const dfloat sigmaye = pmlSigmaY[pmlId*p_cubNp+n];

            const dfloat msigmaxe = sigmaxe + sigmaye*p_pmlAlpha;
            const dfloat msigmaye = sigmaye + sigmaxe*p_pmlAlpha;

            #pragma unroll p_Nfields
            for(int fld=0; fld<p_Nfields;++fld){       
             s_cubqx[es][fld][n] = -msigmaxe*r_qx[fld];
             s_cubqy[es][fld][n] = -msigmaye*r_qy[fld];
            }


            dfloat icubq1 = 1.f/r_q[0];

            // Hold the constant part of nonlinear function
            dfloat N4c = -           ( r_q[1]*r_q[2]*icubq1 );
            dfloat N5c = -p_invsqrt2*( r_q[1]*r_q[1]*icubq1 );
            dfloat N6c = -p_invsqrt2*( r_q[2]*r_q[2]*icubq1 );      
            //
            dfloat qex4 = r_q[3];
            dfloat qex5 = r_q[4];
            dfloat qex6 = r_q[5];         
            // Initialize implicit sol
            dfloat qim4 = qex4;
            dfloat qim5 = qex5;
            dfloat qim6 = qex6; 
            //
            if(akk>0){    
              dfloat cc  = akk * dt * p_tauInv;
              dfloat icc = 1.0f/(cc+1.0f); 
              //N(Y)
              dfloat N4 = -cc*( qim4 + N4c);
              dfloat N5 = -cc*( qim5 + N5c);
              dfloat N6 = -cc*( qim6 + N6c);
              // z0 = y + akk*dt*N(Y);
              qim4 = qex4 +  N4 ;
              qim5 = qex5 +  N5 ;
              qim6 = qex6 +  N6 ;

              // akk*dt*N(z0)
              N4 = -cc*( qim4 + N4c);
              N5 = -cc*( qim5 + N5c);
              N6 = -cc*( qim6 + N6c);
              //Update Qim = Qim + (I-akk*dt*del(N)/del(Qim) )^-1 * ( Qex-Qim + N(Qim) )
              // Qim += icc*(y-z+akk*dt*N(z0) )
              qim4 += (qex4 - qim4  + N4)*icc;
              qim5 += (qex5 - qim5  + N5)*icc;
              qim6 += (qex6 - qim6  + N6)*icc;
            }
            // BGK relaxation approximation to the Boltzmann collision operator
            s_cubN4[es][n] = -p_tauInv*(qim4 + N4c);
            s_cubN5[es][n] = -p_tauInv*(qim5 + N5c);
            s_cubN6[es][n] = -p_tauInv*(qim6 + N6c);
        }
      }
    }
  }

          
      // make sure all cubature node data is loaded into @shared
    @barrier("local");
      
    // partial projection to nodes from cubature-sub-group
    for(int es=0;es<p_NblockCub;++es;@inner(1)){
      for(int n=0;n<p_maxCubNodes;++n;@inner(0)){
        int et = eo+es; // element in block
        if(et<pmlNelements){
          if(n<p_Np){
            const int rhsId    = p_Nfields*(p_Np*e + n)    ;
            const int pmlrhsId = p_Nfields*(p_Np*pmlId + n);

              dfloat r_rhsqx[p_Nfields];
              dfloat r_rhsqy[p_Nfields]; 
              dfloat N4 = 0.f, N5 = 0.f, N6 = 0.f;
            
              #pragma unroll p_Nfields
              for(int fld=0; fld<p_Nfields;++fld){
                r_rhsqx[fld] = 0.f;
                r_rhsqy[fld] = 0.f;
              }

              // use temporaries for part sums for N4,N5,N6 because of @exclusives
              #pragma unroll p_cubNp
              for(int m=0;m<p_cubNp;++m){
                const dfloat Pnc  = cubProjectT[m*p_Np+n];
                N4 += Pnc*s_cubN4[es][m];
                N5 += Pnc*s_cubN5[es][m];
                N6 += Pnc*s_cubN6[es][m];
                #pragma unroll p_Nfields
                for(int fld=0; fld<p_Nfields; fld++){
                 r_rhsqx[fld] += Pnc*s_cubqx[es][fld][m];
                 r_rhsqy[fld] += Pnc*s_cubqy[es][fld][m];
                }
              }          
              // do not update q1 ,q2 ,q3 
              qZ[rhsId+0] =  0. ;
              qZ[rhsId+1] =  0. ;
              qZ[rhsId+2] =  0. ;  
              qZ[rhsId+3] =  N4 ;
              qZ[rhsId+4] =  N5 ;
              qZ[rhsId+5] =  N6 ; 

              #pragma unroll p_Nfields 
              for(int fld=0; fld<p_Nfields;++fld){
                rhsqx[pmlrhsId + fld] = r_rhsqx[fld];
                rhsqy[pmlrhsId + fld] = r_rhsqy[fld];
                rhsq[rhsId + fld]     = r_rhsqx[fld] + r_rhsqy[fld]; 
              }         
          }
        }
      }
    }

  }
}







































// @kernel void boltzmannLSIMEXSplitPmlImplicitSolve2D(const int pmlNelements,
//                               @restrict const  int *  pmlElementIds,
//                               @restrict const  int *  pmlIds,
//                                const dfloat dt,  
//                                const dfloat ramp,
//                                const dfloat akk,
//                                @restrict const  dfloat *  cubInterpT,
//                                @restrict const  dfloat *  cubProjectT,
//                                @restrict const  dfloat *  qYx,
//                                @restrict const  dfloat *  qYy,
//                                @restrict dfloat *  qZx,
//                                @restrict dfloat *  qZy,
//                                @restrict dfloat *  qZ ){

// for(int es=0;es<pmlNelements;++es;@outer(0)){
//     for(int n=0;n<p_Np;++n;@inner(0)){
      
//         const int e = elementIds[es];
//         const int id = p_Nfields*(e*p_Np + n);

//         // Initialize, combine fields
//         dfloat q1 =  p_q1bar            + qYx[id1] + qYy[id+1];
//         dfloat q2 =  ramp*p_q2bar       + qYx[id2] + qYy[id+2];
//         dfloat q3 =  ramp*p_q3bar       + qYx[id3] + qYy[id+3];
//         dfloat q4 =  ramp*ramp*p_q4bar  + qYx[id4] + qYy[id+4];
//         dfloat q5 =  ramp*ramp*p_q5bar  + qYx[id5] + qYy[id+5];
//         dfloat q6 =  ramp*ramp*p_q6bar  + qYx[id6] + qYy[id+6];

//         // Initialize Implicit part
//         dfloat qxe4 = qYx[id4];
//         dfloat qxe5 = qYx[id5];
//         dfloat qxe6 = qYx[id6]; 
        
//         // Initialize Implicit Part
//         dfloat qye4 = qYy[id4];
//         dfloat qye5 = qYy[id5];
//         dfloat qye6 = qYy[id6]; 
//         //
//         #if DENSITY_SHIFT
//         dfloat delta = 1e-2;
//         dfloat iq1 = 1.f/sqrt(q1*q1+delta*delta);
//         #else
//         dfloat  iq1 = 1.f/q1;
//         #endif
    
//          // Hold the constant part of nonlinear relaxation term
//         dfloat N4c = -(q2*q3*iq1 );
//         dfloat N5c = -p_invsqrt2*( q2*q2*iq1 );
//         dfloat N6c = -p_invsqrt2*( q3*q3*iq1 );
//         //
//         dfloat N4=0.f, N5=0.f, N6=0.f;  

//         if(akk>0) { 
//             // OLD: half-half: dfloat cc  = 0.5f*akk * dt * p_tauInv;
//             // Collect All N(q) in Qx
//             dfloat cc  = 1.0f*akk * dt * p_tauInv;
//             dfloat icc = 1.f/(cc+1.f); 
            
//             // N(Qex)
//             N4 = -cc*( q4 + N4c );
//             N5 = -cc*( q5 + N5c );
//             N6 = -cc*( q6 + N6c );      
//             // Z0 = Y + akk*dt*N(Qex)
//             dfloat qxi4 =  qxe4 +  N4 ;
//             dfloat qxi5 =  qxe5 +  N5 ;
//             dfloat qxi6 =  qxe6 +  N6 ;
//             // // 
//             // dfloat qyi4 =  qye4 +  N4 ;
//             // dfloat qyi5 =  qye5 +  N5 ;
//             // dfloat qyi6 =  qye6 +  N6 ;
            
//    //          // Recombine
//       //       q4 =  ramp*ramp*p_q4bar  + qxi4 + qyi4;
//             // q5 =  ramp*ramp*p_q5bar  + qxi5 + qyi5;
//             // q6 =  ramp*ramp*p_q6bar  + qxi6 + qyi6;

//                      // Recombine
//             q4 =  ramp*ramp*p_q4bar  + qxi4 + qye4;
//             q5 =  ramp*ramp*p_q5bar  + qxi5 + qye5;
//             q6 =  ramp*ramp*p_q6bar  + qxi6 + qye6;

            
//             // akk*dt*N(Qim)
//             N4 = -cc*( q4 + N4c );
//             N5 = -cc*( q5 + N5c );
//             N6 = -cc*( q6 + N6c );

//             //Update Qim = Qim + (I-akk*dt*del(N)/del(Qim) )^-1 * ( Qex-Qim + N(Qim) )
                
//             qxi4  += icc*(qxe4 - qxi4 + N4);    
//             qxi5  += icc*(qxe5 - qxi5 + N5);   
//             qxi6  += icc*(qxe6 - qxi6 + N6); 
//             //      
//             // qyi4  += icc*(qye4 - qyi4 + N4);    
//             // qyi5  += icc*(qye5 - qyi5 + N5);  
//             // qyi6  += icc*(qye6 - qyi6 + N6);    
//             // //                   
//             // q4 =  ramp*ramp*p_q4bar + qxi4 + qyi4;
//             // q5 =  ramp*ramp*p_q5bar + qxi5 + qyi5;
//             // q6 =  ramp*ramp*p_q6bar + qxi6 + qyi6;   

//             //                  
//             q4 =  ramp*ramp*p_q4bar + qxi4 + qye4;
//             q5 =  ramp*ramp*p_q5bar + qxi5 + qye5;
//             q6 =  ramp*ramp*p_q6bar + qxi6 + qye6;                                       
        
//         }  

//        //
//        N4 = -p_tauInv*( q4 + N4c );
//        N5 = -p_tauInv*( q5 + N5c );
//        N6 = -p_tauInv*( q6 + N6c );
       
//        // Collect all N(q) in Qx
//        dfloat alpha = 1.0f;
//        dfloat beta  = 0.0f; 

//         // 
//       qZx[id1]  = 0.f; // Required because of low storage
//       qZx[id2]  = 0.f;
//       qZx[id3]  = 0.f;
//       qZx[id4]  = alpha*N4;
//       qZx[id5]  = alpha*N5;
//       qZx[id6]  = alpha*N6; 
       
//     //  
//       qZy[id1]  = 0.f;
//       qZy[id2]  = 0.f;
//       qZy[id3]  = 0.f;
//       qZy[id4]  = beta*N4;
//       qZy[id5]  = beta*N5;
//       qZy[id6]  = beta*N6; 
//      // 
//       dfloat4 temp;
//       temp.x =  0.f;
//       temp.y =  0.f;
//       temp.z =  0.f;
//       temp.w =  N4;

//       qZ[2*(n + element*p_Np)] = temp;

//       temp.x =  N5;
//       temp.y =  N6;
//       temp.z =  0.;
//       temp.w =  0.;

//       qZ[2*(n + element*p_Np) +1] = temp;      
//     }
//   }
// }









// @kernel void boltzmannLSIMEXSplitPmlImplicitSolveCub2D(const int Nelements,
//                               @restrict const  int *  elementIds,
//                               const dfloat dt,  
//                               const dfloat ramp,
//                               const dfloat akk,
//                               @restrict const  dfloat *  cubInterpT,
//                               @restrict const  dfloat *  cubProjectT,
//                               @restrict const  dfloat *  qYx,
//                               @restrict const  dfloat *  qYy,
//                               @restrict dfloat *  qZx,
//                               @restrict dfloat *  qZy,
//                               @restrict dfloat4 * qZ ){
//   for(int eo=0;eo<Nelements;eo+=p_NblockCub;@outer(0)){  // for all elements

//     // @shared memory for q at nodes
//     @shared dfloat s_qxE[p_NblockV][6][p_Np];            
//     @shared dfloat s_qyE[p_NblockV][6][p_Np];
      
//     // sub-group of p_Np cubature node interpolants of N4,N5,N6
//     @shared dfloat s_cubN4x[p_NblockV][p_cubNp];
//     @shared dfloat s_cubN4y[p_NblockV][p_cubNp];
//     @shared dfloat s_cubN5x[p_NblockV][p_cubNp];
//     @shared dfloat s_cubN5y[p_NblockV][p_cubNp];
//     @shared dfloat s_cubN6x[p_NblockV][p_cubNp];
//     @shared dfloat s_cubN6y[p_NblockV][p_cubNp];
    
    
//     @exclusive int   element;
    
//     @exclusive dfloat N4xc =0.f, N4yc =0.f, N4c=0.f,  N5c =0.f, N6c =0.f ;
//     @exclusive dfloat qxe4 =0.f, qxe5 =0.f, qxe6=0.f ; 
//     @exclusive dfloat qye4 =0.f, qye5 =0.f, qye6=0.f ;     
//     @exclusive dfloat q4   =0.f, q5   =0.f, q6   =0.f;
//     @exclusive dfloat q4x =0.f, q4y=0.f, q5x =0.f, q5y=0.f, q6x =0.f, q6y=0.f; 
    
    
//     // prefetch q to @shared
//     for(int es=0;es<p_NblockV;++es;@inner(1)){
//       for(int n=0;n<p_maxNodesVolume;++n;@inner(0)){    
    
//     int e = eo+es; // element in block
//     if(e<Nelements){
//       element = elementIds[e];
//       if(n<p_Np){
//         //
//         const int base = n + element*p_Nfields*p_Np;
//         const int id1 = base + 0*p_Np;
//         const int id2 = base + 1*p_Np;
//         const int id3 = base + 2*p_Np;
//         const int id4 = base + 3*p_Np;
//         const int id5 = base + 4*p_Np;
//         const int id6 = base + 5*p_Np;
        
//         // PML UPDATES
//         s_qxE[es][0][n] = qYx[id1];
//         s_qxE[es][1][n] = qYx[id2];
//         s_qxE[es][2][n] = qYx[id3];
//         s_qxE[es][3][n] = qYx[id4];
//         s_qxE[es][4][n] = qYx[id5];
//         s_qxE[es][5][n] = qYx[id6]; 
//         //
//         s_qyE[es][0][n] = qYy[id1];
//         s_qyE[es][1][n] = qYy[id2];
//         s_qyE[es][2][n] = qYy[id3];
//         s_qyE[es][3][n] = qYy[id4];
//         s_qyE[es][4][n] = qYy[id5];
//         s_qyE[es][5][n] = qYy[id6]; 
        
//       }
//     }
//       }
//     }
    
//     // make sure all node data is loaded into @shared
//     @barrier("local");
    

//     // interpolate q to cubature
//     for(int es=0;es<p_NblockV;++es;@inner(1)){
//       for(int n=0;n<p_maxNodesVolume;++n;@inner(0)){
    
//     int e = eo+es; // element in block
//     if(e<Nelements){
//       if(n<p_cubNp){
//         dfloat qx1=0.f, qx2=0.f, qx3=0.f;
//         dfloat qx4=0.f, qx5=0.f, qx6=0.f;
//         dfloat qy1=0.f, qy2=0.f, qy3=0.f;
//         dfloat qy4=0.f, qy5=0.f, qy6=0.f;

//         #pragma unroll p_Np
//           for(int m=0;m<p_Np;++m){
//         const dfloat Icn  = cubInterpT[m*p_cubNp+n];
//         qx1 += Icn*s_qxE[es][0][m];
//         qx2 += Icn*s_qxE[es][1][m];
//         qx3 += Icn*s_qxE[es][2][m];
//         qx4 += Icn*s_qxE[es][3][m];
//         qx5 += Icn*s_qxE[es][4][m];
//         qx6 += Icn*s_qxE[es][5][m];
//         //
//         qy1 += Icn*s_qyE[es][0][m];
//         qy2 += Icn*s_qyE[es][1][m];
//         qy3 += Icn*s_qyE[es][2][m];
//         qy4 += Icn*s_qyE[es][3][m];
//         qy5 += Icn*s_qyE[es][4][m];
//         qy6 += Icn*s_qyE[es][5][m];
//           }
//         //
//         dfloat q1 =  p_q1bar      + qx1 + qy1;
//         dfloat q2 =  ramp*p_q2bar + qx2 + qy2;
//         dfloat q3 =  ramp*p_q3bar + qx3 + qy3;
//         //
//         // q4 =  ramp*ramp*p_q4bar  + qx4 + qy4;
//         // q5 =  ramp*ramp*p_q5bar  + qx5;
//         // q6 =  ramp*ramp*p_q6bar  + qy6;
//         //
//          // Split Q2 for splitting Q4
//         dfloat q2x=  0.5f*ramp*p_q2bar  + qx2;  
//         dfloat q2y=  0.5f*ramp*p_q2bar  + qy2;
//         //
//         q4x=  0.5f*ramp*ramp*p_q4bar  + qx4;   q4y=  0.5f*ramp*ramp*p_q4bar + qy4;
//         q5x=  0.5f*ramp*ramp*p_q5bar  + qx5;   q5y=  0.5f*ramp*ramp*p_q5bar + qy5;
//         q6x=  0.5f*ramp*ramp*p_q6bar  + qx6;   q6y=  0.5f*ramp*ramp*p_q6bar + qy6;

//         // q4x=  0.5f*ramp*ramp*p_q4bar  + qx4;   q4y=  0.5f*ramp*ramp*p_q4bar + qy4;
//      //    q5x=  0.5f*ramp*ramp*p_q5bar  + qx5;   q5y=  0.5f*ramp*ramp*p_q5bar + qy5;
//         // q6x=  0.5f*ramp*ramp*p_q6bar  + qx6;   q6y=  0.5f*ramp*ramp*p_q6bar + qy6;

//         #if DENSITY_SHIFT
//             dfloat delta  = 1e-2;
//             dfloat iq1    = 1.f/sqrt(q1*q1+delta*delta);
//          #else
//             dfloat iq1    = 1.f/q1;
//          #endif
//         //
//         N4c = -(q2*q3*iq1 );
//         N5c = -p_invsqrt2*( q2*q2*iq1 );
//         N6c = -p_invsqrt2*( q3*q3*iq1 );
//         // 
//         N4xc = -(q2x*q3*iq1 );
//         N4yc = -(q2y*q3*iq1 );

//         qxe4 = qx4;
//         qxe5 = qx5;
//         qxe6 = qx6;
        
//         qye4 = qy4;
//         qye5 = qy5;
//         qye6 = qy6;
     
//       }
//     }
//       }
//     }
    
//     // make sure all node data is loaded into @shared
//     @barrier("local");

    
//       // partial projection to nodes from cubature-sub-group
//       for(int es=0;es<p_NblockV;++es;@inner(1)){
//     for(int n=0;n<p_maxNodesVolume;++n;@inner(0)){
      
//       int e = eo+es; // element in block
//       if(e<Nelements){
//         if(n<p_cubNp){
//             if(akk>0){
//             //OLD PML: half-half/ dfloat cc  = 0.5f*akk*dt*p_tauInv;
//             dfloat cc  = 1.0f*akk*dt*p_tauInv;
//             dfloat icc = 1.f/(cc + 1.f);            
//             // N(Qex)
//             dfloat N4x = -cc*( q4x + N4xc );
//             dfloat N4y = -cc*( q4y + N4yc );
//             //
//             dfloat N5x  = -cc*( q5x + N5c );
//             dfloat N5y  = -cc*( q5y + N5c );
//             //
//             dfloat N6x  = -cc*( q6x + N6c );
//             dfloat N6y  = -cc*( q6y + N6c );
//             // Z0 = Y + akk*dt*N(Qex)
//             dfloat qxi4 =  qxe4 + N4x ;
//             dfloat qxi5 =  qxe5 + N5x ;
//             dfloat qxi6 =  qxe6 + N6x ;
//             // // 
//             dfloat qyi4 =  qye4 + N4y ;
//             dfloat qyi5 =  qye5 + N5y ;
//             dfloat qyi6 =  qye6 + N6y ;
            
//             // Recombine

             
//             q4x=  ramp*ramp*p_q4bar  + qxi4;   q4y=  qyi4;
//             q5x=  ramp*ramp*p_q5bar  + qxi5;   q5y=  qyi5;
//             q6x=  ramp*ramp*p_q6bar  + qxi6;   q6y=  qyi6;
//             // //
//             // q4x=  0.5f*ramp*ramp*p_q4bar  + qxi4;   q4y=  0.5f*ramp*ramp*p_q4bar  + qyi4;
//             // q5x=  0.5f*ramp*ramp*p_q5bar  + qxi5;   q5y=  0.5f*ramp*ramp*p_q5bar  + qyi5;
//             // q6x=  0.5f*ramp*ramp*p_q6bar  + qxi6;   q6y=  0.5f*ramp*ramp*p_q6bar  + qyi6;
    

//             // N(Qex)
//             N4x = -cc*( q4x + N4xc );
//             N4y = -cc*( q4y + N4yc );
//             //
//             N5x  = -cc*( q5x + N5c );
//             N5y  = -cc*( q5y + N5c );
//             //
//             N6x  = -cc*( q6x + N6c );
//             N6y  = -cc*( q6y + N6c );
//             //Update Qim = Qim + (I-akk*dt*del(N)/del(Qim) )^-1 * ( Qex-Qim + N(Qim) )    
//             qxi4  += icc*(qxe4 - qxi4 + N4x);    
//             qxi5  += icc*(qxe5 - qxi5 + N5x);   
//             qxi6  += icc*(qxe6 - qxi6 + N6x); 
//             //      
//             qyi4  += icc*(qye4 - qyi4 + N4y);    
//             qyi5  += icc*(qye5 - qyi5 + N5y);  
//             qyi6  += icc*(qye6 - qyi6 + N6y);    
            
//             //
//             q4x=  ramp*ramp*p_q4bar  + qxi4;   q4y=  qyi4;
//             q5x=  ramp*ramp*p_q5bar  + qxi5;   q5y=  qyi5;
//             q6x=  ramp*ramp*p_q6bar  + qxi6;   q6y=  qyi6;

//             // q4x=  0.5f*ramp*ramp*p_q4bar  + qxi4;   q4y=  0.5f*ramp*ramp*p_q4bar  + qyi4;
//             // q5x=  0.5f*ramp*ramp*p_q5bar  + qxi5;   q5y=  0.5f*ramp*ramp*p_q5bar  + qyi5;
//             // q6x=  0.5f*ramp*ramp*p_q6bar  + qxi6;   q6y=  0.5f*ramp*ramp*p_q6bar  + qyi6;

//           } 


//         // BGK relaxation approximation to the Boltzmann collision operator
//         s_cubN4x[es][n] = -p_tauInv*(q4x + N4xc);
//         s_cubN4y[es][n] = -p_tauInv*(q4y + N4yc);
//         s_cubN5x[es][n] = -p_tauInv*(q5x + N5c);
//         s_cubN5y[es][n] = -p_tauInv*(q5y + N5c);
//         s_cubN6x[es][n] = -p_tauInv*(q6x + N6c);   
//         s_cubN6y[es][n] = -p_tauInv*(q6y + N6c);                                  
        
//         }
//       }
//     }
//       }
      
//       // make sure all cubature node data is loaded into @shared
//       @barrier("local");
      
//       // partial projection to nodes from cubature-sub-group
//       for(int es=0;es<p_NblockV;++es;@inner(1)){
//     for(int n=0;n<p_maxNodesVolume;++n;@inner(0)){
//       int e = eo+es; // element in block
//       if(e<Nelements){
//         if(n<p_Np){             
//             // use temporaries for part sums for N4,N5,N6 because of @exclusives
//             dfloat N4x = 0.f, N4y = 0.f;
//             dfloat N5x = 0.f, N5y = 0.f;
//             dfloat N6x = 0.f, N6y = 0.f; 
//             for(int i=0;i<p_cubNp;++i){
//               const dfloat Pnc  = cubProjectT[i*p_Np+n];
//               N4x += Pnc*s_cubN4x[es][i];
//               N4y += Pnc*s_cubN4y[es][i];
//               N5x += Pnc*s_cubN5x[es][i];
//               N5y += Pnc*s_cubN5y[es][i];
//               N6x += Pnc*s_cubN6x[es][i];
//               N6y += Pnc*s_cubN6y[es][i];
//             }

//           //
//           const int base = n + element*p_Nfields*p_Np;
        

//         // Collect N(q) in Qx         
//         dfloat alpha = 1.0f; 
//         dfloat beta  = 1.0f;      

//         // split relaxation
//         qZx[base+0*p_Np]  = 0.;
//         qZx[base+1*p_Np]  = 0.;
//         qZx[base+2*p_Np]  = 0.;
//         qZx[base+3*p_Np]  = N4x;
//         qZx[base+4*p_Np]  = N5x;
//         qZx[base+5*p_Np]  = N6x;


//         qZy[base+0*p_Np]  = 0.;
//         qZy[base+1*p_Np]  = 0.;
//         qZy[base+2*p_Np]  = 0.;
//         qZy[base+3*p_Np]  = N4y;
//         qZy[base+4*p_Np]  = N5y;
//         qZy[base+5*p_Np]  = N6y;
        
//          //
//         dfloat4 temp;

//         temp.x =  0.f;
//         temp.y =  0.f;
//         temp.z =  0.f;
//         temp.w =  (N4x+N4y);

//         qZ[2*(n + element*p_Np)] = temp;

//         temp.x =  N5x+N5y;
//         temp.y =  N6x+N6y;
//         temp.z =  0.f;
//         temp.w =  0.f;

//         qZ[2*(n + element*p_Np) +1] = temp; 
          
//         }
//       }
//     }
//       }
//   //  }
//   }
// }






// @kernel void boltzmannLSIMEXImplicitSolve2D(const int Nelements,
//                         @restrict const  int *  elementIds,
//                         const dfloat dt, 
//                         const dfloat akk,
//                         @restrict const  dfloat  *  cubInterpT,
//                         @restrict const  dfloat  *  cubProjectT,
//                         @restrict const  dfloat4 *  qex,
//                               @restrict dfloat4 *  qim){

// for(int e=0;e<Nelements;++e;@outer(0)){
//  for(int n=0;n<p_Np;++n;@inner(0)){

//  const int element = elementIds[e];
//  const int id0     = 2*(element*p_Np + n);
//  const int id1     = id0 + 1;

//  dfloat N4=0.0,  N5 = 0.0,  N6=0.0;

//  // Read explicit part 
//  dfloat4 qexa = qex[id0];
//  dfloat4 qexb = qex[id1];
//  //
//  dfloat qex1 = qexa.x;
//  dfloat qex2 = qexa.y;
//  dfloat qex3 = qexa.z;
//  dfloat qex4 = qexa.w;
//  dfloat qex5 = qexb.x;
//  dfloat qex6 = qexb.y;       

//  // First iteration, Qim = Qex; 
//  dfloat qim4 = qex4;
//  dfloat qim5 = qex5;
//  dfloat qim6 = qex6; 
//  //
//     #if DENSITY_SHIFT
//      dfloat delta = 1e-2;
//      dfloat iqex1 = 1.f/sqrt(qex1*qex1+delta*delta);
//     #else
//      dfloat  iqex1 = 1.f/qex1;
//     #endif
    
//     // Hold the constant part of nonlinear function
//  dfloat N4c = -(qex2*qex3*iqex1 );
//  dfloat N5c = -p_invsqrt2*( qex2*qex2*iqex1 );
//  dfloat N6c = -p_invsqrt2*( qex3*qex3*iqex1 );
//       //         
//       if(akk>0){ // No need to solve, just update
//      dfloat cc  = akk * dt * p_tauInv;
//      dfloat icc = 1.0f/(cc+1.0f); 
//      //N(Y)
//      N4 = -cc*( qim4 + N4c);
//      N5 = -cc*( qim5 + N5c);
//      N6 = -cc*( qim6 + N6c);
//         // z0 = y + akk*dt*N(Y);
//         qim4 = qex4 +  N4 ;
//      qim5 = qex5 +  N5 ;
//      qim6 = qex6 +  N6 ;
//         // N(z0)
//         N4 = -cc*( qim4 + N4c);
//      N5 = -cc*( qim5 + N5c);
//      N6 = -cc*( qim6 + N6c);
//      //Update Qim = Qim + (I-akk*dt*del(N)/del(Qim) )^-1 * ( Qex-Qim + N(Qim) )
//      // Qim += icc*(y-z+akk*dt*N(z0) )
//         qim4 += (qex4 - qim4  + N4)*icc;
//      qim5 += (qex5 - qim5  + N5)*icc;
//      qim6 += (qex6 - qim6  + N6)*icc;
//  }

//  N4 = -p_tauInv*( qim4 + N4c );
//  N5 = -p_tauInv*( qim5 + N5c );
//  N6 = -p_tauInv*( qim6 + N6c );
    
//  // do not update q1 ,q2 ,q3 
//  qim[id0].x =  0. ;
//  qim[id0].y =  0. ;
//  qim[id0].z =  0. ;  
//  qim[id0].w =  N4 ;
//  //
//  qim[id1].x =  N5 ;
//  qim[id1].y =  N6 ;  
    
//  }
// }
  

// }


// @kernel void boltzmannLSIMEXImplicitSolveCub2D(const int Nelements,
//                        @restrict const  int *  elementIds,
//                        const dfloat dt, 
//                        const dfloat akk,
//                        @restrict const  dfloat *  cubInterpT,
//                        @restrict const  dfloat *  cubProjectT,
//                        @restrict const  dfloat4 *  qe,
//                              @restrict dfloat4 *  q){ 

//   for(int eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){  // for all elements

//     // @shared memory for q at nodes
//     @shared dfloat s_qE[p_NblockV][6][p_Np];
//     // sub-group of p_Np cubature node interpolants of N4,N5,N6
//     @shared dfloat s_cubN4[p_NblockV][p_cubNp];
//     @shared dfloat s_cubN5[p_NblockV][p_cubNp];
//     @shared dfloat s_cubN6[p_NblockV][p_cubNp];

//     @exclusive int   element;  
//     //
//     @exclusive dfloat N4c, N5c, N6c;
//     //
//     @exclusive dfloat qim4 =0.f, qim5 = 0.f, qim6=0.f ;  
//     @exclusive dfloat qex4 =0.f, qex5 = 0.f, qex6=0.f ; 

//     // prefetch q to @shared
//     for(int es=0;es<p_NblockV;++es;@inner(1)){
//       for(int n=0;n<p_maxNodesVolume;++n;@inner(0)){    
    
//         int e = eo+es; // element in block
//         if(e<Nelements){
      
//    element = elementIds[e];
//    if(n<p_Np){
        
//      const int id = element*p_Np+n;
//      dfloat4 qea  = qe[2*id];
//      dfloat4 qeb  = qe[2*id+1];
//      //load 
//      s_qE[es][0][n] = qea.x;
//      s_qE[es][1][n] = qea.y;
//      s_qE[es][2][n] = qea.z;
//      s_qE[es][3][n] = qea.w;   
//      s_qE[es][4][n] = qeb.x;
//      s_qE[es][5][n] = qeb.y;
//      } 
      
//  }
//       }
//     }
    
//     // make sure all node data is loaded into @shared
//     @barrier("local");

//     // interpolate q to cubature
//     for(int es=0;es<p_NblockV;++es;@inner(1)){
//       for(int n=0;n<p_maxNodesVolume;++n;@inner(0)){

//      int e = eo+es; // element in block
//      if(e<Nelements){

//          if(n<p_cubNp){
//              dfloat qe1=0.f , qe2 =0.f , qe3 =0.f ;
//              dfloat qe4=0.f , qe5 =0.f , qe6 =0.f ;

//              #pragma unroll p_Np
//              for(int m=0;m<p_Np;++m){

//              const dfloat Icn  = cubInterpT[m*p_cubNp+n];
//              //
//              qe1 += Icn*s_qE[es][0][m];
//              qe2 += Icn*s_qE[es][1][m];
//              qe3 += Icn*s_qE[es][2][m];
//              qe4 += Icn*s_qE[es][3][m];
//              qe5 += Icn*s_qE[es][4][m];
//              qe6 += Icn*s_qE[es][5][m];
//        }
        
//         //
//      #if DENSITY_SHIFT
//      dfloat delta = 1e-2;
//         dfloat iqe1 = 1.f/sqrt(qe1*qe1+delta*delta);
//         #else
//      dfloat  iqe1 = 1.f/qe1;
//         #endif
   
//         // Hold the constant part of nonlinear function
//          N4c = -(qe2*qe3*iqe1 );
//       N5c = -p_invsqrt2*( qe2*qe2*iqe1 );
//       N6c = -p_invsqrt2*( qe3*qe3*iqe1 );
         
//       //
//       qex4 = qe4;
//       qex5 = qe5;
//       qex6 = qe6;
//       //
//       qim4 = qe4;
//       qim5 = qe5;
//       qim6 = qe6; 

//    }
//  }
//       }
//     }

//     // make sure all node data is loaded into @shared
//     @barrier("local");

    
//       // partial projection to nodes from cubature-sub-group
//       for(int es=0;es<p_NblockV;++es;@inner(1)){
//  for(int n=0;n<p_maxNodesVolume;++n;@inner(0)){
//    int e = eo+es; // element in block
//    if(e<Nelements){
//      if(n<p_cubNp){
//        if(akk>0){    
//          dfloat cc  = akk * dt * p_tauInv;
//          dfloat icc = 1.0f/(cc+1.0f); 
//          //N(Y)
//          dfloat N4 = -cc*( qim4 + N4c);
//          dfloat N5 = -cc*( qim5 + N5c);
//          dfloat N6 = -cc*( qim6 + N6c);
//          // z0 = y + akk*dt*N(Y);
//          qim4 = qex4 +  N4 ;
//          qim5 = qex5 +  N5 ;
//          qim6 = qex6 +  N6 ;

//          // akk*dt*N(z0)
//          N4 = -cc*( qim4 + N4c);
//          N5 = -cc*( qim5 + N5c);
//          N6 = -cc*( qim6 + N6c);
//          //Update Qim = Qim + (I-akk*dt*del(N)/del(Qim) )^-1 * ( Qex-Qim + N(Qim) )
//          // Qim += icc*(y-z+akk*dt*N(z0) )
//          qim4 += (qex4 - qim4  + N4)*icc;
//          qim5 += (qex5 - qim5  + N5)*icc;
//          qim6 += (qex6 - qim6  + N6)*icc;
//          }
//             // BGK relaxation approximation to the Boltzmann collision operator
//              s_cubN4[es][n] = -p_tauInv*(qim4 + N4c);
//              s_cubN5[es][n] = -p_tauInv*(qim5 + N5c);
//              s_cubN6[es][n] = -p_tauInv*(qim6 + N6c);
//      }
//    }
//  }
//       }
      
//       // make sure all cubature node data is loaded into @shared
//     @barrier("local");
      
//       // partial projection to nodes from cubature-sub-group
//       for(int es=0;es<p_NblockV;++es;@inner(1)){
//  for(int n=0;n<p_maxNodesVolume;++n;@inner(0)){
//    int e = eo+es; // element in block
//    if(e<Nelements){
//      if(n<p_Np){

//        // use temporaries for part sums for N4,N5,N6 because of @exclusives
//          dfloat N4 = 0.f, N5 = 0.f, N6 = 0.f;
//          for(int i=0;i<p_cubNp;++i){
//            const dfloat Pnc  = cubProjectT[i*p_Np+n];
//            N4 += Pnc*s_cubN4[es][i];
//            N5 += Pnc*s_cubN5[es][i];
//            N6 += Pnc*s_cubN6[es][i];
//          }

//      const int id = element*p_Np+n;
                  
//        //  
//        dfloat4 temp; 
//        temp.x = 0.; 
//        temp.y = 0.;
//        temp.z = 0.; 
//        temp.w = N4; 

//        q[2*id] = temp; 

//        temp.x = N5;
//        temp.y = N6;
//        temp.z = 0.; 
//        temp.w = 0.; 

//        q[2*id +1] = temp; 
          
//      }
//    }
//  }
//       }
//   }
// }







// @kernel void boltzmannLSIMEXSplitPmlImplicitSolve2D(const int Nelements,
//                             @restrict const  int *  elementIds,
//                             const dfloat dt,  
//                             const dfloat ramp,
//                             const dfloat akk,
//                             @restrict const  dfloat *  cubInterpT,
//                             @restrict const  dfloat *  cubProjectT,
//                             @restrict const  dfloat *  qYx,
//                             @restrict const  dfloat *  qYy,
//                             @restrict dfloat *  qZx,
//                             @restrict dfloat *  qZy,
//                             @restrict dfloat4 * qZ ){

// for(int e=0;e<Nelements;++e;@outer(0)){
//  for(int n=0;n<p_Np;++n;@inner(0)){
      
//      const int element = elementIds[e];
//      //
//      const int base = n + element*p_Nfields*p_Np;
//      const int id1 = base + 0*p_Np;
//      const int id2 = base + 1*p_Np;
//      const int id3 = base + 2*p_Np;
//      const int id4 = base + 3*p_Np;
//      const int id5 = base + 4*p_Np;
//      const int id6 = base + 5*p_Np;

//      // Initialize, combine fields
//      dfloat q1 =  p_q1bar            + qYx[id1] + qYy[id1];
//      dfloat q2 =  ramp*p_q2bar       + qYx[id2] + qYy[id2];
//      dfloat q3 =  ramp*p_q3bar       + qYx[id3] + qYy[id3];
//      dfloat q4 =  ramp*ramp*p_q4bar  + qYx[id4] + qYy[id4];
//      dfloat q5 =  ramp*ramp*p_q5bar  + qYx[id5] + qYy[id5];
//      dfloat q6 =  ramp*ramp*p_q6bar  + qYx[id6] + qYy[id6];

//      // Initialize Implicit part
//      dfloat qxe4 = qYx[id4];
//      dfloat qxe5 = qYx[id5];
//      dfloat qxe6 = qYx[id6]; 
        
//      // Initialize Implicit Part
//      dfloat qye4 = qYy[id4];
//      dfloat qye5 = qYy[id5];
//      dfloat qye6 = qYy[id6]; 
//      //
//         #if DENSITY_SHIFT
//      dfloat delta = 1e-2;
//         dfloat iq1 = 1.f/sqrt(q1*q1+delta*delta);
//         #else
//      dfloat  iq1 = 1.f/q1;
//         #endif
    
//          // Hold the constant part of nonlinear relaxation term
//      dfloat N4c = -(q2*q3*iq1 );
//      dfloat N5c = -p_invsqrt2*( q2*q2*iq1 );
//      dfloat N6c = -p_invsqrt2*( q3*q3*iq1 );
//         //
//      dfloat N4=0.f, N5=0.f, N6=0.f;  

//      if(akk>0) { 
//          // OLD: half-half: dfloat cc  = 0.5f*akk * dt * p_tauInv;
//          // Collect All N(q) in Qx
//          dfloat cc  = 1.0f*akk * dt * p_tauInv;
//          dfloat icc = 1.f/(cc+1.f); 
            
//          // N(Qex)
//          N4 = -cc*( q4 + N4c );
//          N5 = -cc*( q5 + N5c );
//          N6 = -cc*( q6 + N6c );      
//          // Z0 = Y + akk*dt*N(Qex)
//          dfloat qxi4 =  qxe4 +  N4 ;
//          dfloat qxi5 =  qxe5 +  N5 ;
//          dfloat qxi6 =  qxe6 +  N6 ;
//          // // 
//          // dfloat qyi4 =  qye4 +  N4 ;
//          // dfloat qyi5 =  qye5 +  N5 ;
//          // dfloat qyi6 =  qye6 +  N6 ;
            
//    //          // Recombine
//    //       q4 =  ramp*ramp*p_q4bar  + qxi4 + qyi4;
//          // q5 =  ramp*ramp*p_q5bar  + qxi5 + qyi5;
//          // q6 =  ramp*ramp*p_q6bar  + qxi6 + qyi6;

//                      // Recombine
//          q4 =  ramp*ramp*p_q4bar  + qxi4 + qye4;
//          q5 =  ramp*ramp*p_q5bar  + qxi5 + qye5;
//          q6 =  ramp*ramp*p_q6bar  + qxi6 + qye6;

            
//             // akk*dt*N(Qim)
//          N4 = -cc*( q4 + N4c );
//          N5 = -cc*( q5 + N5c );
//          N6 = -cc*( q6 + N6c );

//          //Update Qim = Qim + (I-akk*dt*del(N)/del(Qim) )^-1 * ( Qex-Qim + N(Qim) )
                
//          qxi4  += icc*(qxe4 - qxi4 + N4);    
//          qxi5  += icc*(qxe5 - qxi5 + N5);   
//          qxi6  += icc*(qxe6 - qxi6 + N6); 
//          //      
//          // qyi4  += icc*(qye4 - qyi4 + N4);    
//          // qyi5  += icc*(qye5 - qyi5 + N5);  
//          // qyi6  += icc*(qye6 - qyi6 + N6);    
//          // //                   
//          // q4 =  ramp*ramp*p_q4bar + qxi4 + qyi4;
//          // q5 =  ramp*ramp*p_q5bar + qxi5 + qyi5;
//          // q6 =  ramp*ramp*p_q6bar + qxi6 + qyi6;   

//          //                  
//          q4 =  ramp*ramp*p_q4bar + qxi4 + qye4;
//          q5 =  ramp*ramp*p_q5bar + qxi5 + qye5;
//          q6 =  ramp*ramp*p_q6bar + qxi6 + qye6;                                       
        
//      }  

//        //
//     N4 = -p_tauInv*( q4 + N4c );
//     N5 = -p_tauInv*( q5 + N5c );
//     N6 = -p_tauInv*( q6 + N6c );
       
//     // Collect all N(q) in Qx
//     dfloat alpha = 1.0f;
//     dfloat beta  = 0.0f; 

//      // 
//       qZx[id1]  = 0.f; // Required because of low storage
//       qZx[id2]  = 0.f;
//       qZx[id3]  = 0.f;
//       qZx[id4]  = alpha*N4;
//       qZx[id5]  = alpha*N5;
//       qZx[id6]  = alpha*N6; 
       
//  //  
//       qZy[id1]  = 0.f;
//       qZy[id2]  = 0.f;
//       qZy[id3]  = 0.f;
//       qZy[id4]  = beta*N4;
//       qZy[id5]  = beta*N5;
//       qZy[id6]  = beta*N6; 
//      // 
//       dfloat4 temp;
//       temp.x =  0.f;
//       temp.y =  0.f;
//       temp.z =  0.f;
//       temp.w =  N4;

//       qZ[2*(n + element*p_Np)] = temp;

//       temp.x =  N5;
//       temp.y =  N6;
//       temp.z =  0.;
//       temp.w =  0.;

//       qZ[2*(n + element*p_Np) +1] = temp;      
//     }
//   }
// }









// @kernel void boltzmannLSIMEXSplitPmlImplicitSolveCub2D(const int Nelements,
//                            @restrict const  int *  elementIds,
//                            const dfloat dt,  
//                            const dfloat ramp,
//                            const dfloat akk,
//                            @restrict const  dfloat *  cubInterpT,
//                            @restrict const  dfloat *  cubProjectT,
//                            @restrict const  dfloat *  qYx,
//                            @restrict const  dfloat *  qYy,
//                            @restrict dfloat *  qZx,
//                            @restrict dfloat *  qZy,
//                            @restrict dfloat4 * qZ ){
//   for(int eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){  // for all elements

//     // @shared memory for q at nodes
//     @shared dfloat s_qxE[p_NblockV][6][p_Np];            
//     @shared dfloat s_qyE[p_NblockV][6][p_Np];
      
//     // sub-group of p_Np cubature node interpolants of N4,N5,N6
//     @shared dfloat s_cubN4x[p_NblockV][p_cubNp];
//     @shared dfloat s_cubN4y[p_NblockV][p_cubNp];
//     @shared dfloat s_cubN5x[p_NblockV][p_cubNp];
//     @shared dfloat s_cubN5y[p_NblockV][p_cubNp];
//     @shared dfloat s_cubN6x[p_NblockV][p_cubNp];
//     @shared dfloat s_cubN6y[p_NblockV][p_cubNp];
    
    
//     @exclusive int   element;
    
//     @exclusive dfloat N4xc =0.f, N4yc =0.f, N4c=0.f,  N5c =0.f, N6c =0.f ;
//     @exclusive dfloat qxe4 =0.f, qxe5 =0.f, qxe6=0.f ; 
//     @exclusive dfloat qye4 =0.f, qye5 =0.f, qye6=0.f ;     
//     @exclusive dfloat q4   =0.f, q5   =0.f, q6   =0.f;
//     @exclusive dfloat q4x =0.f, q4y=0.f, q5x =0.f, q5y=0.f, q6x =0.f, q6y=0.f; 
    
    
//     // prefetch q to @shared
//     for(int es=0;es<p_NblockV;++es;@inner(1)){
//       for(int n=0;n<p_maxNodesVolume;++n;@inner(0)){    
    
//  int e = eo+es; // element in block
//  if(e<Nelements){
//    element = elementIds[e];
//    if(n<p_Np){
//      //
//      const int base = n + element*p_Nfields*p_Np;
//      const int id1 = base + 0*p_Np;
//      const int id2 = base + 1*p_Np;
//      const int id3 = base + 2*p_Np;
//      const int id4 = base + 3*p_Np;
//      const int id5 = base + 4*p_Np;
//      const int id6 = base + 5*p_Np;
        
//      // PML UPDATES
//      s_qxE[es][0][n] = qYx[id1];
//      s_qxE[es][1][n] = qYx[id2];
//      s_qxE[es][2][n] = qYx[id3];
//      s_qxE[es][3][n] = qYx[id4];
//      s_qxE[es][4][n] = qYx[id5];
//      s_qxE[es][5][n] = qYx[id6]; 
//      //
//      s_qyE[es][0][n] = qYy[id1];
//      s_qyE[es][1][n] = qYy[id2];
//      s_qyE[es][2][n] = qYy[id3];
//      s_qyE[es][3][n] = qYy[id4];
//      s_qyE[es][4][n] = qYy[id5];
//      s_qyE[es][5][n] = qYy[id6]; 
        
//    }
//  }
//       }
//     }
    
//     // make sure all node data is loaded into @shared
//     @barrier("local");
    

//     // interpolate q to cubature
//     for(int es=0;es<p_NblockV;++es;@inner(1)){
//       for(int n=0;n<p_maxNodesVolume;++n;@inner(0)){
    
//  int e = eo+es; // element in block
//  if(e<Nelements){
//    if(n<p_cubNp){
//      dfloat qx1=0.f, qx2=0.f, qx3=0.f;
//      dfloat qx4=0.f, qx5=0.f, qx6=0.f;
//      dfloat qy1=0.f, qy2=0.f, qy3=0.f;
//      dfloat qy4=0.f, qy5=0.f, qy6=0.f;

//      #pragma unroll p_Np
//        for(int m=0;m<p_Np;++m){
//      const dfloat Icn  = cubInterpT[m*p_cubNp+n];
//      qx1 += Icn*s_qxE[es][0][m];
//      qx2 += Icn*s_qxE[es][1][m];
//      qx3 += Icn*s_qxE[es][2][m];
//      qx4 += Icn*s_qxE[es][3][m];
//      qx5 += Icn*s_qxE[es][4][m];
//      qx6 += Icn*s_qxE[es][5][m];
//      //
//      qy1 += Icn*s_qyE[es][0][m];
//      qy2 += Icn*s_qyE[es][1][m];
//      qy3 += Icn*s_qyE[es][2][m];
//      qy4 += Icn*s_qyE[es][3][m];
//      qy5 += Icn*s_qyE[es][4][m];
//      qy6 += Icn*s_qyE[es][5][m];
//        }
//      //
//         dfloat q1 =  p_q1bar      + qx1 + qy1;
//         dfloat q2 =  ramp*p_q2bar + qx2 + qy2;
//         dfloat q3 =  ramp*p_q3bar + qx3 + qy3;
//      //
//      // q4 =  ramp*ramp*p_q4bar  + qx4 + qy4;
//      // q5 =  ramp*ramp*p_q5bar  + qx5;
//      // q6 =  ramp*ramp*p_q6bar  + qy6;
//      //
//       // Split Q2 for splitting Q4
//      dfloat q2x=  0.5f*ramp*p_q2bar  + qx2;  
//      dfloat q2y=  0.5f*ramp*p_q2bar  + qy2;
//      //
//      q4x=  0.5f*ramp*ramp*p_q4bar  + qx4;   q4y=  0.5f*ramp*ramp*p_q4bar + qy4;
//         q5x=  0.5f*ramp*ramp*p_q5bar  + qx5;   q5y=  0.5f*ramp*ramp*p_q5bar + qy5;
//      q6x=  0.5f*ramp*ramp*p_q6bar  + qx6;   q6y=  0.5f*ramp*ramp*p_q6bar + qy6;

//      // q4x=  0.5f*ramp*ramp*p_q4bar  + qx4;   q4y=  0.5f*ramp*ramp*p_q4bar + qy4;
//      //    q5x=  0.5f*ramp*ramp*p_q5bar  + qx5;   q5y=  0.5f*ramp*ramp*p_q5bar + qy5;
//      // q6x=  0.5f*ramp*ramp*p_q6bar  + qx6;   q6y=  0.5f*ramp*ramp*p_q6bar + qy6;

//      #if DENSITY_SHIFT
//          dfloat delta  = 1e-2;
//          dfloat iq1    = 1.f/sqrt(q1*q1+delta*delta);
//       #else
//          dfloat iq1    = 1.f/q1;
//          #endif
//         //
//         N4c = -(q2*q3*iq1 );
//      N5c = -p_invsqrt2*( q2*q2*iq1 );
//      N6c = -p_invsqrt2*( q3*q3*iq1 );
//      // 
//      N4xc = -(q2x*q3*iq1 );
//         N4yc = -(q2y*q3*iq1 );

//      qxe4 = qx4;
//      qxe5 = qx5;
//      qxe6 = qx6;
        
//      qye4 = qy4;
//      qye5 = qy5;
//      qye6 = qy6;
     
//    }
//  }
//       }
//     }
    
//     // make sure all node data is loaded into @shared
//     @barrier("local");

    
//       // partial projection to nodes from cubature-sub-group
//       for(int es=0;es<p_NblockV;++es;@inner(1)){
//  for(int n=0;n<p_maxNodesVolume;++n;@inner(0)){
      
//    int e = eo+es; // element in block
//    if(e<Nelements){
//      if(n<p_cubNp){
//          if(akk>0){
//          //OLD PML: half-half/ dfloat cc  = 0.5f*akk*dt*p_tauInv;
//          dfloat cc  = 1.0f*akk*dt*p_tauInv;
//          dfloat icc = 1.f/(cc + 1.f);            
//          // N(Qex)
//          dfloat N4x = -cc*( q4x + N4xc );
//          dfloat N4y = -cc*( q4y + N4yc );
//             //
//          dfloat N5x  = -cc*( q5x + N5c );
//          dfloat N5y  = -cc*( q5y + N5c );
//          //
//          dfloat N6x  = -cc*( q6x + N6c );
//          dfloat N6y  = -cc*( q6y + N6c );
//          // Z0 = Y + akk*dt*N(Qex)
//          dfloat qxi4 =  qxe4 + N4x ;
//          dfloat qxi5 =  qxe5 + N5x ;
//          dfloat qxi6 =  qxe6 + N6x ;
//          // // 
//          dfloat qyi4 =  qye4 + N4y ;
//          dfloat qyi5 =  qye5 + N5y ;
//          dfloat qyi6 =  qye6 + N6y ;
            
//             // Recombine

             
//          q4x=  ramp*ramp*p_q4bar  + qxi4;   q4y=  qyi4;
//          q5x=  ramp*ramp*p_q5bar  + qxi5;   q5y=  qyi5;
//          q6x=  ramp*ramp*p_q6bar  + qxi6;   q6y=  qyi6;
//          // //
//          // q4x=  0.5f*ramp*ramp*p_q4bar  + qxi4;   q4y=  0.5f*ramp*ramp*p_q4bar  + qyi4;
//          // q5x=  0.5f*ramp*ramp*p_q5bar  + qxi5;   q5y=  0.5f*ramp*ramp*p_q5bar  + qyi5;
//          // q6x=  0.5f*ramp*ramp*p_q6bar  + qxi6;   q6y=  0.5f*ramp*ramp*p_q6bar  + qyi6;
    

//          // N(Qex)
//          N4x = -cc*( q4x + N4xc );
//          N4y = -cc*( q4y + N4yc );
//             //
//          N5x  = -cc*( q5x + N5c );
//          N5y  = -cc*( q5y + N5c );
//          //
//          N6x  = -cc*( q6x + N6c );
//          N6y  = -cc*( q6y + N6c );
//          //Update Qim = Qim + (I-akk*dt*del(N)/del(Qim) )^-1 * ( Qex-Qim + N(Qim) )    
//          qxi4  += icc*(qxe4 - qxi4 + N4x);    
//          qxi5  += icc*(qxe5 - qxi5 + N5x);   
//          qxi6  += icc*(qxe6 - qxi6 + N6x); 
//          //      
//          qyi4  += icc*(qye4 - qyi4 + N4y);    
//          qyi5  += icc*(qye5 - qyi5 + N5y);  
//          qyi6  += icc*(qye6 - qyi6 + N6y);    
            
//              //
//          q4x=  ramp*ramp*p_q4bar  + qxi4;   q4y=  qyi4;
//          q5x=  ramp*ramp*p_q5bar  + qxi5;   q5y=  qyi5;
//          q6x=  ramp*ramp*p_q6bar  + qxi6;   q6y=  qyi6;

//          // q4x=  0.5f*ramp*ramp*p_q4bar  + qxi4;   q4y=  0.5f*ramp*ramp*p_q4bar  + qyi4;
//          // q5x=  0.5f*ramp*ramp*p_q5bar  + qxi5;   q5y=  0.5f*ramp*ramp*p_q5bar  + qyi5;
//          // q6x=  0.5f*ramp*ramp*p_q6bar  + qxi6;   q6y=  0.5f*ramp*ramp*p_q6bar  + qyi6;

//        } 


//         // BGK relaxation approximation to the Boltzmann collision operator
//          s_cubN4x[es][n] = -p_tauInv*(q4x + N4xc);
//          s_cubN4y[es][n] = -p_tauInv*(q4y + N4yc);
//          s_cubN5x[es][n] = -p_tauInv*(q5x + N5c);
//          s_cubN5y[es][n] = -p_tauInv*(q5y + N5c);
//         s_cubN6x[es][n] = -p_tauInv*(q6x + N6c);   
//          s_cubN6y[es][n] = -p_tauInv*(q6y + N6c);                                  
        
//      }
//    }
//  }
//       }
      
//       // make sure all cubature node data is loaded into @shared
//       @barrier("local");
      
//       // partial projection to nodes from cubature-sub-group
//       for(int es=0;es<p_NblockV;++es;@inner(1)){
//  for(int n=0;n<p_maxNodesVolume;++n;@inner(0)){
//    int e = eo+es; // element in block
//    if(e<Nelements){
//      if(n<p_Np){             
//              // use temporaries for part sums for N4,N5,N6 because of @exclusives
//              dfloat N4x = 0.f, N4y = 0.f;
//              dfloat N5x = 0.f, N5y = 0.f;
//              dfloat N6x = 0.f, N6y = 0.f; 
//              for(int i=0;i<p_cubNp;++i){
//                const dfloat Pnc  = cubProjectT[i*p_Np+n];
//                N4x += Pnc*s_cubN4x[es][i];
//                N4y += Pnc*s_cubN4y[es][i];
//                N5x += Pnc*s_cubN5x[es][i];
//                N5y += Pnc*s_cubN5y[es][i];
//                N6x += Pnc*s_cubN6x[es][i];
//                N6y += Pnc*s_cubN6y[es][i];
//              }

//        //
//        const int base = n + element*p_Nfields*p_Np;
        

//      // Collect N(q) in Qx         
//      dfloat alpha = 1.0f; 
//      dfloat beta  = 1.0f;      

//      // split relaxation
//      qZx[base+0*p_Np]  = 0.;
//      qZx[base+1*p_Np]  = 0.;
//      qZx[base+2*p_Np]  = 0.;
//      qZx[base+3*p_Np]  = N4x;
//      qZx[base+4*p_Np]  = N5x;
//      qZx[base+5*p_Np]  = N6x;


//      qZy[base+0*p_Np]  = 0.;
//      qZy[base+1*p_Np]  = 0.;
//      qZy[base+2*p_Np]  = 0.;
//      qZy[base+3*p_Np]  = N4y;
//      qZy[base+4*p_Np]  = N5y;
//      qZy[base+5*p_Np]  = N6y;
        
//       //
//      dfloat4 temp;

//      temp.x =  0.f;
//      temp.y =  0.f;
//      temp.z =  0.f;
//      temp.w =  (N4x+N4y);

//      qZ[2*(n + element*p_Np)] = temp;

//      temp.x =  N5x+N5y;
//      temp.y =  N6x+N6y;
//      temp.z =  0.f;
//      temp.w =  0.f;

//      qZ[2*(n + element*p_Np) +1] = temp; 
          
//      }
//    }
//  }
//       }
//   //  }
//   }
// }

