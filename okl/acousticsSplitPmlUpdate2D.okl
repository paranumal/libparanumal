
@kernel void acousticsSplitPmlUpdate2D(const int Ntotal,
					  const int recombine,
					  const dfloat dt,	
					  const dfloat rka,
					  const dfloat rkb,
					  @restrict const  dfloat *  rhsqx,
					  @restrict const  dfloat *  rhsqy,
					  @restrict dfloat *  resqx,
					  @restrict dfloat *  resqy,
					  @restrict dfloat *  qx,
					  @restrict dfloat *  qy,
					  @restrict dfloat *  q){
  
  // Low storage Runge Kutta time step update
  for(int n=0;n<Ntotal;++n;@tile(256,@outer,@inner)){
    if(n<Ntotal){
      dfloat resqxn = resqx[n];
      dfloat qxn = qx[n];
      resqxn = rka*resqxn + dt*rhsqx[n];
      resqx[n] = resqxn;
      qxn += rkb*resqxn;

      dfloat resqyn = resqy[n];
      dfloat qyn = qy[n];
      resqyn = rka*resqyn + dt*rhsqy[n];
      resqy[n] = resqyn;
      qyn += rkb*resqyn;
      
      // need to map between qx, qy storage and q storage
      int node  = n%p_Np;
      int field = (n/p_Np)%p_Nfields;
      int element = n/(p_Np*p_Nfields);
      int id = field + node*p_Nfields + element*p_Np*p_Nfields;
      dfloat sumq = qxn+qyn;
      q[id] = sumq + (field==0)*p_q1bar + (field==1)*p_q2bar + (field==2)*p_q3bar;

      if(recombine == 1){
	qxn = 0.5f*sumq;
	qyn = 0.5f*sumq;
      }
	
      qx[n] = qxn;
      qy[n] = qyn;
      
    }
  }
}

