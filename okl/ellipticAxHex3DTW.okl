
#if (p_Nq%2 == 0)
#define p_pad 1
#else
#define p_pad 0
#endif

// cuboid of storage
@kernel void ellipticAxHex3D_cuboid0(const int Nelements,
                                    @restrict const  int *  elementList,
                                    @restrict const  dfloat *  ggeo,
                                    @restrict const  dfloat *  D,
                                    const dfloat lambda,
                                    @restrict const  dfloat *  q,
                                    @restrict dfloat *  Aq,
                                    @restrict dfloat *  grad){

	for(int e=0; e<Nelements; ++e; @outer(0)){

		@shared dfloat s_q[p_Nz][p_Nq][p_Nq];
		@shared dfloat s_D[p_Nq][p_Nq];

		@exclusive int emap;
		@exclusive dfloat r_tmpr, r_tmps, r_tmpt, r_Aq;

		for(int k=0; k<p_Nz; ++k; @inner(2)){
			for(int j=0; j<p_Nq; ++j; @inner(1)){
				for(int i=0; i<p_Nq; ++i; @inner(0)){

					emap = elementList[e];

					if(k==0)
						s_D[j][i] = D[j*p_Nq+i];
				}
			}
		}

		for(int jo=0;jo<p_Nq;jo+=p_Nz){

			@barrier("local");

			for(int js=0; js<p_Nz; ++js; @inner(2)){
				for(int k=0; k<p_Nq; ++k; @inner(1)){
					for(int i=0; i<p_Nq; ++i; @inner(0)){
						int j = js+jo;
						if(j<p_Nq)
							s_q[js][k][i] = q[emap*p_Np + k*p_Nq*p_Nq + j*p_Nq + i];
					}
				}
			}

			@barrier("local");

			for(int js=0; js<p_Nz; ++js; @inner(2)){
				for(int k=0; k<p_Nq; ++k; @inner(1)){
					for(int i=0; i<p_Nq; ++i; @inner(0)){
						int j = js+jo;
						if(j<p_Nq){
							dfloat qt = 0;

							#pragma unroll p_Nq
							for(int n=0;n<p_Nq;++n){
								qt += s_D[k][n]*s_q[js][n][i];
							}
							grad[emap*p_Np + k*p_Nq*p_Nq + j*p_Nq + i] = qt;
						}
					}
				}
			}
		}

		@barrier("global");

		for(int ko=0;ko<p_Nq;ko+=p_Nz){

			@barrier("local");

			for(int ks=0; ks<p_Nz; ++ks; @inner(2)){
				for(int j=0; j<p_Nq; ++j; @inner(1)){
					for(int i=0; i<p_Nq; ++i; @inner(0)){
						int k = ks+ko;
						if(k<p_Nq)
							s_q[ks][j][i] = q[emap*p_Np + k*p_Nq*p_Nq + j*p_Nq + i];
					}
				}
			}

			@barrier("local");

			for(int ks=0; ks<p_Nz; ++ks; @inner(2)){
				for(int j=0; j<p_Nq; ++j; @inner(1)){
					for(int i=0; i<p_Nq; ++i; @inner(0)){
						const int k = ko+ks;

						if(k<p_Nq){
							// refetch qt
							const dfloat qt = grad[emap*p_Np+k*p_Nq*p_Nq + j*p_Nq + i];

							const int base = emap*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

							const dfloat G00 = ggeo[base+p_G00ID*p_Np];
							const dfloat G01 = ggeo[base+p_G01ID*p_Np];
							const dfloat G02 = ggeo[base+p_G02ID*p_Np];
							const dfloat G11 = ggeo[base+p_G11ID*p_Np];
							const dfloat G12 = ggeo[base+p_G12ID*p_Np];
							const dfloat G22 = ggeo[base+p_G22ID*p_Np];
							const dfloat GwJ = ggeo[base+p_GWJID*p_Np];

							dfloat qr = 0.f, qs = 0.f;
							for(int n=0; n<p_Nq; ++n) {

								qr += s_D[i][n]*s_q[ks][j][n];
								qs += s_D[j][n]*s_q[ks][n][i];
							}

							// assumes w*J built into G entries
							r_tmpr = G00*qr + G01*qs + G02*qt;
							r_tmps = G01*qr + G11*qs + G12*qt;
							r_tmpt = G02*qr + G12*qs + G22*qt;

							grad[emap*p_Np+ k*p_Nq*p_Nq + j*p_Nq + i] = r_tmpt;

							r_Aq = GwJ*s_q[ks][j][i];
						}
					}
				}
			}

			barrier(localMemfence);

			for(int ks=0; ks<p_Nz; ++ks; @inner(2)){
				for(int j=0; j<p_Nq; ++j; @inner(1)){
					for(int i=0; i<p_Nq; ++i; @inner(0)){
						s_q[ks][j][i] = r_tmpr;
					}
				}
			}

			barrier(localMemfence);

			for(int ks=0; ks<p_Nz; ++ks; @inner(2)){
				for(int j=0; j<p_Nq; ++j; @inner(1)){
					for(int i=0; i<p_Nq; ++i; @inner(0)){
						const int k = ko+ks;

						if(k<p_Nq){
							dfloat tmpr = 0;

							#pragma unroll p_Nq
							for(int n=0;n<p_Nq;++n){
								tmpr += s_D[n][i]*s_q[ks][j][n];
							}
							r_Aq += tmpr;
						}
					}
				}
			}

			barrier(localMemfence);

			for(int ks=0; ks<p_Nz; ++ks; @inner(2)){
				for(int j=0; j<p_Nq; ++j; @inner(1)){
					for(int i=0; i<p_Nq; ++i; @inner(0)){
						s_q[ks][j][i] = r_tmps;
					}
				}
			}

			barrier(localMemfence);

			for(int ks=0; ks<p_Nz; ++ks; @inner(2)){
				for(int j=0; j<p_Nq; ++j; @inner(1)){
					for(int i=0; i<p_Nq; ++i; @inner(0)){
						const int k = ko+ks;

						if(k<p_Nq){
							dfloat tmps = 0;

							#pragma unroll p_Nq
							for(int n=0;n<p_Nq;++n){
								tmps += s_D[n][j]*s_q[ks][n][i];
							}
							r_Aq += tmps;
							Aq[emap*p_Np+k*p_Nq*p_Nq + j*p_Nq + i] = r_Aq;

						}
					}
				}
			}
		}

		@barrier("global");

		for(int jo=0;jo<p_Nq;jo+=p_Nz){

			@barrier("local");

			for(int js=0; js<p_Nz; ++js; @inner(2)){
				for(int k=0; k<p_Nq; ++k; @inner(1)){
					for(int i=0; i<p_Nq; ++i; @inner(0)){
						int j = js+jo;
						if(j<p_Nq){
							s_q[js][k][i] = grad[emap*p_Np +  k*p_Nq*p_Nq + j*p_Nq + i];
						}
					}
				}
			}

			@barrier("local");

			for(int js=0; js<p_Nz; ++js; @inner(2)){
				for(int k=0; k<p_Nq; ++k; @inner(1)){
					for(int i=0; i<p_Nq; ++i; @inner(0)){
						int j = js+jo;
						if(j<p_Nq){
							dfloat tmpt = 0;

							#pragma unroll p_Nq
							for(int n=0;n<p_Nq;++n){
								tmpt += s_D[n][k]*s_q[js][n][i];
							}

							Aq[emap*p_Np + k*p_Nq*p_Nq + j*p_Nq + i] += tmpt;

						}
					}
				}
			}
		}
	}
}

#if 0
@kernel void ellipticAxHex3D_cuboid1(const int Nelements,
                                    @restrict const  int *  elementList,
                                    @restrict const  dfloat *  ggeo,
                                    @restrict const  dfloat *  D,
                                    const dfloat lambda,
                                    @restrict const  dfloat *  q,
                                    @restrict dfloat *  Aq,
                                    @restrict dfloat *  grad){

	for(int e=0; e<Nelements; ++e; @outer(0)){

		@shared dfloat s_q[p_Nz][p_Nq][p_Nq];
		@shared dfloat s_qr[p_Nz][p_Nq][p_Nq];
		@shared dfloat s_qs[p_Nz][p_Nq][p_Nq];
		@shared dfloat s_D[p_Nq][p_Nq];

		@exclusive int emap;
		@exclusive dfloat r_tmpr, r_tmps, r_tmpt, r_Aq;

		for(int k=0; k<p_Nz; ++k; @inner(2)){
			for(int j=0; j<p_Nq; ++j; @inner(1)){
				for(int i=0; i<p_Nq; ++i; @inner(0)){

					emap = elementList[e];

					if(k==0)
						s_D[j][i] = D[j*p_Nq+i];
				}
			}
		}

		for(int jo=0;jo<p_Nq;jo+=p_Nz){

			@barrier("local");

			for(int js=0; js<p_Nz; ++js; @inner(2)){
				for(int k=0; k<p_Nq; ++k; @inner(1)){
					for(int i=0; i<p_Nq; ++i; @inner(0)){
						int j = js+jo;
						if(j<p_Nq)
							s_q[js][k][i] = q[emap*p_Np + k*p_Nq*p_Nq + j*p_Nq + i];
					}
				}
			}

			@barrier("local");

			for(int js=0; js<p_Nz; ++js; @inner(2)){
				for(int k=0; k<p_Nq; ++k; @inner(1)){
					for(int i=0; i<p_Nq; ++i; @inner(0)){
						int j = js+jo;
						if(j<p_Nq){
							dfloat qt = 0;

							#pragma unroll p_Nq
							for(int n=0;n<p_Nq;++n){
								qt += s_D[k][n]*s_q[js][n][i];
							}
							grad[emap*p_Np + k*p_Nq*p_Nq + j*p_Nq + i] = qt;
						}
					}
				}
			}
		}

		@barrier("global");

		for(int ko=0;ko<p_Nq;ko+=p_Nz){

			@barrier("local");

			for(int ks=0; ks<p_Nz; ++ks; @inner(2)){
				for(int j=0; j<p_Nq; ++j; @inner(1)){
					for(int i=0; i<p_Nq; ++i; @inner(0)){
						int k = ks+ko;
						if(k<p_Nq)
							s_q[ks][j][i] = q[emap*p_Np + k*p_Nq*p_Nq + j*p_Nq + i];
					}
				}
			}

			@barrier("local");

			for(int ks=0; ks<p_Nz; ++ks; @inner(2)){
				for(int j=0; j<p_Nq; ++j; @inner(1)){
					for(int i=0; i<p_Nq; ++i; @inner(0)){
						const int k = ko+ks;

						if(k<p_Nq){
							// refetch qt
							const dfloat qt = grad[emap*p_Np+k*p_Nq*p_Nq + j*p_Nq + i];

							const int base = emap*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

							const dfloat G00 = ggeo[base+p_G00ID*p_Np];
							const dfloat G01 = ggeo[base+p_G01ID*p_Np];
							const dfloat G02 = ggeo[base+p_G02ID*p_Np];
							const dfloat G11 = ggeo[base+p_G11ID*p_Np];
							const dfloat G12 = ggeo[base+p_G12ID*p_Np];
							const dfloat G22 = ggeo[base+p_G22ID*p_Np];
							const dfloat GwJ = ggeo[base+p_GWJID*p_Np];

							dfloat qr = 0.f, qs = 0.f;
							for(int n=0; n<p_Nq; ++n) {

								qr += s_D[i][n]*s_q[ks][j][n];
								qs += s_D[j][n]*s_q[ks][n][i];
							}

							// assumes w*J built into G entries
							s_qr[ks][j][i] = G00*qr + G01*qs + G02*qt;
							s_qs[ks][j][i] = G01*qr + G11*qs + G12*qt;
							r_tmpt = G02*qr + G12*qs + G22*qt;

							grad[emap*p_Np+ k*p_Nq*p_Nq + j*p_Nq + i] = r_tmpt;

							r_Aq = GwJ*s_q[ks][j][i];
						}
					}
				}
			}

			barrier(localMemfence);

			for(int ks=0; ks<p_Nz; ++ks; @inner(2)){
				for(int j=0; j<p_Nq; ++j; @inner(1)){
					for(int i=0; i<p_Nq; ++i; @inner(0)){
						const int k = ko+ks;

						if(k<p_Nq){
							dfloat tmpr = 0, tmps = 0;

							#pragma unroll p_Nq
							for(int n=0;n<p_Nq;++n){
								tmpr += s_D[n][i]*s_q[ks][j][n];
								tmps += s_D[n][j]*s_q[ks][n][i];
							}
							r_Aq += tmpr;
							r_Aq += tmps;

							Aq[emap*p_Np+k*p_Nq*p_Nq + j*p_Nq + i] = r_Aq;
						}
					}
				}
			}
		}
	}

	for(int e=0; e<Nelements; ++e; @outer(0)){

		@shared dfloat s_q[p_Nz][p_Nq][p_Nq];
		@shared dfloat s_D[p_Nq][p_Nq+1];

		@exclusive int emap;
		@exclusive dfloat r_Aq;

		for(int k=0; k<p_Nz; ++k; @inner(2)){
			for(int j=0; j<p_Nq; ++j; @inner(1)){
				for(int i=0; i<p_Nq; ++i; @inner(0)){

					emap = elementList[e];

					if(k==0)
						s_D[j][i] = D[j*p_Nq+i];
				}
			}
		}

		for(int jo=0;jo<p_Nq;jo+=p_Nz){

			@barrier("local");

			for(int js=0; js<p_Nz; ++js; @inner(2)){
				for(int k=0; k<p_Nq; ++k; @inner(1)){
					for(int i=0; i<p_Nq; ++i; @inner(0)){
						int j = js+jo;
						if(j<p_Nq){
							s_q[js][k][i] = grad[emap*p_Np +  k*p_Nq*p_Nq + j*p_Nq + i];
						}
					}
				}
			}

			@barrier("local");

			for(int js=0; js<p_Nz; ++js; @inner(2)){
				for(int k=0; k<p_Nq; ++k; @inner(1)){
					for(int i=0; i<p_Nq; ++i; @inner(0)){
						int j = js+jo;
						if(j<p_Nq){
							dfloat tmpt = 0;

							#pragma unroll p_Nq
							for(int n=0;n<p_Nq;++n){
								tmpt += s_D[n][k]*s_q[js][n][i];
							}

							r_Aq += tmpt;

							Aq[emap*p_Np + k*p_Nq*p_Nq + j*p_Nq + i] += r_Aq;

						}
					}
				}
			}
		}
	}
}
#endif

@kernel void ellipticAxHex3D_slab1(const int Nelements,
                                  @restrict const  int *  elementList,
                                  @restrict const  dfloat *  ggeo,
                                  @restrict const  dfloat *  D,
                                  const dfloat lambda,
                                  @restrict const  dfloat *  q,
                                  @restrict dfloat *  Aq,
                                  @restrict const  dfloat *  grad){

	for(int e=0; e<Nelements; ++e; @outer(0)) {

		@shared dfloat s_tmpr[p_Nq][p_Nq+p_pad];
		@shared dfloat s_tmps[p_Nq][p_Nq+p_pad];
		@shared dfloat s_q[p_Nq][p_Nq+p_pad];
		@shared dfloat s_D[p_Nq][p_Nq+p_pad];

		@exclusive dfloat r_q[p_Nq], r_Aq[p_Nq], r_qt, r_tmpt;
		@exclusive int emap;
		@exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;

		// prefetch q(i,j,:,e) to register array
		for(int j=0; j<p_Nq; ++j; @inner(1)) {
			for(int i=0; i<p_Nq; ++i; @inner(0)) {

				emap = elementList[e];

				const int base = i + j*p_Nq + emap*p_Np;

				#pragma unroll p_Nq
				for(int k=0; k<p_Nq; ++k) {
					r_q[k] = q[base + k*p_Nq*p_Nq];
					r_Aq[k] = 0.f;
				}

				s_D[j][i] = D[j*p_Nq+i];
			}
		}

		@barrier("local");

		#pragma unroll p_Nq
		for(int k=0; k<p_Nq; ++k) {

			for(int j=0; j<p_Nq; ++j; @inner(1)) {
				for(int i=0; i<p_Nq; ++i; @inner(0)) {

					const int gbase = emap*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

					r_G00 = ggeo[gbase+p_G00ID*p_Np];
					r_G01 = ggeo[gbase+p_G01ID*p_Np];
					r_G02 = ggeo[gbase+p_G02ID*p_Np];
					r_G11 = ggeo[gbase+p_G11ID*p_Np];
					r_G12 = ggeo[gbase+p_G12ID*p_Np];
					r_G22 = ggeo[gbase+p_G22ID*p_Np];
					r_GwJ = ggeo[gbase+p_GWJID*p_Np];

					// share k-slice of q
					s_q[j][i] = r_q[k];

					// hide @shared latency behind t-derivative
					dfloat qtk = 0.f;
					#pragma unroll p_Nq
					for(int n=0; n<p_Nq; ++n) {
						qtk += s_D[k][n]*r_q[n];
					}
					r_qt = qtk;
				}
			}

			@barrier("local");

			// process k-slice (first r- and s-derivatives)
			for(int j=0; j<p_Nq; ++j; @inner(1)) {
				for(int i=0; i<p_Nq; ++i; @inner(0)) {
#if 0
					const int base = emap*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

					const dfloat r_G00 = ggeo[base+p_G00ID*p_Np];
					const dfloat r_G01 = ggeo[base+p_G01ID*p_Np];
					const dfloat r_G02 = ggeo[base+p_G02ID*p_Np];
					const dfloat r_G11 = ggeo[base+p_G11ID*p_Np];
					const dfloat r_G12 = ggeo[base+p_G12ID*p_Np];
					const dfloat r_G22 = ggeo[base+p_G22ID*p_Np];
					const dfloat r_GwJ = ggeo[base+p_GWJID*p_Np];
#endif

					dfloat qr = 0.f, qs = 0.f;
					#pragma unroll p_Nq
					for(int n=0; n<p_Nq; ++n) {
						qr += s_D[i][n]*s_q[j][n];
						qs += s_D[j][n]*s_q[n][i];
					}

					// assumes w*J built into r_G entries
					s_tmpr[j][i] = r_G00*qr + r_G01*qs + r_G02*r_qt;
					s_tmps[j][i] = r_G01*qr + r_G11*qs + r_G12*r_qt;
					r_tmpt           = r_G02*qr + r_G12*qs + r_G22*r_qt;

					r_Aq[k] += r_GwJ*lambda*r_q[k];

					#pragma unroll p_Nq
					for(int n=0; n<p_Nq; ++n) {
						r_Aq[n] += s_D[k][n]*r_tmpt;
					}
				}
			}

			@barrier("local");

			// second derivatives
			for(int j=0; j<p_Nq; ++j; @inner(1)) {
				for(int i=0; i<p_Nq; ++i; @inner(0)) {
					dfloat Aq1 = 0.0f, Aq2 = 0.0f;

					#pragma unroll p_Nq
					for(int n=0; n<p_Nq; ++n) {
						Aq1 += s_D[n][i]*s_tmpr[j][n];
						Aq2 += s_D[n][j]*s_tmps[n][i];
					}

					r_Aq[k] +=  Aq1 + Aq2;
				}
			}
		}

		// write result out (local node storage)
		for(int j=0; j<p_Nq; ++j; @inner(1)) {
			for(int i=0; i<p_Nq; ++i; @inner(0)) {
				int id = emap*p_Np + j*p_Nq + i;
				#pragma unroll p_Nq
				for(int k=0; k<p_Nq; ++k) {
					Aq[id] = r_Aq[k];
					id += p_Nq*p_Nq;
				}
			}
		}
	}
}



@kernel void ellipticAxHex3D_family1(const int Nelements,
                                    @restrict const  int *  elementList,
                                    @restrict const  dfloat *  ggeo,
                                    @restrict const  dfloat *  D,
                                    const dfloat lambda,
                                    @restrict const  dfloat *  q,
                                    @restrict dfloat *  Aq,
                                    @restrict const  dfloat *  grad){

	for(int e=0; e<Nelements; ++e; @outer(0)) {

		@shared dfloat s_tmpr[p_Nq][p_Nq];
		@shared dfloat s_tmps[p_Nq][p_Nq];
		@shared dfloat s_q[p_Nq][p_Nq];
		@shared dfloat s_D[p_Nq][p_Nq];
		@shared dfloat s_vgeo[p_Nvgeo];

		@exclusive dfloat r_q[p_Nq], r_Aq[p_Nq], r_qt, r_tmpt;
		@exclusive int emap;
		@exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;

		// prefetch q(i,j,:,e) to register array
		for(int j=0; j<p_Nq; ++j; @inner(1)) {
			for(int i=0; i<p_Nq; ++i; @inner(0)) {

				emap = elementList[e];

				const int base = i + j*p_Nq + emap*p_Np;

				#pragma unroll p_Nq
				for(int k=0; k<p_Nq; ++k) {
					r_q[k] = q[base + k*p_Nq*p_Nq];
					r_Aq[k] = 0.f;
				}

				s_D[j][i] = D[j*p_Nq+i];

				int t = i+j*p_Nq;
				while(t<p_Nvgeo){
					s_vgeo[t] = ggeo[4*p_Nggeo*p_Np + emap*p_Nvgeo + t];
					t += p_Nq*p_Nq;
				}

			}
		}

		@barrier("local");

		#pragma unroll p_Nq
		for(int k=0; k<p_Nq; ++k) {

			for(int j=0; j<p_Nq; ++j; @inner(1)) {
				for(int i=0; i<p_Nq; ++i; @inner(0)) {

					// share k-slice of q
					s_q[j][i] = r_q[k];

					const int gbase = (emap%4)*p_Nvgeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

					// for now just load Jacobian matrix
					const dfloat drda = ggeo[gbase+0*p_Np];
					const dfloat drdb = ggeo[gbase+1*p_Np];
					const dfloat drdc = ggeo[gbase+2*p_Np];
					const dfloat dsda = ggeo[gbase+3*p_Np];
					const dfloat dsdb = ggeo[gbase+4*p_Np];
					const dfloat dsdc = ggeo[gbase+5*p_Np];
					const dfloat dtda = ggeo[gbase+6*p_Np];
					const dfloat dtdb = ggeo[gbase+7*p_Np];
					const dfloat dtdc = ggeo[gbase+8*p_Np];
					const dfloat J    = ggeo[gbase+9*p_Np];
					// what about Jacobian

#define dadx s_vgeo[0]
#define dbdx s_vgeo[1]
#define dcdx s_vgeo[2]
#define dady s_vgeo[3]
#define dbdy s_vgeo[4]
#define dcdy s_vgeo[5]
#define dadz s_vgeo[6]
#define dbdz s_vgeo[7]
#define dcdz s_vgeo[8]
#define Jabc s_vgeo[9]

					const dfloat drdx = dadx*drda + dbdx*drdb + dcdx*drdc;
					const dfloat dsdx = dadx*dsda + dbdx*dsdb + dcdx*dsdc;
					const dfloat dtdx = dadx*dtda + dbdx*dtdb + dcdx*dtdc;

					const dfloat drdy = dady*drda + dbdy*drdb + dcdy*drdc;
					const dfloat dsdy = dady*dsda + dbdy*dsdb + dcdy*dsdc;
					const dfloat dtdy = dady*dtda + dbdy*dtdb + dcdy*dtdc;

					const dfloat drdz = dadz*drda + dbdz*drdb + dcdz*drdc;
					const dfloat dsdz = dadz*dsda + dbdz*dsdb + dcdz*dsdc;
					const dfloat dtdz = dadz*dtda + dbdz*dtdb + dcdz*dtdc;

					r_G00 = drdx*drdx + drdy*drdy + drdz*drdz;
					r_G01 = drdx*dsdx + drdy*dsdy + drdz*dsdz;
					r_G02 = drdx*dtdx + drdy*dtdy + drdz*dtdz;

					r_G11 = dsdx*dsdx + dsdy*dsdy + dsdz*dsdz;
					r_G12 = dsdx*dtdx + dsdy*dtdy + dsdz*dtdz;

					r_G22 = dtdx*dtdx + dtdy*dtdy + dtdz*dtdz;
					r_GwJ = J*Jabc;



					// hide @shared latency behind t-derivative
					dfloat qtk = 0.f;
					#pragma unroll p_Nq
					for(int n=0; n<p_Nq; ++n) {
						qtk += s_D[k][n]*r_q[n];
					}
					r_qt = qtk;

				}
			}

#ifdef LMF
			@barrier("local");
#else
			__threadfence_block();
#endif

			// process k-slice (first r- and s-derivatives)
			for(int j=0; j<p_Nq; ++j; @inner(1)) {
				for(int i=0; i<p_Nq; ++i; @inner(0)) {
#if 0
					const int base = emap*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

					const dfloat r_G00 = ggeo[base+p_G00ID*p_Np];
					const dfloat r_G01 = ggeo[base+p_G01ID*p_Np];
					const dfloat r_G02 = ggeo[base+p_G02ID*p_Np];
					const dfloat r_G11 = ggeo[base+p_G11ID*p_Np];
					const dfloat r_G12 = ggeo[base+p_G12ID*p_Np];
					const dfloat r_G22 = ggeo[base+p_G22ID*p_Np];
					const dfloat r_GwJ = ggeo[base+p_GWJID*p_Np];
#endif

					dfloat qr = 0.f, qs = 0.f;
					#pragma unroll p_Nq
					for(int n=0; n<p_Nq; ++n) {
						qr += s_D[i][n]*s_q[j][n];
						qs += s_D[j][n]*s_q[n][i];
					}

					// assumes w*J built into r_G entries
					s_tmpr[j][i] = r_G00*qr + r_G01*qs + r_G02*r_qt;
					s_tmps[j][i] = r_G01*qr + r_G11*qs + r_G12*r_qt;
					r_tmpt       = r_G02*qr + r_G12*qs + r_G22*r_qt;

					r_Aq[k] += r_GwJ*lambda*r_q[k];

					#pragma unroll p_Nq
					for(int n=0; n<p_Nq; ++n) {
						r_Aq[n] += s_D[k][n]*r_tmpt;
					}
				}
			}

#ifdef LMF
			@barrier("local");
#else
			__threadfence_block();
#endif

			// second derivatives
			for(int j=0; j<p_Nq; ++j; @inner(1)) {
				for(int i=0; i<p_Nq; ++i; @inner(0)) {
					dfloat Aq1 = 0.0f, Aq2 = 0.0f;

					#pragma unroll p_Nq
					for(int n=0; n<p_Nq; ++n) {
						Aq1 += s_D[n][i]*s_tmpr[j][n];
						Aq2 += s_D[n][j]*s_tmps[n][i];
					}

					r_Aq[k] +=  Aq1 + Aq2;
				}
			}
		}

		// write result out (local node storage)
		for(int j=0; j<p_Nq; ++j; @inner(1)) {
			for(int i=0; i<p_Nq; ++i; @inner(0)) {
				#pragma unroll p_Nq
				for(int k=0; k<p_Nq; ++k) {
					Aq[emap*p_Np+k*p_Nq*p_Nq+j*p_Nq+i] = r_Aq[k];
				}
			}
		}
	}
}



@kernel void ellipticAxHex3D_trilinear1(const int Nelements,
                                       @restrict const  int *  elementList,
                                       @restrict const  dfloat *  ggeo,
                                       @restrict const  dfloat *  D,
                                       const dfloat lambda,
                                       @restrict const  dfloat *  q,
                                       @restrict dfloat *  Aq,
                                       @restrict const  dfloat *  grad){

	for(int e=0; e<Nelements; ++e; @outer(0)) {

		@shared dfloat s_tmpr[p_Nq][p_Nq+p_pad];
		@shared dfloat s_tmps[p_Nq][p_Nq+p_pad];
		@shared dfloat s_q[p_Nq][p_Nq+p_pad];
		@shared dfloat s_D[p_Nq][p_Nq+p_pad];
		@shared dfloat s_EXYZ[9][3];
		@shared dfloat s_rw[2][p_Nq];

		@exclusive dfloat r_q[p_Nq];
		@exclusive dfloat r_Aq[p_Nq], r_qt, r_tmpt;
		@exclusive int emap;
		@exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22;
		@exclusive dfloat r_GwJ;

		// prefetch q(i,j,:,e) to register array
		for(int j=0; j<p_Nq; ++j; @inner(1)) {
			for(int i=0; i<p_Nq; ++i; @inner(0)) {

				emap = elementList[e];

				s_D[i][j] = D[j*p_Nq+i];

				int t = i+j*p_Nq;

				while(t<2*p_Nq){
					s_rw[0][t] = ggeo[t];
					t += p_Nq*p_Nq;
				}

				t = i+j*p_Nq;
				while(t<9*3){ // 54
					s_EXYZ[0][t] = ggeo[2*p_Nq + emap*p_Nverts*9 + t];
					t += p_Nq*p_Nq;
				}

				const int base = i + j*p_Nq + emap*p_Np;

				#pragma unroll p_Nq
				for(int k=0; k<p_Nq; ++k) {
					r_q[k] = q[base + k*p_Nq*p_Nq];
					r_Aq[k] = 0.f;
				}
			}
		}

		@barrier("local");

		#pragma unroll p_Nq
		for(int k=0; k<p_Nq; ++k) {

			for(int j=0; j<p_Nq; ++j; @inner(1)) {
				for(int i=0; i<p_Nq; ++i; @inner(0)) {

					/* local node coordinates */
					const dfloat rn = s_rw[0][i];
					const dfloat sn = s_rw[0][j];
					const dfloat tn = s_rw[0][k];

					const dfloat xr = (1.-tn)*(1.-sn)*(s_EXYZ[0][0]) + (1.-tn)*(1.+sn)*(s_EXYZ[0][1]) + (1.+tn)*(1.-sn)*(s_EXYZ[0][2]);
					const dfloat xs = (1.-tn)*(1.-rn)*(s_EXYZ[1][0]) + (1.-tn)*(1.+rn)*(s_EXYZ[1][1]) + (1.+tn)*(1.-rn)*(s_EXYZ[1][2]);
					const dfloat xt = (1.-rn)*(1.-sn)*(s_EXYZ[2][0]) + (1.+rn)*(1.-sn)*(s_EXYZ[2][1]) + (1.+rn)*(1.+sn)*(s_EXYZ[2][2]);

					const dfloat yr = (1.-tn)*(1.-sn)*(s_EXYZ[3][0]) + (1.-tn)*(1.+sn)*(s_EXYZ[3][1]) + (1.+tn)*(1.-sn)*(s_EXYZ[3][2]);
					const dfloat ys = (1.-tn)*(1.-rn)*(s_EXYZ[4][0]) + (1.-tn)*(1.+rn)*(s_EXYZ[4][1]) + (1.+tn)*(1.-rn)*(s_EXYZ[4][2]);
					const dfloat yt = (1.-rn)*(1.-sn)*(s_EXYZ[5][0]) + (1.+rn)*(1.-sn)*(s_EXYZ[5][1]) + (1.+rn)*(1.+sn)*(s_EXYZ[5][2]);

					const dfloat zr = (1.-tn)*(1.-sn)*(s_EXYZ[6][0]) + (1.-tn)*(1.+sn)*(s_EXYZ[6][1]) + (1.+tn)*(1.-sn)*(s_EXYZ[6][2]);
					const dfloat zs = (1.-tn)*(1.-rn)*(s_EXYZ[7][0]) + (1.-tn)*(1.+rn)*(s_EXYZ[7][1]) + (1.+tn)*(1.-rn)*(s_EXYZ[7][2]);
					const dfloat zt = (1.-rn)*(1.-sn)*(s_EXYZ[8][0]) + (1.+rn)*(1.-sn)*(s_EXYZ[8][1]) + (1.+rn)*(1.+sn)*(s_EXYZ[8][2]);

					/* compute geometric factors for affine coordinate transform*/
					const dfloat J = xr*(ys*zt-zs*yt) - yr*(xs*zt-zs*xt) + zr*(xs*yt-ys*xt);
					const dfloat Jinv = 1./J;

					const dfloat rx =  (ys*zt - zs*yt), ry = -(xs*zt - zs*xt), rz =  (xs*yt - ys*xt); // removed Jinv factor to below
					const dfloat sx = -(yr*zt - zr*yt), sy =  (xr*zt - zr*xt), sz = -(xr*yt - yr*xt);
					const dfloat tx =  (yr*zs - zr*ys), ty = -(xr*zs - zr*xs), tz =  (xr*ys - yr*xs);

					const dfloat JW = J*s_rw[1][i]*s_rw[1][j]*s_rw[1][k];

					/* store second order geometric factors */
					r_G00 = Jinv*(rx*rx + ry*ry + rz*rz); // removed J factor to below
					r_G01 = Jinv*(rx*sx + ry*sy + rz*sz);
					r_G02 = Jinv*(rx*tx + ry*ty + rz*tz);
					r_G11 = Jinv*(sx*sx + sy*sy + sz*sz);
					r_G12 = Jinv*(sx*tx + sy*ty + sz*tz);
					r_G22 = Jinv*(tx*tx + ty*ty + tz*tz);
					r_GwJ = JW;

					// share k-slice of q
					s_q[j][i] = r_q[k];


					// hide @shared latency behind t-derivative
					dfloat qtk = 0.f;
					#pragma unroll p_Nq
					for(int n=0; n<p_Nq; ++n) {
						qtk += s_D[k][n]*r_q[n];
					}
					r_qt = qtk;

				}
			}

			@barrier("local");

			for(int j=0; j<p_Nq; ++j; @inner(1)) {
				for(int i=0; i<p_Nq; ++i; @inner(0)) {

					// process k-slice (first r- and s-derivatives)

					dfloat qr = 0.f, qs = 0.f;
					#pragma unroll p_Nq
					for(int n=0; n<p_Nq; ++n) {
						qr += s_D[i][n]*s_q[j][n];
						qs += s_D[j][n]*s_q[n][i];
						//		qr += __ldg(D+n*p_Nq+i)*s_q[j][n];
					}

					// assumes w*J built into r_G entries
					s_tmpr[j][i] = (r_G00*qr + r_G01*qs + r_G02*r_qt); // put back J/(J^2)
					s_tmps[j][i] = (r_G01*qr + r_G11*qs + r_G12*r_qt); // note switch
					r_tmpt = (r_G02*qr + r_G12*qs + r_G22*r_qt);

				}
			}

			@barrier("local");

			// second derivatives
			for(int j=0; j<p_Nq; ++j; @inner(1)) {
				for(int i=0; i<p_Nq; ++i; @inner(0)) {
					dfloat Aq1 = 0.0f, Aq2 = 0.0f;

					#pragma unroll p_Nq
					for(int n=0; n<p_Nq; ++n) {
						Aq1 += s_D[n][i]*s_tmpr[j][n];
						Aq2 += s_D[n][j]*s_tmps[n][i];
					}

					//r_Aq[k] +=  Aq1 + Aq2 + r_GwJ*lambda*s_q[j][i];
					Aq[emap*p_Np+k*p_Nq*p_Nq+j*p_Nq+i] =  Aq1 + Aq2 + r_GwJ*lambda*s_q[j][i];

					#pragma unroll p_Nq
					for(int n=0; n<p_Nq; ++n) {
						r_Aq[n] += s_D[k][n]*r_tmpt;
					}
				}
			}
		}

		// write result out (local node storage)
		for(int j=0; j<p_Nq; ++j; @inner(1)) {
			for(int i=0; i<p_Nq; ++i; @inner(0)) {
				#pragma unroll p_Nq
				for(int k=0; k<p_Nq; ++k) {
					Aq[emap*p_Np+k*p_Nq*p_Nq+j*p_Nq+i] += r_Aq[k];
				}
			}
		}
	}
}



@kernel void ellipticAxHex3D_trilinear2(const int Nelements,
                                       @restrict const  int *  elementList,
                                       @restrict const  dfloat *  ggeo,
                                       @restrict const  dfloat *  D,
                                       const dfloat lambda,
                                       @restrict const  dfloat *  q,
                                       @restrict dfloat *  Aq,
                                       @restrict const  dfloat *  grad){

	for(int e=0; e<Nelements; ++e; @outer(0)) {

		@shared dfloat s_tmpr[p_Nq][p_Nq+p_pad];
		@shared dfloat s_tmps[p_Nq][p_Nq+p_pad];
		@shared dfloat s_q[p_Nq][p_Nq+p_pad];
		@shared dfloat s_D[p_Nq][p_Nq+p_pad];
		@shared dfloat s_EXYZ[9][3];
		@shared dfloat s_rw[2][p_Nq];

		@exclusive dfloat r_Aq[p_Nq], r_qt, r_tmpt;
		@exclusive int emap;
		@exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22;
		@exclusive dfloat r_GwJ;

		// prefetch q(i,j,:,e) to register array
		for(int j=0; j<p_Nq; ++j; @inner(1)) {
			for(int i=0; i<p_Nq; ++i; @inner(0)) {

				int t = i+j*p_Nq;

				while(t<2*p_Nq){
					s_rw[0][t] = __ldg(ggeo+t);
					t += p_Nq*p_Nq;
				}

				t = i+j*p_Nq;
				while(t<9*3){ // 54
					s_EXYZ[0][t] = ggeo[2*p_Nq + emap*p_Nverts*9 + t];
					t += p_Nq*p_Nq;
				}

				emap = elementList[e];

				s_D[j][i] = __ldg(D+j*p_Nq+i);

				#pragma unroll p_Nq
				for(int k=0; k<p_Nq; ++k) {
					r_Aq[k] = 0.f;
				}


			}
		}

		@barrier("local");

		// do horizontal slabs
		#pragma unroll p_Nq
		for(int k=0; k<p_Nq; ++k) {

			for(int j=0; j<p_Nq; ++j; @inner(1)) {
				for(int i=0; i<p_Nq; ++i; @inner(0)) {

					/* local node coordinates */
					const dfloat rn = s_rw[0][i];
					const dfloat sn = s_rw[0][j];
					const dfloat tn = s_rw[0][k];

					const dfloat xr = (1.-tn)*(1.-sn)*(s_EXYZ[0][0]) + (1.-tn)*(1.+sn)*(s_EXYZ[0][1]) + (1.+tn)*(1.-sn)*(s_EXYZ[0][2]);
					const dfloat xs = (1.-tn)*(1.-rn)*(s_EXYZ[1][0]) + (1.-tn)*(1.+rn)*(s_EXYZ[1][1]) + (1.+tn)*(1.-rn)*(s_EXYZ[1][2]);
					const dfloat xt = (1.-rn)*(1.-sn)*(s_EXYZ[2][0]) + (1.+rn)*(1.-sn)*(s_EXYZ[2][1]) + (1.+rn)*(1.+sn)*(s_EXYZ[2][2]);

					const dfloat yr = (1.-tn)*(1.-sn)*(s_EXYZ[3][0]) + (1.-tn)*(1.+sn)*(s_EXYZ[3][1]) + (1.+tn)*(1.-sn)*(s_EXYZ[3][2]);
					const dfloat ys = (1.-tn)*(1.-rn)*(s_EXYZ[4][0]) + (1.-tn)*(1.+rn)*(s_EXYZ[4][1]) + (1.+tn)*(1.-rn)*(s_EXYZ[4][2]);
					const dfloat yt = (1.-rn)*(1.-sn)*(s_EXYZ[5][0]) + (1.+rn)*(1.-sn)*(s_EXYZ[5][1]) + (1.+rn)*(1.+sn)*(s_EXYZ[5][2]);

					const dfloat zr = (1.-tn)*(1.-sn)*(s_EXYZ[6][0]) + (1.-tn)*(1.+sn)*(s_EXYZ[6][1]) + (1.+tn)*(1.-sn)*(s_EXYZ[6][2]);
					const dfloat zs = (1.-tn)*(1.-rn)*(s_EXYZ[7][0]) + (1.-tn)*(1.+rn)*(s_EXYZ[7][1]) + (1.+tn)*(1.-rn)*(s_EXYZ[7][2]);
					const dfloat zt = (1.-rn)*(1.-sn)*(s_EXYZ[8][0]) + (1.+rn)*(1.-sn)*(s_EXYZ[8][1]) + (1.+rn)*(1.+sn)*(s_EXYZ[8][2]);

					/* compute geometric factors for affine coordinate transform*/
					const dfloat J = xr*(ys*zt-zs*yt) - yr*(xs*zt-zs*xt) + zr*(xs*yt-ys*xt);
					const dfloat Jinv = 1./J;

					const dfloat rx =  (ys*zt - zs*yt), ry = -(xs*zt - zs*xt), rz =  (xs*yt - ys*xt); // removed Jinv factor to below
					const dfloat sx = -(yr*zt - zr*yt), sy =  (xr*zt - zr*xt), sz = -(xr*yt - yr*xt);
					const dfloat tx =  (yr*zs - zr*ys), ty = -(xr*zs - zr*xs), tz =  (xr*ys - yr*xs);

					const dfloat JW = J*s_rw[1][i]*s_rw[1][j]*s_rw[1][k];

					/* store second order geometric factors */
					r_G00 = Jinv*(rx*rx + ry*ry + rz*rz); // removed J factor to below
					r_G01 = Jinv*(rx*sx + ry*sy + rz*sz);
					r_G02 = Jinv*(rx*tx + ry*ty + rz*tz);
					r_G11 = Jinv*(sx*sx + sy*sy + sz*sz);
					r_G12 = Jinv*(sx*tx + sy*ty + sz*tz);
					r_GwJ = JW;

					// share k-slice of q
					s_q[j][i] = q[emap*p_Np+k*p_Nq*p_Nq+j*p_Nq+i];
				}
			}

			@barrier("local");

			for(int j=0; j<p_Nq; ++j; @inner(1)) {
				for(int i=0; i<p_Nq; ++i; @inner(0)) {

					// process k-slice (first r- and s-derivatives)

					dfloat qr = 0.f, qs = 0.f;
					#pragma unroll p_Nq
					for(int n=0; n<p_Nq; ++n) {
						qr += s_D[i][n]*s_q[j][n];
						qs += s_D[j][n]*s_q[n][i];
					}

					// assumes w*J built into r_G entries
					s_tmpr[j][i] = (r_G00*qr + r_G01*qs); // put back J/(J^2)
					s_tmps[j][i] = (r_G01*qr + r_G11*qs);
					r_tmpt       = (r_G02*qr + r_G12*qs);

					#pragma unroll p_Nq
					for(int n=0; n<p_Nq; ++n) {
						r_Aq[n] += s_D[k][n]*r_tmpt;
					}
				}
			}

			@barrier("local");

			// second derivatives
			for(int j=0; j<p_Nq; ++j; @inner(1)) {
				for(int i=0; i<p_Nq; ++i; @inner(0)) {
					dfloat Aq1 = 0.0f, Aq2 = 0.0f;

					#pragma unroll p_Nq
					for(int n=0; n<p_Nq; ++n) {
						Aq1 += s_D[n][i]*s_tmpr[j][n];
						Aq2 += s_D[n][j]*s_tmps[n][i];
					}

					r_Aq[k] +=  Aq1 + Aq2 + r_GwJ*lambda*s_q[j][i];
				}
			}
		}


		// do vertical (i.k) slabs
		#pragma unroll p_Nq
		for(int j=0; j<p_Nq; ++j) {

			for(int k=0; k<p_Nq; ++k; @inner(1)) {
				for(int i=0; i<p_Nq; ++i; @inner(0)) {

					/* local node coordinates */
					const dfloat rn = s_rw[0][i];
					const dfloat sn = s_rw[0][j];
					const dfloat tn = s_rw[0][k];

					const dfloat xr = (1.-tn)*(1.-sn)*(s_EXYZ[0][0]) + (1.-tn)*(1.+sn)*(s_EXYZ[0][1]) + (1.+tn)*(1.-sn)*(s_EXYZ[0][2]);
					const dfloat xs = (1.-tn)*(1.-rn)*(s_EXYZ[1][0]) + (1.-tn)*(1.+rn)*(s_EXYZ[1][1]) + (1.+tn)*(1.-rn)*(s_EXYZ[1][2]);
					const dfloat xt = (1.-rn)*(1.-sn)*(s_EXYZ[2][0]) + (1.+rn)*(1.-sn)*(s_EXYZ[2][1]) + (1.+rn)*(1.+sn)*(s_EXYZ[2][2]);

					const dfloat yr = (1.-tn)*(1.-sn)*(s_EXYZ[3][0]) + (1.-tn)*(1.+sn)*(s_EXYZ[3][1]) + (1.+tn)*(1.-sn)*(s_EXYZ[3][2]);
					const dfloat ys = (1.-tn)*(1.-rn)*(s_EXYZ[4][0]) + (1.-tn)*(1.+rn)*(s_EXYZ[4][1]) + (1.+tn)*(1.-rn)*(s_EXYZ[4][2]);
					const dfloat yt = (1.-rn)*(1.-sn)*(s_EXYZ[5][0]) + (1.+rn)*(1.-sn)*(s_EXYZ[5][1]) + (1.+rn)*(1.+sn)*(s_EXYZ[5][2]);

					const dfloat zr = (1.-tn)*(1.-sn)*(s_EXYZ[6][0]) + (1.-tn)*(1.+sn)*(s_EXYZ[6][1]) + (1.+tn)*(1.-sn)*(s_EXYZ[6][2]);
					const dfloat zs = (1.-tn)*(1.-rn)*(s_EXYZ[7][0]) + (1.-tn)*(1.+rn)*(s_EXYZ[7][1]) + (1.+tn)*(1.-rn)*(s_EXYZ[7][2]);
					const dfloat zt = (1.-rn)*(1.-sn)*(s_EXYZ[8][0]) + (1.+rn)*(1.-sn)*(s_EXYZ[8][1]) + (1.+rn)*(1.+sn)*(s_EXYZ[8][2]);

					/* compute geometric factors for affine coordinate transform*/
					const dfloat J = xr*(ys*zt-zs*yt) - yr*(xs*zt-zs*xt) + zr*(xs*yt-ys*xt);
					const dfloat Jinv = 1./J;

					const dfloat rx =  (ys*zt - zs*yt), ry = -(xs*zt - zs*xt), rz =  (xs*yt - ys*xt); // removed Jinv factor to below
					const dfloat sx = -(yr*zt - zr*yt), sy =  (xr*zt - zr*xt), sz = -(xr*yt - yr*xt);
					const dfloat tx =  (yr*zs - zr*ys), ty = -(xr*zs - zr*xs), tz =  (xr*ys - yr*xs);

					const dfloat JW = J*s_rw[1][i]*s_rw[1][j]*s_rw[1][k];

					/* store second order geometric factors */
					r_G02 = Jinv*(rx*tx + ry*ty + rz*tz);
					r_G12 = Jinv*(sx*tx + sy*ty + sz*tz);
					r_G22 = Jinv*(tx*tx + ty*ty + tz*tz);
					r_GwJ = JW;

					// share k-slice of q
					s_q[k][i] = q[emap*p_Np+k*p_Nq*p_Nq+j*p_Nq+i];

				}
			}

			@barrier("local");

			for(int k=0; k<p_Nq; ++k; @inner(1)) {
				for(int i=0; i<p_Nq; ++i; @inner(0)) {

					// hide @shared latency behind t-derivative
					dfloat qtk = 0.f;
					#pragma unroll p_Nq
					for(int n=0; n<p_Nq; ++n) {
						qtk += s_D[k][n]*s_q[n][i];
					}
					r_qt = qtk;

					// assumes w*J built into r_G entries
					s_tmpr[j][i] = (r_G02*r_qt); // put back J/(J^2)
					s_tmps[j][i] = (r_G12*r_qt);
					r_tmpt       = (r_G22*r_qt);

					#pragma unroll p_Nq
					for(int n=0; n<p_Nq; ++n) {
						r_Aq[n] += s_D[k][n]*r_tmpt;
					}
				}
			}

			@barrier("local");

			// second derivatives
			for(int k=0; k<p_Nq; ++k; @inner(1)) {
				for(int i=0; i<p_Nq; ++i; @inner(0)) {
					dfloat Aq1 = 0.0f, Aq2 = 0.0f;

					#pragma unroll p_Nq
					for(int n=0; n<p_Nq; ++n) {
						Aq1 += s_D[n][i]*s_tmpr[j][n];
						Aq2 += s_D[n][j]*s_tmps[n][i];
					}

					r_Aq[k] +=  Aq1 + Aq2;
				}
			}
		}


		// write result out (local node storage)
		for(int j=0; j<p_Nq; ++j; @inner(1)) {
			for(int i=0; i<p_Nq; ++i; @inner(0)) {
				#pragma unroll p_Nq
				for(int k=0; k<p_Nq; ++k) {
					Aq[emap*p_Np+k*p_Nq*p_Nq+j*p_Nq+i] = r_Aq[k];
				}
			}
		}
	}
}
#define p_Nslabs 4
@kernel void ellipticAxHex3D_trilinear3(const int Nelements,
                                       @restrict const  int *  elementList,
                                       @restrict const  dfloat *  ggeo,
                                       @restrict const  dfloat *  D,
                                       const dfloat lambda,
                                       @restrict const  dfloat *  q,
                                       @restrict dfloat *  Aq,
                                       @restrict const  dfloat *  grad){

	// assume multiple of 4

	for(int e=0; e<Nelements; ++e; @outer(0)) {

		@shared dfloat s_q[p_Nslabs][p_Nq][p_Nq+p_pad];
		@shared dfloat s_tmp1[p_Nslabs][p_Nq][p_Nq+p_pad];
		@shared dfloat s_tmp2[p_Nslabs][p_Nq][p_Nq+p_pad];
		@shared dfloat s_D[p_Nq][p_Nq+p_pad];
		@shared dfloat s_EXYZ[9][3];
			@shared dfloat s_rw[2][p_Nq];
			@exclusive dfloat G00, G01, G11, G02,  G12, G22, GwJ;

		@exclusive int emap;

		for(int ks=0;ks<p_Nslabs;++ks;@inner(2)){
			for(int j=0;j<p_Nq;++j;@inner(1)){
				for(int i=0;i<p_Nq;++i;@inner(0)){
					emap = elementList[e];
					if(ks==0){
						s_D[j][i] = D[j*p_Nq+i];
	// KS: code starts
		// load the other data structires (node coefficients, weights etc)
		int t = i+j*p_Nq;				
		while(t<2*p_Nq){
							s_rw[0][t] = ggeo[t];
							t += p_Nq*p_Nq;
						}

						t = i+j*p_Nq;
						while(t<9*3){ // 54
							s_EXYZ[0][t] = ggeo[2*p_Nq + emap*p_Nverts*9 + t];
							t += p_Nq*p_Nq;
						}
 //KS: code ends
					}
				}
			}
		}


		for(int kslab=0;kslab<p_Nslabs;++kslab){

			for(int ks=0;ks<p_Nslabs;++ks;@inner(2)){
				for(int j=0;j<p_Nq;++j;@inner(1)){
					for(int i=0;i<p_Nq;++i;@inner(0)){
						const int t = i+j*p_Nq+ks*p_Nq*p_Nq;
						const int iT = t&3;
						const int jT = (t>>2)&3;
						const int kT = (t>>4)&3;
						const int iB = (t>>6)&3;
						const int jB = (t>>8)&3;
						const int kB = kslab;

						s_q[kT][jB*4+jT][iB*4+iT] = q[iT+jT*4+kT*16+iB*64+jB*256+kB*1024];
					}
				}
			}

			@barrier("local");

			for(int ks=0;ks<p_Nslabs;++ks;@inner(2)){
				for(int j=0;j<p_Nq;++j;@inner(1)){
					for(int i=0;i<p_Nq;++i;@inner(0)){
						dfloat tmpr = 0, tmps = 0;

						for(int n=0;n<p_Nq;++n){
							tmpr += s_D[i][n]*s_q[ks][j][n];
							tmps += s_D[j][n]*s_q[ks][n][i];
						}

						
						// TW to-do: compute geofacs here by function call ? might need to move this earlier ?
            //KS: can try here but reg count would sky rocket
		        int k = kslab+ks;
            const dfloat rn = s_rw[0][i];
						const dfloat sn = s_rw[0][j];
						const dfloat tn = s_rw[0][k];

						const dfloat xr = (1.-tn)*(1.-sn)*(s_EXYZ[0][0]) + (1.-tn)*(1.+sn)*(s_EXYZ[0][1]) + (1.+tn)*(1.-sn)*(s_EXYZ[0][2]);
						const dfloat xs = (1.-tn)*(1.-rn)*(s_EXYZ[1][0]) + (1.-tn)*(1.+rn)*(s_EXYZ[1][1]) + (1.+tn)*(1.-rn)*(s_EXYZ[1][2]);
						const dfloat xt = (1.-rn)*(1.-sn)*(s_EXYZ[2][0]) + (1.+rn)*(1.-sn)*(s_EXYZ[2][1]) + (1.+rn)*(1.+sn)*(s_EXYZ[2][2]);

						const dfloat yr = (1.-tn)*(1.-sn)*(s_EXYZ[3][0]) + (1.-tn)*(1.+sn)*(s_EXYZ[3][1]) + (1.+tn)*(1.-sn)*(s_EXYZ[3][2]);
						const dfloat ys = (1.-tn)*(1.-rn)*(s_EXYZ[4][0]) + (1.-tn)*(1.+rn)*(s_EXYZ[4][1]) + (1.+tn)*(1.-rn)*(s_EXYZ[4][2]);
						const dfloat yt = (1.-rn)*(1.-sn)*(s_EXYZ[5][0]) + (1.+rn)*(1.-sn)*(s_EXYZ[5][1]) + (1.+rn)*(1.+sn)*(s_EXYZ[5][2]);

						const dfloat zr = (1.-tn)*(1.-sn)*(s_EXYZ[6][0]) + (1.-tn)*(1.+sn)*(s_EXYZ[6][1]) + (1.+tn)*(1.-sn)*(s_EXYZ[6][2]);
						const dfloat zs = (1.-tn)*(1.-rn)*(s_EXYZ[7][0]) + (1.-tn)*(1.+rn)*(s_EXYZ[7][1]) + (1.+tn)*(1.-rn)*(s_EXYZ[7][2]);
						const dfloat zt = (1.-rn)*(1.-sn)*(s_EXYZ[8][0]) + (1.+rn)*(1.-sn)*(s_EXYZ[8][1]) + (1.+rn)*(1.+sn)*(s_EXYZ[8][2]);

						
						const dfloat J = xr*(ys*zt-zs*yt) - yr*(xs*zt-zs*xt) + zr*(xs*yt-ys*xt);
						const dfloat Jinv = 1./J;

						const dfloat rx =  (ys*zt - zs*yt), ry = -(xs*zt - zs*xt), rz =  (xs*yt - ys*xt); // removed Jinv factor to below
						const dfloat sx = -(yr*zt - zr*yt), sy =  (xr*zt - zr*xt), sz = -(xr*yt - yr*xt);
				

						
						G00 = Jinv*(rx*rx + ry*ry + rz*rz); // removed J factor to below
						G01 = Jinv*(rx*sx + ry*sy + rz*sz);
					
						G11 = Jinv*(sx*sx + sy*sy + sz*sz);
							
						s_tmp1[ks][j][i] = tmpr;
						//G00*tmpr + G01*tmps;
						s_tmp2[ks][j][i] = tmps;
						//G01*tmpr + G11*tmps;
					}
				}
			}

			@barrier("local");

			for(int ks=0;ks<p_Nslabs;++ks;@inner(2)){
				for(int j=0;j<p_Nq;++j;@inner(1)){
					for(int i=0;i<p_Nq;++i;@inner(0)){
						dfloat tmpr = 0, tmps = 0;
						
						
						
						
						for(int n=0;n<p_Nq;++n){
							tmpr += s_D[n][i]*(G00*s_tmp1[ks][j][n]+G01*s_tmp2[ks][j][n]);
							tmps += s_D[n][j]*(G01*s_tmp1[ks][n][i]+G11*s_tmp1[ks][n][i]);
						}
						s_q[ks][j][i] = tmpr+tmps;
					
				
				
					}
				}
			}

			@barrier("local");

			for(int ks=0;ks<p_Nslabs;++ks;@inner(2)){
				for(int j=0;j<p_Nq;++j;@inner(1)){
					for(int i=0;i<p_Nq;++i;@inner(0)){

						const int t = i+j*p_Nq+ks*p_Nq*p_Nq;
						const int iT = t&3;
						const int jT = (t>>2)&3;
						const int kT = (t>>4)&3;
						const int iB = (t>>6)&3;
						const int jB = (t>>8)&3;
						const int kB = kslab;

						Aq[iT+jT*4+kT*16+iB*64+jB*256+kB*1024] = s_q[kT][jB*4+jT][iB*4+iT];
					}
				}
			}
		} // end of kslabbing

		@barrier("global");

		for(int jslab=0;jslab<p_Nslabs;++jslab){

			for(int js=0;js<p_Nslabs;++js;@inner(2)){
				for(int k=0;k<p_Nq;++k;@inner(1)){
					for(int i=0;i<p_Nq;++i;@inner(0)){

						const int t = i+k*p_Nq+js*p_Nq*p_Nq;
						const int iT = t&3;
						const int jT = (t>>2)&3;
						const int kT = (t>>4)&3;
						const int iB = (t>>6)&3;
						const int jB = jslab;
						const int kB = (t>>8)&3;

						s_q[jT][kB*4+kT][iB*4+iT] = q[iT+jT*4+kT*16+iB*64+jB*256+kB*1024];
					}
				}
			}

			@barrier("local");

			for(int js=0;js<p_Nslabs;++js;@inner(2)){
				for(int k=0;k<p_Nq;++k;@inner(1)){
					for(int i=0;i<p_Nq;++i;@inner(0)){
						dfloat tmpr = 0, tmpt = 0;

						for(int n=0;n<p_Nq;++n){
							tmpr += s_D[i][n]*s_q[js][k][n];
							tmpt += s_D[k][n]*s_q[js][n][i];
						}

					
						// TW to-do: compute geofacs here by function call ?
						//KS: here it goes
						int j = js + jslab;
						const dfloat rn = s_rw[0][i];
						const dfloat sn = s_rw[0][j];
						const dfloat tn = s_rw[0][k];

						const dfloat xr = (1.-tn)*(1.-sn)*(s_EXYZ[0][0]) + (1.-tn)*(1.+sn)*(s_EXYZ[0][1]) + (1.+tn)*(1.-sn)*(s_EXYZ[0][2]);
						const dfloat xs = (1.-tn)*(1.-rn)*(s_EXYZ[1][0]) + (1.-tn)*(1.+rn)*(s_EXYZ[1][1]) + (1.+tn)*(1.-rn)*(s_EXYZ[1][2]);
						const dfloat xt = (1.-rn)*(1.-sn)*(s_EXYZ[2][0]) + (1.+rn)*(1.-sn)*(s_EXYZ[2][1]) + (1.+rn)*(1.+sn)*(s_EXYZ[2][2]);

						const dfloat yr = (1.-tn)*(1.-sn)*(s_EXYZ[3][0]) + (1.-tn)*(1.+sn)*(s_EXYZ[3][1]) + (1.+tn)*(1.-sn)*(s_EXYZ[3][2]);
						const dfloat ys = (1.-tn)*(1.-rn)*(s_EXYZ[4][0]) + (1.-tn)*(1.+rn)*(s_EXYZ[4][1]) + (1.+tn)*(1.-rn)*(s_EXYZ[4][2]);
						const dfloat yt = (1.-rn)*(1.-sn)*(s_EXYZ[5][0]) + (1.+rn)*(1.-sn)*(s_EXYZ[5][1]) + (1.+rn)*(1.+sn)*(s_EXYZ[5][2]);

						const dfloat zr = (1.-tn)*(1.-sn)*(s_EXYZ[6][0]) + (1.-tn)*(1.+sn)*(s_EXYZ[6][1]) + (1.+tn)*(1.-sn)*(s_EXYZ[6][2]);
						const dfloat zs = (1.-tn)*(1.-rn)*(s_EXYZ[7][0]) + (1.-tn)*(1.+rn)*(s_EXYZ[7][1]) + (1.+tn)*(1.-rn)*(s_EXYZ[7][2]);
						const dfloat zt = (1.-rn)*(1.-sn)*(s_EXYZ[8][0]) + (1.+rn)*(1.-sn)*(s_EXYZ[8][1]) + (1.+rn)*(1.+sn)*(s_EXYZ[8][2]);

						
						const dfloat J = xr*(ys*zt-zs*yt) - yr*(xs*zt-zs*xt) + zr*(xs*yt-ys*xt);
						const dfloat Jinv = 1./J;

						const dfloat rx =  (ys*zt - zs*yt), ry = -(xs*zt - zs*xt), rz =  (xs*yt - ys*xt); // removed Jinv factor to below
						const dfloat tx =  (yr*zs - zr*ys), ty = -(xr*zs - zr*xs), tz =  (xr*ys - yr*xs);
						
						G00 = Jinv*(rx*rx + ry*ry + rz*rz); // removed J factor to below						
						G02 = Jinv*(rx*tx + ry*ty + rz*tz);				
						G22 = Jinv*(tx*tx + ty*ty + tz*tz);

						s_tmp1[js][k][i] = tmpr;
						//G00*tmpr + G02*tmpt;
						s_tmp2[js][k][i] = tmpt;
						//G02*tmpr + G22*tmpt;
					}
				}
			}

			@barrier("local");

			for(int js=0;js<p_Nslabs;++js;@inner(2)){
				for(int k=0;k<p_Nq;++k;@inner(1)){
					for(int i=0;i<p_Nq;++i;@inner(0)){
						dfloat tmpr = 0, tmpt = 0;
						for(int n=0;n<p_Nq;++n){
							tmpr += s_D[n][i]*(G00*s_tmp1[js][k][n]+G02*s_tmp2[js][k][n]);
							tmpt += s_D[n][k]*(G02*s_tmp1[js][n][i]+G22*s_tmp2[js][n][i]);
						}
						s_q[js][k][i] = tmpr+tmpt;
			
				
					}
				}
			}

			@barrier("local");

			for(int js=0;js<p_Nslabs;++js;@inner(2)){
				for(int k=0;k<p_Nq;++k;@inner(1)){
					for(int i=0;i<p_Nq;++i;@inner(0)){

						const int t = i+k*p_Nq+js*p_Nq*p_Nq;
						const int iT = t&3;
						const int jT = (t>>2)&3;
						const int kT = (t>>4)&3;
						const int iB = (t>>6)&3;
						const int jB = jslab;
						const int kB = (t>>8)&3;

						Aq[iT+jT*4+kT*16+iB*64+jB*256+kB*1024] += s_q[jT][kB*4+kT][iB*4+iT];
					}
				}
			}
		} // end of jslabbing

		@barrier("global");

		for(int islab=0;islab<p_Nslabs;++islab){

			for(int is=0;is<p_Nslabs;++is;@inner(2)){
				for(int k=0;k<p_Nq;++k;@inner(1)){
					for(int j=0;j<p_Nq;++j;@inner(0)){

						const int t = j+k*p_Nq+is*p_Nq*p_Nq;
						const int iT = t&3;
						const int jT = (t>>2)&3;
						const int kT = (t>>4)&3;
						const int iB = islab;
						const int jB = (t>>6)&3;
						const int kB = (t>>8)&3;

						s_q[iT][kB*4+kT][jB*4+jT] = q[iT+jT*4+kT*16+iB*64+jB*256+kB*1024];
					}
				}
			}

			@barrier("local");

			for(int is=0;is<p_Nslabs;++is;@inner(2)){
				for(int k=0;k<p_Nq;++k;@inner(1)){
					for(int j=0;j<p_Nq;++j;@inner(0)){

						dfloat tmps = 0, tmpt = 0;

						for(int n=0;n<p_Nq;++n){
							tmps += s_D[j][n]*s_q[is][k][n];
							tmpt += s_D[k][n]*s_q[is][n][j];
						}

						
						// TW to-do: compute geofacs here by function call ?
						int i = islab+is;
							
					const dfloat rn = s_rw[0][i];
					const dfloat sn = s_rw[0][j];
					const dfloat tn = s_rw[0][k];

					const dfloat xr = (1.-tn)*(1.-sn)*(s_EXYZ[0][0]) + (1.-tn)*(1.+sn)*(s_EXYZ[0][1]) + (1.+tn)*(1.-sn)*(s_EXYZ[0][2]);
					const dfloat xs = (1.-tn)*(1.-rn)*(s_EXYZ[1][0]) + (1.-tn)*(1.+rn)*(s_EXYZ[1][1]) + (1.+tn)*(1.-rn)*(s_EXYZ[1][2]);
					const dfloat xt = (1.-rn)*(1.-sn)*(s_EXYZ[2][0]) + (1.+rn)*(1.-sn)*(s_EXYZ[2][1]) + (1.+rn)*(1.+sn)*(s_EXYZ[2][2]);

					const dfloat yr = (1.-tn)*(1.-sn)*(s_EXYZ[3][0]) + (1.-tn)*(1.+sn)*(s_EXYZ[3][1]) + (1.+tn)*(1.-sn)*(s_EXYZ[3][2]);
					const dfloat ys = (1.-tn)*(1.-rn)*(s_EXYZ[4][0]) + (1.-tn)*(1.+rn)*(s_EXYZ[4][1]) + (1.+tn)*(1.-rn)*(s_EXYZ[4][2]);
					const dfloat yt = (1.-rn)*(1.-sn)*(s_EXYZ[5][0]) + (1.+rn)*(1.-sn)*(s_EXYZ[5][1]) + (1.+rn)*(1.+sn)*(s_EXYZ[5][2]);

					const dfloat zr = (1.-tn)*(1.-sn)*(s_EXYZ[6][0]) + (1.-tn)*(1.+sn)*(s_EXYZ[6][1]) + (1.+tn)*(1.-sn)*(s_EXYZ[6][2]);
					const dfloat zs = (1.-tn)*(1.-rn)*(s_EXYZ[7][0]) + (1.-tn)*(1.+rn)*(s_EXYZ[7][1]) + (1.+tn)*(1.-rn)*(s_EXYZ[7][2]);
					const dfloat zt = (1.-rn)*(1.-sn)*(s_EXYZ[8][0]) + (1.+rn)*(1.-sn)*(s_EXYZ[8][1]) + (1.+rn)*(1.+sn)*(s_EXYZ[8][2]);

					/* compute geometric factors for affine coordinate transform*/
					const dfloat J = xr*(ys*zt-zs*yt) - yr*(xs*zt-zs*xt) + zr*(xs*yt-ys*xt);
					const dfloat Jinv = 1./J;

				//	const dfloat rx =  (ys*zt - zs*yt), ry = -(xs*zt - zs*xt), rz =  (xs*yt - ys*xt); // removed Jinv factor to below
					const dfloat sx = -(yr*zt - zr*yt), sy =  (xr*zt - zr*xt), sz = -(xr*yt - yr*xt);
					const dfloat tx =  (yr*zs - zr*ys), ty = -(xr*zs - zr*xs), tz =  (xr*ys - yr*xs);

					const dfloat JW = J*s_rw[1][i]*s_rw[1][j]*s_rw[1][k];

				
					G11 = Jinv*(sx*sx + sy*sy + sz*sz);
					G12 = Jinv*(sx*tx + sy*ty + sz*tz);
					G22 = Jinv*(tx*tx + ty*ty + tz*tz);
					GwJ = JW;
						
						
						

						s_tmp1[is][k][j] = tmps;
						//G11*tmps + G12*tmpt;
						s_tmp2[is][k][j] = tmpt;
						//G12*tmps + G22*tmpt;
					}
				}
			}

			@barrier("local");

			for(int is=0;is<p_Nslabs;++is;@inner(2)){
				for(int k=0;k<p_Nq;++k;@inner(1)){
					for(int j=0;j<p_Nq;++j;@inner(0)){

						dfloat tmps = 0, tmpt = 0;
						for(int n=0;n<p_Nq;++n){
							tmps += s_D[n][j]*(G11*s_tmp1[is][k][n]+G12*s_tmp2[is][k][n]);
							tmpt += s_D[n][k]*(G12*s_tmp1[is][n][j]+G22*s_tmp2[is][n][j]);
						}
						s_q[is][k][j] = tmps+tmpt;
					
						
						
					}
				}
			}

			@barrier("local");

			for(int is=0;is<p_Nslabs;++is;@inner(2)){
				for(int k=0;k<p_Nq;++k;@inner(1)){
					for(int j=0;j<p_Nq;++j;@inner(0)){

						const int t = j+k*p_Nq+is*p_Nq*p_Nq;
						const int iT = t&3;
						const int jT = (t>>2)&3;
						const int kT = (t>>4)&3;
						const int iB = islab;
						const int jB = (t>>6)&3;
						const int kB = (t>>8)&3;

						Aq[iT+jT*4+kT*16+iB*64+jB*256+kB*1024] += s_q[iT][kB*4+kT][jB*4+jT];
					}
				}
			}
		} // end of islabbing
	}
}

