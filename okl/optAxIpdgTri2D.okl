// A very very bad @kernel dont use @shared for global read, register, const, loopunroll etc.. 
@kernel void ellipticPartialAxIpdgTri2D_v0(const int Nelements,
                                @restrict const  int *  elementList,
                                @restrict const  int *  vmapM,
                                @restrict const  int *  vmapP,
                                const dfloat lambda,
                                const dfloat tau,
                                @restrict const  dfloat *  vgeo,
                                @restrict const  dfloat *  sgeo,
                                @restrict const  int   *  EToB,
                                @restrict const  dfloat *  DrT,
                                @restrict const  dfloat *  DsT,
                                @restrict const  dfloat *  LIFTT,
                                @restrict const  dfloat *  MM,
                                @restrict const  dfloat4 *  gradq,
                                      @restrict dfloat  *  Aq){

  for(int e=0;e<Nelements;++e;@outer(0)){
    @shared  dfloat s_dqdx[p_Np];
    @shared  dfloat s_dqdy[p_Np];
    @shared  dfloat s_lapq[p_Np];
    @shared  dfloat s_nxdq[p_NfacesNfp];
    @shared  dfloat s_nydq[p_NfacesNfp];
    @shared  dfloat s_lapflux[p_NfacesNfp];
    @shared  dfloat s_Lnxdq[p_Np];
    @shared  dfloat s_Lnydq[p_Np];
    // dqdx += LIFT*(sJ/J)*nx*dq
    for(int n=0;n<p_maxNodes;++n;@inner(0)){

      if(n<p_Np){
        int element = elementList[e];
        int gid = element*p_Nvgeo;
        dfloat drdx = vgeo[gid + p_RXID];
        dfloat drdy = vgeo[gid + p_RYID];
        dfloat dsdx = vgeo[gid + p_SXID];
        dfloat dsdy = vgeo[gid + p_SYID];

        dfloat Lnxdq = 0;
        dfloat Lnydq = 0;

        //#pragma unroll p_NfacesNfp
          for(int i=0;i<p_NfacesNfp;++i){
             int id  = i + element*p_Nfaces*p_Nfp;
             int idM = vmapM[id];
             int idP = vmapP[id];
             int face = n/p_Nfp;

             int sid = p_Nsgeo*(element*p_Nfaces+face);
             dfloat nx   = sgeo[sid+p_NXID];
             dfloat ny   = sgeo[sid+p_NYID];
             dfloat sJ   = sgeo[sid+p_SJID];
             dfloat invJ = sgeo[sid+p_IJID];
             dfloat hinv = sgeo[sid+p_IHID];

             dfloat4 gradqM = gradq[idM];// could fetch from @shared after barrier
             dfloat4 gradqP = gradq[idP];

             dfloat dq = gradqP.w - gradqM.w;
             dfloat hlf = 0.5f;

            dfloat nxdq = hlf*sJ*invJ*nx*dq;
            dfloat nydq = hlf*sJ*invJ*ny*dq;

            Lnxdq += LIFTT[n+i*p_Np]*nxdq;
            Lnydq += LIFTT[n+i*p_Np]*nydq;
          }

        dfloat4 gradqn = gradq[element*p_Np+n];
        dfloat dqdx = gradqn.x + Lnxdq;
        dfloat dqdy = gradqn.y + Lnydq;

        s_dqdx[n] = drdx*dqdx + drdy*dqdy; // abuse of notation
        s_dqdy[n] = dsdx*dqdx + dsdy*dqdy;

        s_Lnxdq[n] = Lnxdq;
        s_Lnydq[n] = Lnydq;
      }
    }

    @barrier("local");

    for(int n=0;n<p_maxNodes;++n;@inner(0)){

      int element = elementList[e];
      if(n<p_NfacesNfp){
        
        int id  = n + element*p_Nfaces*p_Nfp;
        int idM = vmapM[id];
        int idP = vmapP[id];
        // find face that owns this node
        int face = n/p_Nfp;

        dfloat4 gradqM = gradq[idM];// could fetch from @shared after barrier
        dfloat4 gradqP = gradq[idP];

        // load surface geofactors for this face
        int sid = p_Nsgeo*(element*p_Nfaces+face);
        dfloat nx   = sgeo[sid+p_NXID];
        dfloat ny   = sgeo[sid+p_NYID];
        dfloat sJ   = sgeo[sid+p_SJID];
        dfloat invJ = sgeo[sid+p_IJID];
        dfloat hinv = sgeo[sid+p_IHID];

        dfloat dq = gradqP.w - gradqM.w;
        dfloat hlf = 0.5f;


        dfloat lapflux = hlf*sJ*invJ*(-nx*(gradqP.x-gradqM.x)
                                      -ny*(gradqP.y-gradqM.y)
                                      -tau*hinv*dq);
        int idm = idM%p_Np;
        s_lapflux[n]  = lapflux + sJ*invJ*(nx*s_Lnxdq[idm]+ny*s_Lnydq[idm]);
      }

      if(n<p_Np){
        dfloat lapr = 0, laps = 0;

        //#pragma unroll p_Np
          for(int i=0;i<p_Np;++i){
            lapr += DrT[n+i*p_Np]*s_dqdx[i];
            laps += DsT[n+i*p_Np]*s_dqdy[i];
          }
  
        dfloat4 gradqn = gradq[element*p_Np+n];
        s_lapq[n] = lambda*gradqn.w - (lapr+laps);
      }

    }

    @barrier("local");

    for(int n=0;n<p_maxNodes;++n;@inner(0)){
      if(n<p_Np){
        dfloat lap = 0;

        // lift remaining surface terms
        //#pragma unroll p_NfacesNfp
          for(int i=0;i<p_NfacesNfp;++i){
            lap += LIFTT[n+i*p_Np]*s_lapflux[i];
          }

        s_lapq[n] += lap;
      }
    }

    @barrier("local");

    for(int n=0;n<p_maxNodes;++n;@inner(0)){

      if(n<p_Np){
        int element = elementList[e];
        dfloat J = vgeo[element*p_Nvgeo + p_JID];

        dfloat Mlapq = 0;

        // multiply by mass matrix
        //#pragma unroll p_Np
          for(int i=0;i<p_Np;++i){
            Mlapq += MM[n+i*p_Np]*s_lapq[i];
          }

        Aq[n+element*p_Np] = J*Mlapq;
      }
    }
  }
}








// Add @shared for global read, registers for nx,ny, idM, etc..
@kernel void ellipticPartialAxIpdgTri2D_v1(const int Nelements,
                                @restrict const  int *  elementList,
                                @restrict const  int *  vmapM,
                                @restrict const  int *  vmapP,
                                const dfloat lambda,
                                const dfloat tau,
                                @restrict const  dfloat *  vgeo,
                                @restrict const  dfloat *  sgeo,
                                @restrict const  int   *  EToB,
                                @restrict const  dfloat *  DrT,
                                @restrict const  dfloat *  DsT,
                                @restrict const  dfloat *  LIFTT,
                                @restrict const  dfloat *  MM,
                                @restrict const  dfloat4 *  gradq,
                                      @restrict dfloat  *  Aq){

  for(int e=0;e<Nelements;++e;@outer(0)){
    @shared  dfloat s_dqdx[p_Np];
    @shared  dfloat s_dqdy[p_Np];
    @shared  dfloat s_lapq[p_Np];
    @shared  dfloat s_nxdq[p_NfacesNfp];
    @shared  dfloat s_nydq[p_NfacesNfp];
    @shared  dfloat s_lapflux[p_NfacesNfp];
    @shared  dfloat s_Lnxdq[p_Np];
    @shared  dfloat s_Lnydq[p_Np];
    @exclusive int idM;
    @exclusive dfloat nx, ny, sJ, invJ, hinv;

    for(int n=0;n<p_maxNodes;++n;@inner(0)){

      if(n<p_Np){
        // assume that this stores (qx, qy, qz, q) as dfloat4
        int element = elementList[e];
        dfloat4 gradqn = gradq[element*p_Np+n];

        s_dqdx[n] = gradqn.x;
        s_dqdy[n] = gradqn.y;
        s_lapq[n] = lambda*gradqn.w;
      }

      if(n<p_NfacesNfp){
        int element = elementList[e];
        int id  = n + element*p_Nfaces*p_Nfp;
        idM = vmapM[id];
        int idP = vmapP[id];
        // find face that owns this node
        int face = n/p_Nfp;

        dfloat4 gradqM = gradq[idM];// could fetch from @shared after barrier
        dfloat4 gradqP = gradq[idP];

        // load surface geofactors for this face
        int sid = p_Nsgeo*(element*p_Nfaces+face);
        nx   = sgeo[sid+p_NXID];
        ny   = sgeo[sid+p_NYID];
        sJ   = sgeo[sid+p_SJID];
        invJ = sgeo[sid+p_IJID];
        hinv = sgeo[sid+p_IHID];

        int bc = EToB[face+p_Nfaces*element];
        // if(bc>0) {
        //   ellipticHomogeneousBC2D(bc, gradqM.w, gradqM.x, gradqM.y, gradqP.w, gradqP.x, gradqP.y);
        //   gradqP = 2*gradqP - gradqM;
        // }

        dfloat dq = gradqP.w - gradqM.w;
        dfloat hlf = 0.5f;

        s_nxdq[n] = hlf*sJ*invJ*nx*dq;
        s_nydq[n] = hlf*sJ*invJ*ny*dq;

        s_lapflux[n] = hlf*sJ*invJ*(-nx*(gradqP.x-gradqM.x)
                                    -ny*(gradqP.y-gradqM.y)
                                    -tau*hinv*dq);
      }
    }

    @barrier("local");

    // dqdx += LIFT*(sJ/J)*nx*dq
    for(int n=0;n<p_maxNodes;++n;@inner(0)){

      if(n<p_Np){
        int element = elementList[e];
        int gid = element*p_Nvgeo;
        dfloat drdx = vgeo[gid + p_RXID];
        dfloat drdy = vgeo[gid + p_RYID];
        dfloat dsdx = vgeo[gid + p_SXID];
        dfloat dsdy = vgeo[gid + p_SYID];

        dfloat Lnxdq = 0;
        dfloat Lnydq = 0;

        //#pragma unroll p_NfacesNfp
          for(int i=0;i<p_NfacesNfp;++i){
            Lnxdq += LIFTT[n+i*p_Np]*s_nxdq[i];
            Lnydq += LIFTT[n+i*p_Np]*s_nydq[i];
          }

        dfloat dqdx = s_dqdx[n] + Lnxdq;
        dfloat dqdy = s_dqdy[n] + Lnydq;
        s_dqdx[n] = drdx*dqdx + drdy*dqdy; // abuse of notation
        s_dqdy[n] = dsdx*dqdx + dsdy*dqdy;

        s_Lnxdq[n] = Lnxdq;
        s_Lnydq[n] = Lnydq;
      }
    }

    @barrier("local");

    for(int n=0;n<p_maxNodes;++n;@inner(0)){
      if(n<p_NfacesNfp){
        int id = idM%p_Np;
        s_lapflux[n] += sJ*invJ*(nx*s_Lnxdq[id]+ny*s_Lnydq[id]);
      }

      if(n<p_Np){
        dfloat lapr = 0, laps = 0;

        //#pragma unroll p_Np
          for(int i=0;i<p_Np;++i){
            lapr += DrT[n+i*p_Np]*s_dqdx[i];
            laps += DsT[n+i*p_Np]*s_dqdy[i];
          }

        s_lapq[n] -= (lapr+laps);
      }

    }

    @barrier("local");

    for(int n=0;n<p_maxNodes;++n;@inner(0)){
      if(n<p_Np){
        dfloat lap = 0;

        // lift remaining surface terms
        //#pragma unroll p_NfacesNfp
          for(int i=0;i<p_NfacesNfp;++i){
            lap += LIFTT[n+i*p_Np]*s_lapflux[i];
          }

        s_lapq[n] += lap;
      }
    }

    @barrier("local");

    for(int n=0;n<p_maxNodes;++n;@inner(0)){

      if(n<p_Np){
        int element = elementList[e];
        dfloat J = vgeo[element*p_Nvgeo + p_JID];

        dfloat Mlapq = 0;

        // multiply by mass matrix
        //#pragma unroll p_Np
          for(int i=0;i<p_Np;++i){
            Mlapq += MM[n+i*p_Np]*s_lapq[i];
          }

        Aq[n+element*p_Np] = J*Mlapq;
      }
    }
  }
}










// Add const and loopunrolling: This @kernel is same with the ellipticTri2D uses
@kernel void ellipticPartialAxIpdgTri2D_v2(const int Nelements,
                                @restrict const  int *  elementList,
                                @restrict const  int *  vmapM,
                                @restrict const  int *  vmapP,
                                const dfloat lambda,
                                const dfloat tau,
                                @restrict const  dfloat *  vgeo,
                                @restrict const  dfloat *  sgeo,
                                @restrict const  int   *  EToB,
                                @restrict const  dfloat *  DrT,
                                @restrict const  dfloat *  DsT,
                                @restrict const  dfloat *  LIFTT,
                                @restrict const  dfloat *  MM,
                                @restrict const  dfloat4 *  gradq,
                                      @restrict dfloat  *  Aq){

  for(int e=0;e<Nelements;++e;@outer(0)){
    @shared  dfloat s_dqdx[p_Np];
    @shared  dfloat s_dqdy[p_Np];
    @shared  dfloat s_lapq[p_Np];
    @shared  dfloat s_nxdq[p_NfacesNfp];
    @shared  dfloat s_nydq[p_NfacesNfp];
    @shared  dfloat s_lapflux[p_NfacesNfp];
    @shared  dfloat s_Lnxdq[p_Np];
    @shared  dfloat s_Lnydq[p_Np];
    @exclusive int idM;
    @exclusive dfloat nx, ny, sJ, invJ, hinv;

    for(int n=0;n<p_maxNodes;++n;@inner(0)){

      const int element = elementList[e];

      if(n<p_Np){
        // assume that this stores (qx, qy, qz, q) as dfloat4
        
        const dfloat4 gradqn = gradq[element*p_Np+n];

        s_dqdx[n] = gradqn.x;
        s_dqdy[n] = gradqn.y;
        s_lapq[n] = lambda*gradqn.w;
      }

      if(n<p_NfacesNfp){
        const int id  = n + element*p_Nfaces*p_Nfp;
        idM = vmapM[id];
        const int idP = vmapP[id];
        // find face that owns this node
        const int face = n/p_Nfp;

        dfloat4 gradqM = gradq[idM];// could fetch from @shared after barrier
        dfloat4 gradqP = gradq[idP];

        // load surface geofactors for this face
        int sid = p_Nsgeo*(element*p_Nfaces+face);
        nx   = sgeo[sid+p_NXID];
        ny   = sgeo[sid+p_NYID];
        sJ   = sgeo[sid+p_SJID];
        invJ = sgeo[sid+p_IJID];
        hinv = sgeo[sid+p_IHID];

        int bc = EToB[face+p_Nfaces*element];
        // if(bc>0) {
        //   ellipticHomogeneousBC2D(bc, gradqM.w, gradqM.x, gradqM.y, gradqP.w, gradqP.x, gradqP.y);
        //   gradqP = 2*gradqP - gradqM;
        // }

        const dfloat dq = gradqP.w - gradqM.w;
        const dfloat hlf = 0.5f;

        s_nxdq[n] = hlf*sJ*invJ*nx*dq;
        s_nydq[n] = hlf*sJ*invJ*ny*dq;

        s_lapflux[n] = hlf*sJ*invJ*(-nx*(gradqP.x-gradqM.x)
                                    -ny*(gradqP.y-gradqM.y)
                                    -tau*hinv*dq);
      }
    }

    @barrier("local");

    // dqdx += LIFT*(sJ/J)*nx*dq
    for(int n=0;n<p_maxNodes;++n;@inner(0)){

      if(n<p_Np){
        const int element = elementList[e];
        const int gid = element*p_Nvgeo;
        const dfloat drdx = vgeo[gid + p_RXID];
        const dfloat drdy = vgeo[gid + p_RYID];
        const dfloat dsdx = vgeo[gid + p_SXID];
        const dfloat dsdy = vgeo[gid + p_SYID];

        dfloat Lnxdq = 0;
        dfloat Lnydq = 0;

        #pragma unroll p_NfacesNfp
          for(int i=0;i<p_NfacesNfp;++i){
            Lnxdq += LIFTT[n+i*p_Np]*s_nxdq[i];
            Lnydq += LIFTT[n+i*p_Np]*s_nydq[i];
          }

        dfloat dqdx = s_dqdx[n] + Lnxdq;
        dfloat dqdy = s_dqdy[n] + Lnydq;
        s_dqdx[n] = drdx*dqdx + drdy*dqdy; // abuse of notation
        s_dqdy[n] = dsdx*dqdx + dsdy*dqdy;

        s_Lnxdq[n] = Lnxdq;
        s_Lnydq[n] = Lnydq;
      }
    }

    @barrier("local");

    for(int n=0;n<p_maxNodes;++n;@inner(0)){
      if(n<p_NfacesNfp){
        int id = idM%p_Np;
        s_lapflux[n] += sJ*invJ*(nx*s_Lnxdq[id]+ny*s_Lnydq[id]);
      }

      if(n<p_Np){
        dfloat lapr = 0, laps = 0;

        #pragma unroll p_Np
          for(int i=0;i<p_Np;++i){
            lapr += DrT[n+i*p_Np]*s_dqdx[i];
            laps += DsT[n+i*p_Np]*s_dqdy[i];
          }

        s_lapq[n] -= (lapr+laps);
      }

    }

    @barrier("local");

    for(int n=0;n<p_maxNodes;++n;@inner(0)){
      if(n<p_Np){
        dfloat lap = 0;

        // lift remaining surface terms
        #pragma unroll p_NfacesNfp
          for(int i=0;i<p_NfacesNfp;++i){
            lap += LIFTT[n+i*p_Np]*s_lapflux[i];
          }

        s_lapq[n] += lap;
      }
    }

    @barrier("local");

    for(int n=0;n<p_maxNodes;++n;@inner(0)){

      if(n<p_Np){
        const int element = elementList[e];
        const dfloat J = vgeo[element*p_Nvgeo + p_JID];

        dfloat Mlapq = 0;

        // multiply by mass matrix
        #pragma unroll p_Np
          for(int i=0;i<p_Np;++i){
            Mlapq += MM[n+i*p_Np]*s_lapq[i];
          }

        Aq[n+element*p_Np] = J*Mlapq;
      }
    }
  }
}



 // // Optimized sizes for @kernel 3
#if p_N==1
 #define p_Nblock 5
#endif

#if p_N==2
 #define p_Nblock 7
#endif

#if p_N==3
 #define p_Nblock 8
#endif

 #if p_N==4
  #define p_Nblock 4
#endif

#if p_N==5
 #define p_Nblock 3
#endif

#if p_N==6
 #define p_Nblock 8
#endif

#if p_N==7
  #define p_Nblock 4
#endif

#if p_N==8
 #define p_Nblock 7
#endif

#if p_N==9
  #define p_Nblock 5
#endif

#if p_N==10
 #define p_Nblock 7
#endif



// Added multiple element per threadblock
@kernel void ellipticPartialAxIpdgTri2D_v3(const int Nelements,
                                @restrict const  int *  elementList,
                                @restrict const  int *  vmapM,
                                @restrict const  int *  vmapP,
                                const dfloat lambda,
                                const dfloat tau,
                                @restrict const  dfloat *  vgeo,
                                @restrict const  dfloat *  sgeo,
                                @restrict const  int   *  EToB,
                                @restrict const  dfloat *  DrT,
                                @restrict const  dfloat *  DsT,
                                @restrict const  dfloat *  LIFTT,
                                @restrict const  dfloat *  MM,
                                @restrict const  dfloat4 *  gradq,
                                      @restrict dfloat  *  Aq){

  for(int eo=0;eo<Nelements;eo+=p_Nblock;@outer(0)){
    @shared  dfloat s_dqdx[p_Nblock][p_Np];
    @shared  dfloat s_dqdy[p_Nblock][p_Np];
    @shared  dfloat s_lapq[p_Nblock][p_Np];
    @shared  dfloat s_nxdq[p_Nblock][p_NfacesNfp];
    @shared  dfloat s_nydq[p_Nblock][p_NfacesNfp];
    @shared  dfloat s_lapflux[p_Nblock][p_NfacesNfp];
    @shared  dfloat s_Lnxdq[p_Nblock][p_Np];
    @shared  dfloat s_Lnydq[p_Nblock][p_Np];
    @exclusive int idM;
    @exclusive dfloat nx, ny, sJ, invJ, hinv;


   for(int es=0;es<p_Nblock;++es;@inner(1)){//
    for(int n=0;n<p_maxNodes;++n;@inner(0)){
       const int e = eo+es;
       if(e<Nelements){
         if(n<p_Np){
          // assume that this stores (qx, qy, qz, q) as dfloat4
          const int element = elementList[e];
          const dfloat4 gradqn = gradq[element*p_Np+n];

          s_dqdx[es][n] = gradqn.x;
          s_dqdy[es][n] = gradqn.y;
          s_lapq[es][n] = lambda*gradqn.w;
        }

        if(n<p_NfacesNfp){
          const int element = elementList[e];
          const int id  = n + element*p_Nfaces*p_Nfp;
          idM = vmapM[id];
          const int idP = vmapP[id];
          // find face that owns this node
          const int face = n/p_Nfp;

          dfloat4 gradqM = gradq[idM];// could fetch from @shared after barrier
          dfloat4 gradqP = gradq[idP];

          // load surface geofactors for this face
          int sid = p_Nsgeo*(element*p_Nfaces+face);
          nx   = sgeo[sid+p_NXID];
          ny   = sgeo[sid+p_NYID];
          sJ   = sgeo[sid+p_SJID];
          invJ = sgeo[sid+p_IJID];
          hinv = sgeo[sid+p_IHID];

          int bc = EToB[face+p_Nfaces*element];
          // if(bc>0) {
          //   ellipticHomogeneousBC2D(bc, gradqM.w, gradqM.x, gradqM.y, gradqP.w, gradqP.x, gradqP.y);
          //   gradqP = 2*gradqP - gradqM;
          // }

          const dfloat dq = gradqP.w - gradqM.w;
          const dfloat hlf = 0.5f;

          s_nxdq[es][n] = hlf*sJ*invJ*nx*dq;
          s_nydq[es][n] = hlf*sJ*invJ*ny*dq;

          s_lapflux[es][n] = hlf*sJ*invJ*(-nx*(gradqP.x-gradqM.x)
                                          -ny*(gradqP.y-gradqM.y)
                                          -tau*hinv*dq);
        }
      }
    }
  }

    @barrier("local");

  for(int es=0;es<p_Nblock;++es;@inner(1)){//
    // dqdx += LIFT*(sJ/J)*nx*dq
    for(int n=0;n<p_maxNodes;++n;@inner(0)){
      const int e = eo+es;
       if(e<Nelements){
        if(n<p_Np){
          const int element = elementList[e];
          const int gid = element*p_Nvgeo;
          const dfloat drdx = vgeo[gid + p_RXID];
          const dfloat drdy = vgeo[gid + p_RYID];
          const dfloat dsdx = vgeo[gid + p_SXID];
          const dfloat dsdy = vgeo[gid + p_SYID];

          dfloat Lnxdq = 0;
          dfloat Lnydq = 0;

          #pragma unroll p_NfacesNfp
            for(int i=0;i<p_NfacesNfp;++i){
              const dfloat L = LIFTT[n+i*p_Np];
              Lnxdq += L*s_nxdq[es][i];
              Lnydq += L*s_nydq[es][i];
            }

          dfloat dqdx = s_dqdx[es][n] + Lnxdq;
          dfloat dqdy = s_dqdy[es][n] + Lnydq;
          s_dqdx[es][n] = drdx*dqdx + drdy*dqdy; // abuse of notation
          s_dqdy[es][n] = dsdx*dqdx + dsdy*dqdy;

          s_Lnxdq[es][n] = Lnxdq;
          s_Lnydq[es][n] = Lnydq;
        }
      }
    }
  }

    @barrier("local");

  for(int es=0;es<p_Nblock;++es;@inner(1)){//
    for(int n=0;n<p_maxNodes;++n;@inner(0)){
      const int e = eo + es; 
      if(e<Nelements){

        if(n<p_NfacesNfp){
          int id = idM%p_Np;
          s_lapflux[es][n] += sJ*invJ*(nx*s_Lnxdq[es][id]+ny*s_Lnydq[es][id]);
        }

        if(n<p_Np){
          dfloat lapr = 0, laps = 0;
          #pragma unroll p_Np
            for(int i=0;i<p_Np;++i){
              lapr += DrT[n+i*p_Np]*s_dqdx[es][i];
              laps += DsT[n+i*p_Np]*s_dqdy[es][i];
            }

          s_lapq[es][n] -= (lapr+laps);
        }
      }
    }
  }

    @barrier("local");

  for(int es=0;es<p_Nblock;++es;@inner(1)){//
    for(int n=0;n<p_maxNodes;++n;@inner(0)){
      const int e = eo + es; 
      if(e<Nelements){
        if(n<p_Np){
        dfloat lap = 0;
        // lift remaining surface terms
        #pragma unroll p_NfacesNfp
          for(int i=0;i<p_NfacesNfp;++i){
            lap += LIFTT[n+i*p_Np]*s_lapflux[es][i];
          }

        s_lapq[es][n] += lap;
       }
      }
    }
  }

    @barrier("local");

  for(int es=0;es<p_Nblock;++es;@inner(1)){//
    for(int n=0;n<p_maxNodes;++n;@inner(0)){
      const int e = eo + es; 
      if(e<Nelements){
        if(n<p_Np){
          const int element = elementList[e];
          const dfloat J = vgeo[element*p_Nvgeo + p_JID];
          dfloat Mlapq = 0;
        // multiply by mass matrix
         #pragma unroll p_Np
          for(int i=0;i<p_Np;++i){
            Mlapq += MM[n+i*p_Np]*s_lapq[es][i];
          }

        Aq[n+element*p_Np] = J*Mlapq;
      }
     }
   }
 }

}
}


  // // Optimized sizes for @kernel 4-5
#if p_N==1
 #define p_NbV 5
 #define p_Nmt 1
 #endif

#if p_N==2
 #define p_NbV 7
 #define p_Nmt 2
#endif

#if p_N==3
 #define p_NbV 5
 #define p_Nmt 2
#endif

 #if p_N==4
  #define p_NbV 2
  #define p_Nmt 2
#endif

 #if p_N==5
 #define p_NbV 3
 #define p_Nmt 2
 #endif

#if p_N==6
 #define p_NbV 4
 #define p_Nmt 2
 #endif

#if p_N==7
  #define p_NbV 4
  #define p_Nmt 2
 #endif

#if p_N==8
 #define p_NbV 2
 #define p_Nmt 3
#endif

#if p_N==9
  #define p_NbV 2
  #define p_Nmt 3
 #endif

#if p_N==10
 #define p_NbV 3
 #define p_Nmt 3
#endif

// Added multiple element per threadblock
@kernel void ellipticPartialAxIpdgTri2D_v4(const int Nelements,
                                @restrict const  int *  elementList,
                                @restrict const  int *  vmapM,
                                @restrict const  int *  vmapP,
                                const dfloat lambda,
                                const dfloat tau,
                                @restrict const  dfloat *  vgeo,
                                @restrict const  dfloat *  sgeo,
                                @restrict const  int   *  EToB,
                                @restrict const  dfloat *  DrT,
                                @restrict const  dfloat *  DsT,
                                @restrict const  dfloat *  LIFTT,
                                @restrict const  dfloat *  MM,
                                @restrict const  dfloat4 *  gradq,
                                      @restrict dfloat  *  Aq){

  for(int eo=0;eo<Nelements;eo+=(p_NbV*p_Nmt);@outer(0)){
    @shared  dfloat s_dqdx[p_Nmt][p_NbV][p_Np];
    @shared  dfloat s_dqdy[p_Nmt][p_NbV][p_Np];
    @shared  dfloat s_lapq[p_Nmt][p_NbV][p_Np];
    @shared  dfloat s_nxdq[p_Nmt][p_NbV][p_NfacesNfp];
    @shared  dfloat s_nydq[p_Nmt][p_NbV][p_NfacesNfp];
    @shared  dfloat s_lapflux[p_Nmt][p_NbV][p_NfacesNfp];
    @shared  dfloat s_Lnxdq[p_Nmt][p_NbV][p_Np];
    @shared  dfloat s_Lnydq[p_Nmt][p_NbV][p_Np];

    // @shared int idM[p_Nmt];
    // @shared dfloat nx[p_Nmt], ny[p_Nmt], sJ[p_Nmt];
    // @shared dfloat invJ[p_Nmt], hinv[p_Nmt];
    
    @exclusive int idM[p_Nmt];
    @exclusive dfloat nx[p_Nmt], ny[p_Nmt], sJ[p_Nmt];
    @exclusive dfloat invJ[p_Nmt], hinv[p_Nmt];

    @exclusive int element[p_Nmt];

   for(int es=0;es<p_NbV;++es;@inner(1)){//
    for(int n=0;n<p_maxNodes;++n;@inner(0)){
      #pragma unroll p_Nmt
        for(int em=0;em<p_Nmt;++em){
          const int e = eo+es*p_Nmt + em;
          if(e<Nelements){
           element[em] = elementList[e];
         }
      }
     
      #pragma unroll p_Nmt
        for(int em=0;em<p_Nmt;++em){
          const int e = eo+es*p_Nmt + em;
          //const int element = elementList[e];

           if(e<Nelements){
             if(n<p_Np){
              // assume that this stores (qx, qy, qz, q) as dfloat4
              
              const dfloat4 gradqn = gradq[element[em]*p_Np+n];

              s_dqdx[em][es][n] = gradqn.x;
              s_dqdy[em][es][n] = gradqn.y;
              s_lapq[em][es][n] = lambda*gradqn.w;
            }

          if(n<p_NfacesNfp){
            const int id  = n + element[em]*p_Nfaces*p_Nfp;
            idM[em] = vmapM[id];
            const int idP = vmapP[id];
            // find face that owns this node
            const int face = n/p_Nfp;

            dfloat4 gradqM = gradq[idM[em]];// could fetch from @shared after barrier
            dfloat4 gradqP = gradq[idP];

            // load surface geofactors for this face
            int sid = p_Nsgeo*(element[em]*p_Nfaces+face);
            nx[em]   = sgeo[sid+p_NXID];
            ny[em]   = sgeo[sid+p_NYID];
            sJ[em]   = sgeo[sid+p_SJID];
            invJ[em] = sgeo[sid+p_IJID];
            hinv[em] = sgeo[sid+p_IHID];

            int bc = EToB[face+p_Nfaces*element[em]];
            // if(bc>0) {
            //   ellipticHomogeneousBC2D(bc, gradqM.w, gradqM.x, gradqM.y, gradqP.w, gradqP.x, gradqP.y);
            //   gradqP = 2*gradqP - gradqM;
            // }

            const dfloat dq = gradqP.w - gradqM.w;
            const dfloat hlf = 0.5f;

            s_nxdq[em][es][n] = hlf*sJ[em]*invJ[em]*nx[em]*dq;
            s_nydq[em][es][n] = hlf*sJ[em]*invJ[em]*ny[em]*dq;

            s_lapflux[em][es][n] = hlf*sJ[em]*invJ[em]*(-nx[em]*(gradqP.x-gradqM.x)
                                                    -ny[em]*(gradqP.y-gradqM.y)
                                                    -tau*hinv[em]*dq);
          }
        }
      }
    }
  }

    @barrier("local");

  for(int es=0;es<p_NbV;++es;@inner(1)){//
    for(int n=0;n<p_maxNodes;++n;@inner(0)){

      dfloat Lnxdq[p_Nmt], Lnydq[p_Nmt];
      
      // // Try holding drdx in register array
      // const dfloat drdx[p_Nmt], drdy[p_Nmt];
      // const dfloat dsdx[p_Nmt], dsdy[p_Nmt];

      #pragma unroll p_Nmt
        for(int em=0;em<p_Nmt;++em){
          Lnxdq[em] = 0.f;
          Lnydq[em] = 0.f;
          //
          //  const int e = eo+es*p_Nmt + em;
          //  const int gid = element*p_Nvgeo;
          // drdx[em] = vgeo[gid + p_RXID];
          // drdy[em] = vgeo[gid + p_RYID];
          // dsdx[em] = vgeo[gid + p_SXID];
          // dsdy[em] = vgeo[gid + p_SYID];
        }

          
       if(n<p_Np){

        #pragma unroll p_NfacesNfp
        for(int i=0;i<p_NfacesNfp;++i){
          const dfloat L = LIFTT[n+i*p_Np];
            #pragma unroll p_Nmt
            for(int em=0;em<p_Nmt;++em){
              Lnxdq[em] += L*s_nxdq[em][es][i];
              Lnydq[em] += L*s_nydq[em][es][i];
            }
          }

        #pragma unroll p_Nmt
        for(int em=0;em<p_Nmt;++em){
          const int e = eo+es*p_Nmt + em;
          if(e<Nelements){
             // const int element = elementList[e];
              const int gid = element[em]*p_Nvgeo;

              // These data can be stored on @shared
              const dfloat drdx = vgeo[gid + p_RXID];
              const dfloat drdy = vgeo[gid + p_RYID];
              const dfloat dsdx = vgeo[gid + p_SXID];
              const dfloat dsdy = vgeo[gid + p_SYID];

              dfloat dqdx = s_dqdx[em][es][n] + Lnxdq[em];
              dfloat dqdy = s_dqdy[em][es][n] + Lnydq[em];
              s_dqdx[em][es][n] = drdx*dqdx + drdy*dqdy; // abuse of notation
              s_dqdy[em][es][n] = dsdx*dqdx + dsdy*dqdy;

              s_Lnxdq[em][es][n] = Lnxdq[em];
              s_Lnydq[em][es][n] = Lnydq[em];
            }
          }

        }
      }
    }
  

    @barrier("local");

  for(int es=0;es<p_NbV;++es;@inner(1)){//
    for(int n=0;n<p_maxNodes;++n;@inner(0)){

      dfloat lapr[p_Nmt], laps[p_Nmt];
      #pragma unroll p_Nmt
        for(int em=0;em<p_Nmt;++em){
          const int e = eo+es*p_Nmt + em;
           
           if(n<p_NfacesNfp){
            int id = idM[em]%p_Np;
            s_lapflux[em][es][n] += sJ[em]*invJ[em]*(nx[em]*s_Lnxdq[em][es][id]
                                                     +ny[em]*s_Lnydq[em][es][id]);
            }

           lapr[em] = 0.f; 
           laps[em] = 0.f;
        }

        if(n<p_Np){
          #pragma unroll p_Np
            for(int i=0;i<p_Np;++i){
              const dfloat drT = DrT[n+i*p_Np];
              const dfloat dsT = DsT[n+i*p_Np];

              #pragma unroll p_Nmt
              for(int em=0;em<p_Nmt;++em){
                lapr[em] += drT*s_dqdx[em][es][i];
                laps[em] += dsT*s_dqdy[em][es][i];
              }
            }


          if(n<p_Np){
         #pragma unroll p_Nmt
              for(int em=0;em<p_Nmt;++em){
          s_lapq[em][es][n] -= (lapr[em]+laps[em]);
           }
         }
        }
      }
    }


    @barrier("local");

  for(int es=0;es<p_NbV;++es;@inner(1)){//
    for(int n=0;n<p_maxNodes;++n;@inner(0)){
      dfloat lap[p_Nmt];
      #pragma unroll p_Nmt
        for(int em=0;em<p_Nmt;++em){
            lap[em] = 0.f;
        }

        if(n<p_Np){

        // lift remaining surface terms
        #pragma unroll p_NfacesNfp
          for(int i=0;i<p_NfacesNfp;++i){
              const dfloat L = LIFTT[n+i*p_Np];
              #pragma unroll p_Nmt
              for(int em=0;em<p_Nmt;++em){
              lap[em] += L*s_lapflux[em][es][i];
            }
          }

         #pragma unroll p_Nmt
          for(int em=0;em<p_Nmt;++em){
             s_lapq[em][es][n] += lap[em];
          } 
          } 
       }
      }
 

    @barrier("local");

  for(int es=0;es<p_NbV;++es;@inner(1)){//
    for(int n=0;n<p_maxNodes;++n;@inner(0)){

      dfloat Mlapq[p_Nmt];

      #pragma unroll p_Nmt
        for(int em=0;em<p_Nmt;++em){
            Mlapq[em] = 0.f;
        }

        if(n<p_Np){

        #pragma unroll p_Np
          for(int i=0;i<p_Np;++i){
            const dfloat mm = MM[n+i*p_Np];
            #pragma unroll p_Nmt
             for(int em=0;em<p_Nmt;++em){
              Mlapq[em] += mm*s_lapq[em][es][i];
            }
          }

         #pragma unroll p_Nmt
         for(int em=0;em<p_Nmt;++em){
          const int e = eo+es*p_Nmt + em;

          if(e<Nelements){
         // const int element = elementList[e];
          const dfloat J = vgeo[element[em]*p_Nvgeo + p_JID];

          Aq[n+element[em]*p_Np] = J*Mlapq[em];
           }
         }
        }

      }
    }
}
}

















// // Added multiple element per threadblock
// @kernel void ellipticPartialAxIpdgTri2D_v4(const int Nelements,
//                                 @restrict const  int *  elementList,
//                                 @restrict const  int *  vmapM,
//                                 @restrict const  int *  vmapP,
//                                 const dfloat lambda,
//                                 const dfloat tau,
//                                 @restrict const  dfloat *  vgeo,
//                                 @restrict const  dfloat *  sgeo,
//                                 @restrict const  int   *  EToB,
//                                 @restrict const  dfloat *  DrT,
//                                 @restrict const  dfloat *  DsT,
//                                 @restrict const  dfloat *  LIFTT,
//                                 @restrict const  dfloat *  MM,
//                                 @restrict const  dfloat4 *  gradq,
//                                       @restrict dfloat  *  Aq){

//   for(int eo=0;eo<Nelements;eo+=(p_NbV*p_Nmt);@outer(0)){
//     @shared  dfloat s_dqdx[p_Nmt][p_NbV][p_Np];
//     @shared  dfloat s_dqdy[p_Nmt][p_NbV][p_Np];
//     @shared  dfloat s_lapq[p_Nmt][p_NbV][p_Np];
//     @shared  dfloat s_nxdq[p_Nmt][p_NbV][p_NfacesNfp];
//     @shared  dfloat s_nydq[p_Nmt][p_NbV][p_NfacesNfp];
//     @shared  dfloat s_lapflux[p_Nmt][p_NbV][p_NfacesNfp];
//     @shared  dfloat s_Lnxdq[p_Nmt][p_NbV][p_Np];
//     @shared  dfloat s_Lnydq[p_Nmt][p_NbV][p_Np];

//     // @shared int idM[p_Nmt];
//     // @shared dfloat nx[p_Nmt], ny[p_Nmt], sJ[p_Nmt];
//     // @shared dfloat invJ[p_Nmt], hinv[p_Nmt];
    
//     @exclusive int idM[p_Nmt];
//     @exclusive dfloat nx[p_Nmt], ny[p_Nmt], sJ[p_Nmt];
//     @exclusive dfloat invJ[p_Nmt], hinv[p_Nmt];

//    for(int es=0;es<p_NbV;++es;@inner(1)){//
//     for(int n=0;n<p_maxNodes;++n;@inner(0)){
     
//       #pragma unroll p_Nmt
//         for(int em=0;em<p_Nmt;++em){
//           const int e = eo+es*p_Nmt + em;
//           const int element = elementList[e];

//            if(e<Nelements){
//              if(n<p_Np){
//               // assume that this stores (qx, qy, qz, q) as dfloat4
              
//               const dfloat4 gradqn = gradq[element*p_Np+n];

//               s_dqdx[em][es][n] = gradqn.x;
//               s_dqdy[em][es][n] = gradqn.y;
//               s_lapq[em][es][n] = lambda*gradqn.w;
//             }

//           if(n<p_NfacesNfp){
//             const int id  = n + element*p_Nfaces*p_Nfp;
//             idM[em] = vmapM[id];
//             const int idP = vmapP[id];
//             // find face that owns this node
//             const int face = n/p_Nfp;

//             dfloat4 gradqM = gradq[idM[em]];// could fetch from @shared after barrier
//             dfloat4 gradqP = gradq[idP];

//             // load surface geofactors for this face
//             int sid = p_Nsgeo*(element*p_Nfaces+face);
//             nx[em]   = sgeo[sid+p_NXID];
//             ny[em]   = sgeo[sid+p_NYID];
//             sJ[em]   = sgeo[sid+p_SJID];
//             invJ[em] = sgeo[sid+p_IJID];
//             hinv[em] = sgeo[sid+p_IHID];

//             int bc = EToB[face+p_Nfaces*element];
//             // if(bc>0) {
//             //   ellipticHomogeneousBC2D(bc, gradqM.w, gradqM.x, gradqM.y, gradqP.w, gradqP.x, gradqP.y);
//             //   gradqP = 2*gradqP - gradqM;
//             // }

//             const dfloat dq = gradqP.w - gradqM.w;
//             const dfloat hlf = 0.5f;

//             s_nxdq[em][es][n] = hlf*sJ[em]*invJ[em]*nx[em]*dq;
//             s_nydq[em][es][n] = hlf*sJ[em]*invJ[em]*ny[em]*dq;

//             s_lapflux[em][es][n] = hlf*sJ[em]*invJ[em]*(-nx[em]*(gradqP.x-gradqM.x)
//                                                     -ny[em]*(gradqP.y-gradqM.y)
//                                                     -tau*hinv[em]*dq);
//           }
//         }
//       }
//     }
//   }

//     @barrier("local");

//   for(int es=0;es<p_NbV;++es;@inner(1)){//
//     for(int n=0;n<p_maxNodes;++n;@inner(0)){

//       dfloat Lnxdq[p_Nmt], Lnydq[p_Nmt];
      
//       // // Try holding drdx in register array
//       // const dfloat drdx[p_Nmt], drdy[p_Nmt];
//       // const dfloat dsdx[p_Nmt], dsdy[p_Nmt];

//       #pragma unroll p_Nmt
//         for(int em=0;em<p_Nmt;++em){
//           Lnxdq[em] = 0.f;
//           Lnydq[em] = 0.f;
//           //
//           //  const int e = eo+es*p_Nmt + em;
//           //  const int gid = element*p_Nvgeo;
//           // drdx[em] = vgeo[gid + p_RXID];
//           // drdy[em] = vgeo[gid + p_RYID];
//           // dsdx[em] = vgeo[gid + p_SXID];
//           // dsdy[em] = vgeo[gid + p_SYID];
//         }

          
//        if(n<p_Np){

//         #pragma unroll p_NfacesNfp
//         for(int i=0;i<p_NfacesNfp;++i){
//           const dfloat L = LIFTT[n+i*p_Np];
//             #pragma unroll p_Nmt
//             for(int em=0;em<p_Nmt;++em){
//               Lnxdq[em] += L*s_nxdq[em][es][i];
//               Lnydq[em] += L*s_nydq[em][es][i];
//             }
//           }

//         #pragma unroll p_Nmt
//         for(int em=0;em<p_Nmt;++em){
//           const int e = eo+es*p_Nmt + em;
//           if(e<Nelements){
//               const int element = elementList[e];
//               const int gid = element*p_Nvgeo;

//               // These data can be stored on @shared
//               const dfloat drdx = vgeo[gid + p_RXID];
//               const dfloat drdy = vgeo[gid + p_RYID];
//               const dfloat dsdx = vgeo[gid + p_SXID];
//               const dfloat dsdy = vgeo[gid + p_SYID];

//               dfloat dqdx = s_dqdx[em][es][n] + Lnxdq[em];
//               dfloat dqdy = s_dqdy[em][es][n] + Lnydq[em];
//               s_dqdx[em][es][n] = drdx*dqdx + drdy*dqdy; // abuse of notation
//               s_dqdy[em][es][n] = dsdx*dqdx + dsdy*dqdy;

//               s_Lnxdq[em][es][n] = Lnxdq[em];
//               s_Lnydq[em][es][n] = Lnydq[em];
//             }
//           }

//         }
//       }
//     }
  

//     @barrier("local");

//   for(int es=0;es<p_NbV;++es;@inner(1)){//
//     for(int n=0;n<p_maxNodes;++n;@inner(0)){

//       dfloat lapr[p_Nmt], laps[p_Nmt];
//       #pragma unroll p_Nmt
//         for(int em=0;em<p_Nmt;++em){
//           const int e = eo+es*p_Nmt + em;
           
//            if(n<p_NfacesNfp){
//             int id = idM[em]%p_Np;
//             s_lapflux[em][es][n] += sJ[em]*invJ[em]*(nx[em]*s_Lnxdq[em][es][id]
//                                                      +ny[em]*s_Lnydq[em][es][id]);
//             }

//            lapr[em] = 0.f; 
//            laps[em] = 0.f;
//         }

//         if(n<p_Np){
//           #pragma unroll p_Np
//             for(int i=0;i<p_Np;++i){
//               const dfloat drT = DrT[n+i*p_Np];
//               const dfloat dsT = DsT[n+i*p_Np];

//               #pragma unroll p_Nmt
//               for(int em=0;em<p_Nmt;++em){
//                 lapr[em] += drT*s_dqdx[em][es][i];
//                 laps[em] += dsT*s_dqdy[em][es][i];
//               }
//             }


//           if(n<p_Np){
//          #pragma unroll p_Nmt
//               for(int em=0;em<p_Nmt;++em){
//           s_lapq[em][es][n] -= (lapr[em]+laps[em]);
//            }
//          }
//         }
//       }
//     }


//     @barrier("local");

//   for(int es=0;es<p_NbV;++es;@inner(1)){//
//     for(int n=0;n<p_maxNodes;++n;@inner(0)){
//       dfloat lap[p_Nmt];
//       #pragma unroll p_Nmt
//         for(int em=0;em<p_Nmt;++em){
//             lap[em] = 0.f;
//         }

//         if(n<p_Np){

//         // lift remaining surface terms
//         #pragma unroll p_NfacesNfp
//           for(int i=0;i<p_NfacesNfp;++i){
//               const dfloat L = LIFTT[n+i*p_Np];
//               #pragma unroll p_Nmt
//               for(int em=0;em<p_Nmt;++em){
//               lap[em] += L*s_lapflux[em][es][i];
//             }
//           }

//          #pragma unroll p_Nmt
//           for(int em=0;em<p_Nmt;++em){
//              s_lapq[em][es][n] += lap[em];
//           } 
//           } 
//        }
//       }
 

//     @barrier("local");

//   for(int es=0;es<p_NbV;++es;@inner(1)){//
//     for(int n=0;n<p_maxNodes;++n;@inner(0)){

//       dfloat Mlapq[p_Nmt];

//       #pragma unroll p_Nmt
//         for(int em=0;em<p_Nmt;++em){
//             Mlapq[em] = 0.f;
//         }

//         if(n<p_Np){

//         #pragma unroll p_Np
//           for(int i=0;i<p_Np;++i){
//             const dfloat mm = MM[n+i*p_Np];
//             #pragma unroll p_Nmt
//              for(int em=0;em<p_Nmt;++em){
//               Mlapq[em] += mm*s_lapq[em][es][i];
//             }
//           }

//          #pragma unroll p_Nmt
//          for(int em=0;em<p_Nmt;++em){
//           const int e = eo+es*p_Nmt + em;
//           const int element = elementList[e];
//           const dfloat J = vgeo[element*p_Nvgeo + p_JID];

//           Aq[n+element*p_Np] = J*Mlapq[em];
//          }
//         }

//       }
//     }
// }
// }






@kernel void ellipticPartialAxIpdgTri2D(const int Nelements,
                                @restrict const  int *  elementList,
                                @restrict const  int *  vmapM,
                                @restrict const  int *  vmapP,
                                const dfloat lambda,
                                const dfloat tau,
                                @restrict const  dfloat *  vgeo,
                                @restrict const  dfloat *  sgeo,
                                @restrict const  int   *  EToB,
                                @restrict const  dfloat *  DrT,
                                @restrict const  dfloat *  DsT,
                                @restrict const  dfloat *  LIFTT,
                                @restrict const  dfloat *  MM,
                                @restrict const  dfloat4 *  gradq,
                                      @restrict dfloat  *  Aq){

  for(int e=0;e<Nelements;++e;@outer(0)){
    @shared  dfloat s_dqdx[p_Np];
    @shared  dfloat s_dqdy[p_Np];
    @shared  dfloat s_lapq[p_Np];
    @shared  dfloat s_nxdq[p_NfacesNfp];
    @shared  dfloat s_nydq[p_NfacesNfp];
    @shared  dfloat s_lapflux[p_NfacesNfp];
    @shared  dfloat s_Lnxdq[p_Np];
    @shared  dfloat s_Lnydq[p_Np];
    @exclusive int idM;
    @exclusive dfloat nx, ny, sJ, invJ, hinv;

    for(int n=0;n<p_maxNodes;++n;@inner(0)){

      if(n<p_Np){
        // assume that this stores (qx, qy, qz, q) as dfloat4
        const int element = elementList[e];
        const dfloat4 gradqn = gradq[element*p_Np+n];

        s_dqdx[n] = gradqn.x;
        s_dqdy[n] = gradqn.y;
        s_lapq[n] = lambda*gradqn.w;
      }

      if(n<p_NfacesNfp){
        const int element = elementList[e];
        const int id  = n + element*p_Nfaces*p_Nfp;
        idM = vmapM[id];
        const int idP = vmapP[id];
        // find face that owns this node
        const int face = n/p_Nfp;

        dfloat4 gradqM = gradq[idM];// could fetch from @shared after barrier
        dfloat4 gradqP = gradq[idP];

        // load surface geofactors for this face
        int sid = p_Nsgeo*(element*p_Nfaces+face);
        nx   = sgeo[sid+p_NXID];
        ny   = sgeo[sid+p_NYID];
        sJ   = sgeo[sid+p_SJID];
        invJ = sgeo[sid+p_IJID];
        hinv = sgeo[sid+p_IHID];

        int bc = EToB[face+p_Nfaces*element];
        // if(bc>0) {
        //   ellipticHomogeneousBC2D(bc, gradqM.w, gradqM.x, gradqM.y, gradqP.w, gradqP.x, gradqP.y);
        //   gradqP = 2*gradqP - gradqM;
        // }

        const dfloat dq = gradqP.w - gradqM.w;
        const dfloat hlf = 0.5f;

        s_nxdq[n] = hlf*sJ*invJ*nx*dq;
        s_nydq[n] = hlf*sJ*invJ*ny*dq;

        s_lapflux[n] = hlf*sJ*invJ*(-nx*(gradqP.x-gradqM.x)
                                    -ny*(gradqP.y-gradqM.y)
                                    -tau*hinv*dq);
      }
    }

    @barrier("local");

    // dqdx += LIFT*(sJ/J)*nx*dq
    for(int n=0;n<p_maxNodes;++n;@inner(0)){

      if(n<p_Np){
        const int element = elementList[e];
        const int gid = element*p_Nvgeo;
        const dfloat drdx = vgeo[gid + p_RXID];
        const dfloat drdy = vgeo[gid + p_RYID];
        const dfloat dsdx = vgeo[gid + p_SXID];
        const dfloat dsdy = vgeo[gid + p_SYID];

        dfloat Lnxdq = 0;
        dfloat Lnydq = 0;

        #pragma unroll p_NfacesNfp
          for(int i=0;i<p_NfacesNfp;++i){
            Lnxdq += LIFTT[n+i*p_Np]*s_nxdq[i];
            Lnydq += LIFTT[n+i*p_Np]*s_nydq[i];
          }

        dfloat dqdx = s_dqdx[n] + Lnxdq;
        dfloat dqdy = s_dqdy[n] + Lnydq;
        s_dqdx[n] = drdx*dqdx + drdy*dqdy; // abuse of notation
        s_dqdy[n] = dsdx*dqdx + dsdy*dqdy;

        s_Lnxdq[n] = Lnxdq;
        s_Lnydq[n] = Lnydq;
      }
    }

    @barrier("local");

    for(int n=0;n<p_maxNodes;++n;@inner(0)){
      if(n<p_NfacesNfp){
        int id = idM%p_Np;
        s_lapflux[n] += sJ*invJ*(nx*s_Lnxdq[id]+ny*s_Lnydq[id]);
      }

      if(n<p_Np){
        dfloat lapr = 0, laps = 0;

        #pragma unroll p_Np
          for(int i=0;i<p_Np;++i){
            lapr += DrT[n+i*p_Np]*s_dqdx[i];
            laps += DsT[n+i*p_Np]*s_dqdy[i];
          }

        s_lapq[n] -= (lapr+laps);
      }

    }

    @barrier("local");

    for(int n=0;n<p_maxNodes;++n;@inner(0)){
      if(n<p_Np){
        dfloat lap = 0;

        // lift remaining surface terms
        #pragma unroll p_NfacesNfp
          for(int i=0;i<p_NfacesNfp;++i){
            lap += LIFTT[n+i*p_Np]*s_lapflux[i];
          }

        s_lapq[n] += lap;
      }
    }

    @barrier("local");

    for(int n=0;n<p_maxNodes;++n;@inner(0)){

      if(n<p_Np){
        const int element = elementList[e];
        const dfloat J = vgeo[element*p_Nvgeo + p_JID];

        dfloat Mlapq = 0;

        // multiply by mass matrix
        #pragma unroll p_Np
          for(int i=0;i<p_Np;++i){
            Mlapq += MM[n+i*p_Np]*s_lapq[i];
          }

        Aq[n+element*p_Np] = J*Mlapq;
      }
    }
  }
}