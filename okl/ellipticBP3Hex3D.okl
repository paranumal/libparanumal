//author: Kasia
//purpose: summary of best A*x @kernels
// NO COLLOCATION differentiation in this file


#define p_gjNp (p_gjNq*p_gjNq*p_gjNq)
#define p_gjNq2 (p_gjNq*p_gjNq)
#define p_Nq2 (p_Nq*p_Nq)


#if p_Nq==8 || p_Nq==16
#define p_gllPad 1
#else
#define p_gllPad 0
#endif

#if p_gjNq ==8 || p_gjNq==16
#define p_gjPad 1
#else
#define p_gjPad 0
#endif

// previously 'reg1'
@kernel void ellipticAxHex3D_v1(const int Nelements,
                               @restrict const  int *  elementList,
                               @restrict const  dfloat *  gjGeo,
                               @restrict const  dfloat *  gllD,
                               @restrict const  dfloat *  gjI,
                               const dfloat lambda,
                               @restrict const  dfloat *  q,
                               @restrict const  dfloat *  Ixq,
                               @restrict dfloat *  Aq
                              ){
	for(int e=0; e<Nelements; ++e; @outer(0)) {

		@exclusive dfloat r_q[p_gjNq];
		@exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ, r_qt;
		//save the SHARED
		@shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq+p_gjPad];

		@shared dfloat s_gllD[p_gjNq][p_gjNq+p_gjPad];
		@shared dfloat s_I[p_gjNq][p_Nq];
		@shared dfloat s_qr[p_gjNq][p_gjNq+p_gjPad];
		@shared dfloat s_qs[p_gjNq][p_gjNq+p_gjPad];
		// LOAD TO SHAEWS
		@exclusive int emap;

		// prefetch D and I matrices and zero register storage
		//LOOP 1
		for(int b=0;b<p_gjNq;++b;@inner(1)){
			for(int a=0;a<p_gjNq;++a;@inner(0)){

				emap = elementList[e];
				//a<p_Nq && b<p_gjNq
				if(a<p_Nq){
					s_I[b][a] = gjI[a+p_Nq*b];
				}

				s_gllD[b][a] = gllD[b*p_gjNq+a];

				if(a<p_Nq && b<p_Nq){
					#pragma unroll p_Nq
					for(int c=0;c<p_Nq;++c){
						s_q[c][b][a] = q[emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a];
					}
				}
			}
		}

		@barrier("local");
		//============== interpolate in 3 dir ========================
		// b --> a --> c
		//Loop 2
		for(int c=0;c<p_gjNq;++c;@inner(1)){
			for(int a=0;a<p_gjNq;++a;@inner(0)){
				if(a<p_Nq && c<p_Nq){
					// prefetch to registers
					#pragma unroll p_Nq
					for(int b=0;b<p_Nq;++b)
						r_q[b] = s_q[c][b][a];

					// transform in b
					#pragma unroll p_gjNq
					for(int j=0;j<p_gjNq;++j){
						dfloat tmp = 0;
						#pragma unroll p_Nq
						for(int b=0;b<p_Nq;++b)
							tmp += s_I[j][b]*r_q[b];
						s_q[c][j][a] = tmp; // ok since only this thread
					}
				}
			}
		}//for c

		@barrier("local");
		//Loop 3
		// transform in a
		for(int c=0;c<p_gjNq;++c;@inner(1)){
			for(int j=0;j<p_gjNq;++j;@inner(0)){
				if(c<p_Nq){
					// prefetch to registers
					#pragma unroll p_Nq
					for(int a=0;a<p_Nq;++a)
						r_q[a] = s_q[c][j][a];

					// transform in a
					#pragma unroll p_gjNq
					for(int i=0;i<p_gjNq;++i){
						dfloat tmp = 0;
						#pragma unroll p_Nq
						for(int a=0;a<p_Nq;++a)
							tmp += s_I[i][a]*r_q[a];
						s_q[c][j][i] = tmp; // ok since only this thread
					}
				}
			}
		}

		@barrier("local");
		// transform in c
		for(int j=0;j<p_gjNq;++j;@inner(1)){
			for(int i=0;i<p_gjNq;++i;@inner(0)){
				// prefetch to registers
				#pragma unroll p_Nq
				for(int c=0;c<p_Nq;++c)
					r_q[c] = s_q[c][j][i];

				// transform in c
				#pragma unroll p_gjNq
				for(int k=0;k<p_gjNq;++k){
					dfloat tmp = 0;
					#pragma unroll p_Nq
					for(int c=0;c<p_Nq;++c){
						tmp += s_I[k][c]*r_q[c];
					}
					s_q[k][j][i] = tmp; // ok since only this thread
				}
			}
		}
		//===============================================now differentiate once interpolated
		//Loop 5
		@barrier("local");
		#pragma unroll p_gjNq
		for(int k=0; k<p_gjNq; ++k)
			for(int j=0;j<p_gjNq;++j;@inner(1))
				for(int i=0;i<p_gjNq;++i;@inner(0))
					r_q[k] =0.0f;

		@barrier("local");
		//Loop6
		#pragma unroll p_gjNq
		for(int k=0; k<p_gjNq; ++k) {
			@barrier("local");
			//Loop6-1
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					const int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					//geofactors for k j i thread
					r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
					r_G00 = gjGeo[base+p_G00ID*p_gjNp];
					r_G01 = gjGeo[base+p_G01ID*p_gjNp];
					r_G02 = gjGeo[base+p_G02ID*p_gjNp];

					r_G11 = gjGeo[base+p_G11ID*p_gjNp];
					r_G12 = gjGeo[base+p_G12ID*p_gjNp];
					r_G22 = gjGeo[base+p_G22ID*p_gjNp];
					// now, put together dq/dr, qq/ds, dq/dt and dq/dI

					dfloat dr = 0.0f;
					dfloat ds = 0.0f;
					dfloat dt = 0.0f;
					#pragma unroll p_gjNq
					for (int n = 0; n<p_gjNq; ++n) {
						dr += s_gllD[i][n]*s_q[k][j][n];
						ds += s_gllD[j][n]*s_q[k][n][i];
						dt += s_gllD[k][n]*s_q[n][j][i];
					}

					s_qr[j][i] = r_G00*dr + r_G01*ds + r_G02*dt;
					s_qs[j][i] = r_G01*dr + r_G11*ds + r_G12*dt;
					r_qt = r_G02*dr + r_G12*ds + r_G22*dt;

					r_q[k] += lambda*r_GwJ*s_q[k][j][i];
				}
			}

			@barrier("local");
			//Loop 6-2
			// weak diff
			for(int j=0;j<p_gjNq;++j;@inner(1)){
				for(int i=0;i<p_gjNq;++i;@inner(0)){
					dfloat lapqr = 0.0f, lapqs = 0.0f;
					#pragma unroll p_gjNq
					for(int n=0;n<p_gjNq;++n){
						lapqr += s_gllD[n][i]*s_qr[j][n];
						lapqs += s_gllD[n][j]*s_qs[n][i];
						r_q[n] += s_gllD[k][n]*r_qt;
					}
					r_q[k] += lapqr + lapqs;
				}
			}
		}//k

		@barrier("local");

		//Loop 7
		for(int j=0;j<p_gjNq;++j;@inner(1)){
			for(int i=0;i<p_gjNq;++i;@inner(0)){
				#pragma unroll p_gjNq
				for(int k=0; k<p_gjNq; ++k) {
					s_q[k][j][i] = r_q[k];
				}
			}
		}

		// ALL CORRECT UNTIL THIS POINT
		@barrier("local");
		//=========== now project =================================================
		// b -> c -> a

		//Loop 8
		// transform back in b
		for(int k=0;k<p_gjNq;++k;@inner(1)){
			for(int i=0;i<p_gjNq;++i;@inner(0)){
				#pragma unroll p_gjNq
				for(int j=0;j<p_gjNq;++j){
					r_q[j] = s_q[k][j][i];
				}

				#pragma unroll p_Nq
				for(int b=0;b<p_Nq;++b){
					dfloat tmp = 0.0f;
					#pragma unroll p_gjNq
					for(int j=0;j<p_gjNq;++j){
						tmp += s_I[j][b]*r_q[j];
					}
					s_q[k][b][i] = tmp; // ok since only this thread
				}
			}
		}

		@barrier("local");
		//Loop 9
		// transform back in a
		for(int k=0;k<p_gjNq;++k;@inner(1)){
			for(int b=0;b<p_gjNq;++b;@inner(0)){
				if(b<p_Nq){
					#pragma unroll p_gjNq
					for(int i=0;i<p_gjNq;++i)
						r_q[i] = s_q[k][b][i];

					#pragma unroll p_Nq
					for(int a=0;a<p_Nq;++a){
						dfloat tmp = 0.0f;
						#pragma unroll p_gjNq
						for(int i=0;i<p_gjNq;++i){
							tmp += s_I[i][a]*r_q[i];
						}
						s_q[k][b][a] =tmp;;
					}
				}
			}
		}

		//Loop 10
		@barrier("local");
		// transform back in c
		for(int b=0;b<p_gjNq;++b;@inner(1)){
			for(int a=0;a<p_gjNq;++a;@inner(0)){
				if(a<p_Nq && b<p_Nq){
					//#pragma unroll p_gjNq
					for(int k=0;k<p_gjNq;++k){
						r_q[k] = s_q[k][b][a];
					}

					#pragma unroll p_Nq
					for(int c=0;c<p_Nq;++c){
						dfloat tmp = 0.0f;
						#pragma unroll p_gjNq
						for(int k=0;k<p_gjNq;++k){
							tmp += s_I[k][c]*r_q[k];
						}
						Aq[emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a] = tmp;
					}//c
				}//if
			}//a
		}//b
	}//e
}//@kernel


//v2 is a splitting version of v1 (split in 3 @kernels)
// previously known as "reg3"

@kernel void ellipticAxHex3D_v2(const int Nelements,
                               @restrict const  int *  elementList,
                               @restrict const  dfloat *  gjGeo,
                               @restrict const  dfloat *  gllD,
                               @restrict const  dfloat *  gjI,
                               const dfloat lambda,
                               @restrict const  dfloat *  q,
                               @restrict dfloat *  Ixq,
                               @restrict dfloat *  Aq
                              ){
	//@kernel 1: interpolate ---------------------------------------------------------
	for(int e=0; e<Nelements; ++e; @outer(0)) {

		@exclusive dfloat r_q[p_gjNq];

		@shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];

		@shared dfloat s_gllD[p_gjNq][p_gjNq+p_gjPad];
		@shared dfloat s_I[p_gjNq][p_Nq+p_gllPad];
		@shared dfloat s_qr[p_gjNq][p_gjNq+p_gjPad];
		@shared dfloat s_qs[p_gjNq][p_gjNq+p_gjPad];
		@exclusive int emap;

		// prefetch D and I matrices
		for(int b=0;b<p_gjNq;++b;@inner(1)){
			for(int a=0;a<p_gjNq;++a;@inner(0)){

				emap = elementList[e];
				if(a<p_Nq){
					s_I[b][a] = gjI[a+p_Nq*b];
				}
				s_gllD[b][a] = gllD[b*p_gjNq+a];
				if(a<p_Nq && b<p_Nq){
					#pragma unroll p_Nq
					for(int c=0;c<p_Nq;++c){
						s_q[c][b][a] = q[emap*p_Np+c*p_Nq*p_Nq+b*p_Nq+a];
					}
				}
			}
		}

		@barrier("local");
		//============== interpolate in 3 dir ========================
		// b --> a --> c
		for(int c=0;c<p_gjNq;++c;@inner(1)){
			for(int a=0;a<p_gjNq;++a;@inner(0)){
				if(a<p_Nq && c<p_Nq){
					// prefetch to registers
					#pragma unroll p_Nq
					for(int b=0;b<p_Nq;++b)
						r_q[b] = s_q[c][b][a];

					// transform in b
					#pragma unroll p_gjNq
					for(int j=0;j<p_gjNq;++j){
						dfloat tmp = 0;
						#pragma unroll p_Nq
						for(int b=0;b<p_Nq;++b)
							tmp += s_I[j][b]*r_q[b];
						s_q[c][j][a] = tmp; // ok since only this thread
					}
				}
			}
		}//for c

		@barrier("local");
		// transform in a
		for(int c=0;c<p_gjNq;++c;@inner(1)){
			for(int j=0;j<p_gjNq;++j;@inner(0)){
				if(c<p_Nq){

					// prefetch to registers
					#pragma unroll p_Nq
					for(int a=0;a<p_Nq;++a)
						r_q[a] = s_q[c][j][a];

					// transform in a
					#pragma unroll p_gjNq
					for(int i=0;i<p_gjNq;++i){
						dfloat tmp = 0;
						#pragma unroll p_Nq
						for(int a=0;a<p_Nq;++a)
							tmp += s_I[i][a]*r_q[a];
						s_q[c][j][i] = tmp; // ok since only this thread
					}
				}
			}
		}

		@barrier("local");
		// transform in c
		for(int j=0;j<p_gjNq;++j;@inner(1)){
			for(int i=0;i<p_gjNq;++i;@inner(0)){
				// prefetch to registers
				#pragma unroll p_Nq
				for(int c=0;c<p_Nq;++c)
					r_q[c] = s_q[c][j][i];

				// transform in c
				#pragma unroll p_gjNq
				for(int k=0;k<p_gjNq;++k){
					dfloat tmp = 0;
					#pragma unroll p_Nq
					for(int c=0;c<p_Nq;++c){
						tmp += s_I[k][c]*r_q[c];
					}
					s_q[k][j][i] = tmp; // ok since only this thread
					Ixq[emap*p_gjNp+k*p_gjNq*p_gjNq+j*p_gjNq+i]=s_q[k][j][i] ;
				}
			}
		}
	}

	//@kernel 2 differntiate --------------------------------------------------------
	//like in slab 1
	for(int e=0; e<Nelements; ++e; @outer(0)) {
		@shared dfloat s_tmpr[p_gjNq][p_gjNq+p_gjPad];
		@shared dfloat s_tmps[p_gjNq][p_gjNq+p_gjPad];
		@shared dfloat s_q[p_gjNq][p_gjNq+p_gjPad];
		@shared dfloat s_D[p_gjNq][p_gjNq+p_gjPad];

		@exclusive dfloat r_q[p_gjNq], r_Aq[p_gjNq], r_qt, r_tmpt;
		@exclusive int emap;
		@exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;
		// prefetch q(i,j,:,e) to register array
		for(int j=0; j<p_gjNq; ++j; @inner(1)) {
			for(int i=0; i<p_gjNq; ++i; @inner(0)) {
				emap = elementList[e];
				const int base = i + j*p_gjNq + emap*p_gjNp;
				#pragma unroll p_gjNq
				for(int k=0; k<p_gjNq; ++k) {
					r_q[k] = Ixq[base + k*p_gjNq*p_gjNq];
					r_Aq[k] = 0.f;
				}
				s_D[j][i] = gllD[j*p_gjNq+i];
			}
		}

		@barrier("local");
		#pragma unroll p_gjNq
		for(int k=0; k<p_gjNq; ++k) {
			@barrier("local");
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					const int gbase = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;

					r_G00 = gjGeo[gbase+p_G00ID*p_gjNp];
					r_G01 = gjGeo[gbase+p_G01ID*p_gjNp];
					r_G02 = gjGeo[gbase+p_G02ID*p_gjNp];
					r_G11 = gjGeo[gbase+p_G11ID*p_gjNp];
					r_G12 = gjGeo[gbase+p_G12ID*p_gjNp];
					r_G22 = gjGeo[gbase+p_G22ID*p_gjNp];
					r_GwJ = gjGeo[gbase+p_GWJID*p_gjNp];

					// share k-slice of q
					s_q[j][i] = r_q[k];

					// hide @shared latency behind t-derivative
					dfloat qtk = 0.f;
					#pragma unroll p_gjNq
					for(int n=0; n<p_gjNq; ++n) {
						qtk += s_D[k][n]*r_q[n];
					}
					r_qt = qtk;
				}
			}

			@barrier("local");

			// process k-slice (first r- and s-derivatives)
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat qr = 0.f, qs = 0.f;
					#pragma unroll p_gjNq
					for(int n=0; n<p_gjNq; ++n) {
						qr += s_D[i][n]*s_q[j][n];
						qs += s_D[j][n]*s_q[n][i];
					}

					// assumes w*J built into r_G entries
					s_tmpr[j][i] = r_G00*qr + r_G01*qs + r_G02*r_qt;
					s_tmps[j][i] = r_G01*qr + r_G11*qs + r_G12*r_qt;
					r_tmpt           = r_G02*qr + r_G12*qs + r_G22*r_qt;

					r_Aq[k] += r_GwJ*lambda*r_q[k];

					#pragma unroll p_gjNq
					for(int n=0; n<p_gjNq; ++n) {
						r_Aq[n] += s_D[k][n]*r_tmpt;
					}
				}
			}

			@barrier("local");
			// second derivatives
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Aq1 = 0.0f, Aq2 = 0.0f;

					#pragma unroll p_gjNq
					for(int n=0; n<p_gjNq; ++n) {
						Aq1 += s_D[n][i]*s_tmpr[j][n];
						Aq2 += s_D[n][j]*s_tmps[n][i];
					}
					r_Aq[k] +=  Aq1 + Aq2;
				}
			}
		}

		// write result out (local node storage)
		for(int j=0; j<p_gjNq; ++j; @inner(1)) {
			for(int i=0; i<p_gjNq; ++i; @inner(0)) {
				int id = emap*p_gjNp + j*p_gjNq + i;
				#pragma unroll p_gjNq
				for(int k=0; k<p_gjNq; ++k) {
					Ixq[id] = r_Aq[k];
					id += p_gjNq*p_gjNq;
				}
			}
		}
	}


	//@kernel 3 project back --------------------------------------------------------
	for(int e=0;e<Nelements;++e;@outer(0)){

		@shared dfloat s_I[p_gjNq][p_Nq+p_gllPad];
		@shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		@exclusive dfloat r_q[p_gjNq];
		@exclusive int emap;
		// prefetch D and I matrices and zero register storage
		for(int b=0;b<p_gjNq;++b;@inner(1)){
			for(int a=0;a<p_gjNq;++a;@inner(0)){
				emap = elementList[e];
				if(a<p_Nq)
					s_I[b][a] = gjI[a+p_Nq*b];

				#pragma unroll p_gjNq
				for(int c=0;c<p_gjNq;++c)
					s_q[c][b][a] = Ixq[emap*p_gjNp+c*p_gjNq*p_gjNq+b*p_gjNq+a];

			}
		}

		@barrier("local");
		for(int k=0;k<p_gjNq;++k;@inner(1)){
			for(int i=0;i<p_gjNq;++i;@inner(0)){
				#pragma unroll p_gjNq
				for(int j=0;j<p_gjNq;++j){
					r_q[j] = s_q[k][j][i];
				}

				#pragma unroll p_Nq
				for(int b=0;b<p_Nq;++b){
					dfloat tmp = 0.0f;
					#pragma unroll p_gjNq
					for(int j=0;j<p_gjNq;++j){
						tmp += s_I[j][b]*r_q[j];
					}
					s_q[k][b][i] = tmp; // ok since only this thread
				}
			}
		}

		@barrier("local");
		// transform back in a
		#pragma unroll p_gjNq
		for(int k=0;k<p_gjNq;++k;@inner(1)){
			@barrier("local");
			for(int b=0;b<p_gjNq;++b;@inner(0)){
				if(b<p_Nq){
					#pragma unroll p_gjNq
					for(int i=0;i<p_gjNq;++i)
						r_q[i] = s_q[k][b][i];

					#pragma unroll p_Nq
					for(int a=0;a<p_Nq;++a){
						dfloat tmp = 0.0f;
						#pragma unroll p_gjNq
						for(int i=0;i<p_gjNq;++i){
							tmp += s_I[i][a]*r_q[i];
						}
						s_q[k][b][a] =tmp;;
					}
				}
			}
		}

		@barrier("local");
		// transform back in c
		for(int b=0;b<p_gjNq;++b;@inner(1)){
			for(int a=0;a<p_gjNq;++a;@inner(0)){
				if(a<p_Nq && b<p_Nq){
					//#pragma unroll p_gjNq
					for(int k=0;k<p_gjNq;++k){
						r_q[k] = s_q[k][b][a];
					}
					#pragma unroll p_Nq
					for(int c=0;c<p_Nq;++c){
						dfloat tmp = 0.0f;
						#pragma unroll p_gjNq
						for(int k=0;k<p_gjNq;++k){
							tmp += s_I[k][c]*r_q[k];
						}
						Aq[emap*p_Np+c*p_Nq*p_Nq+b*p_Nq+a] = tmp;
					}//c
				}//if
			}//a
		}//b
	}//e
}

//v3, previously known as 'reg4'

//reg4 is one @kernel version of reg 3
@kernel void ellipticAxHex3D_v3(const int Nelements,
                               @restrict const  int *  elementList,
                               @restrict const  dfloat *  gjGeo,
                               @restrict const  dfloat *  gllD,
                               @restrict const  dfloat *  gjI,
                               const dfloat lambda,
                               @restrict const  dfloat *  q,
                               @restrict const  dfloat *  Ixq,
                               @restrict dfloat *  Aq
                              ){
	for(int e=0; e<Nelements; ++e; @outer(0)) {
		@exclusive dfloat r_q[p_gjNq];
		@exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ, r_qt;
		//save the SHARED
		@shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];

		@shared dfloat s_tmpr[p_gjNq][p_gjNq+p_gjPad];
		@shared dfloat s_tmps[p_gjNq][p_gjNq+p_gjPad];

		@shared dfloat s_D[p_gjNq][p_gjNq+p_gjPad];
		@exclusive dfloat r_Aq[p_gjNq],  r_tmpt;
		@shared dfloat s_I[p_gjNq][p_Nq+p_gllPad];
		@shared dfloat s_qr[p_gjNq][p_gjNq+p_gjPad];
		@shared dfloat s_qs[p_gjNq][p_gjNq+p_gjPad];
		@exclusive int emap;

		// prefetch D and I matrices
		for(int b=0;b<p_gjNq;++b;@inner(1)){
			for(int a=0;a<p_gjNq;++a;@inner(0)){
				emap = elementList[e];
				if(a<p_Nq){
					s_I[b][a] = gjI[a+p_Nq*b];
				}
				s_D[b][a] = gllD[b*p_gjNq+a];
				if(a<p_Nq && b<p_Nq){
					#pragma unroll p_Nq
					for(int c=0;c<p_Nq;++c){
						s_q[c][b][a] = q[emap*p_Np+c*p_Nq*p_Nq+b*p_Nq+a];
					}
				}
			}
		}

		//synch threads
		@barrier("local");
		//============== interpolate in 3 dir ========================
		// b --> a --> c
		for(int c=0;c<p_gjNq;++c;@inner(1)){
			for(int a=0;a<p_gjNq;++a;@inner(0)){
				if(a<p_Nq && c<p_Nq){
					// prefetch to registers
					#pragma unroll p_Nq
					for(int b=0;b<p_Nq;++b)
						r_q[b] = s_q[c][b][a];

					// transform in b
					#pragma unroll p_gjNq
					for(int j=0;j<p_gjNq;++j){
						dfloat tmp = 0;
						#pragma unroll p_Nq
						for(int b=0;b<p_Nq;++b)
							tmp += s_I[j][b]*r_q[b];
						s_q[c][j][a] = tmp; // ok since only this thread
					}
				}
			}
		}//for c

		@barrier("local");
		// transform in a
		for(int c=0;c<p_gjNq;++c;@inner(1)){
			for(int j=0;j<p_gjNq;++j;@inner(0)){
				if(c<p_Nq){

					// prefetch to registers
					#pragma unroll p_Nq
					for(int a=0;a<p_Nq;++a)
						r_q[a] = s_q[c][j][a];

					// transform in a
					#pragma unroll p_gjNq
					for(int i=0;i<p_gjNq;++i){
						dfloat tmp = 0;
						#pragma unroll p_Nq
						for(int a=0;a<p_Nq;++a)
							tmp += s_I[i][a]*r_q[a];
						s_q[c][j][i] = tmp; // ok since only this thread
					}
				}
			}
		}

		@barrier("local");
		// transform in c
		for(int j=0;j<p_gjNq;++j;@inner(1)){
			for(int i=0;i<p_gjNq;++i;@inner(0)){
				// prefetch to registers
				#pragma unroll p_Nq
				for(int c=0;c<p_Nq;++c)
					r_q[c] = s_q[c][j][i];

				// transform in c
				#pragma unroll p_gjNq
				for(int k=0;k<p_gjNq;++k){
					dfloat tmp = 0;
					#pragma unroll p_Nq
					for(int c=0;c<p_Nq;++c){
						tmp += s_I[k][c]*r_q[c];
					}
					s_q[k][j][i] = tmp; // ok since only this thread
				}
			}
		}

		@barrier("local");
		// prefetch q(i,j,:,e) to register array
		for(int j=0; j<p_gjNq; ++j; @inner(1)) {
			for(int i=0; i<p_gjNq; ++i; @inner(0)) {
				emap = elementList[e];
				const int base = i + j*p_gjNq + emap*p_gjNp;
				#pragma unroll p_gjNq
				for(int k=0; k<p_gjNq; ++k) {
					r_q[k] = s_q[k][j][i];
					r_Aq[k] = 0.f;
				}
			}
		}

		@barrier("local");
		#pragma unroll p_gjNq
		for(int k=0; k<p_gjNq; ++k) {
			@barrier("local");
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {

					const int gbase = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;

					r_G00 = gjGeo[gbase+p_G00ID*p_gjNp];
					r_G01 = gjGeo[gbase+p_G01ID*p_gjNp];
					r_G02 = gjGeo[gbase+p_G02ID*p_gjNp];
					r_G11 = gjGeo[gbase+p_G11ID*p_gjNp];
					r_G12 = gjGeo[gbase+p_G12ID*p_gjNp];
					r_G22 = gjGeo[gbase+p_G22ID*p_gjNp];
					r_GwJ = gjGeo[gbase+p_GWJID*p_gjNp];

					dfloat qtk = 0.f;
					#pragma unroll p_gjNq
					for(int n=0; n<p_gjNq; ++n) {
						qtk += s_D[k][n]*r_q[n];
					}
					r_qt = qtk;
				}
			}

			@barrier("local");
			// process k-slice (first r- and s-derivatives)
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat qr = 0.f, qs = 0.f;
					#pragma unroll p_gjNq
					for(int n=0; n<p_gjNq; ++n) {
						qr += s_D[i][n]*s_q[k][j][n];
						qs += s_D[j][n]*s_q[k][n][i];
					}

					// assumes w*J built into r_G entries
					s_tmpr[j][i] = r_G00*qr + r_G01*qs + r_G02*r_qt;
					s_tmps[j][i] = r_G01*qr + r_G11*qs + r_G12*r_qt;
					r_tmpt       = r_G02*qr + r_G12*qs + r_G22*r_qt;

					r_Aq[k] += r_GwJ*lambda*r_q[k];

					#pragma unroll p_gjNq
					for(int n=0; n<p_gjNq; ++n) {
						r_Aq[n] += s_D[k][n]*r_tmpt;
					}
				}
			}

			@barrier("local");
			// second derivatives
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Aq1 = 0.0f, Aq2 = 0.0f;

					#pragma unroll p_gjNq
					for(int n=0; n<p_gjNq; ++n) {
						Aq1 += s_D[n][i]*s_tmpr[j][n];
						Aq2 += s_D[n][j]*s_tmps[n][i];
					}
					r_Aq[k] +=  Aq1 + Aq2;
				}
			}
		}

		@barrier("local");
		// write result out (local node storage)
		for(int j=0; j<p_gjNq; ++j; @inner(1)) {
			for(int i=0; i<p_gjNq; ++i; @inner(0)) {
				int id = emap*p_gjNp + j*p_gjNq + i;
				#pragma unroll p_gjNq
				for(int k=0; k<p_gjNq; ++k) {
					s_q[k][j][i] = r_Aq[k];
				}
			}
		}
		//@kernel 3 project back --------------------------------------------------------

		@barrier("local");
		for(int k=0;k<p_gjNq;++k;@inner(1)){
			for(int i=0;i<p_gjNq;++i;@inner(0)){
				#pragma unroll p_gjNq
				for(int j=0;j<p_gjNq;++j){
					r_q[j] = s_q[k][j][i];
				}

				#pragma unroll p_Nq
				for(int b=0;b<p_Nq;++b){
					dfloat tmp = 0.0f;
					#pragma unroll p_gjNq
					for(int j=0;j<p_gjNq;++j){
						tmp += s_I[j][b]*r_q[j];
					}
					s_q[k][b][i] = tmp; // ok since only this thread
				}
			}
		}

		@barrier("local");
		// transform back in a
		#pragma unroll p_gjNq
		for(int k=0;k<p_gjNq;++k;@inner(1)){
			@barrier("local");
			for(int b=0;b<p_gjNq;++b;@inner(0)){
				if(b<p_Nq){
					#pragma unroll p_gjNq
					for(int i=0;i<p_gjNq;++i)
						r_q[i] = s_q[k][b][i];

					#pragma unroll p_Nq
					for(int a=0;a<p_Nq;++a){
						dfloat tmp = 0.0f;
						#pragma unroll p_gjNq
						for(int i=0;i<p_gjNq;++i){
							tmp += s_I[i][a]*r_q[i];
						}
						s_q[k][b][a] =tmp;;
					}
				}
			}
		}

		@barrier("local");
		// transform back in c
		for(int b=0;b<p_gjNq;++b;@inner(1)){
			for(int a=0;a<p_gjNq;++a;@inner(0)){
				if(a<p_Nq && b<p_Nq){
					#pragma unroll p_gjNq
					for(int k=0;k<p_gjNq;++k){
						r_q[k] = s_q[k][b][a];
					}

					#pragma unroll p_Nq
					for(int c=0;c<p_Nq;++c){
						dfloat tmp = 0.0f;
						#pragma unroll p_gjNq
						for(int k=0;k<p_gjNq;++k){
							tmp += s_I[k][c]*r_q[k];
						}
						Aq[emap*p_Np+c*p_Nq*p_Nq+b*p_Nq+a] = tmp;
					}//c
				}//if
			}//a
		}//b
	}//e
}

//v4, previously 'reg7'; here we get rid of one of the shmem arrays in cost of extra copy/synchronization

@kernel void ellipticAxHex3D_v4(const int Nelements,
                               @restrict const  int *  elementList,
                               @restrict const  dfloat *  gjGeo,
                               @restrict const  dfloat *  gllD,
                               @restrict const  dfloat *  gjI,
                               const dfloat lambda,
                               @restrict const  dfloat *  q,
                               @restrict const  dfloat *  Ixq,
                               @restrict dfloat *  Aq
                              ){
	for(int e=0; e<Nelements; ++e; @outer(0)) {

		@exclusive dfloat r_q[p_gjNq];
		@exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ, r_qt, r_qs;
		@shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];

		@shared dfloat s_gllD[p_gjNq][p_gjNq+p_gjPad];
		@shared dfloat s_qr[p_gjNq][p_gjNq+p_gjPad];
		@shared dfloat s_I[p_gjNq][p_Nq+p_gllPad];

		@exclusive int emap;

		// prefetch D and I matrices
		//LOOP 1
		for(int b=0;b<p_gjNq;++b;@inner(1)){
			for(int a=0;a<p_gjNq;++a;@inner(0)){
				emap = elementList[e];
				if(a<p_Nq){
					s_I[b][a] = gjI[a+p_Nq*b];
				}
				s_gllD[b][a] = gllD[b*p_gjNq+a];
				if(a<p_Nq && b<p_Nq){
					#pragma unroll p_Nq
					for(int c=0;c<p_Nq;++c){
						s_q[c][b][a] = q[emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a];
					}
				}
			}
		}

		@barrier("local");
		//============== interpolate in 3 dir ========================
		// b --> a --> c
		//Loop 2
		for(int c=0;c<p_gjNq;++c;@inner(1)){
			for(int a=0;a<p_gjNq;++a;@inner(0)){
				if(a<p_Nq && c<p_Nq){
					// prefetch to registers
					#pragma unroll p_Nq
					for(int b=0;b<p_Nq;++b)
						r_q[b] = s_q[c][b][a];

					// transform in b
					#pragma unroll p_gjNq
					for(int j=0;j<p_gjNq;++j){
						dfloat tmp = 0;
						#pragma unroll p_Nq
						for(int b=0;b<p_Nq;++b)
							tmp += s_I[j][b]*r_q[b];
						s_q[c][j][a] = tmp; // ok since only this thread
					}
				}
			}
		}//for c

		@barrier("local");
		//Loop 3
		// transform in a
		for(int c=0;c<p_gjNq;++c;@inner(1)){
			for(int j=0;j<p_gjNq;++j;@inner(0)){
				if(c<p_Nq){

					// prefetch to registers
					#pragma unroll p_Nq
					for(int a=0;a<p_Nq;++a)
						r_q[a] = s_q[c][j][a];

					// transform in a
					#pragma unroll p_gjNq
					for(int i=0;i<p_gjNq;++i){
						dfloat tmp = 0;
						#pragma unroll p_Nq
						for(int a=0;a<p_Nq;++a)
							tmp += s_I[i][a]*r_q[a];
						s_q[c][j][i] = tmp; // ok since only this thread
					}
				}
			}
		}

		//now synch
		@barrier("local");
		//Loop4
		// transform in c
		for(int j=0;j<p_gjNq;++j;@inner(1)){
			for(int i=0;i<p_gjNq;++i;@inner(0)){
				// prefetch to registers
				#pragma unroll p_Nq
				for(int c=0;c<p_Nq;++c)
					r_q[c] = s_q[c][j][i];

				// transform in c
				#pragma unroll p_gjNq
				for(int k=0;k<p_gjNq;++k){
					dfloat tmp = 0;
					#pragma unroll p_Nq
					for(int c=0;c<p_Nq;++c){
						tmp += s_I[k][c]*r_q[c];
					}
					s_q[k][j][i] = tmp; // ok since only this thread
				}
			}
		}

		//===============================================now differentiate once interpolated
		//Loop 5
		#pragma unroll p_gjNq
		for(int k=0; k<p_gjNq; ++k)
			for(int j=0;j<p_gjNq;++j;@inner(1))
				for(int i=0;i<p_gjNq;++i;@inner(0))
					r_q[k] =0.0f;
		@barrier("local");
		//Loop6
		#pragma unroll p_gjNq
		for(int k=0; k<p_gjNq; ++k) {
			@barrier("local");
			//Loop6-1
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					const int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					//geofactors for k j i thread
					r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
					r_G00 = gjGeo[base+p_G00ID*p_gjNp];
					r_G01 = gjGeo[base+p_G01ID*p_gjNp];
					r_G02 = gjGeo[base+p_G02ID*p_gjNp];

					r_G11 = gjGeo[base+p_G11ID*p_gjNp];
					r_G12 = gjGeo[base+p_G12ID*p_gjNp];
					r_G22 = gjGeo[base+p_G22ID*p_gjNp];
					// now, put together dq/dr, qq/ds, dq/dt and dq/dI

					dfloat dr = 0.0f;
					dfloat ds = 0.0f;
					dfloat dt = 0.0f;
					#pragma unroll p_gjNq
					for (int n = 0; n<p_gjNq; ++n) {
						dr += s_gllD[i][n]*s_q[k][j][n];
						ds += s_gllD[j][n]*s_q[k][n][i];
						dt += s_gllD[k][n]*s_q[n][j][i];
					}

					s_qr[j][i] = r_G00*dr + r_G01*ds + r_G02*dt;
					r_qs = r_G01*dr + r_G11*ds + r_G12*dt;
					r_qt = r_G02*dr + r_G12*ds + r_G22*dt;

					r_q[k] += lambda*r_GwJ*s_q[k][j][i];
				}
			}
			@barrier("local");
			//Loop 6-2
			// weak diff
			for(int j=0;j<p_gjNq;++j;@inner(1)){
				for(int i=0;i<p_gjNq;++i;@inner(0)){
					dfloat lapqr = 0.0f;

					#pragma unroll p_gjNq
					for(int n=0;n<p_gjNq;++n){
						lapqr += s_gllD[n][i]*s_qr[j][n];
						r_q[n] += s_gllD[k][n]*r_qt;
					}
					r_q[k] += lapqr;
				}
			}

			@barrier("local");
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					s_qr[j][i] = r_qs;
				}
			}
			@barrier("local");
			for(int j=0;j<p_gjNq;++j;@inner(1)){
				for(int i=0;i<p_gjNq;++i;@inner(0)){
					dfloat lapqs = 0.0f;

					#pragma unroll p_gjNq
					for(int n=0;n<p_gjNq;++n){
						lapqs += s_gllD[n][j]*s_qr[n][i];
					}
					r_q[k] += lapqs;
				}
			}
		}//k

		@barrier("local");

		//Loop 7
		for(int j=0;j<p_gjNq;++j;@inner(1)){
			for(int i=0;i<p_gjNq;++i;@inner(0)){

				#pragma unroll p_gjNq
				for(int k=0; k<p_gjNq; ++k) {
					s_q[k][j][i] = r_q[k];
				}
			}
		}

		// ALL CORRECT UNTIL THIS POINT
		@barrier("local");
		//=========== now project =================================================
		// b -> c -> a
		//Loop 8
		// transform back in b
		for(int k=0;k<p_gjNq;++k;@inner(1)){
			for(int i=0;i<p_gjNq;++i;@inner(0)){
				#pragma unroll p_gjNq
				for(int j=0;j<p_gjNq;++j){
					r_q[j] = s_q[k][j][i];
				}

				#pragma unroll p_Nq
				for(int b=0;b<p_Nq;++b){
					dfloat tmp = 0.0f;
					#pragma unroll p_gjNq
					for(int j=0;j<p_gjNq;++j){
						tmp += s_I[j][b]*r_q[j];
					}
					s_q[k][b][i] = tmp; // ok since only this thread
				}
			}
		}

		@barrier("local");
		//Loop 9
		// transform back in a
		for(int k=0;k<p_gjNq;++k;@inner(1)){
			for(int b=0;b<p_gjNq;++b;@inner(0)){
				if(b<p_Nq){
					#pragma unroll p_gjNq
					for(int i=0;i<p_gjNq;++i)
						r_q[i] = s_q[k][b][i];

					#pragma unroll p_Nq
					for(int a=0;a<p_Nq;++a){
						dfloat tmp = 0.0f;
						#pragma unroll p_gjNq
						for(int i=0;i<p_gjNq;++i){
							tmp += s_I[i][a]*r_q[i];
						}
						s_q[k][b][a] =tmp;;
					}
				}
			}
		}
		//Loop 10
		@barrier("local");
		//@shared dfloat s_I[p_gjNq][p_Nq];
		// transform back in c
		for(int b=0;b<p_gjNq;++b;@inner(1)){
			for(int a=0;a<p_gjNq;++a;@inner(0)){
				if(a<p_Nq && b<p_Nq){
					#pragma unroll p_gjNq
					for(int k=0;k<p_gjNq;++k){
						r_q[k] = s_q[k][b][a];
					}

					#pragma unroll p_Nq
					for(int c=0;c<p_Nq;++c){
						dfloat tmp = 0.0f;
						#pragma unroll p_gjNq
						for(int k=0;k<p_gjNq;++k){
							tmp += s_I[k][c]*r_q[k];
						}
						Aq[emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a] = tmp;
					}//c
				}//if
			}//a
		}//b
	}//e
}//@kernel

//v5, previously 'e6a'

@kernel void ellipticPartialAxHex3D_v5(const int Nelements,
                                      @restrict const  int *  elementList,
                                      @restrict const  dfloat *  gjGeo,
                                      @restrict const  dfloat *  gjD,
                                      @restrict const  dfloat *  gjI,
                                      const dfloat   lambda,
                                      @restrict const  dfloat *  q,
                                      @restrict dfloat *  Aq,
                                      @restrict const  dfloat *  qAq){


	for(int e=0;e<Nelements;++e;@outer(0)){

		@shared dfloat s_D[p_gjNq][p_gjNq];
		@shared dfloat s_I[p_gjNq][p_Nq+p_gllPad];

		@exclusive dfloat r_lapq[p_gjNq];

		@shared dfloat s_qr[p_gjNq][p_gjNq+p_gjPad];
		@shared dfloat s_qs[p_gjNq][p_gjNq+p_gjPad];

		@shared dfloat s_tmpq[p_gjNq][p_gjNq][p_gjNq];

		@exclusive int emap;
		@exclusive dfloat r_qt;

		// prefetch D and I matrices and zero register storage
		for(int b=0;b<p_gjNq;++b;@inner(1)){
			for(int a=0;a<p_gjNq;++a;@inner(0)){

				emap = elementList[e];

				const int t = a + p_gjNq*b;

				s_D[b][a] = gjD[b*p_gjNq+a];

				if(a<p_Nq && b<p_gjNq)
					s_I[b][a] = gjI[b*p_Nq+a];

				if(a<p_Nq && b<p_Nq){
					// prefetch q(a,b,:) to registers
					#pragma unroll p_Nq
					for(int c=0;c<p_Nq;++c){
						r_lapq[c] = q[emap*p_Np+c*p_Nq2+b*p_Nq+a];
					}
				}
			}
		}

		@barrier("local");

		for(int b=0;b<p_gjNq;++b;@inner(1)){
			for(int a=0;a<p_gjNq;++a;@inner(0)){

				if(a<p_Nq && b<p_Nq){

					#pragma unroll p_Nq
					for(int k=0;k<p_gjNq;++k){
						dfloat tmp = 0;

						#pragma unroll p_Nq
						for(int c=0;c<p_Nq;++c){
							tmp += s_I[k][c]*r_lapq[c];
						}

						s_tmpq[k][b][a] = tmp;
					}
				}
				#pragma unroll p_gjNq
				for(int k=0;k<p_gjNq;++k){
					r_lapq[k] = 0;
				}
			}
		}

		// scan through k slices
		// interpolate to GJ in each 'r' and 's' direction
		#pragma unroll p_gjNq
		for(int k=0;k<p_gjNq;++k){

			@barrier("local");

			for(int b=0;b<p_gjNq;++b;@inner(1)){
				for(int i=0;i<p_gjNq;++i;@inner(0)){
					dfloat tmp = 0;

					if(b<p_Nq){
						#pragma unroll p_Nq
						for(int a=0;a<p_Nq;++a){
							tmp += s_I[i][a]*s_tmpq[k][b][a];
						}
					}
					s_qr[b][i] = tmp;
				}
			}

			@barrier("local");

			for(int j=0;j<p_gjNq;++j;@inner(1)){
				for(int i=0;i<p_gjNq;++i;@inner(0)){

					dfloat tmp = 0;

					#pragma unroll p_Nq
					for(int b=0;b<p_Nq;++b){
						tmp += s_I[j][b]*s_qr[b][i];
					}

					s_tmpq[k][j][i] = tmp;
				}
			}
		}

		#pragma unroll p_gjNq
		for(int k=0;k<p_gjNq;++k){

			@barrier("local");

			for(int j=0;j<p_gjNq;++j;@inner(1)){
				for(int i=0;i<p_gjNq;++i;@inner(0)){

					const int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					const dfloat r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
					const dfloat r_G00 = gjGeo[base+p_G00ID*p_gjNp];
					const dfloat r_G01 = gjGeo[base+p_G01ID*p_gjNp];
					const dfloat r_G02 = gjGeo[base+p_G02ID*p_gjNp];

					const dfloat r_G11 = gjGeo[base+p_G11ID*p_gjNp];
					const dfloat r_G12 = gjGeo[base+p_G12ID*p_gjNp];
					const dfloat r_G22 = gjGeo[base+p_G22ID*p_gjNp];

					// differentiate
					dfloat qr = 0, qs = 0, qt = 0;
					#pragma unroll p_gjNq
					for(int n=0;n<p_gjNq;++n){
						qr += s_D[i][n]*s_tmpq[k][j][n];
						qs += s_D[j][n]*s_tmpq[k][n][i];
						qt += s_D[k][n]*s_tmpq[n][j][i];
					}

				}
			}

			@barrier("local");

			// weak diff
			for(int j=0;j<p_gjNq;++j;@inner(1)){
				for(int i=0;i<p_gjNq;++i;@inner(0)){
					dfloat lapqr = 0, lapqs = 0;

					#pragma unroll p_gjNq
					for(int n=0;n<p_gjNq;++n){
						lapqr += s_D[n][i]*s_qr[j][n];
						lapqs += s_D[n][j]*s_qs[n][i];
						r_lapq[n] += s_D[k][n]*r_qt;
					}

					r_lapq[k] += lapqr + lapqs;
				}
			}
		}

		// now interpolate back in 't'
		#pragma unroll p_Nq
		for(int c=0;c<p_Nq;++c){

			@barrier("local");

			for(int j=0;j<p_gjNq;++j;@inner(1)){
				for(int i=0;i<p_gjNq;++i;@inner(0)){
					dfloat tmp = 0;

					#pragma unroll p_gjNq
					for(int k=0;k<p_gjNq;++k){
						tmp += s_I[k][c]*r_lapq[k];
					}

					s_tmpq[c][j][i] = tmp;
				}
			}

			@barrier("local");

			for(int b=0;b<p_gjNq;++b;@inner(1)){
				for(int i=0;i<p_gjNq;++i;@inner(0)){
					if(b<p_Nq){
						dfloat tmp = 0;

						#pragma unroll p_gjNq
						for(int j=0;j<p_gjNq;++j){
							tmp += s_I[j][b]*s_tmpq[c][j][i];
						}

						s_qr[b][i] = tmp;
					}
				}
			}

			@barrier("local");

			for(int b=0;b<p_gjNq;++b;@inner(1)){
				for(int a=0;a<p_gjNq;++a;@inner(0)){
					const int t = a + b*p_gjNq;
					if(t<p_Nq*p_Nq){
						const int ta = t%p_Nq;
						const int tb = t/p_Nq;

						dfloat tmp = 0;

						#pragma unroll p_gjNq
						for(int i=0;i<p_gjNq;++i){
							tmp += s_I[i][ta]*s_qr[tb][i];
						}

						const int id = emap*p_Np + c*p_Nq2 + tb*p_Nq + ta;
						Aq[id] = tmp;
					}
				}
			}
		}
	}
}


//previously known as e6b
@kernel void ellipticPartialAxHex3D_v6(const int Nelements,
                                      @restrict const  int *  elementList,
                                      @restrict const  dfloat *  gjGeo,
                                      @restrict const  dfloat *  gjD,
                                      @restrict const  dfloat *  gjI,
                                      const dfloat   lambda,
                                      @restrict const  dfloat *  q,
                                      @restrict dfloat *  Aq,
                                      @restrict const  dfloat *  qAq){


	for(int e=0;e<Nelements;++e;@outer(0)){

		@shared dfloat s_D[p_gjNq][p_gjNq];
		@shared dfloat s_I[p_gjNq][p_Nq+p_gllPad];

		@exclusive dfloat r_lapq[p_gjNq];
		@exclusive dfloat r_tmpq[p_gjNq];

		@shared dfloat s_tmpq[p_gjNq][p_gjNq];

		@shared dfloat s_qr[p_gjNq][p_gjNq+p_gjPad];
		@shared dfloat s_qs[p_gjNq][p_gjNq+p_gjPad];

		@exclusive int emap;
		@exclusive dfloat r_qt;

		// prefetch D and I matrices and zero register storage
		for(int b=0;b<p_gjNq;++b;@inner(1)){
			for(int a=0;a<p_gjNq;++a;@inner(0)){

				emap = elementList[e];

				const int t = a + p_gjNq*b;

				s_D[b][a] = gjD[b*p_gjNq+a];

				if(a<p_Nq && b<p_gjNq)
					s_I[b][a] = gjI[b*p_Nq+a];

#if 0
				if(a<p_Nq && b<p_Nq){
					// prefetch q(a,b,:) to registers
					#pragma unroll p_Nq
					for(int c=0;c<p_Nq;++c){
						r_lapq[c] = q[emap*p_Np+c*p_Nq2+b*p_Nq+a];
					}
				}
#endif
			}
		}

		#pragma unroll p_Nq
		for(int k=0;k<p_gjNq;++k){

			@barrier("local");

			for(int b=0;b<p_gjNq;++b;@inner(1)){
				for(int a=0;a<p_gjNq;++a;@inner(0)){

					dfloat tmp = 0;

					if(a<p_Nq && b<p_Nq){
						#pragma unroll p_Nq
						for(int c=0;c<p_Nq;++c){

							tmp += s_I[k][c]*q[emap*p_Np+c*p_Nq2+b*p_Nq+a]; // r_lapq[c];
						}
					}

					s_tmpq[b][a] = tmp;
				}
			}

			@barrier("local");

			for(int b=0;b<p_gjNq;++b;@inner(1)){
				for(int i=0;i<p_gjNq;++i;@inner(0)){
					dfloat tmp = 0;

					if(b<p_Nq){
						#pragma unroll p_Nq
						for(int a=0;a<p_Nq;++a){
							tmp += s_I[i][a]*s_tmpq[b][a];
						}
					}

					s_qr[b][i] = tmp;
				}
			}

			@barrier("local");

			for(int j=0;j<p_gjNq;++j;@inner(1)){
				for(int i=0;i<p_gjNq;++i;@inner(0)){

					dfloat tmp = 0;

					#pragma unroll p_Nq
					for(int b=0;b<p_Nq;++b){
						tmp += s_I[j][b]*s_qr[b][i];
					}

					r_tmpq[k] = tmp;
				}
			}
		}

		for(int j=0;j<p_gjNq;++j;@inner(1))
			for(int i=0;i<p_gjNq;++i;@inner(0))
				for(int k=0;k<p_gjNq;++k)
					r_lapq[k] = 0;

		#pragma unroll p_gjNq
		for(int k=0;k<p_gjNq;++k){

			@barrier("local");

			for(int j=0;j<p_gjNq;++j;@inner(1))
				for(int i=0;i<p_gjNq;++i;@inner(0))
					s_tmpq[j][i] = r_tmpq[k];

			@barrier("local");

			for(int j=0;j<p_gjNq;++j;@inner(1)){
				for(int i=0;i<p_gjNq;++i;@inner(0)){

					const int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					const dfloat r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
					const dfloat r_G00 = gjGeo[base+p_G00ID*p_gjNp];
					const dfloat r_G01 = gjGeo[base+p_G01ID*p_gjNp];
					const dfloat r_G02 = gjGeo[base+p_G02ID*p_gjNp];

					const dfloat r_G11 = gjGeo[base+p_G11ID*p_gjNp];
					const dfloat r_G12 = gjGeo[base+p_G12ID*p_gjNp];
					const dfloat r_G22 = gjGeo[base+p_G22ID*p_gjNp];

					// differentiate
					dfloat qr = 0, qs = 0, qt = 0;
					#pragma unroll p_gjNq
					for(int n=0;n<p_gjNq;++n){
						qr += s_D[i][n]*s_tmpq[j][n];
						qs += s_D[j][n]*s_tmpq[n][i];
						qt += s_D[k][n]*r_tmpq[n];
					}

					// apply chain rule (notice the swtich of indices in i,j)
					s_qr[j][i] = r_G00*qr + r_G01*qs + r_G02*qt;
					s_qs[j][i] = r_G01*qr + r_G11*qs + r_G12*qt;
					r_qt = r_G02*qr + r_G12*qs + r_G22*qt;

					r_lapq[k] += lambda*r_GwJ*r_tmpq[k];
				}
			}

			@barrier("local");

			// weak diff
			for(int j=0;j<p_gjNq;++j;@inner(1)){
				for(int i=0;i<p_gjNq;++i;@inner(0)){
					dfloat lapqr = 0, lapqs = 0;

					#pragma unroll p_gjNq
					for(int n=0;n<p_gjNq;++n){
						lapqr += s_D[n][i]*s_qr[j][n];
						lapqs += s_D[n][j]*s_qs[n][i];
					}
					#pragma unroll p_gjNq
					for(int n=0;n<p_gjNq;++n){
						r_lapq[n] += s_D[k][n]*r_qt;
					}

					r_lapq[k] += lapqr + lapqs;
				}
			}
		}

		// now interpolate back in 't'
		#pragma unroll p_Nq
		for(int c=0;c<p_Nq;++c){

			@barrier("local");

			for(int j=0;j<p_gjNq;++j;@inner(1)){
				for(int i=0;i<p_gjNq;++i;@inner(0)){
					dfloat tmp = 0;

					#pragma unroll p_gjNq
					for(int k=0;k<p_gjNq;++k){
						tmp += s_I[k][c]*r_lapq[k];
					}

					s_tmpq[j][i] = tmp;
				}
			}

			@barrier("local");

			for(int b=0;b<p_gjNq;++b;@inner(1)){
				for(int i=0;i<p_gjNq;++i;@inner(0)){
					if(b<p_Nq){
						dfloat tmp = 0;

						#pragma unroll p_gjNq
						for(int j=0;j<p_gjNq;++j){
							tmp += s_I[j][b]*s_tmpq[j][i];
						}

						s_qr[b][i] = tmp;
					}
				}
			}

			@barrier("local");

			for(int b=0;b<p_gjNq;++b;@inner(1)){
				for(int a=0;a<p_gjNq;++a;@inner(0)){
					const int t = a + b*p_gjNq;
					if(t<p_Nq2){
						const int ta = t%p_Nq;
						const int tb = t/p_Nq;
						dfloat tmp = 0;

						#pragma unroll p_gjNq
						for(int i=0;i<p_gjNq;++i){
							tmp += s_I[i][ta]*s_qr[tb][i];
						}

						const int id = emap*p_Np + c*p_Nq2 + tb*p_Nq + ta;
						Aq[id] = tmp;
					}
				}
			}
		}
	}
}

//v7, previously e9 (our 'standard' @kernel)

@kernel void ellipticAxHex3D_v7(const int Nelements,
                               @restrict const  int *  elementList,
                               @restrict const  dfloat *  gjGeo,
                               @restrict const  dfloat *  gllD,
                               @restrict const  dfloat *  gjI,
                               const dfloat lambda,
                               @restrict dfloat *  q,
                               @restrict dfloat *  Ixq,
                               @restrict dfloat *  Aq
                              ){


	// load q into @shared first
	//@kernel 1 - interpolate to gj hex
	for(int e=0; e<Nelements; ++e; @outer(0)) {
		@exclusive int emap;
		@exclusive dfloat r_res;
		@shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		@shared dfloat s_gsI[p_gjNq][p_Nq];

		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int a=0; a<p_gjNq; ++a; @inner(0)) {
					r_res =0.0f;
					if (c == 0 && a<p_Nq && b<p_gjNq) {
						s_gsI[b][a] = gjI[b*p_Nq+a];
					}
					emap = elementList[e];
					int t = a + b*p_gjNq + c*p_gjNq2;
					if (t<p_Np) {
						int ta = t%p_Nq;
						int tb = (t/p_Nq)%p_Nq;
						int tc = t/p_Nq2;
						s_q[tc][tb][ta] = q[emap*p_Np+t];
					}//if
				}//for a
			}// for b
		}//for c
		//synch threads
		@barrier("local");
		//============== interpolate in 3 dir ========================
		// r --> s --> t
		// rrrrrrr
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Iq = 0.0f;
					if (c<p_Nq && b<p_Nq){
						#pragma unroll p_Nq
						for(int n=0; n<p_Nq; ++n) {
							Iq += s_gsI[i][n]*s_q[c][b][n];
						}
					}
					r_res = Iq;			a
				}
			}
		}

		@barrier("local");

		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					s_q[c][b][i] = r_res;
				}
			}
		}
		@barrier("local");

		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Iq = 0.0f;
					if(c<p_Nq) {
						#pragma unroll p_Nq
						for(int n=0; n<p_Nq; ++n) {
							Iq += s_gsI[j][n]*s_q[c][n][i];
						}
					}
					r_res = Iq;
				}
			}
		}

		@barrier("local");
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					s_q[c][j][i] = r_res;
				}
			}
		}

		@barrier("local");
		// t direction
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Iq = 0.0f;
					#pragma unroll p_Nq
					for(int n=0; n<p_Nq; ++n) {
						Iq += s_gsI[k][n]*s_q[n][j][i];
					}
					//	r_res = Iq;
					//		s_q[k][j][i] = Iq;
					emap = elementList[e];
					const int id = emap*p_gjNp + k*p_gjNq*p_gjNq+ j*p_gjNq + i;
					Ixq[id] = Iq;
				}
			}
		}
	}// for e

	// at this point q is interpolated in all 3 dim.
	// ------------KERNEL 2 -------------->

	// @kernel 2 differentiate on gj hex
	for(int e=0; e<Nelements; ++e; @outer(0)) {
		@shared dfloat s_gjD[p_gjNq][p_gjNq];
		//	@shared dfloat s_gllD[p_gjNq][p_Nq];
		@shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		@exclusive dfloat r_qr, r_qs, r_qt, r_tmp;
		@exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;
		@exclusive int emap;

		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					// D to @shared, q to @shared,
					if (k==0 ) {
						s_gjD[j][i] = gllD[j*p_gjNq+i];
					}
					emap = elementList[e];
					int t = i + j*p_gjNq + k*p_gjNq2;
					s_q[k][j][i] = Ixq[emap*p_gjNp+t];
				}//for i
			}//for j
		}//for k
		@barrier("local");

		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					//load geofactors for my (k,j,i)
					//		emap = elementList[e];
					const int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					//geofactors for k j i thread
					r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
					r_G00 = gjGeo[base+p_G00ID*p_gjNp];
					r_G01 = gjGeo[base+p_G01ID*p_gjNp];
					r_G02 = gjGeo[base+p_G02ID*p_gjNp];

					r_G11 = gjGeo[base+p_G11ID*p_gjNp];
					r_G12 = gjGeo[base+p_G12ID*p_gjNp];
					r_G22 = gjGeo[base+p_G22ID*p_gjNp];
					// now, put together dq/dr, qq/ds, dq/dt and dq/dI

					dfloat dr = 0.0f;
					dfloat ds = 0.0f;
					dfloat dt = 0.0f;
					#pragma unroll p_gjNq
					for (int n = 0; n<p_gjNq; ++n) {
						dr += s_gjD[i][n] * s_q[k][j][n];
						ds += s_gjD[j][n]*s_q[k][n][i];
						dt += s_gjD[k][n]*s_q[n][j][i];
					}
					r_qr = r_G00*dr + r_G01*ds + r_G02*dt;
					r_qs = r_G01*dr + r_G11*ds + r_G12*dt;
					r_qt = r_G02*dr + r_G12*ds + r_G22*dt;

					r_tmp = r_GwJ*s_q[k][j][i]*lambda;
				}
			}
		}
		@barrier("local");
		// Multiply by D^T, size p_Nq x p_gjNq
		// D size p_gjNq x p_Nq

		// r direction
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					s_q[k][j][i] = r_qr;
				}
			}
		}
		@barrier("local");

		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat tmp = 0.f;
					#pragma unroll p_gjNq
					for(int m=0; m<p_gjNq; ++m) {
						tmp += s_gjD[m][i]*s_q[k][j][m];
					}
					r_tmp +=tmp;
				}
			}
		}
		@barrier("local");

		//s direction

		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					s_q[k][j][i] = r_qs;
				}
			}
		}
		@barrier("local");
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat tmp = 0.f;
					#pragma unroll p_gjNq
					for(int m=0; m<p_gjNq; ++m) {
						tmp += s_gjD[m][j]*s_q[k][m][i];
					}
					r_tmp +=tmp;
				}
			}
		}
		@barrier("local");
		//t direction

		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					s_q[k][j][i] = r_qt;
				}
			}
		}
		@barrier("local");
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat tmp = 0.f;
					#pragma unroll p_gjNq
					for(int m=0; m<p_gjNq; ++m) {
						tmp += s_gjD[m][k]*s_q[m][j][i];
					}
					r_tmp +=tmp;
					int base = emap*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					Ixq[base] = r_tmp;
				}
			}
		}
	}//for e

	//-------------------- @kernel 3 interpolate back to gll hex ------------------->

	for(int e=0; e<Nelements; ++e; @outer(0)) {
		// read q

		@shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		@shared dfloat s_I[p_gjNq][p_Nq];
		@exclusive dfloat r_res = 0.0f, r_Aq=0.0f;
		int emap;
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {

					int base = k*p_gjNq*p_gjNq + j*p_gjNq + i;
					emap =elementList[e];
					s_q[k][j][i] = Ixq[emap*p_gjNp+base];
					if(i<p_Nq &&  k == 0 && j<p_gjNq) {
						s_I[j][i] = gjI[j*p_Nq+i];
					}
				}
			}
		}
		@barrier("local");


		// t first
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Iq = 0.0f;
					if(c<p_Nq){
						#pragma unroll p_gjNq
						for(int m=0; m<p_gjNq; ++m) {
							// k--> c
							Iq += s_I[m][c]*s_q[m][j][i];
						}
					}
					r_res = Iq;
				}
			}
		}

		@barrier("local");

		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					s_q[c][j][i] = r_res;
				}
			}
		}


		// @shared dfloat s_I[p_gjNq][p_Nq];

		// r direction
		@barrier("local");

		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					if(c<p_Nq && b<p_Nq){
						dfloat Iq = 0.0f;
						#pragma unroll p_gjNq
						for(int m=0; m<p_gjNq; ++m) {
							Iq += s_I[m][b]*s_q[c][m][i];
						}
						r_res = Iq;
					}
				}
			}
		}
		@barrier("local");

		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					s_q[c][b][i]= r_res;
				}
			}
		}
		@barrier("local");

		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int a=0; a<p_gjNq; ++a; @inner(0)) {
					if (c<p_Nq && b<p_Nq && a< p_Nq){
						dfloat Iq = 0.0f;
						#pragma unroll p_gjNq
						for(int m=0; m<p_gjNq; ++m) {
							Iq += s_I[m][a]*s_q[c][b][m];
						}
						emap = elementList[e];
						int base = emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a;
						Aq[base] = Iq;
					}
				}
			}
		}
	}//e
} //@kernel e7


