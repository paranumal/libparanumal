
#define RXID 0  
#define RYID 1  
#define SXID 2  
#define SYID 3

@kernel void acousticsSplitPmlVolume2D(const int Nelements,
					  @restrict const  dfloat *  vgeo,
					  @restrict const  dfloat *  sigmax,
					  @restrict const  dfloat *  sigmay,
					  @restrict const  dfloat *  DrT,
					  @restrict const  dfloat *  DsT,
					  @restrict const  dfloat4 *  q,
					  @restrict const  dfloat *  pmlqx,
					  @restrict const  dfloat *  pmlqy,
					  @restrict dfloat *  rhspmlqx,
					  @restrict dfloat *  rhspmlqy){
  
  for(int eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){  // for all elements

    @shared dfloat s_q[p_NblockV][p_Nfields][p_Np];
    
    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element
	
	int e = eo+es; // element in block
	if(e<Nelements){
	  const int id = e*p_Np+n;
	  dfloat4 qan = q[id];
	  
	  s_q[es][0][n] = qan.x;
	  s_q[es][1][n] = qan.y;
	  s_q[es][2][n] = qan.z;
	}
      }
    }

    // make sure all node data is loaded into @shared
    @barrier("local");

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element
	
	int e = eo+es; // element in block
	if(e<Nelements){
	  
	  // prefetch geometric factors (constant on triangle)
	  const dfloat drdx = vgeo[e*p_Nvgeo + RXID];
	  const dfloat drdy = vgeo[e*p_Nvgeo + RYID];
	  const dfloat dsdx = vgeo[e*p_Nvgeo + SXID];
	  const dfloat dsdy = vgeo[e*p_Nvgeo + SYID];

	  const dfloat sigmaxe = sigmax[e*p_Np+n];
	  const dfloat sigmaye = sigmay[e*p_Np+n];

	  int base = e*p_Np*p_Nfields+n;
	  dfloat pmlqx1 = pmlqx[base+0*p_Np];
	  dfloat pmlqx2 = pmlqx[base+1*p_Np];
	  dfloat pmlqx3 = pmlqx[base+2*p_Np];

	  dfloat pmlqy1 = pmlqy[base+0*p_Np];
	  dfloat pmlqy2 = pmlqy[base+1*p_Np];
	  dfloat pmlqy3 = pmlqy[base+2*p_Np];
	  
	  // compute 'r' and 's' derivatives of (q_m) at node n
	  dfloat dq1dr = 0, dq2dr = 0, dq3dr = 0;
	  dfloat dq1ds = 0, dq2ds = 0, dq3ds = 0;

	  #pragma unroll p_Np
	  for(int i=0;i<p_Np;++i){
	    const dfloat Drni = DrT[n+i*p_Np];
	    const dfloat Dsni = DsT[n+i*p_Np];
	    
	    // differentiate q components with respect to 'r' and 's'
	    dq1dr += Drni*s_q[es][0][i];
	    dq1ds += Dsni*s_q[es][0][i];
	    dq2dr += Drni*s_q[es][1][i];
	    dq2ds += Dsni*s_q[es][1][i];
	    dq3dr += Drni*s_q[es][2][i];
	    dq3ds += Dsni*s_q[es][2][i];
	  }
	  
	  // chain rule
	  dfloat dq1dx = drdx*dq1dr + dsdx*dq1ds;
	  dfloat dq2dx = drdx*dq2dr + dsdx*dq2ds;
	  dfloat dq3dx = drdx*dq3dr + dsdx*dq3ds;

	  dfloat dq1dy = drdy*dq1dr + dsdy*dq1ds;
	  dfloat dq2dy = drdy*dq2dr + dsdy*dq2ds;
	  dfloat dq3dy = drdy*dq3dr + dsdy*dq3ds;
	  	 	  
	  // transport operator
	  dfloat rhspmlqx1 = -p_sqrtRT*(dq2dx);
	  dfloat rhspmlqx2 = -p_sqrtRT*(dq1dx);
	  dfloat rhspmlqx3 = 0.f;

	  dfloat rhspmlqy1 = -p_sqrtRT*(dq3dy);
	  dfloat rhspmlqy2 = 0.f;
	  dfloat rhspmlqy3 = -p_sqrtRT*(dq1dy);

	  // pml relaxation back to mean flow
	  rhspmlqx1 += -sigmaxe*(pmlqx1);
	  rhspmlqx2 += -sigmaxe*(pmlqx2);
	  rhspmlqx3 += 0.f; -sigmaxe*(pmlqx3);

	  rhspmlqy1 += -sigmaye*(pmlqy1);
	  rhspmlqy2 += 0.f; -sigmaye*(pmlqy2);
	  rhspmlqy3 += -sigmaye*(pmlqy3);
	  
	  rhspmlqx[base+0*p_Np] = rhspmlqx1;
	  rhspmlqx[base+1*p_Np] = rhspmlqx2;
	  rhspmlqx[base+2*p_Np] = 0; rhspmlqx3;
	  
	  rhspmlqy[base+0*p_Np] = rhspmlqy1;
	  rhspmlqy[base+1*p_Np] = 0; rhspmlqy2;
	  rhspmlqy[base+2*p_Np] = rhspmlqy3;
	}
      }
    }
  }
}


