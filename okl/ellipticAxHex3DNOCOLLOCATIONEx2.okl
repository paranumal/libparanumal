//this is a sequwnce of optimizations applied to a full Ax AKA BP3 (benchmark problem 3)
// put together by Kasia for paper
// ONLY 2D versions in this file

#define p_gjNp (p_gjNq*p_gjNq*p_gjNq)
#define p_gjNq2 (p_gjNq*p_gjNq)
#define p_Nq2 (p_Nq*p_Nq)

//Ref 0, no optimizations and 3 @kernel version, as inefficient as I was able to think

@kernel void ellipticAxHex3D_Ref3D0( int Nelements,
                                    int *  elementList,
                                    dfloat *gjGeo,
                                    dfloat *  gllD,
                                    dfloat *  gjI,
                                    dfloat lambda,
                                    dfloat * q,
                                    dfloat * Ixq,
                                    dfloat *  Aq
                                  ){
                                  
                                  
	// load q into @shared first
	//@kernel 1 - interpolate to gj hex
	for(int e=0; e<Nelements; ++e; @outer(0)) {
		@exclusive int emap;
		@exclusive dfloat r_res;
		//	@shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		//	@shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		@shared dfloat s_gsI[p_gjNq][p_Nq];
		
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int a=0; a<p_gjNq; ++a; @inner(0)) {
					//	r_res =0.0f;
					if (c == 0 && a<p_Nq && b<p_gjNq) {
						s_gsI[b][a] = gjI[b*p_Nq+a];
					}
					int emap = elementList[e];
					int t = a + b*p_gjNq + c*p_gjNq2;
					/*		if (t<p_Np) {
								int ta = t%p_Nq;
								int tb = (t/p_Nq)%p_Nq;
								int tc = t/p_Nq2;
								s_q[tc][tb][ta] = q[emap*p_Np+t];
							}//if*/
					
				}//for a
			}// for b
		}//for c
		
		//synch threads
		@barrier("local");
		//============== interpolate in 3 dir ========================
		// r --> s --> t
		// rrrrrrr
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Iq = 0.0f;
					if (c<p_Nq && b<p_Nq){
					
						for(int n=0; n<p_Nq; ++n) {
							int emap = elementList[e];
							
							
							int t = n + b*p_Nq + c*p_Nq2;
							//we need s_q[c][b][n];
							//and there is A MAPPING
							// remember Q has fewer elements
							
							
							Iq += s_gsI[i][n]*q[t+emap*p_Np];
							//s_q[c][b][n];
						}
					}
					//		r_res = Iq;
					int emap = elementList[e];
					int t = i + b*p_gjNq + c*p_gjNq2;
					Aq[t+emap*p_gjNp] = Iq;
				}
			}
		}
		
		
		@barrier("local");
		
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Iq = 0.0f;
					if(c<p_Nq) {
					
						for(int n=0; n<p_Nq; ++n) {
							int emap = elementList[e];
							int t = i + n*p_gjNq + c*p_gjNq2;
							Iq += s_gsI[j][n]*Aq[emap*p_gjNp+t];
						}
					}
					int emap = elementList[e];
					int t = i + j*p_gjNq + c*p_gjNq2;
					Ixq[t+emap*p_gjNp] = Iq;
					//		r_res = Iq;
				}
			}
		}
		
		@barrier("local");
		
		
		
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Iq = 0.0f;
					
					for(int n=0; n<p_Nq; ++n) {
						int emap = elementList[e];
						int t = i + j*p_gjNq + n*p_gjNq2;
						Iq += s_gsI[k][n]*Ixq[t+emap*p_gjNp];
					}
					//	r_res = Iq;
					//		s_q[k][j][i] = Iq;
					emap = elementList[e];
					const int id = emap*p_gjNp + k*p_gjNq*p_gjNq+ j*p_gjNq + i;
					Aq[id] = Iq;
					
				}
			}
		}
	}
	
	
	
	
	// at this point q is interpolated in all 3 dim.
	// ------------KERNEL 2 -------------->
	
	// @kernel 2 differentiate on gj hex
	for(int e=0; e<Nelements; ++e; @outer(0)) {
		@shared dfloat s_gjD[p_gjNq][p_gjNq];
		//	@shared dfloat s_gllD[p_gjNq][p_Nq];
		//	@shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		@exclusive dfloat r_dr, r_ds, r_dt, r_tmp;
		//	@exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;
		//	@exclusive int emap;
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					// D to @shared, q to @shared,
					if (k==0 ) {
						s_gjD[j][i] = gllD[j*p_gjNq+i];
					}
					
				}//for i
			}//for j
		}//for k
		@barrier("local");
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					//load geofactors for my (k,j,i)
					int		emap = elementList[e];
					int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					//geofactors for k j i thread
					dfloat		GwJ = gjGeo[base+p_GWJID*p_gjNp];
					
					
					dfloat dr = 0.0f;
					dfloat ds = 0.0f;
					dfloat dt = 0.0f;
					
					for (int n = 0; n<p_gjNq; ++n) {
						dr += s_gjD[i][n]*Aq[n + j*p_gjNq + k*p_gjNq*p_gjNq + elementList[e]*p_gjNp];
						ds += s_gjD[j][n]*Aq[i + n*p_gjNq + k*p_gjNq*p_gjNq + elementList[e]*p_gjNp];
						dt += s_gjD[k][n]*Aq[i + j*p_gjNq + n*p_gjNq*p_gjNq + elementList[e]*p_gjNp];
					}
					r_dr = dr;
					r_ds = ds;
					r_dt = dt;
					
					//	emap = elementList[e];
					int t = i + j*p_gjNq + k*p_gjNq2;
					
					Ixq[t+emap*p_gjNp] = GwJ*Aq[t+emap*p_gjNp]*lambda;
				}
			}
		}
		@barrier("local");
		// Multiply by D^T, size p_Nq x p_gjNq
		// D size p_gjNq x p_Nq
		
		// r direction
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					int		emap = elementList[e];
					int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					dfloat		G00 = gjGeo[base+p_G00ID*p_gjNp];
					dfloat		G01 = gjGeo[base+p_G01ID*p_gjNp];
					dfloat		G02 = gjGeo[base+p_G02ID*p_gjNp];
					//	s_q[k][j][i] = r_qr;
					
					int t = i + j*p_gjNq + k*p_gjNq2;
					Aq[t+emap*p_gjNp] = G00*r_dr + G01*r_ds + G02*r_dt;;
					
				}
			}
		}
		
		@barrier("local");
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat tmp = 0.f;
					int emap = elementList[e];
					
					for(int m=0; m<p_gjNq; ++m) {
						//k j m
						emap = elementList[e];
						int t = m + j*p_gjNq + k*p_gjNq2;
						tmp += s_gjD[m][i]*Aq[t+p_gjNp*emap];
					}
					
					int t = i + j*p_gjNq + k*p_gjNq2;
					Ixq[t+emap*p_gjNp] +=tmp;
				}
			}
		}
		
		@barrier("local");
		
		//s direction
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					int emap = elementList[e];
					int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					dfloat G11 = gjGeo[base+p_G11ID*p_gjNp];
					dfloat G12 = gjGeo[base+p_G12ID*p_gjNp];
					dfloat		G01 = gjGeo[base+p_G01ID*p_gjNp];
					
					int t = i + j*p_gjNq + k*p_gjNq2;
					Aq[t+emap*p_gjNp] =G01*r_dr + G11*r_ds + G12*r_dt;
					//s_q[k][j][i] = r_qs;
				}
			}
		}
		@barrier("local");
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat tmp = 0.f;
					int emap = elementList[e];
					
					for(int m=0; m<p_gjNq; ++m) {
						//k m i
						emap = elementList[e];
						int t = i + m*p_gjNq + k*p_gjNq2;
						tmp += s_gjD[m][j]*Aq[t+emap*p_gjNp];
					}
					
					int t = i + j*p_gjNq + k*p_gjNq2;
					Ixq[t+emap*p_gjNp] +=tmp;
				}
			}
		}
		@barrier("local");
		//t direction
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
			
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					int emap = elementList[e];
					int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					
					dfloat		G02 = gjGeo[base+p_G02ID*p_gjNp];
					dfloat G12 = gjGeo[base+p_G12ID*p_gjNp];
					dfloat		G22 = gjGeo[base+p_G22ID*p_gjNp];
					
					int t = i + j*p_gjNq + k*p_gjNq2;
					Aq[t+emap*p_gjNp] =G02*r_dr + G12*r_ds + G22*r_dt;
					//		s_q[k][j][i] = r_qt;
				}
			}
		}
		@barrier("local");
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat tmp = 0.f;
					int emap = elementList[e];
					
					for(int m=0; m<p_gjNq; ++m) {
						// m j i
						
						int t = i + j*p_gjNq + m*p_gjNq2;
						tmp += s_gjD[m][k]*Aq[t+emap*p_gjNp];
					}
					//	r_tmp +=tmp;
					
					int base = emap*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					Ixq[base] += tmp;
				}
			}
		}
		
		
		
		
	}//for e
	
	
	
	
	//-------------------- @kernel 3 interpolate back to gll hex ------------------->
	
	for(int e=0; e<Nelements; ++e; @outer(0)) {
		// read q
		
		//		@shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		@shared dfloat s_I[p_gjNq][p_Nq];
		@exclusive dfloat r_res;
		
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
				
				
					//	s_q[k][j][i] = Ixq[emap*p_gjNp+base];
					if(i<p_Nq &&  k == 0 && j<p_gjNq) {
						s_I[j][i] = gjI[j*p_Nq+i];
					}
					int emap = elementList[e];
					int t = i + j*p_gjNq + k*p_gjNq2;
					r_res  = 0.0f;
				}
			}
		}
		@barrier("local");
		
		
		// t first
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Iq = 0.0f;
					int emap = elementList[e];
					if(c<p_Nq){
					
						for(int m=0; m<p_gjNq; ++m) {
							// k--> c
							
							int t = i + j*p_gjNq + m*p_gjNq2;
							
							Iq += s_I[m][c]*Ixq[t+p_gjNp*emap];
						}
					}
					r_res = Iq;
					
					//	int t = i + j*p_gjNq + c*p_gjNq2;
					//	Aq[t+emap*p_gjNp] =Iq;
				}
			}
		}
		
		@barrier("local");
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					int emap = elementList[e];
					int t = i + j*p_gjNq + c*p_gjNq2;
					Aq[t+emap*p_gjNp] =r_res;
				}
			}
		}
		
		
		
		
		
		
		// r direction
		
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					int emap = elementList[e];
					if(c<p_Nq && b<p_Nq){
						dfloat Iq = 0.0f;
						
						
						for(int m=0; m<p_gjNq; ++m) {
						
							int t = i + m*p_gjNq + c*p_gjNq2;
							Iq += s_I[m][b]*Aq[emap*p_gjNp+t];
						}
						
						r_res = Iq;
						
						//	int t = i + b*p_gjNq + c*p_gjNq2;
						//	Ixq[t+emap*p_gjNp] =Iq;
					}
					//	else
					//	{
					//	int t = i + b*p_gjNq + c*p_gjNq2;
					//	Ixq[t+emap*p_gjNp]  = Aq[t+emap*p_gjNp];
					//	}
				}
			}
		}
		@barrier("local");
		@barrier("local");
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					int emap = elementList[e];
					int t = i + j*p_gjNq + c*p_gjNq2;
					Ixq[t+emap*p_gjNp] =r_res;
					Aq[t+emap*p_gjNp] = 0.0f;
				}
			}
		}
		
		
		
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int a=0; a<p_gjNq; ++a; @inner(0)) {
					if (c<p_Nq && b<p_Nq && a< p_Nq){
						dfloat Iq = 0.0f;
						int emap = elementList[e];
						
						for(int m=0; m<p_gjNq; ++m) {
						
							int t = m + b*p_gjNq + c*p_gjNq2;
							
							Iq += s_I[m][a]*Ixq[t+emap*p_gjNp];
						}
						
						int base = emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a;
						Aq[base] = Iq;
					}
				}
			}
			
		}//e
	} //@kernel e9
	
}// REF 0 ends here

//same stuff but 1 @kernel version

@kernel void ellipticAxHex3D_Ref3D1( int Nelements,
                                    int *  elementList,
                                    dfloat *gjGeo,
                                    dfloat *  gllD,
                                    dfloat *  gjI,
                                    dfloat lambda,
                                    dfloat * q,
                                    dfloat * Ixq,
                                    dfloat *  Aq
                                  ){
                                  
                                  
	// load q into @shared first
	//@kernel 1 - interpolate to gj hex
	for(int e=0; e<Nelements; ++e; @outer(0)) {
		@exclusive int emap;
		
		//	@shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		//	@shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		@shared dfloat s_gsI[p_gjNq][p_Nq];
		@shared dfloat s_gjD[p_gjNq][p_gjNq];
		@exclusive dfloat r_dr, r_ds, r_dt, r_tmp, r_res;
		
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int a=0; a<p_gjNq; ++a; @inner(0)) {
					//	r_res =0.0f;
					if (c == 0 && a<p_Nq && b<p_gjNq) {
						s_gsI[b][a] = gjI[b*p_Nq+a];
					}
					int emap = elementList[e];
					int t = a + b*p_gjNq + c*p_gjNq2;
					/*		if (t<p_Np) {
								int ta = t%p_Nq;
								int tb = (t/p_Nq)%p_Nq;
								int tc = t/p_Nq2;
								s_q[tc][tb][ta] = q[emap*p_Np+t];
							}//if*/
					
				}//for a
			}// for b
		}//for c
		
		//synch threads
		@barrier("local");
		//============== interpolate in 3 dir ========================
		// r --> s --> t
		// rrrrrrr
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Iq = 0.0f;
					if (c<p_Nq && b<p_Nq){
					
						for(int n=0; n<p_Nq; ++n) {
							int emap = elementList[e];
							
							
							int t = n + b*p_Nq + c*p_Nq2;
							//we need s_q[c][b][n];
							//and there is A MAPPING
							// remember Q has fewer elements
							
							
							Iq += s_gsI[i][n]*q[t+emap*p_Np];
							//s_q[c][b][n];
						}
					}
					//		r_res = Iq;
					int emap = elementList[e];
					int t = i + b*p_gjNq + c*p_gjNq2;
					Aq[t+emap*p_gjNp] = Iq;
				}
			}
		}
		
		
		@barrier("local");
		
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Iq = 0.0f;
					if(c<p_Nq) {
					
						for(int n=0; n<p_Nq; ++n) {
							int emap = elementList[e];
							int t = i + n*p_gjNq + c*p_gjNq2;
							Iq += s_gsI[j][n]*Aq[emap*p_gjNp+t];
						}
					}
					int emap = elementList[e];
					int t = i + j*p_gjNq + c*p_gjNq2;
					Ixq[t+emap*p_gjNp] = Iq;
					//		r_res = Iq;
				}
			}
		}
		
		@barrier("local");
		
		
		
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Iq = 0.0f;
					
					for(int n=0; n<p_Nq; ++n) {
						int emap = elementList[e];
						int t = i + j*p_gjNq + n*p_gjNq2;
						Iq += s_gsI[k][n]*Ixq[t+emap*p_gjNp];
					}
					//	r_res = Iq;
					//		s_q[k][j][i] = Iq;
					emap = elementList[e];
					const int id = emap*p_gjNp + k*p_gjNq*p_gjNq+ j*p_gjNq + i;
					Aq[id] = Iq;
					
				}
			}
		}
		@barrier("local");
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					// D to @shared, q to @shared,
					if (k==0 ) {
						s_gjD[j][i] = gllD[j*p_gjNq+i];
					}
					
				}//for i
			}//for j
		}//for k
		@barrier("local");
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					//load geofactors for my (k,j,i)
					int		emap = elementList[e];
					int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					//geofactors for k j i thread
					dfloat		GwJ = gjGeo[base+p_GWJID*p_gjNp];
					
					
					dfloat dr = 0.0f;
					dfloat ds = 0.0f;
					dfloat dt = 0.0f;
					
					for (int n = 0; n<p_gjNq; ++n) {
						dr += s_gjD[i][n]*Aq[n + j*p_gjNq + k*p_gjNq*p_gjNq + elementList[e]*p_gjNp];
						ds += s_gjD[j][n]*Aq[i + n*p_gjNq + k*p_gjNq*p_gjNq + elementList[e]*p_gjNp];
						dt += s_gjD[k][n]*Aq[i + j*p_gjNq + n*p_gjNq*p_gjNq + elementList[e]*p_gjNp];
					}
					r_dr = dr;
					r_ds = ds;
					r_dt = dt;
					
					//	emap = elementList[e];
					int t = i + j*p_gjNq + k*p_gjNq2;
					
					Ixq[t+emap*p_gjNp] = GwJ*Aq[t+emap*p_gjNp]*lambda;
				}
			}
		}
		@barrier("local");
		// Multiply by D^T, size p_Nq x p_gjNq
		// D size p_gjNq x p_Nq
		
		// r direction
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					int		emap = elementList[e];
					int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					dfloat		G00 = gjGeo[base+p_G00ID*p_gjNp];
					dfloat		G01 = gjGeo[base+p_G01ID*p_gjNp];
					dfloat		G02 = gjGeo[base+p_G02ID*p_gjNp];
					//	s_q[k][j][i] = r_qr;
					
					int t = i + j*p_gjNq + k*p_gjNq2;
					Aq[t+emap*p_gjNp] = G00*r_dr + G01*r_ds + G02*r_dt;;
					
				}
			}
		}
		
		@barrier("local");
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat tmp = 0.f;
					int emap = elementList[e];
					
					for(int m=0; m<p_gjNq; ++m) {
						//k j m
						emap = elementList[e];
						int t = m + j*p_gjNq + k*p_gjNq2;
						tmp += s_gjD[m][i]*Aq[t+p_gjNp*emap];
					}
					
					int t = i + j*p_gjNq + k*p_gjNq2;
					Ixq[t+emap*p_gjNp] +=tmp;
				}
			}
		}
		
		@barrier("local");
		
		//s direction
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					int emap = elementList[e];
					int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					dfloat G11 = gjGeo[base+p_G11ID*p_gjNp];
					dfloat G12 = gjGeo[base+p_G12ID*p_gjNp];
					dfloat		G01 = gjGeo[base+p_G01ID*p_gjNp];
					
					int t = i + j*p_gjNq + k*p_gjNq2;
					Aq[t+emap*p_gjNp] =G01*r_dr + G11*r_ds + G12*r_dt;
					//s_q[k][j][i] = r_qs;
				}
			}
		}
		@barrier("local");
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat tmp = 0.f;
					int emap = elementList[e];
					
					for(int m=0; m<p_gjNq; ++m) {
						//k m i
						emap = elementList[e];
						int t = i + m*p_gjNq + k*p_gjNq2;
						tmp += s_gjD[m][j]*Aq[t+emap*p_gjNp];
					}
					
					int t = i + j*p_gjNq + k*p_gjNq2;
					Ixq[t+emap*p_gjNp] +=tmp;
				}
			}
		}
		@barrier("local");
		//t direction
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
			
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					int emap = elementList[e];
					int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					
					dfloat		G02 = gjGeo[base+p_G02ID*p_gjNp];
					dfloat G12 = gjGeo[base+p_G12ID*p_gjNp];
					dfloat		G22 = gjGeo[base+p_G22ID*p_gjNp];
					
					int t = i + j*p_gjNq + k*p_gjNq2;
					Aq[t+emap*p_gjNp] =G02*r_dr + G12*r_ds + G22*r_dt;
					//		s_q[k][j][i] = r_qt;
				}
			}
		}
		@barrier("local");
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat tmp = 0.f;
					r_res =0.0f;
					int emap = elementList[e];
					
					for(int m=0; m<p_gjNq; ++m) {
						// m j i
						
						int t = i + j*p_gjNq + m*p_gjNq2;
						tmp += s_gjD[m][k]*Aq[t+emap*p_gjNp];
					}
					//	r_tmp +=tmp;
					
					int base = emap*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					Ixq[base] += tmp;
				}
			}
		}
		
		
		
		
		
		@barrier("local");
		
		
		// t first
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Iq = 0.0f;
					int emap = elementList[e];
					if(c<p_Nq){
					
						for(int m=0; m<p_gjNq; ++m) {
							// k--> c
							
							int t = i + j*p_gjNq + m*p_gjNq2;
							
							Iq += s_gsI[m][c]*Ixq[t+p_gjNp*emap];
						}
					}
					r_res = Iq;
					
					//	int t = i + j*p_gjNq + c*p_gjNq2;
					//	Aq[t+emap*p_gjNp] =Iq;
				}
			}
		}
		
		@barrier("local");
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					int emap = elementList[e];
					int t = i + j*p_gjNq + c*p_gjNq2;
					Aq[t+emap*p_gjNp] =r_res;
				}
			}
		}
		
		
		
		
		
		
		// r direction
		
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					int emap = elementList[e];
					if(c<p_Nq && b<p_Nq){
						dfloat Iq = 0.0f;
						
						
						for(int m=0; m<p_gjNq; ++m) {
						
							int t = i + m*p_gjNq + c*p_gjNq2;
							Iq += s_gsI[m][b]*Aq[emap*p_gjNp+t];
						}
						
						r_res = Iq;
						
						//	int t = i + b*p_gjNq + c*p_gjNq2;
						//	Ixq[t+emap*p_gjNp] =Iq;
					}
					//	else
					//	{
					//	int t = i + b*p_gjNq + c*p_gjNq2;
					//	Ixq[t+emap*p_gjNp]  = Aq[t+emap*p_gjNp];
					//	}
				}
			}
		}
		@barrier("local");
		@barrier("local");
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					int emap = elementList[e];
					int t = i + j*p_gjNq + c*p_gjNq2;
					Ixq[t+emap*p_gjNp] =r_res;
					Aq[t+emap*p_gjNp] = 0.0f;
				}
			}
		}
		
		
		
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int a=0; a<p_gjNq; ++a; @inner(0)) {
					if (c<p_Nq && b<p_Nq && a< p_Nq){
						dfloat Iq = 0.0f;
						int emap = elementList[e];
						
						for(int m=0; m<p_gjNq; ++m) {
						
							int t = m + b*p_gjNq + c*p_gjNq2;
							
							Iq += s_gsI[m][a]*Ixq[t+emap*p_gjNp];
						}
						
						int base = emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a;
						Aq[base] = Iq;
					}
				}
			}
			
		}//e
	} //@kernel e9
	
}//REF 1 ends here

//REF2: const variables, loop unrolling

@kernel void ellipticAxHex3D_Ref3D2(const int Nelements,
                                   @restrict const  int *  elementList,
                                   @restrict const  dfloat *  gjGeo,
                                   @restrict const  dfloat *  gllD,
                                   @restrict const  dfloat *  gjI,
                                   const dfloat lambda,
                                   @restrict dfloat *  q,
                                   @restrict dfloat *  Ixq,
                                   @restrict dfloat *  Aq
                                  ){
                                  
                                  
	// load q into @shared first
	//@kernel 1 - interpolate to gj hex
	for(int e=0; e<Nelements; ++e; @outer(0)) {
		@exclusive int emap;
		
		//	@shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		//	@shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		@shared dfloat s_gsI[p_gjNq][p_Nq];
		@shared dfloat s_gjD[p_gjNq][p_gjNq];
		@exclusive dfloat r_dr, r_ds, r_dt, r_tmp, r_res;
		
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int a=0; a<p_gjNq; ++a; @inner(0)) {
					//	r_res =0.0f;
					if (c == 0 && a<p_Nq && b<p_gjNq) {
						s_gsI[b][a] = gjI[b*p_Nq+a];
					}
					int emap = elementList[e];
					int t = a + b*p_gjNq + c*p_gjNq2;
					/*		if (t<p_Np) {
								int ta = t%p_Nq;
								int tb = (t/p_Nq)%p_Nq;
								int tc = t/p_Nq2;
								s_q[tc][tb][ta] = q[emap*p_Np+t];
							}//if*/
					
				}//for a
			}// for b
		}//for c
		
		//synch threads
		@barrier("local");
		//============== interpolate in 3 dir ========================
		// r --> s --> t
		// rrrrrrr
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Iq = 0.0f;
					if (c<p_Nq && b<p_Nq){
						#pragma unroll p_Nq
						for(int n=0; n<p_Nq; ++n) {
							int emap = elementList[e];
							
							
							int t = n + b*p_Nq + c*p_Nq2;
							//we need s_q[c][b][n];
							//and there is A MAPPING
							// remember Q has fewer elements
							
							
							Iq += s_gsI[i][n]*q[t+emap*p_Np];
							//s_q[c][b][n];
						}
					}
					//		r_res = Iq;
					int emap = elementList[e];
					int t = i + b*p_gjNq + c*p_gjNq2;
					Aq[t+emap*p_gjNp] = Iq;
				}
			}
		}
		
		
		@barrier("local");
		
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Iq = 0.0f;
					if(c<p_Nq) {
						#pragma unroll p_Nq
						for(int n=0; n<p_Nq; ++n) {
							int emap = elementList[e];
							int t = i + n*p_gjNq + c*p_gjNq2;
							Iq += s_gsI[j][n]*Aq[emap*p_gjNp+t];
						}
					}
					int emap = elementList[e];
					int t = i + j*p_gjNq + c*p_gjNq2;
					Ixq[t+emap*p_gjNp] = Iq;
					//		r_res = Iq;
				}
			}
		}
		
		@barrier("local");
		
		
		
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Iq = 0.0f;
					#pragma unroll p_Nq
					for(int n=0; n<p_Nq; ++n) {
						int emap = elementList[e];
						int t = i + j*p_gjNq + n*p_gjNq2;
						Iq += s_gsI[k][n]*Ixq[t+emap*p_gjNp];
					}
					//	r_res = Iq;
					//		s_q[k][j][i] = Iq;
					emap = elementList[e];
					const int id = emap*p_gjNp + k*p_gjNq*p_gjNq+ j*p_gjNq + i;
					Aq[id] = Iq;
					
				}
			}
		}
		@barrier("local");
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					// D to @shared, q to @shared,
					if (k==0 ) {
						s_gjD[j][i] = gllD[j*p_gjNq+i];
					}
					
				}//for i
			}//for j
		}//for k
		@barrier("local");
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					//load geofactors for my (k,j,i)
					int		emap = elementList[e];
					int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					//geofactors for k j i thread
					dfloat		GwJ = gjGeo[base+p_GWJID*p_gjNp];
					
					
					dfloat dr = 0.0f;
					dfloat ds = 0.0f;
					dfloat dt = 0.0f;
					#pragma unroll p_gjNq
					for (int n = 0; n<p_gjNq; ++n) {
						dr += s_gjD[i][n]*Aq[n + j*p_gjNq + k*p_gjNq*p_gjNq + elementList[e]*p_gjNp];
						ds += s_gjD[j][n]*Aq[i + n*p_gjNq + k*p_gjNq*p_gjNq + elementList[e]*p_gjNp];
						dt += s_gjD[k][n]*Aq[i + j*p_gjNq + n*p_gjNq*p_gjNq + elementList[e]*p_gjNp];
					}
					r_dr = dr;
					r_ds = ds;
					r_dt = dt;
					
					//	emap = elementList[e];
					int t = i + j*p_gjNq + k*p_gjNq2;
					
					Ixq[t+emap*p_gjNp] = GwJ*Aq[t+emap*p_gjNp]*lambda;
				}
			}
		}
		@barrier("local");
		// Multiply by D^T, size p_Nq x p_gjNq
		// D size p_gjNq x p_Nq
		
		// r direction
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					int		emap = elementList[e];
					int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					dfloat		G00 = gjGeo[base+p_G00ID*p_gjNp];
					dfloat		G01 = gjGeo[base+p_G01ID*p_gjNp];
					dfloat		G02 = gjGeo[base+p_G02ID*p_gjNp];
					//	s_q[k][j][i] = r_qr;
					
					int t = i + j*p_gjNq + k*p_gjNq2;
					Aq[t+emap*p_gjNp] = G00*r_dr + G01*r_ds + G02*r_dt;;
					
				}
			}
		}
		
		@barrier("local");
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat tmp = 0.f;
					int emap = elementList[e];
					#pragma unroll p_gjNq
					for(int m=0; m<p_gjNq; ++m) {
						//k j m
						emap = elementList[e];
						int t = m + j*p_gjNq + k*p_gjNq2;
						tmp += s_gjD[m][i]*Aq[t+p_gjNp*emap];
					}
					
					int t = i + j*p_gjNq + k*p_gjNq2;
					Ixq[t+emap*p_gjNp] +=tmp;
				}
			}
		}
		
		@barrier("local");
		
		//s direction
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					int emap = elementList[e];
					int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					dfloat G11 = gjGeo[base+p_G11ID*p_gjNp];
					dfloat G12 = gjGeo[base+p_G12ID*p_gjNp];
					dfloat G01 = gjGeo[base+p_G01ID*p_gjNp];
					
					int t = i + j*p_gjNq + k*p_gjNq2;
					Aq[t+emap*p_gjNp] =G01*r_dr + G11*r_ds + G12*r_dt;
					//s_q[k][j][i] = r_qs;
				}
			}
		}
		@barrier("local");
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat tmp = 0.f;
					int emap = elementList[e];
					#pragma unroll p_gjNq
					for(int m=0; m<p_gjNq; ++m) {
						//k m i
						emap = elementList[e];
						int t = i + m*p_gjNq + k*p_gjNq2;
						tmp += s_gjD[m][j]*Aq[t+emap*p_gjNp];
					}
					
					int t = i + j*p_gjNq + k*p_gjNq2;
					Ixq[t+emap*p_gjNp] +=tmp;
				}
			}
		}
		@barrier("local");
		//t direction
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
			
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					int emap = elementList[e];
					int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					
					dfloat		G02 = gjGeo[base+p_G02ID*p_gjNp];
					dfloat    G12 = gjGeo[base+p_G12ID*p_gjNp];
					dfloat		G22 = gjGeo[base+p_G22ID*p_gjNp];
					
					int t = i + j*p_gjNq + k*p_gjNq2;
					Aq[t+emap*p_gjNp] =G02*r_dr + G12*r_ds + G22*r_dt;
					//		s_q[k][j][i] = r_qt;
				}
			}
		}
		@barrier("local");
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat tmp = 0.f;
					r_res =0.0f;
					int emap = elementList[e];
					#pragma unroll p_gjNq
					for(int m=0; m<p_gjNq; ++m) {
						// m j i
						
						int t = i + j*p_gjNq + m*p_gjNq2;
						tmp += s_gjD[m][k]*Aq[t+emap*p_gjNp];
					}
					//	r_tmp +=tmp;
					
					int base = emap*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					Ixq[base] += tmp;
				}
			}
		}
		
		
		
		
		
		@barrier("local");
		
		
		// t first
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Iq = 0.0f;
					int emap = elementList[e];
					if(c<p_Nq){
						#pragma unroll p_gjNq
						for(int m=0; m<p_gjNq; ++m) {
							// k--> c
							
							int t = i + j*p_gjNq + m*p_gjNq2;
							
							Iq += s_gsI[m][c]*Ixq[t+p_gjNp*emap];
						}
					}
					r_res = Iq;
					
					//	int t = i + j*p_gjNq + c*p_gjNq2;
					//	Aq[t+emap*p_gjNp] =Iq;
				}
			}
		}
		
		@barrier("local");
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					int emap = elementList[e];
					int t = i + j*p_gjNq + c*p_gjNq2;
					Aq[t+emap*p_gjNp] =r_res;
				}
			}
		}
		
		
		
		
		
		
		// r direction
		
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					int emap = elementList[e];
					if(c<p_Nq && b<p_Nq){
						dfloat Iq = 0.0f;
						
						#pragma unroll p_gjNq
						for(int m=0; m<p_gjNq; ++m) {
						
							int t = i + m*p_gjNq + c*p_gjNq2;
							Iq += s_gsI[m][b]*Aq[emap*p_gjNp+t];
						}
						
						r_res = Iq;
						
						//	int t = i + b*p_gjNq + c*p_gjNq2;
						//	Ixq[t+emap*p_gjNp] =Iq;
					}
					//	else
					//	{
					//	int t = i + b*p_gjNq + c*p_gjNq2;
					//	Ixq[t+emap*p_gjNp]  = Aq[t+emap*p_gjNp];
					//	}
				}
			}
		}
		@barrier("local");
		@barrier("local");
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					int emap = elementList[e];
					int t = i + j*p_gjNq + c*p_gjNq2;
					Ixq[t+emap*p_gjNp] =r_res;
					Aq[t+emap*p_gjNp] = 0.0f;
				}
			}
		}
		
		
		
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int a=0; a<p_gjNq; ++a; @inner(0)) {
					if (c<p_Nq && b<p_Nq && a< p_Nq){
						dfloat Iq = 0.0f;
						int emap = elementList[e];
						#pragma unroll p_gjNq
						for(int m=0; m<p_gjNq; ++m) {
						
							int t = m + b*p_gjNq + c*p_gjNq2;
							
							Iq += s_gsI[m][a]*Ixq[t+emap*p_gjNp];
						}
						
						int base = emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a;
						Aq[base] = Iq;
					}
				}
			}
			
		}//e
	} //@kernel e9
	
}//REF 2 ends here

//REF3

// load geometric factors to registers.
// declare 'emap' only once


@kernel void ellipticAxHex3D_Ref3D3(const int Nelements,
                                   @restrict const  int *  elementList,
                                   @restrict const  dfloat *  gjGeo,
                                   @restrict const  dfloat *  gllD,
                                   @restrict const  dfloat *  gjI,
                                   const dfloat lambda,
                                   @restrict dfloat *  q,
                                   @restrict dfloat *  Ixq,
                                   @restrict dfloat *  Aq
                                  ){
                                  
                                  
	// load q into @shared first
	//@kernel 1 - interpolate to gj hex
	for(int e=0; e<Nelements; ++e; @outer(0)) {
		@exclusive int emap;
		
		//	@shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		//	@shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		@shared dfloat s_gsI[p_gjNq][p_Nq];
		@shared dfloat s_gjD[p_gjNq][p_gjNq];
		@exclusive dfloat r_dr, r_ds, r_dt, r_tmp, r_res;
		@exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;
		
		
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int a=0; a<p_gjNq; ++a; @inner(0)) {
					//	r_res =0.0f;
					if (c == 0 && a<p_Nq && b<p_gjNq) {
						s_gsI[b][a] = gjI[b*p_Nq+a];
					}
					emap = elementList[e];
					int t = a + b*p_gjNq + c*p_gjNq2;
					/*		if (t<p_Np) {
								int ta = t%p_Nq;
								int tb = (t/p_Nq)%p_Nq;
								int tc = t/p_Nq2;
								s_q[tc][tb][ta] = q[emap*p_Np+t];
							}//if*/
					
				}//for a
			}// for b
		}//for c
		
		//synch threads
		@barrier("local");
		//============== interpolate in 3 dir ========================
		// r --> s --> t
		// rrrrrrr
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Iq = 0.0f;
					if (c<p_Nq && b<p_Nq){
						#pragma unroll p_Nq
						for(int n=0; n<p_Nq; ++n) {
						
						
						
							int t = n + b*p_Nq + c*p_Nq2;
							//we need s_q[c][b][n];
							//and there is A MAPPING
							// remember Q has fewer elements
							
							
							Iq += s_gsI[i][n]*q[t+emap*p_Np];
							//s_q[c][b][n];
						}
					}
					//		r_res = Iq;
					
					int t = i + b*p_gjNq + c*p_gjNq2;
					Aq[t+emap*p_gjNp] = Iq;
				}
			}
		}
		
		
		@barrier("local");
		
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Iq = 0.0f;
					if(c<p_Nq) {
						#pragma unroll p_Nq
						for(int n=0; n<p_Nq; ++n) {
						
							int t = i + n*p_gjNq + c*p_gjNq2;
							Iq += s_gsI[j][n]*Aq[emap*p_gjNp+t];
						}
					}
					
					int t = i + j*p_gjNq + c*p_gjNq2;
					Ixq[t+emap*p_gjNp] = Iq;
					//		r_res = Iq;
				}
			}
		}
		
		@barrier("local");
		
		
		
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Iq = 0.0f;
					#pragma unroll p_Nq
					for(int n=0; n<p_Nq; ++n) {
					
						int t = i + j*p_gjNq + n*p_gjNq2;
						Iq += s_gsI[k][n]*Ixq[t+emap*p_gjNp];
					}
					//	r_res = Iq;
					//		s_q[k][j][i] = Iq;
					
					const int id = emap*p_gjNp + k*p_gjNq*p_gjNq+ j*p_gjNq + i;
					Aq[id] = Iq;
					
				}
			}
		}
		@barrier("local");
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					// D to @shared, q to @shared,
					if (k==0 ) {
						s_gjD[j][i] = gllD[j*p_gjNq+i];
					}
					
				}//for i
			}//for j
		}//for k
		@barrier("local");
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					//load geofactors for my (k,j,i)
					
					int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					//geofactors for k j i thread
					r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
					r_G00 = gjGeo[base+p_G00ID*p_gjNp];
					r_G01 = gjGeo[base+p_G01ID*p_gjNp];
					r_G02 = gjGeo[base+p_G02ID*p_gjNp];
					
					r_G11 = gjGeo[base+p_G11ID*p_gjNp];
					r_G12 = gjGeo[base+p_G12ID*p_gjNp];
					r_G22 = gjGeo[base+p_G22ID*p_gjNp];
					
					
					dfloat dr = 0.0f;
					dfloat ds = 0.0f;
					dfloat dt = 0.0f;
					#pragma unroll p_gjNq
					for (int n = 0; n<p_gjNq; ++n) {
						dr += s_gjD[i][n]*Aq[n + j*p_gjNq + k*p_gjNq*p_gjNq + elementList[e]*p_gjNp];
						ds += s_gjD[j][n]*Aq[i + n*p_gjNq + k*p_gjNq*p_gjNq + elementList[e]*p_gjNp];
						dt += s_gjD[k][n]*Aq[i + j*p_gjNq + n*p_gjNq*p_gjNq + elementList[e]*p_gjNp];
					}
					r_dr = dr;
					r_ds = ds;
					r_dt = dt;
					
					//	emap = elementList[e];
					int t = i + j*p_gjNq + k*p_gjNq2;
					
					Ixq[t+emap*p_gjNp] = r_GwJ*Aq[t+emap*p_gjNp]*lambda;
				}
			}
		}
		@barrier("local");
		// Multiply by D^T, size p_Nq x p_gjNq
		// D size p_gjNq x p_Nq
		
		// r direction
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
				
					//	s_q[k][j][i] = r_qr;
					
					int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					int t = i + j*p_gjNq + k*p_gjNq2;
					Aq[t+emap*p_gjNp] = r_G00*r_dr + r_G01*r_ds + r_G02*r_dt;;
					
				}
			}
		}
		
		@barrier("local");
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat tmp = 0.f;
					int emap = elementList[e];
					#pragma unroll p_gjNq
					for(int m=0; m<p_gjNq; ++m) {
						//k j m
						
						int t = m + j*p_gjNq + k*p_gjNq2;
						tmp += s_gjD[m][i]*Aq[t+p_gjNp*emap];
					}
					
					int t = i + j*p_gjNq + k*p_gjNq2;
					Ixq[t+emap*p_gjNp] +=tmp;
				}
			}
		}
		
		@barrier("local");
		
		//s direction
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
				
					int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					
					
					int t = i + j*p_gjNq + k*p_gjNq2;
					Aq[t+emap*p_gjNp] =r_G01*r_dr + r_G11*r_ds + r_G12*r_dt;
					//s_q[k][j][i] = r_qs;
				}
			}
		}
		@barrier("local");
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat tmp = 0.f;
					
					#pragma unroll p_gjNq
					for(int m=0; m<p_gjNq; ++m) {
						//k m i
						
						int t = i + m*p_gjNq + k*p_gjNq2;
						tmp += s_gjD[m][j]*Aq[t+emap*p_gjNp];
					}
					
					int t = i + j*p_gjNq + k*p_gjNq2;
					Ixq[t+emap*p_gjNp] +=tmp;
				}
			}
		}
		@barrier("local");
		//t direction
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
			
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
				
					int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					
					
					int t = i + j*p_gjNq + k*p_gjNq2;
					Aq[t+emap*p_gjNp] =r_G02*r_dr + r_G12*r_ds + r_G22*r_dt;
					//		s_q[k][j][i] = r_qt;
				}
			}
		}
		@barrier("local");
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat tmp = 0.f;
					r_res =0.0f;
					
					#pragma unroll p_gjNq
					for(int m=0; m<p_gjNq; ++m) {
						// m j i
						
						int t = i + j*p_gjNq + m*p_gjNq2;
						tmp += s_gjD[m][k]*Aq[t+emap*p_gjNp];
					}
					//	r_tmp +=tmp;
					
					int base = emap*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					Ixq[base] += tmp;
				}
			}
		}
		
		
		
		
		
		@barrier("local");
		
		
		// t first
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Iq = 0.0f;
					
					if(c<p_Nq){
						#pragma unroll p_gjNq
						for(int m=0; m<p_gjNq; ++m) {
							// k--> c
							
							int t = i + j*p_gjNq + m*p_gjNq2;
							
							Iq += s_gsI[m][c]*Ixq[t+p_gjNp*emap];
						}
					}
					r_res = Iq;
					
					//	int t = i + j*p_gjNq + c*p_gjNq2;
					//	Aq[t+emap*p_gjNp] =Iq;
				}
			}
		}
		
		@barrier("local");
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
				
					int t = i + j*p_gjNq + c*p_gjNq2;
					Aq[t+emap*p_gjNp] =r_res;
				}
			}
		}
		
		
		
		
		
		
		// r direction
		
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
				
					if(c<p_Nq && b<p_Nq){
						dfloat Iq = 0.0f;
						
						#pragma unroll p_gjNq
						for(int m=0; m<p_gjNq; ++m) {
						
							int t = i + m*p_gjNq + c*p_gjNq2;
							Iq += s_gsI[m][b]*Aq[emap*p_gjNp+t];
						}
						
						r_res = Iq;
						
						//	int t = i + b*p_gjNq + c*p_gjNq2;
						//	Ixq[t+emap*p_gjNp] =Iq;
					}
					//	else
					//	{
					//	int t = i + b*p_gjNq + c*p_gjNq2;
					//	Ixq[t+emap*p_gjNp]  = Aq[t+emap*p_gjNp];
					//	}
				}
			}
		}
		@barrier("local");
		@barrier("local");
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
				
					int t = i + j*p_gjNq + c*p_gjNq2;
					Ixq[t+emap*p_gjNp] =r_res;
					Aq[t+emap*p_gjNp] = 0.0f;
				}
			}
		}
		
		
		
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int a=0; a<p_gjNq; ++a; @inner(0)) {
					if (c<p_Nq && b<p_Nq && a< p_Nq){
						dfloat Iq = 0.0f;
						
						#pragma unroll p_gjNq
						for(int m=0; m<p_gjNq; ++m) {
						
							int t = m + b*p_gjNq + c*p_gjNq2;
							
							Iq += s_gsI[m][a]*Ixq[t+emap*p_gjNp];
						}
						
						int base = emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a;
						Aq[base] = Iq;
					}
				}
			}
			
		}//e
	} //@kernel e9
	
}//REF 3 ends here

//REF 4 -- used @shared memory array just for differentiation, to store patial result.

@kernel void ellipticAxHex3D_Ref3D4(const int Nelements,
                                   @restrict const  int *  elementList,
                                   @restrict const  dfloat *  gjGeo,
                                   @restrict const  dfloat *  gllD,
                                   @restrict const  dfloat *  gjI,
                                   const dfloat lambda,
                                   @restrict dfloat *  q,
                                   @restrict dfloat *  Ixq,
                                   @restrict dfloat *  Aq
                                  ){
                                  
                                  
	// load q into @shared first
	//@kernel 1 - interpolate to gj hex
	for(int e=0; e<Nelements; ++e; @outer(0)) {
		@exclusive int emap;
		
		@shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		//	@shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		@shared dfloat s_gsI[p_gjNq][p_Nq];
		@shared dfloat s_gjD[p_gjNq][p_gjNq];
		@exclusive dfloat r_dr, r_ds, r_dt, r_tmp, r_res;
		@exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;
		
		
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int a=0; a<p_gjNq; ++a; @inner(0)) {
					//	r_res =0.0f;
					if (c == 0 && a<p_Nq && b<p_gjNq) {
						s_gsI[b][a] = gjI[b*p_Nq+a];
					}
					emap = elementList[e];
					int t = a + b*p_gjNq + c*p_gjNq2;
					/*		if (t<p_Np) {
								int ta = t%p_Nq;
								int tb = (t/p_Nq)%p_Nq;
								int tc = t/p_Nq2;
								s_q[tc][tb][ta] = q[emap*p_Np+t];
							}//if*/
					
				}//for a
			}// for b
		}//for c
		
		//synch threads
		@barrier("local");
		//============== interpolate in 3 dir ========================
		// r --> s --> t
		// rrrrrrr
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Iq = 0.0f;
					if (c<p_Nq && b<p_Nq){
						#pragma unroll p_Nq
						for(int n=0; n<p_Nq; ++n) {
						
						
						
							int t = n + b*p_Nq + c*p_Nq2;
							//we need s_q[c][b][n];
							//and there is A MAPPING
							// remember Q has fewer elements
							
							
							Iq += s_gsI[i][n]*q[t+emap*p_Np];
							//s_q[c][b][n];
						}
					}
					//		r_res = Iq;
					
					int t = i + b*p_gjNq + c*p_gjNq2;
					Aq[t+emap*p_gjNp] = Iq;
				}
			}
		}
		
		
		@barrier("local");
		
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Iq = 0.0f;
					if(c<p_Nq) {
						#pragma unroll p_Nq
						for(int n=0; n<p_Nq; ++n) {
						
							int t = i + n*p_gjNq + c*p_gjNq2;
							Iq += s_gsI[j][n]*Aq[emap*p_gjNp+t];
						}
					}
					
					int t = i + j*p_gjNq + c*p_gjNq2;
					Ixq[t+emap*p_gjNp] = Iq;
					//		r_res = Iq;
				}
			}
		}
		
		@barrier("local");
		
		
		
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Iq = 0.0f;
					#pragma unroll p_Nq
					for(int n=0; n<p_Nq; ++n) {
					
						int t = i + j*p_gjNq + n*p_gjNq2;
						Iq += s_gsI[k][n]*Ixq[t+emap*p_gjNp];
					}
					//	r_res = Iq;
					//		s_q[k][j][i] = Iq;
					
					const int id = emap*p_gjNp + k*p_gjNq*p_gjNq+ j*p_gjNq + i;
					Aq[id] = Iq;
					
				}
			}
		}
		@barrier("local");
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					// D to @shared, q to @shared,
					if (k==0 ) {
						s_gjD[j][i] = gllD[j*p_gjNq+i];
					}
					int t = i + j*p_gjNq + k*p_gjNq2;
					s_q[k][j][i] = Aq[emap*p_gjNp+t];
				}//for i
			}//for j
		}//for k
		@barrier("local");
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					//load geofactors for my (k,j,i)
					
					int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					//geofactors for k j i thread
					r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
					r_G00 = gjGeo[base+p_G00ID*p_gjNp];
					r_G01 = gjGeo[base+p_G01ID*p_gjNp];
					r_G02 = gjGeo[base+p_G02ID*p_gjNp];
					
					r_G11 = gjGeo[base+p_G11ID*p_gjNp];
					r_G12 = gjGeo[base+p_G12ID*p_gjNp];
					r_G22 = gjGeo[base+p_G22ID*p_gjNp];
					
					
					dfloat dr = 0.0f;
					dfloat ds = 0.0f;
					dfloat dt = 0.0f;
					#pragma unroll p_gjNq
					for (int n = 0; n<p_gjNq; ++n) {
						dr += s_gjD[i][n] * s_q[k][j][n];
						ds += s_gjD[j][n]*s_q[k][n][i];
						dt += s_gjD[k][n]*s_q[n][j][i];
					}
					
					
					r_dr = dr;
					r_ds = ds;
					r_dt = dt;
					
					//	emap = elementList[e];
					int t = i + j*p_gjNq + k*p_gjNq2;
					
					Ixq[t+emap*p_gjNp] = r_GwJ*s_q[k][j][i]*lambda;
				}
			}
		}
		@barrier("local");
		// Multiply by D^T, size p_Nq x p_gjNq
		// D size p_gjNq x p_Nq
		
		// r direction
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
				
					//	s_q[k][j][i] = r_qr;
					
					//	int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					//	int t = i + j*p_gjNq + k*p_gjNq2;
					//	Aq[t+emap*p_gjNp]
					s_q[k][j][i] = r_G00*r_dr + r_G01*r_ds + r_G02*r_dt;;
					
				}
			}
		}
		
		@barrier("local");
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat tmp = 0.f;
					int emap = elementList[e];
					#pragma unroll p_gjNq
					for(int m=0; m<p_gjNq; ++m) {
						//k j m
						
						//			int t = m + j*p_gjNq + k*p_gjNq2;
						tmp += s_gjD[m][i]*s_q[k][j][m];
					}
					
					int t = i + j*p_gjNq + k*p_gjNq2;
					Ixq[t+emap*p_gjNp] +=tmp;
				}
			}
		}
		
		@barrier("local");
		
		//s direction
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
				
					//	int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					
					
					//	int t = i + j*p_gjNq + k*p_gjNq2;
					//	Aq[t+emap*p_gjNp] =
					s_q[k][j][i] = r_G01*r_dr + r_G11*r_ds + r_G12*r_dt;
					//s_q[k][j][i] = r_qs;
				}
			}
		}
		@barrier("local");
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat tmp = 0.f;
					
					#pragma unroll p_gjNq
					for(int m=0; m<p_gjNq; ++m) {
						//k m i
						//	emap = elementList[e];
						//	int t = i + m*p_gjNq + k*p_gjNq2;
						tmp += s_gjD[m][j]*s_q[k][m][i];
					}
					
					int t = i + j*p_gjNq + k*p_gjNq2;
					Ixq[t+emap*p_gjNp] +=tmp;
				}
			}
		}
		@barrier("local");
		//t direction
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
			
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
				
					//		int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					
					
					//		int t = i + j*p_gjNq + k*p_gjNq2;
					//		Aq[t+emap*p_gjNp] =
					
					s_q[k][j][i] = r_G02*r_dr + r_G12*r_ds + r_G22*r_dt;
					//		s_q[k][j][i] = r_qt;
				}
			}
		}
		@barrier("local");
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat tmp = 0.f;
					r_res =0.0f;
					
					#pragma unroll p_gjNq
					for(int m=0; m<p_gjNq; ++m) {
						// m j i
						
						//	int t = i + j*p_gjNq + m*p_gjNq2;
						tmp += s_gjD[m][k]*s_q[m][j][i];
					}
					//	r_tmp +=tmp;
					
					int base = emap*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					Ixq[base] += tmp;
				}
			}
		}
		
		
		
		
		
		@barrier("local");
		
		
		// t first
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Iq = 0.0f;
					
					if(c<p_Nq){
						#pragma unroll p_gjNq
						for(int m=0; m<p_gjNq; ++m) {
							// k--> c
							
							int t = i + j*p_gjNq + m*p_gjNq2;
							
							Iq += s_gsI[m][c]*Ixq[t+p_gjNp*emap];
						}
					}
					r_res = Iq;
					
					//	int t = i + j*p_gjNq + c*p_gjNq2;
					//	Aq[t+emap*p_gjNp] =Iq;
				}
			}
		}
		
		@barrier("local");
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
				
					int t = i + j*p_gjNq + c*p_gjNq2;
					Aq[t+emap*p_gjNp] =r_res;
				}
			}
		}
		
		
		
		
		
		
		// r direction
		
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
				
					if(c<p_Nq && b<p_Nq){
						dfloat Iq = 0.0f;
						
						#pragma unroll p_gjNq
						for(int m=0; m<p_gjNq; ++m) {
						
							int t = i + m*p_gjNq + c*p_gjNq2;
							Iq += s_gsI[m][b]*Aq[emap*p_gjNp+t];
						}
						
						r_res = Iq;
						
						//	int t = i + b*p_gjNq + c*p_gjNq2;
						//	Ixq[t+emap*p_gjNp] =Iq;
					}
					//	else
					//	{
					//	int t = i + b*p_gjNq + c*p_gjNq2;
					//	Ixq[t+emap*p_gjNp]  = Aq[t+emap*p_gjNp];
					//	}
				}
			}
		}
		@barrier("local");
		@barrier("local");
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
				
					int t = i + j*p_gjNq + c*p_gjNq2;
					Ixq[t+emap*p_gjNp] =r_res;
					Aq[t+emap*p_gjNp] = 0.0f;
				}
			}
		}
		
		
		
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int a=0; a<p_gjNq; ++a; @inner(0)) {
					if (c<p_Nq && b<p_Nq && a< p_Nq){
						dfloat Iq = 0.0f;
						
						#pragma unroll p_gjNq
						for(int m=0; m<p_gjNq; ++m) {
						
							int t = m + b*p_gjNq + c*p_gjNq2;
							
							Iq += s_gsI[m][a]*Ixq[t+emap*p_gjNp];
						}
						
						int base = emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a;
						Aq[base] = Iq;
					}
				}
			}
			
		}//e
	} //@kernel e9
	
}//REF 4 ends here

//REF5 - register variable instead of global load in differentiation


@kernel void ellipticAxHex3D_Ref3D5(const int Nelements,
                                   @restrict const  int *  elementList,
                                   @restrict const  dfloat *  gjGeo,
                                   @restrict const  dfloat *  gllD,
                                   @restrict const  dfloat *  gjI,
                                   const dfloat lambda,
                                   @restrict dfloat *  q,
                                   @restrict dfloat *  Ixq,
                                   @restrict dfloat *  Aq
                                  ){
                                  
                                  
	// load q into @shared first
	//@kernel 1 - interpolate to gj hex
	for(int e=0; e<Nelements; ++e; @outer(0)) {
		@exclusive int emap;
		
		@shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		//	@shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		@shared dfloat s_gsI[p_gjNq][p_Nq];
		@shared dfloat s_gjD[p_gjNq][p_gjNq];
		@exclusive dfloat r_dr, r_ds, r_dt, r_tmp, r_res;
		@exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;
		
		
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int a=0; a<p_gjNq; ++a; @inner(0)) {
					//	r_res =0.0f;
					if (c == 0 && a<p_Nq && b<p_gjNq) {
						s_gsI[b][a] = gjI[b*p_Nq+a];
					}
					emap = elementList[e];
					int t = a + b*p_gjNq + c*p_gjNq2;
					/*		if (t<p_Np) {
								int ta = t%p_Nq;
								int tb = (t/p_Nq)%p_Nq;
								int tc = t/p_Nq2;
								s_q[tc][tb][ta] = q[emap*p_Np+t];
							}//if*/
					
				}//for a
			}// for b
		}//for c
		
		//synch threads
		@barrier("local");
		//============== interpolate in 3 dir ========================
		// r --> s --> t
		// rrrrrrr
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Iq = 0.0f;
					if (c<p_Nq && b<p_Nq){
						#pragma unroll p_Nq
						for(int n=0; n<p_Nq; ++n) {
						
						
						
							int t = n + b*p_Nq + c*p_Nq2;
							//we need s_q[c][b][n];
							//and there is A MAPPING
							// remember Q has fewer elements
							
							
							Iq += s_gsI[i][n]*q[t+emap*p_Np];
							//s_q[c][b][n];
						}
					}
					//		r_res = Iq;
					
					int t = i + b*p_gjNq + c*p_gjNq2;
					Aq[t+emap*p_gjNp] = Iq;
				}
			}
		}
		
		
		@barrier("local");
		
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Iq = 0.0f;
					if(c<p_Nq) {
						#pragma unroll p_Nq
						for(int n=0; n<p_Nq; ++n) {
						
							int t = i + n*p_gjNq + c*p_gjNq2;
							Iq += s_gsI[j][n]*Aq[emap*p_gjNp+t];
						}
					}
					
					int t = i + j*p_gjNq + c*p_gjNq2;
					Ixq[t+emap*p_gjNp] = Iq;
					//		r_res = Iq;
				}
			}
		}
		
		@barrier("local");
		
		
		
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Iq = 0.0f;
					#pragma unroll p_Nq
					for(int n=0; n<p_Nq; ++n) {
					
						int t = i + j*p_gjNq + n*p_gjNq2;
						Iq += s_gsI[k][n]*Ixq[t+emap*p_gjNp];
					}
					//	r_res = Iq;
					//		s_q[k][j][i] = Iq;
					
					const int id = emap*p_gjNp + k*p_gjNq*p_gjNq+ j*p_gjNq + i;
					Aq[id] = Iq;
					
				}
			}
		}
		@barrier("local");
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					// D to @shared, q to @shared,
					if (k==0 ) {
						s_gjD[j][i] = gllD[j*p_gjNq+i];
					}
					int t = i + j*p_gjNq + k*p_gjNq2;
					s_q[k][j][i] = Aq[emap*p_gjNp+t];
				}//for i
			}//for j
		}//for k
		@barrier("local");
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					//load geofactors for my (k,j,i)
					
					int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					//geofactors for k j i thread
					r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
					r_G00 = gjGeo[base+p_G00ID*p_gjNp];
					r_G01 = gjGeo[base+p_G01ID*p_gjNp];
					r_G02 = gjGeo[base+p_G02ID*p_gjNp];
					
					r_G11 = gjGeo[base+p_G11ID*p_gjNp];
					r_G12 = gjGeo[base+p_G12ID*p_gjNp];
					r_G22 = gjGeo[base+p_G22ID*p_gjNp];
					
					
					dfloat dr = 0.0f;
					dfloat ds = 0.0f;
					dfloat dt = 0.0f;
					#pragma unroll p_gjNq
					for (int n = 0; n<p_gjNq; ++n) {
						dr += s_gjD[i][n] * s_q[k][j][n];
						ds += s_gjD[j][n]*s_q[k][n][i];
						dt += s_gjD[k][n]*s_q[n][j][i];
					}
					
					
					r_dr = dr;
					r_ds = ds;
					r_dt = dt;
					
					//	emap = elementList[e];
					//		int t = i + j*p_gjNq + k*p_gjNq2;
					
					//	Ixq[t+emap*p_gjNp]
					r_tmp = r_GwJ*s_q[k][j][i]*lambda;
				}
			}
		}
		@barrier("local");
		// Multiply by D^T, size p_Nq x p_gjNq
		// D size p_gjNq x p_Nq
		
		// r direction
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
				
					//	s_q[k][j][i] = r_qr;
					
					//	int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					//	int t = i + j*p_gjNq + k*p_gjNq2;
					//	Aq[t+emap*p_gjNp]
					s_q[k][j][i] = r_G00*r_dr + r_G01*r_ds + r_G02*r_dt;;
					
				}
			}
		}
		
		@barrier("local");
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat tmp = 0.f;
					int emap = elementList[e];
					#pragma unroll p_gjNq
					for(int m=0; m<p_gjNq; ++m) {
						//k j m
						
						//			int t = m + j*p_gjNq + k*p_gjNq2;
						tmp += s_gjD[m][i]*s_q[k][j][m];
					}
					
					//			int t = i + j*p_gjNq + k*p_gjNq2;
					//	Ixq[t+emap*p_gjNp] +=tmp;
					r_tmp +=tmp;
				}
			}
		}
		
		@barrier("local");
		
		//s direction
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
				
					//	int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					
					
					//	int t = i + j*p_gjNq + k*p_gjNq2;
					//	Aq[t+emap*p_gjNp] =
					s_q[k][j][i] = r_G01*r_dr + r_G11*r_ds + r_G12*r_dt;
					//s_q[k][j][i] = r_qs;
				}
			}
		}
		@barrier("local");
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat tmp = 0.f;
					
					#pragma unroll p_gjNq
					for(int m=0; m<p_gjNq; ++m) {
						//k m i
						//	emap = elementList[e];
						//	int t = i + m*p_gjNq + k*p_gjNq2;
						tmp += s_gjD[m][j]*s_q[k][m][i];
					}
					
					//			int t = i + j*p_gjNq + k*p_gjNq2;
					//		Ixq[t+emap*p_gjNp] +=tmp;
					r_tmp +=tmp;
				}
			}
		}
		@barrier("local");
		//t direction
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
			
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
				
					//		int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					
					
					//		int t = i + j*p_gjNq + k*p_gjNq2;
					//		Aq[t+emap*p_gjNp] =
					
					s_q[k][j][i] = r_G02*r_dr + r_G12*r_ds + r_G22*r_dt;
					//		s_q[k][j][i] = r_qt;
				}
			}
		}
		@barrier("local");
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat tmp = 0.f;
					r_res =0.0f;
					
					#pragma unroll p_gjNq
					for(int m=0; m<p_gjNq; ++m) {
						// m j i
						
						//	int t = i + j*p_gjNq + m*p_gjNq2;
						tmp += s_gjD[m][k]*s_q[m][j][i];
					}
					r_tmp +=tmp;
					
					int base = emap*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					
					Ixq[base] =r_tmp;
					//+= tmp;
				}
			}
		}
		
		
		
		
		
		@barrier("local");
		
		
		// t first
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Iq = 0.0f;
					
					if(c<p_Nq){
						#pragma unroll p_gjNq
						for(int m=0; m<p_gjNq; ++m) {
							// k--> c
							
							int t = i + j*p_gjNq + m*p_gjNq2;
							
							Iq += s_gsI[m][c]*Ixq[t+p_gjNp*emap];
						}
					}
					r_res = Iq;
					
					//	int t = i + j*p_gjNq + c*p_gjNq2;
					//	Aq[t+emap*p_gjNp] =Iq;
				}
			}
		}
		
		@barrier("local");
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
				
					int t = i + j*p_gjNq + c*p_gjNq2;
					Aq[t+emap*p_gjNp] =r_res;
				}
			}
		}
		
		
		
		
		
		
		// r direction
		
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
				
					if(c<p_Nq && b<p_Nq){
						dfloat Iq = 0.0f;
						
						#pragma unroll p_gjNq
						for(int m=0; m<p_gjNq; ++m) {
						
							int t = i + m*p_gjNq + c*p_gjNq2;
							Iq += s_gsI[m][b]*Aq[emap*p_gjNp+t];
						}
						
						r_res = Iq;
						
						//	int t = i + b*p_gjNq + c*p_gjNq2;
						//	Ixq[t+emap*p_gjNp] =Iq;
					}
					//	else
					//	{
					//	int t = i + b*p_gjNq + c*p_gjNq2;
					//	Ixq[t+emap*p_gjNp]  = Aq[t+emap*p_gjNp];
					//	}
				}
			}
		}
		@barrier("local");
		@barrier("local");
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
				
					int t = i + j*p_gjNq + c*p_gjNq2;
					Ixq[t+emap*p_gjNp] =r_res;
					Aq[t+emap*p_gjNp] = 0.0f;
				}
			}
		}
		
		
		
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int a=0; a<p_gjNq; ++a; @inner(0)) {
					if (c<p_Nq && b<p_Nq && a< p_Nq){
						dfloat Iq = 0.0f;
						
						#pragma unroll p_gjNq
						for(int m=0; m<p_gjNq; ++m) {
						
							int t = m + b*p_gjNq + c*p_gjNq2;
							
							Iq += s_gsI[m][a]*Ixq[t+emap*p_gjNp];
						}
						
						int base = emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a;
						Aq[base] = Iq;
					}
				}
			}
			
		}//e
	}
	
}//REF5 ends here

//REF6 global storage only BETWEEN parts


@kernel void ellipticAxHex3D_Ref3D6(const int Nelements,
                                   @restrict const  int *  elementList,
                                   @restrict const  dfloat *  gjGeo,
                                   @restrict const  dfloat *  gllD,
                                   @restrict const  dfloat *  gjI,
                                   const dfloat lambda,
                                   @restrict dfloat *  q,
                                   @restrict dfloat *  Ixq,
                                   @restrict dfloat *  Aq
                                  ){
                                  
                                  
	// load q into @shared first
	//@kernel 1 - interpolate to gj hex
	for(int e=0; e<Nelements; ++e; @outer(0)) {
		@exclusive int emap;
		
		@shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		//	@shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		@shared dfloat s_gsI[p_gjNq][p_Nq];
		@shared dfloat s_gjD[p_gjNq][p_gjNq];
		@exclusive dfloat r_dr, r_ds, r_dt, r_tmp, r_res;
		@exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;
		
		
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int a=0; a<p_gjNq; ++a; @inner(0)) {
					//	r_res =0.0f;
					if (c == 0 && a<p_Nq && b<p_gjNq) {
						s_gsI[b][a] = gjI[b*p_Nq+a];
					}
					emap = elementList[e];
					int t = a + b*p_gjNq + c*p_gjNq2;
					if (t<p_Np) {
						int ta = t%p_Nq;
						int tb = (t/p_Nq)%p_Nq;
						int tc = t/p_Nq2;
						s_q[tc][tb][ta] = q[emap*p_Np+t];
					}//if
					
				}//for a
			}// for b
		}//for c
		
		//synch threads
		@barrier("local");
		//============== interpolate in 3 dir ========================
		// r --> s --> t
		// rrrrrrr
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Iq = 0.0f;
					if (c<p_Nq && b<p_Nq){
						#pragma unroll p_Nq
						for(int n=0; n<p_Nq; ++n) {
							Iq += s_gsI[i][n]*s_q[c][b][n];
						}
					}
					r_res = Iq;			a
				}
			}
		}
		
		@barrier("local");
		
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					s_q[c][b][i] = r_res;
				}
			}
		}
		@barrier("local");
		
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Iq = 0.0f;
					if(c<p_Nq) {
						#pragma unroll p_Nq
						for(int n=0; n<p_Nq; ++n) {
							Iq += s_gsI[j][n]*s_q[c][n][i];
						}
					}
					r_res = Iq;
				}
			}
		}
		@barrier("local");
		
		
		
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					s_q[c][j][i] = r_res;
				}
			}
		}
		@barrier("local");
		
		// t direction
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Iq = 0.0f;
					#pragma unroll p_Nq
					for(int n=0; n<p_Nq; ++n) {
						Iq += s_gsI[k][n]*s_q[n][j][i];
					}
					//	r_res = Iq;
					//		s_q[k][j][i] = Iq;
					emap = elementList[e];
					const int id = emap*p_gjNp + k*p_gjNq*p_gjNq+ j*p_gjNq + i;
					Aq[id] = Iq;
					//s_q[k][j][i];
				}
			}
		}
		
		
		//differentiate
		@barrier("local");
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					// D to @shared, q to @shared,
					if (k==0 ) {
						s_gjD[j][i] = gllD[j*p_gjNq+i];
					}
					int t = i + j*p_gjNq + k*p_gjNq2;
					s_q[k][j][i] = Aq[emap*p_gjNp+t];
				}//for i
			}//for j
		}//for k
		@barrier("local");
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					//load geofactors for my (k,j,i)
					
					int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					//geofactors for k j i thread
					r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
					r_G00 = gjGeo[base+p_G00ID*p_gjNp];
					r_G01 = gjGeo[base+p_G01ID*p_gjNp];
					r_G02 = gjGeo[base+p_G02ID*p_gjNp];
					
					r_G11 = gjGeo[base+p_G11ID*p_gjNp];
					r_G12 = gjGeo[base+p_G12ID*p_gjNp];
					r_G22 = gjGeo[base+p_G22ID*p_gjNp];
					
					
					dfloat dr = 0.0f;
					dfloat ds = 0.0f;
					dfloat dt = 0.0f;
					#pragma unroll p_gjNq
					for (int n = 0; n<p_gjNq; ++n) {
						dr += s_gjD[i][n] * s_q[k][j][n];
						ds += s_gjD[j][n]*s_q[k][n][i];
						dt += s_gjD[k][n]*s_q[n][j][i];
					}
					
					
					r_dr = dr;
					r_ds = ds;
					r_dt = dt;
					
					//	emap = elementList[e];
					//		int t = i + j*p_gjNq + k*p_gjNq2;
					
					//	Ixq[t+emap*p_gjNp]
					r_tmp = r_GwJ*s_q[k][j][i]*lambda;
				}
			}
		}
		@barrier("local");
		// Multiply by D^T, size p_Nq x p_gjNq
		// D size p_gjNq x p_Nq
		
		// r direction
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
				
					//	s_q[k][j][i] = r_qr;
					
					//	int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					//	int t = i + j*p_gjNq + k*p_gjNq2;
					//	Aq[t+emap*p_gjNp]
					s_q[k][j][i] = r_G00*r_dr + r_G01*r_ds + r_G02*r_dt;;
					
				}
			}
		}
		
		@barrier("local");
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat tmp = 0.f;
					int emap = elementList[e];
					#pragma unroll p_gjNq
					for(int m=0; m<p_gjNq; ++m) {
						//k j m
						
						//			int t = m + j*p_gjNq + k*p_gjNq2;
						tmp += s_gjD[m][i]*s_q[k][j][m];
					}
					
					//			int t = i + j*p_gjNq + k*p_gjNq2;
					//	Ixq[t+emap*p_gjNp] +=tmp;
					r_tmp +=tmp;
				}
			}
		}
		
		@barrier("local");
		
		//s direction
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
				
					//	int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					
					
					//	int t = i + j*p_gjNq + k*p_gjNq2;
					//	Aq[t+emap*p_gjNp] =
					s_q[k][j][i] = r_G01*r_dr + r_G11*r_ds + r_G12*r_dt;
					//s_q[k][j][i] = r_qs;
				}
			}
		}
		@barrier("local");
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat tmp = 0.f;
					
					#pragma unroll p_gjNq
					for(int m=0; m<p_gjNq; ++m) {
						//k m i
						//	emap = elementList[e];
						//	int t = i + m*p_gjNq + k*p_gjNq2;
						tmp += s_gjD[m][j]*s_q[k][m][i];
					}
					
					//			int t = i + j*p_gjNq + k*p_gjNq2;
					//		Ixq[t+emap*p_gjNp] +=tmp;
					r_tmp +=tmp;
				}
			}
		}
		@barrier("local");
		//t direction
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
			
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
				
					//		int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					
					
					//		int t = i + j*p_gjNq + k*p_gjNq2;
					//		Aq[t+emap*p_gjNp] =
					
					s_q[k][j][i] = r_G02*r_dr + r_G12*r_ds + r_G22*r_dt;
					//		s_q[k][j][i] = r_qt;
				}
			}
		}
		@barrier("local");
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat tmp = 0.f;
					r_res =0.0f;
					
					#pragma unroll p_gjNq
					for(int m=0; m<p_gjNq; ++m) {
						// m j i
						
						//	int t = i + j*p_gjNq + m*p_gjNq2;
						tmp += s_gjD[m][k]*s_q[m][j][i];
					}
					r_tmp +=tmp;
					
					int base = emap*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					
					Ixq[base] =r_tmp;
					//+= tmp;
				}
			}
		}
		
		
		
		
		
		@barrier("local");
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
				
					int base = k*p_gjNq*p_gjNq + j*p_gjNq + i;
					emap =elementList[e];
					s_q[k][j][i] = Ixq[emap*p_gjNp+base];
					
				}
			}
		}
		@barrier("local");
		
		
		
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Iq = 0.0f;
					if(c<p_Nq){
						#pragma unroll p_gjNq
						for(int m=0; m<p_gjNq; ++m) {
							// k--> c
							Iq += s_gsI[m][c]*s_q[m][j][i];
						}
					}
					r_res = Iq;
				}
			}
		}
		
		@barrier("local");
		
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					s_q[c][j][i] = r_res;
				}
			}
		}
		
		
		
		
		// r direction
		@barrier("local");
		
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					if(c<p_Nq && b<p_Nq){
						dfloat Iq = 0.0f;
						#pragma unroll p_gjNq
						for(int m=0; m<p_gjNq; ++m) {
							Iq += s_gsI[m][b]*s_q[c][m][i];
						}
						r_res = Iq;
					}
				}
			}
		}
		@barrier("local");
		
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					s_q[c][b][i]= r_res;
				}
			}
		}
		@barrier("local");
		
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int a=0; a<p_gjNq; ++a; @inner(0)) {
					if (c<p_Nq && b<p_Nq && a< p_Nq){
						dfloat Iq = 0.0f;
						#pragma unroll p_gjNq
						for(int m=0; m<p_gjNq; ++m) {
							Iq += s_gsI[m][a]*s_q[c][b][m];
						}
						emap = elementList[e];
						int base = emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a;
						Aq[base] = Iq;
					}
				}
			}
		}
	}
	
}//REF6 ends here

//REF7 - no global storage

@kernel void ellipticAxHex3D_Ref3D7(const int Nelements,
                                   @restrict const  int *  elementList,
                                   @restrict const  dfloat *  gjGeo,
                                   @restrict const  dfloat *  gllD,
                                   @restrict const  dfloat *  gjI,
                                   const dfloat lambda,
                                   @restrict dfloat *  q,
                                   @restrict dfloat *  Ixq,
                                   @restrict dfloat *  Aq
                                  ){
                                  
                                  
	// load q into @shared first
	//@kernel 1 - interpolate to gj hex
	for(int e=0; e<Nelements; ++e; @outer(0)) {
		@exclusive int emap;
		
		@shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		//	@shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		@shared dfloat s_gsI[p_gjNq][p_Nq];
		@shared dfloat s_gjD[p_gjNq][p_gjNq];
		@exclusive dfloat r_dr, r_ds, r_dt, r_tmp, r_res;
		@exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;
		
		
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int a=0; a<p_gjNq; ++a; @inner(0)) {
					//	r_res =0.0f;
					if (c == 0 && a<p_Nq && b<p_gjNq) {
						s_gsI[b][a] = gjI[b*p_Nq+a];
					}
					emap = elementList[e];
					int t = a + b*p_gjNq + c*p_gjNq2;
					if (t<p_Np) {
						int ta = t%p_Nq;
						int tb = (t/p_Nq)%p_Nq;
						int tc = t/p_Nq2;
						s_q[tc][tb][ta] = q[emap*p_Np+t];
					}//if
					
				}//for a
			}// for b
		}//for c
		
		//synch threads
		@barrier("local");
		//============== interpolate in 3 dir ========================
		// r --> s --> t
		// rrrrrrr
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Iq = 0.0f;
					if (c<p_Nq && b<p_Nq){
						#pragma unroll p_Nq
						for(int n=0; n<p_Nq; ++n) {
							Iq += s_gsI[i][n]*s_q[c][b][n];
						}
					}
					r_res = Iq;			a
				}
			}
		}
		
		@barrier("local");
		
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					s_q[c][b][i] = r_res;
				}
			}
		}
		@barrier("local");
		
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Iq = 0.0f;
					if(c<p_Nq) {
						#pragma unroll p_Nq
						for(int n=0; n<p_Nq; ++n) {
							Iq += s_gsI[j][n]*s_q[c][n][i];
						}
					}
					r_res = Iq;
				}
			}
		}
		@barrier("local");
		
		
		
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					s_q[c][j][i] = r_res;
				}
			}
		}
		@barrier("local");
		
		// t direction
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Iq = 0.0f;
					#pragma unroll p_Nq
					for(int n=0; n<p_Nq; ++n) {
						Iq += s_gsI[k][n]*s_q[n][j][i];
					}
					r_res = Iq;
					//		s_q[k][j][i] = Iq;
					emap = elementList[e];
					const int id = emap*p_gjNp + k*p_gjNq*p_gjNq+ j*p_gjNq + i;
					//	Aq[id] = Iq;
					//s_q[k][j][i];
				}
			}
		}
		
		
		//differentiate
		@barrier("local");
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					// D to @shared, q to @shared,
					if (k==0 ) {
						s_gjD[j][i] = gllD[j*p_gjNq+i];
					}
					int t = i + j*p_gjNq + k*p_gjNq2;
					s_q[k][j][i] = r_res;
					Aq[emap*p_gjNp+t];
				}//for i
			}//for j
		}//for k
		@barrier("local");
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					//load geofactors for my (k,j,i)
					
					int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					//geofactors for k j i thread
					r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
					r_G00 = gjGeo[base+p_G00ID*p_gjNp];
					r_G01 = gjGeo[base+p_G01ID*p_gjNp];
					r_G02 = gjGeo[base+p_G02ID*p_gjNp];
					
					r_G11 = gjGeo[base+p_G11ID*p_gjNp];
					r_G12 = gjGeo[base+p_G12ID*p_gjNp];
					r_G22 = gjGeo[base+p_G22ID*p_gjNp];
					
					
					dfloat dr = 0.0f;
					dfloat ds = 0.0f;
					dfloat dt = 0.0f;
					#pragma unroll p_gjNq
					for (int n = 0; n<p_gjNq; ++n) {
						dr += s_gjD[i][n] * s_q[k][j][n];
						ds += s_gjD[j][n]*s_q[k][n][i];
						dt += s_gjD[k][n]*s_q[n][j][i];
					}
					
					
					r_dr = dr;
					r_ds = ds;
					r_dt = dt;
					
					//	emap = elementList[e];
					//		int t = i + j*p_gjNq + k*p_gjNq2;
					
					//	Ixq[t+emap*p_gjNp]
					r_tmp = r_GwJ*s_q[k][j][i]*lambda;
				}
			}
		}
		@barrier("local");
		// Multiply by D^T, size p_Nq x p_gjNq
		// D size p_gjNq x p_Nq
		
		// r direction
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
				
					//	s_q[k][j][i] = r_qr;
					
					//	int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					//	int t = i + j*p_gjNq + k*p_gjNq2;
					//	Aq[t+emap*p_gjNp]
					s_q[k][j][i] = r_G00*r_dr + r_G01*r_ds + r_G02*r_dt;;
					
				}
			}
		}
		
		@barrier("local");
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat tmp = 0.f;
					int emap = elementList[e];
					#pragma unroll p_gjNq
					for(int m=0; m<p_gjNq; ++m) {
						//k j m
						
						//			int t = m + j*p_gjNq + k*p_gjNq2;
						tmp += s_gjD[m][i]*s_q[k][j][m];
					}
					
					//			int t = i + j*p_gjNq + k*p_gjNq2;
					//	Ixq[t+emap*p_gjNp] +=tmp;
					r_tmp +=tmp;
				}
			}
		}
		
		@barrier("local");
		
		//s direction
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
				
					//	int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					
					
					//	int t = i + j*p_gjNq + k*p_gjNq2;
					//	Aq[t+emap*p_gjNp] =
					s_q[k][j][i] = r_G01*r_dr + r_G11*r_ds + r_G12*r_dt;
					//s_q[k][j][i] = r_qs;
				}
			}
		}
		@barrier("local");
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat tmp = 0.f;
					
					#pragma unroll p_gjNq
					for(int m=0; m<p_gjNq; ++m) {
						//k m i
						//	emap = elementList[e];
						//	int t = i + m*p_gjNq + k*p_gjNq2;
						tmp += s_gjD[m][j]*s_q[k][m][i];
					}
					
					//			int t = i + j*p_gjNq + k*p_gjNq2;
					//		Ixq[t+emap*p_gjNp] +=tmp;
					r_tmp +=tmp;
				}
			}
		}
		@barrier("local");
		//t direction
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
			
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
				
					//		int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					
					
					//		int t = i + j*p_gjNq + k*p_gjNq2;
					//		Aq[t+emap*p_gjNp] =
					
					s_q[k][j][i] = r_G02*r_dr + r_G12*r_ds + r_G22*r_dt;
					//		s_q[k][j][i] = r_qt;
				}
			}
		}
		@barrier("local");
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat tmp = 0.f;
					r_res =0.0f;
					
					#pragma unroll p_gjNq
					for(int m=0; m<p_gjNq; ++m) {
						// m j i
						
						//	int t = i + j*p_gjNq + m*p_gjNq2;
						tmp += s_gjD[m][k]*s_q[m][j][i];
					}
					r_tmp +=tmp;
					
					int base = emap*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					
					//			Ixq[base] =r_tmp;
					//+= tmp;
				}
			}
		}
		
		
		
		
		
		@barrier("local");
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
				
					int base = k*p_gjNq*p_gjNq + j*p_gjNq + i;
					emap =elementList[e];
					s_q[k][j][i] = r_tmp;
					//Ixq[emap*p_gjNp+base];
					
				}
			}
		}
		@barrier("local");
		
		
		
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Iq = 0.0f;
					if(c<p_Nq){
						#pragma unroll p_gjNq
						for(int m=0; m<p_gjNq; ++m) {
							// k--> c
							Iq += s_gsI[m][c]*s_q[m][j][i];
						}
					}
					r_res = Iq;
				}
			}
		}
		
		@barrier("local");
		
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					s_q[c][j][i] = r_res;
				}
			}
		}
		
		
		
		
		// r direction
		@barrier("local");
		
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					if(c<p_Nq && b<p_Nq){
						dfloat Iq = 0.0f;
						#pragma unroll p_gjNq
						for(int m=0; m<p_gjNq; ++m) {
							Iq += s_gsI[m][b]*s_q[c][m][i];
						}
						r_res = Iq;
					}
				}
			}
		}
		@barrier("local");
		
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					s_q[c][b][i]= r_res;
				}
			}
		}
		@barrier("local");
		
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int a=0; a<p_gjNq; ++a; @inner(0)) {
					if (c<p_Nq && b<p_Nq && a< p_Nq){
						dfloat Iq = 0.0f;
						#pragma unroll p_gjNq
						for(int m=0; m<p_gjNq; ++m) {
							Iq += s_gsI[m][a]*s_q[c][b][m];
						}
						emap = elementList[e];
						int base = emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a;
						Aq[base] = Iq;
					}
				}
			}
		}
	}
	
}//REF7 ends here

//REF8 all partial results stored in @shared
@kernel void ellipticAxHex3D_Ref3D8(const int Nelements,
                                   @restrict const  int *  elementList,
                                   @restrict const  dfloat *  gjGeo,
                                   @restrict const  dfloat *  gllD,
                                   @restrict const  dfloat *  gjI,
                                   const dfloat lambda,
                                   @restrict dfloat *  q,
                                   @restrict dfloat *  Ixq,
                                   @restrict dfloat *  Aq
                                  ){
	// load q into @shared first
	//@kernel 1 - interpolate to gj hex
	for(int e=0; e<Nelements; ++e; @outer(0)) {
		//	@exclusive int emap;
		//	@exclusive dfloat r_res;
		@shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		
		@shared dfloat s_q1[p_gjNq][p_gjNq][p_gjNq];
		@shared dfloat s_q2[p_gjNq][p_gjNq][p_gjNq];
		@shared dfloat s_q3[p_gjNq][p_gjNq][p_gjNq];
		@shared dfloat s_i4[p_gjNq][p_gjNq][p_gjNq];
		
		@shared dfloat s_gjD[p_gjNq][p_gjNq];
		@shared dfloat s_gsI[p_gjNq][p_Nq];
		
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int a=0; a<p_gjNq; ++a; @inner(0)) {
					//		r_res =0.0f;
					if (c == 0 && a<p_Nq && b<p_gjNq) {
						s_gsI[b][a] = gjI[b*p_Nq+a];
					}
					if (c==0 ) {
						s_gjD[b][a] = gllD[b*p_gjNq+a];
					}
					
					int emap = elementList[e];
					int t = a + b*p_gjNq + c*p_gjNq2;
					if (t<p_Np) {
						int ta = t%p_Nq;
						int tb = (t/p_Nq)%p_Nq;
						int tc = t/p_Nq2;
						s_q2[tc][tb][ta] = q[emap*p_Np+t];
					}//if
				}//for a
			}// for b
		}//for c
		//synch threads
		@barrier("local");
		//============== interpolate in 3 dir ========================
		// r --> s --> t
		// rrrrrrr
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					//		dfloat Iq = 0.0f;
					s_q[c][b][i] = 0.0f;
					if (c<p_Nq && b<p_Nq){
						#pragma unroll p_Nq
						for(int n=0; n<p_Nq; ++n) {
							s_q[c][b][i] += s_gsI[i][n]*s_q2[c][b][n];
						}
					}
					
				}
			}
		}
		
		@barrier("local");
		
		
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					//	dfloat Iq = 0.0f;
					s_q2[c][j][i] = 0.0f;
					if(c<p_Nq) {
						#pragma unroll p_Nq
						for(int n=0; n<p_Nq; ++n) {
							s_q2[c][j][i] += s_gsI[j][n]*s_q[c][n][i];
						}
					}
					
				}
			}
		}
		@barrier("local");
		
		
		
		// t direction
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					//	dfloat Iq = 0.0f;
					s_q[k][j][i] =0.0f;
					#pragma unroll p_Nq
					for(int n=0; n<p_Nq; ++n) {
						s_q[k][j][i] += s_gsI[k][n]*s_q2[n][j][i];
					}
				}
			}
		}
		
		
		// at this point q is interpolated in all 3 dim.
		// ------------KERNEL 2 -------------->
		
		@barrier("local");
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					//load geofactors for my (k,j,i)
					dfloat qr, qs, qt, tmp;
					dfloat G00, G01, G02, G11, G12, G22, GwJ;
					int emap;
					
					const int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					//geofactors for k j i thread
					GwJ = gjGeo[base+p_GWJID*p_gjNp];
					G00 = gjGeo[base+p_G00ID*p_gjNp];
					G01 = gjGeo[base+p_G01ID*p_gjNp];
					G02 = gjGeo[base+p_G02ID*p_gjNp];
					
					G11 = gjGeo[base+p_G11ID*p_gjNp];
					G12 = gjGeo[base+p_G12ID*p_gjNp];
					G22 = gjGeo[base+p_G22ID*p_gjNp];
					// now, put together dq/dr, qq/ds, dq/dt and dq/dI
					
					dfloat dr = 0.0f;
					dfloat ds = 0.0f;
					dfloat dt = 0.0f;
					#pragma unroll p_gjNq
					for (int n = 0; n<p_gjNq; ++n) {
						dr += s_gjD[i][n] * s_q[k][j][n];
						ds += s_gjD[j][n] * s_q[k][n][i];
						dt += s_gjD[k][n] * s_q[n][j][i];
					}
					qr = G00*dr + G01*ds + G02*dt;
					qs = G01*dr + G11*ds + G12*dt;
					qt = G02*dr + G12*ds + G22*dt;
					
					tmp = GwJ*s_q[k][j][i]*lambda;
					
					s_q1[k][j][i] = qr;
					s_q2[k][j][i] = qs;
					s_q3[k][j][i] = qt;
					s_i4[k][j][i] = tmp;
					
					
					
				}
			}
		}
		@barrier("local");
		// Multiply by D^T, size p_Nq x p_gjNq
		// D size p_gjNq x p_Nq
		
		
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat tmp = 0.f;
					#pragma unroll p_gjNq
					for(int m=0; m<p_gjNq; ++m) {
						tmp += s_gjD[m][i]*s_q1[k][j][m];
						tmp += s_gjD[m][j]*s_q2[k][m][i];
						tmp += s_gjD[m][k]*s_q3[m][j][i];
					}
					s_i4[k][j][i]+=tmp;
					
					s_q[k][j][i] =	s_i4[k][j][i];
				}
			}
		}
		
		@barrier("local");
		
		
		// t first
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Iq = 0.0f;
					if(c<p_Nq){
						#pragma unroll p_gjNq
						for(int m=0; m<p_gjNq; ++m) {
							// k--> c
							Iq += s_gsI[m][c]*s_q[m][j][i];
						}
					}
					//r_res = Iq;
					s_q2[c][j][i] = Iq;
					
				}
			}
		}
		
		
		
		
		
		
		// r direction
		@barrier("local");
		
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					if(c<p_Nq && b<p_Nq){
						dfloat Iq = 0.0f;
						#pragma unroll p_gjNq
						for(int m=0; m<p_gjNq; ++m) {
							Iq += s_gsI[m][b]*s_q2[c][m][i];
						}
						
						s_q[c][b][i] = Iq;
					}
				}
			}
		}
		@barrier("local");
		
		
		
		
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int a=0; a<p_gjNq; ++a; @inner(0)) {
					if (c<p_Nq && b<p_Nq && a< p_Nq){
						dfloat Iq = 0.0f;
						#pragma unroll p_gjNq
						for(int m=0; m<p_gjNq; ++m) {
							Iq += s_gsI[m][a]*s_q[c][b][m];
						}
						int emap = elementList[e];
						int base = emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a;
						Aq[base] = Iq;
					}
				}
			}
		}
	}//e
} //REF8



// for refeence and testing

@kernel void ellipticAxHex3D_e9(const int Nelements,
                               @restrict const  int *  elementList,
                               @restrict const  dfloat *  gjGeo,
                               @restrict const  dfloat *  gllD,
                               @restrict const  dfloat *  gjI,
                               const dfloat lambda,
                               @restrict dfloat *  q,
                               @restrict dfloat *  Ixq,
                               @restrict dfloat *  Aq
                              ){
                              
                              
	// load q into @shared first
	//@kernel 1 - interpolate to gj hex
	for(int e=0; e<Nelements; ++e; @outer(0)) {
		@exclusive int emap;
		@exclusive dfloat r_res;
		@shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		@shared dfloat s_gsI[p_gjNq][p_Nq];
		
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int a=0; a<p_gjNq; ++a; @inner(0)) {
					r_res =0.0f;
					if (c == 0 && a<p_Nq && b<p_gjNq) {
						s_gsI[b][a] = gjI[b*p_Nq+a];
					}
					emap = elementList[e];
					int t = a + b*p_gjNq + c*p_gjNq2;
					if (t<p_Np) {
						int ta = t%p_Nq;
						int tb = (t/p_Nq)%p_Nq;
						int tc = t/p_Nq2;
						s_q[tc][tb][ta] = q[emap*p_Np+t];
					}//if
				}//for a
			}// for b
		}//for c
		//synch threads
		@barrier("local");
		//============== interpolate in 3 dir ========================
		// r --> s --> t
		// rrrrrrr
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Iq = 0.0f;
					if (c<p_Nq && b<p_Nq){
						#pragma unroll p_Nq
						for(int n=0; n<p_Nq; ++n) {
							Iq += s_gsI[i][n]*s_q[c][b][n];
						}
					}
					r_res = Iq;			a
				}
			}
		}
		
		@barrier("local");
		
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					s_q[c][b][i] = r_res;
				}
			}
		}
		@barrier("local");
		
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Iq = 0.0f;
					if(c<p_Nq) {
						#pragma unroll p_Nq
						for(int n=0; n<p_Nq; ++n) {
							Iq += s_gsI[j][n]*s_q[c][n][i];
						}
					}
					r_res = Iq;
				}
			}
		}
		@barrier("local");
		
		
		
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					s_q[c][j][i] = r_res;
				}
			}
		}
		@barrier("local");
		
		// t direction
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Iq = 0.0f;
					#pragma unroll p_Nq
					for(int n=0; n<p_Nq; ++n) {
						Iq += s_gsI[k][n]*s_q[n][j][i];
					}
					//	r_res = Iq;
					//		s_q[k][j][i] = Iq;
					emap = elementList[e];
					const int id = emap*p_gjNp + k*p_gjNq*p_gjNq+ j*p_gjNq + i;
					Ixq[id] = Iq;
					//s_q[k][j][i];
				}
			}
		}
	}// for e
	
	
	// at this point q is interpolated in all 3 dim.
	// ------------KERNEL 2 -------------->
	
	// @kernel 2 differentiate on gj hex
	for(int e=0; e<Nelements; ++e; @outer(0)) {
		@shared dfloat s_gjD[p_gjNq][p_gjNq];
		@shared dfloat s_gllD[p_gjNq][p_Nq];
		@shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		@exclusive dfloat r_qr, r_qs, r_qt, r_tmp;
		@exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;
		@exclusive int emap;
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					// D to @shared, q to @shared,
					if (k==0 ) {
						s_gjD[j][i] = gllD[j*p_gjNq+i];
					}
					emap = elementList[e];
					int t = i + j*p_gjNq + k*p_gjNq2;
					s_q[k][j][i] = Ixq[emap*p_gjNp+t];
				}//for i
			}//for j
		}//for k
		@barrier("local");
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					//load geofactors for my (k,j,i)
					//		emap = elementList[e];
					const int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					//geofactors for k j i thread
					r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
					r_G00 = gjGeo[base+p_G00ID*p_gjNp];
					r_G01 = gjGeo[base+p_G01ID*p_gjNp];
					r_G02 = gjGeo[base+p_G02ID*p_gjNp];
					
					r_G11 = gjGeo[base+p_G11ID*p_gjNp];
					r_G12 = gjGeo[base+p_G12ID*p_gjNp];
					r_G22 = gjGeo[base+p_G22ID*p_gjNp];
					// now, put together dq/dr, qq/ds, dq/dt and dq/dI
					
					dfloat dr = 0.0f;
					dfloat ds = 0.0f;
					dfloat dt = 0.0f;
					#pragma unroll p_gjNq
					for (int n = 0; n<p_gjNq; ++n) {
						dr += s_gjD[i][n] * s_q[k][j][n];
						ds += s_gjD[j][n]*s_q[k][n][i];
						dt += s_gjD[k][n]*s_q[n][j][i];
					}
					r_qr = r_G00*dr + r_G01*ds + r_G02*dt;
					r_qs = r_G01*dr + r_G11*ds + r_G12*dt;
					r_qt = r_G02*dr + r_G12*ds + r_G22*dt;
					
					r_tmp = r_GwJ*s_q[k][j][i]*lambda;
				}
			}
		}
		@barrier("local");
		// Multiply by D^T, size p_Nq x p_gjNq
		// D size p_gjNq x p_Nq
		
		// r direction
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					s_q[k][j][i] = r_qr;
				}
			}
		}
		@barrier("local");
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat tmp = 0.f;
					#pragma unroll p_gjNq
					for(int m=0; m<p_gjNq; ++m) {
						tmp += s_gjD[m][i]*s_q[k][j][m];
					}
					r_tmp +=tmp;
				}
			}
		}
		@barrier("local");
		
		//s direction
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					s_q[k][j][i] = r_qs;
				}
			}
		}
		@barrier("local");
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat tmp = 0.f;
					#pragma unroll p_gjNq
					for(int m=0; m<p_gjNq; ++m) {
						tmp += s_gjD[m][j]*s_q[k][m][i];
					}
					r_tmp +=tmp;
				}
			}
		}
		@barrier("local");
		//t direction
		
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					s_q[k][j][i] = r_qt;
				}
			}
		}
		@barrier("local");
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat tmp = 0.f;
					#pragma unroll p_gjNq
					for(int m=0; m<p_gjNq; ++m) {
						tmp += s_gjD[m][k]*s_q[m][j][i];
					}
					r_tmp +=tmp;
					int base = emap*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					Ixq[base] = r_tmp;
				}
			}
		}
	}//for e
	
	
	//-------------------- @kernel 3 interpolate back to gll hex ------------------->
	
	for(int e=0; e<Nelements; ++e; @outer(0)) {
		// read q
		
		@shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		@shared dfloat s_I[p_gjNq][p_Nq];
		@exclusive dfloat r_res = 0.0f, r_Aq=0.0f;
		int emap;
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
				
					int base = k*p_gjNq*p_gjNq + j*p_gjNq + i;
					emap =elementList[e];
					s_q[k][j][i] = Ixq[emap*p_gjNp+base];
					if(i<p_Nq &&  k == 0 && j<p_gjNq) {
						s_I[j][i] = gjI[j*p_Nq+i];
					}
				}
			}
		}
		@barrier("local");
		
		
		// t first
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Iq = 0.0f;
					if(c<p_Nq){
						#pragma unroll p_gjNq
						for(int m=0; m<p_gjNq; ++m) {
							// k--> c
							Iq += s_I[m][c]*s_q[m][j][i];
						}
					}
					r_res = Iq;
				}
			}
		}
		
		@barrier("local");
		
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					s_q[c][j][i] = r_res;
				}
			}
		}
		
		
		
		
		// r direction
		@barrier("local");
		
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					if(c<p_Nq && b<p_Nq){
						dfloat Iq = 0.0f;
						#pragma unroll p_gjNq
						for(int m=0; m<p_gjNq; ++m) {
							Iq += s_I[m][b]*s_q[c][m][i];
						}
						r_res = Iq;
					}
				}
			}
		}
		@barrier("local");
		
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					s_q[c][b][i]= r_res;
				}
			}
		}
		@barrier("local");
		
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int a=0; a<p_gjNq; ++a; @inner(0)) {
					if (c<p_Nq && b<p_Nq && a< p_Nq){
						dfloat Iq = 0.0f;
						#pragma unroll p_gjNq
						for(int m=0; m<p_gjNq; ++m) {
							Iq += s_I[m][a]*s_q[c][b][m];
						}
						emap = elementList[e];
						int base = emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a;
						Aq[base] = Iq;
					}
				}
			}
		}
	}//e
} //@kernel e9



