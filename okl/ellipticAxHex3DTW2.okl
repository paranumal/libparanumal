

// [ Dr' Ds' Dt' ] [G00 G01 G02]  [ Dr ]
//               ] [G01 G11 G12]  [ Ds ]      
//               ] [G02 G12 G22]  [ Dt ]      

// [ Dr' Ds' ] [G00 G01]  [ Dr ]
//           ] [G01   0]  [ Ds ]      

// [ Dr' Dt' ] [  0 G02]  [ Dr ]
//           ] [G02 G22]  [ Dt ]      


// [ Ds' Dt' ] [G11 G12]  [ Ds ]
//           ] [G12   0]  [ Dt ]      

#define UNROLL0(a) a
#define UNROLL1(a) a UNROLL0(a)
#define UNROLL2(a) a UNROLL1(a)
#define UNROLL3(a) a UNROLL2(a)
#define UNROLL4(a) a UNROLL3(a)
#define UNROLL5(a) a UNROLL4(a)
#define UNROLL6(a) a UNROLL5(a)
#define UNROLL7(a) a UNROLL6(a)
#define UNROLL8(a) a UNROLL7(a)
#define UNROLL9(a) a UNROLL8(a)
#define UNROLL10(a) a UNROLL9(a)
#define UNROLL11(a) a UNROLL10(a)
#define UNROLL12(a) a UNROLL11(a)
#define UNROLL13(a) a UNROLL12(a)
#define UNROLL14(a) a UNROLL13(a)
#define UNROLL15(a) a UNROLL14(a)
#define UNROLL16(a) a UNROLL15(a)

#define UNROLLN(n,a) UNROLL##n(a)


#if p_Nq==4
#define UNROLLNq(a) UNROLL3(a)
#define p_Bskip 1
#define p_Bmask 1
#define p_Nslabs 1
#define p_Nslab 4
#define p_Bsize 2
#endif

#if p_Nq==8
#define UNROLLNq(a) UNROLL7(a)
#define p_Bskip 1
#define p_Bmask 1
#define p_Nslabs 2
#define p_Nslab 4
#define p_Bsize 2
#endif


#if p_Nq==16
#define UNROLLNq(a) UNROLL15(a)
#define p_Bskip 2
#define p_Bmask 3
#define p_Nslabs 4
#define p_Nslab 4
#define p_Bsize 4
#endif

#define p_pad 1

@kernel void ellipticAxHex3D_trilinear3(const int Nelements,
                                       @restrict const  int *  elementList,
                                       @restrict const  dfloat *  ggeo,
                                       @restrict const  dfloat *  D,
                                       const dfloat lambda,
                                       @restrict const  dfloat *  q,
                                       @restrict dfloat *  Aq,
                                       @restrict const  dfloat *  grad){

  // assume multiple of 4

  for(int e=0; e<Nelements; ++e; @outer(0)) {

    @shared dfloat s_q[p_Nslab][p_Nq][p_Nq+p_pad];
    @shared dfloat s_tmp1[p_Nslab][p_Nq][p_Nq+p_pad]; // 
    @shared dfloat s_tmp2[p_Nslab][p_Nq][p_Nq+p_pad];
    @shared dfloat s_D[p_Nq][p_Nq+p_pad];
    @shared dfloat s_DT[p_Nq][p_Nq+p_pad];
    
    @exclusive int emap, r_nodeId, r_smemId;
    @exclusive dfloat r_res;

    for(int ks=0;ks<p_Nslab;++ks;@inner(2)){
      for(int j=0;j<p_Nq;++j;@inner(1)){
	for(int i=0;i<p_Nq;++i;@inner(0)){
	  emap = elementList[e];
	  if(ks==0){
	    s_D[j][i] = D[j*p_Nq+i];
	    s_DT[i][j] = D[j*p_Nq+i];
	  }
	}
      }
    }

    #pragma unroll p_Nslabs
      for(int kslab=0;kslab<p_Nslabs;++kslab){

	@barrier("local");

	for(int ks=0;ks<p_Nslab;++ks;@inner(2)){
	  for(int j=0;j<p_Nq;++j;@inner(1)){
	    for(int i=0;i<p_Nq;++i;@inner(0)){

	      const unsigned int t = i+j*p_Nq+ks*p_Nq*p_Nq;
	      const unsigned int iT = t&3;
	      const unsigned int jT = (t>>2)&3;
	      const unsigned int kT = (t>>4)&3;
	      const unsigned int iB = (t>>6)&p_Bmask;
	      const unsigned int jB = (t>>(6+p_Bskip))&p_Bmask;
	      const unsigned int kB = kslab;
	      const unsigned int id = iT+jT*4+kT*16+64*(iB+jB*p_Bsize+kB*p_Bsize*p_Bsize);
	      r_nodeId = id+emap*p_Np;
	      r_smemId = iB*4+iT + (p_Nq+p_pad)*(jB*4+jT) + kT*p_Nq*(p_Nq+p_pad);
	      s_q[0][0][r_smemId] = q[r_nodeId];
	      
	    }
	  }
	}

	@barrier("local");

	for(int ks=0;ks<p_Nslab;++ks;@inner(2)){
	  for(int j=0;j<p_Nq;++j;@inner(1)){
	    for(int i=0;i<p_Nq;++i;@inner(0)){

	      // assume specific data layout for G00 and G01
	      const unsigned int base = emap*p_Np*p_Nggeo+(ks+kslab*p_Nslab)*p_Nq*p_Nq+j*p_Nq+i;
	      const dfloat r_G00 = ggeo[base+p_G00ID*p_Np];
	      const dfloat r_G01 = ggeo[base+p_G01ID*p_Np];
	      r_res = lambda*ggeo[base+p_GWJID*p_Np]; // lambda*GwJ

	      dfloat tmpr = 0, tmps = 0;
	      int n;

	      n=0;
	      UNROLLNq(tmpr += s_DT[n][i]*s_q[ks][j][n];++n;); 
	      
	      n=0;
	      UNROLLNq(tmps += s_D[j][n]*s_q[ks][n][i];++n;);

	      s_tmp1[ks][j][i] = r_G00*tmpr + r_G01*tmps;
	      s_tmp2[ks][j][i] = r_G01*tmpr;
	    }
	  }
	}

	@barrier("local");
	
	for(int ks=0;ks<p_Nslab;++ks;@inner(2)){
	  for(int j=0;j<p_Nq;++j;@inner(1)){
	    for(int i=0;i<p_Nq;++i;@inner(0)){
	      dfloat tmpr = 0, tmps = 0;
	      int n;
	      n=0;
	      UNROLLNq(tmpr += s_D[n][i]*s_tmp1[ks][j][n]; ++n;);

	      n=0;
	      UNROLLNq(tmps += s_D[n][j]*s_tmp2[ks][n][i]; ++n;);

	      s_q[ks][j][i] = tmpr+tmps+r_res;
	    }
	  }
	}
	
	@barrier("local");
	
	for(int ks=0;ks<p_Nslab;++ks;@inner(2)){
	  for(int j=0;j<p_Nq;++j;@inner(1)){
	    for(int i=0;i<p_Nq;++i;@inner(0)){
	      
	      Aq[r_nodeId] = s_q[0][0][r_smemId];
	    }
	  }
	}
      } // end of kslabbing
  }

  // cannot merge @kernels because of different ordering of access and output
  for(int e=0; e<Nelements; ++e; @outer(0)) {
    
    @shared dfloat s_q[p_Nslab][p_Nq][p_Nq+p_pad];
    @shared dfloat s_tmp1[p_Nslab][p_Nq][p_Nq+p_pad];
    @shared dfloat s_tmp2[p_Nslab][p_Nq][p_Nq+p_pad];
    @shared dfloat s_D[p_Nq][p_Nq+p_pad];
    @shared dfloat s_DT[p_Nq][p_Nq+p_pad];
    
    @exclusive int emap, r_nodeId, r_smemId, r_res;

    for(int ks=0;ks<p_Nslab;++ks;@inner(2)){
      for(int j=0;j<p_Nq;++j;@inner(1)){
	for(int i=0;i<p_Nq;++i;@inner(0)){
	  emap = elementList[e];
	  if(ks==0){
	    s_D[j][i] = D[j*p_Nq+i];
	    s_DT[i][j] = D[j*p_Nq+i];
	  }
	}
      }
    }
    
    #pragma unroll p_Nslabs
      for(int jslab=0;jslab<p_Nslabs;++jslab){
	
	@barrier("local");
	
	for(int js=0;js<p_Nslab;++js;@inner(2)){
	  for(int k=0;k<p_Nq;++k;@inner(1)){
	    for(int i=0;i<p_Nq;++i;@inner(0)){

	      const unsigned int t = i+k*p_Nq+js*p_Nq*p_Nq;
	      const unsigned int iT = t&3;
	      const unsigned int jT = (t>>2)&3;
	      const unsigned int kT = (t>>4)&3;
	      const unsigned int iB = (t>>6)&p_Bmask;
	      const unsigned int jB = jslab;
	      const unsigned int kB = (t>>(6+p_Bskip))&p_Bmask;
	      const unsigned int id = iT+jT*4+kT*16+64*(iB+jB*p_Bsize+kB*p_Bsize*p_Bsize);
	      r_nodeId = id+emap*p_Np;
	      r_smemId = iB*4+iT + (p_Nq+p_pad)*(kB*4+kT) + p_Nq*(p_Nq+p_pad)*jT;
	      s_q[0][0][r_smemId] = q[r_nodeId];
	      r_res = Aq[r_nodeId];
	    }
	  }
	}

	@barrier("local");

	for(int js=0;js<p_Nslab;++js;@inner(2)){
	  for(int k=0;k<p_Nq;++k;@inner(1)){
	    for(int i=0;i<p_Nq;++i;@inner(0)){

	      const unsigned int base = emap*p_Np*p_Nggeo+(js+jslab*p_Nslab)*p_Nq*p_Nq+k*p_Nq+i; // assume ordering (j,k,i) with i fastest
	      const dfloat r_G02 = ggeo[base+p_G02ID*p_Np];
	      const dfloat r_G22 = ggeo[base+p_G22ID*p_Np];
	      
	      dfloat tmpr = 0, tmpt = 0;

	      int n=0;
	      UNROLLNq(tmpr += s_DT[n][i]*s_q[js][k][n]; tmpt += s_D[k][n]*s_q[js][n][i]; ++n;);
	      
	      s_tmp1[js][i][k] =              r_G02*tmpt;
	      s_tmp2[js][k][i] = r_G02*tmpr + r_G22*tmpt;
	    }
	  }
	}

	@barrier("local");

	for(int js=0;js<p_Nslab;++js;@inner(2)){
	  for(int k=0;k<p_Nq;++k;@inner(1)){
	    for(int i=0;i<p_Nq;++i;@inner(0)){
	      dfloat tmpr = 0, tmpt = 0;
	      int n=0;
	      UNROLLNq(tmpt += s_D[n][k]*s_tmp2[js][n][i]; tmpr += s_D[n][i]*s_tmp1[js][n][k]; ++n;);

	      s_q[js][k][i] = tmpr+tmpt;
	      
	    }
	  }
	}

	@barrier("local");

	for(int js=0;js<p_Nslab;++js;@inner(2)){
	  for(int k=0;k<p_Nq;++k;@inner(1)){
	    for(int i=0;i<p_Nq;++i;@inner(0)){

	      Aq[r_nodeId] = r_res + s_q[0][0][r_smemId];
	    }
	  }
	}
      } // end of jslabbing
  }
  
  for(int e=0; e<Nelements; ++e; @outer(0)) {
    
    @shared dfloat s_q[p_Nslab][p_Nq][p_Nq+p_pad];
    @shared dfloat s_tmp1[p_Nslab][p_Nq][p_Nq+p_pad];
    @shared dfloat s_tmp2[p_Nslab][p_Nq][p_Nq+p_pad];
    @shared dfloat s_D[p_Nq][p_Nq+p_pad];
    @shared dfloat s_DT[p_Nq][p_Nq+p_pad];

    @exclusive int emap, r_nodeId, r_smemId;
    @exclusive dfloat r_res;
    
    for(int ks=0;ks<p_Nslab;++ks;@inner(2)){
      for(int j=0;j<p_Nq;++j;@inner(1)){
	for(int i=0;i<p_Nq;++i;@inner(0)){
	  emap = elementList[e];
	  if(ks==0){
	    s_D[j][i] = D[j*p_Nq+i];
    	    s_DT[i][j] = D[j*p_Nq+i];
	  }
	}
      }
    }
    
    #pragma unroll p_Nslabs
      for(int islab=0;islab<p_Nslabs;++islab){
	
	for(int is=0;is<p_Nslab;++is;@inner(2)){
	  for(int k=0;k<p_Nq;++k;@inner(1)){
	    for(int j=0;j<p_Nq;++j;@inner(0)){

	      const unsigned int t = j+k*p_Nq+is*p_Nq*p_Nq;
	      const unsigned int iT = t&3;
	      const unsigned int jT = (t>>2)&3;
	      const unsigned int kT = (t>>4)&3;
	      const unsigned int iB = islab;
	      const unsigned int jB = (t>>6)&p_Bmask;
	      const unsigned int kB = (t>>(6+p_Bskip))&p_Bmask;
	      const unsigned int id = iT+jT*4+kT*16+64*(iB+jB*p_Bsize+kB*p_Bsize*p_Bsize);
	      r_nodeId = id+emap*p_Np;
	      r_smemId = jB*4+jT + (p_Nq+p_pad)*(kB*4+kT) + p_Nq*(p_Nq+p_pad)*iT;
	      s_q[0][0][r_smemId] = q[r_nodeId];

	      r_res = Aq[r_nodeId];
	    }
	  }
	}

	@barrier("local");

	for(int is=0;is<p_Nslab;++is;@inner(2)){
	  for(int k=0;k<p_Nq;++k;@inner(1)){
	    for(int j=0;j<p_Nq;++j;@inner(0)){

	      const unsigned int base = emap*p_Np*p_Nggeo+k*p_Nq+j + p_Nq*p_Nq*(is+islab*p_Nslab); // assume ordering (i,k,j)
	      const dfloat r_G11 = ggeo[base+p_G11ID*p_Np];
	      const dfloat r_G12 = ggeo[base+p_G12ID*p_Np];

	      dfloat tmps = 0, tmpt = 0;
	      int n=0;
	      
	      UNROLLNq(tmps += s_DT[n][j]*s_q[is][k][n]; tmpt += s_D[k][n]*s_q[is][n][j];++n;);

	      s_tmp1[is][k][j] = r_G11*tmps + r_G12*tmpt;
	      s_tmp2[is][k][j] = r_G12*tmps;
	    }
	  }
	}

	@barrier("local");

	for(int is=0;is<p_Nslab;++is;@inner(2)){
	  for(int k=0;k<p_Nq;++k;@inner(1)){
	    for(int j=0;j<p_Nq;++j;@inner(0)){

	      dfloat tmps = 0, tmpt = 0;
	      int n=0;
	      UNROLLNq(tmps += s_D[n][j]*(s_tmp1[is][k][n]); tmpt += s_D[n][k]*(s_tmp2[is][n][j]);++n;);
	      s_q[is][k][j] = tmps+tmpt;
	    }
	  }
	}

	@barrier("local");
	
	for(int is=0;is<p_Nslab;++is;@inner(2)){
	  for(int k=0;k<p_Nq;++k;@inner(1)){
	    for(int j=0;j<p_Nq;++j;@inner(0)){
	    
	      Aq[r_nodeId] = r_res + s_q[0][0][r_smemId];
	    }
	  }
	}
      } // end of islabbing
  }
  
}

