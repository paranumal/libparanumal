
kernel void boltzmannUpdateQuad3D(const iint Nelements,
				  const dfloat dt,  
				  const dfloat rka,
				  const dfloat rkb,
				  const dfloat * restrict rhsq,
				  dfloat * restrict resq,
				  dfloat * restrict q){
  
  // Low storage Runge Kutta time step update
  for(iint e=0;e<Nelements;++e;outer0){

    for(iint n=0;n<p_Np;++n;inner0){

      for(iint fld=0; fld< p_Nfields; ++fld){

	const iint id = e*p_Np*p_Nfields + fld*p_Np + n;
	
	dfloat r_resq = resq[id];
	dfloat r_rhsq = rhsq[id]; 
	dfloat r_q    = q[id];

	//	printf("before: e=%d, n=%d, fld=%d, q=%g, resq=%g, rhsq=%g\n", e, n, fld, r_q, r_resq, r_rhsq);
	//
	r_resq = rka*r_resq + dt*r_rhsq;
	r_q   += rkb*r_resq;
	//
	resq[id] = r_resq;
	q[id]    = r_q;
	//	printf("after: e=%d, n=%d, fld=%d, q=%g, resq=%g, rhsq=%g\n", e, n, fld, r_q, r_resq, r_rhsq);
      }
    }
  }
}

// Same kernel for update and trace update
kernel void boltzmannMRSAABUpdateQuadold3D(const iint Nelements,
					   const iint * restrict elementIds,	
					   const dfloat expdt, 
					   const dfloat ab1,
					   const dfloat ab2,
					   const dfloat ab3,
					   const dfloat saab1,
					   const dfloat saab2,
					   const dfloat saab3,
					   const iint   shift,
					   const dfloat * restrict rhsq,
					   const iint * restrict vmapM,
					   dfloat * restrict fQ,
					   dfloat * restrict q){
  
  // Low storage Runge Kutta time step update
  // hard-coded for 3th order
  for(iint es=0;es<Nelements;++es;outer0){
    shared dfloat s_q[p_Np*p_Nfields];
    for(iint n=0;n<p_Np;++n;inner0){
      const iint e  = elementIds[es];
      const iint id = p_Nfields*e*p_Np + n;
      const iint rid = n + e*p_Np*p_Nfields*3;
      
      const iint rhsId1 = rid + ((shift+0)%3)*p_Nfields*p_Np;
      const iint rhsId2 = rid + ((shift+1)%3)*p_Nfields*p_Np;
      const iint rhsId3 = rid + ((shift+2)%3)*p_Nfields*p_Np;

      for(iint fld=0; fld< p_Nfields; ++fld){

	//load q and update
	if(fld<4)
	  s_q[n+fld*p_Np] = q[id+fld*p_Np] + ab1*rhsq[rhsId1+fld*p_Np]+ab2*rhsq[rhsId2+fld*p_Np]+ab3*rhsq[rhsId3+fld*p_Np];
	else
	  s_q[n+fld*p_Np] = expdt*q[id+fld*p_Np] + saab1*rhsq[rhsId1+fld*p_Np] + saab2*rhsq[rhsId2+fld*p_Np] + saab3*rhsq[rhsId3+fld*p_Np];

	//store new q
	q[id+fld*p_Np] = s_q[n+fld*p_Np];
      }
    }
    barrier(localMemFence);
    for(iint n = 0; n < p_Np; ++n;inner0) {
      //store values for surface kernel
      if(n<p_Nfaces*p_Nfp){
        const iint e = elementIds[es];
	for (iint fld=0; fld<p_Nfields; ++fld) {
	  const iint iid  = e*p_Nfp*p_Nfaces + n;
	  const iint qidM = vmapM[iid] - e*p_Np;
	  const iint qid  = e*p_Nfp*p_Nfaces*p_Nfields + n; 
	  
	  fQ[qid+fld*p_Nfp*p_Nfaces] = s_q[qidM + fld*p_Nfp*p_Nfaces];
	}
      }     
    }
  }
}


kernel void boltzmannMRSAABUpdateQuad3D(const iint Nelements,
					const iint * restrict elementIds,
					const dfloat expdt,
					const dfloat ab1,
					const dfloat ab2,
					const dfloat ab3,
					const dfloat saab1,
					const dfloat saab2,
					const dfloat saab3,
					const iint   shift,
					const dfloat * restrict rhsq,
					const iint   * restrict vmapM,
					dfloat * restrict fQM,
					dfloat * restrict q){

  // Low storage Runge Kutta time step update
  for(iint es=0;es<Nelements;++es;outer0){
    
    shared dfloat s_q[p_Np*p_Nfields];
    exclusive iint e;
    for(iint n=0;n<p_StoVmaxNodes;++n;inner0){
      e  = elementIds[es];
      if(n<p_Np){
	const iint id = n + e*p_Np*p_Nfields;
	const iint rid = n + e*p_Np*p_Nfields*3;

        // hard-coded for 3th order
	const iint rhsId1 = rid + ((shift+0)%3)*p_Nfields*p_Np;
	const iint rhsId2 = rid + ((shift+1)%3)*p_Nfields*p_Np;
	const iint rhsId3 = rid + ((shift+2)%3)*p_Nfields*p_Np;

	for(iint fld=0; fld< p_Nfields; ++fld){
	  
	  //load q and update
	  if(fld<4)
	    s_q[n+fld*p_Np] = q[id+fld*p_Np] + ab1*rhsq[rhsId1+fld*p_Np]+ab2*rhsq[rhsId2+fld*p_Np]+ab3*rhsq[rhsId3+fld*p_Np];
	  else
	    s_q[n+fld*p_Np] = expdt*q[id+fld*p_Np] + saab1*rhsq[rhsId1+fld*p_Np] + saab2*rhsq[rhsId2+fld*p_Np] + saab3*rhsq[rhsId3+fld*p_Np];
	}
      }
    }
    // make sure all node data is loaded into shared
    barrier(localMemFence);
    for(iint n=0;n<p_StoVmaxNodes;++n;inner0){
      // Update q
      if(n<p_Np){

        const iint id = p_Nfields*e*p_Np + n;

        for (iint fld = 0; fld < p_Nfields; ++fld){
	  q[id+fld*p_Np]   = s_q[n+fld*p_Np];
	}

      }
      if(n<p_Nfaces*p_Nfp){

        const iint iid  = e*p_Nfp*p_Nfaces + n;
	const iint qidM = vmapM[iid] - e*p_Np;
	const iint qid  = e*p_Nfp*p_Nfaces*p_Nfields + n;

	for (iint fld = 0; fld < p_Nfields; ++fld){
	  fQM[qid+fld*p_Nfp*p_Nfaces] = s_q[qidM+fld*p_Np];
	}
      }

    }

  }
}
  
