#define RXID 0  
#define RYID 1  
#define SXID 2  
#define SYID 3

@kernel void eulerVolume2D_c0(const int Nelements,
			     @restrict const  dfloat *  vgeo,
			     @restrict const  dfloat *  cubInterpT,
			     @restrict const  dfloat *  cubDrWT,
			     @restrict const  dfloat *  cubDsWT,
			     @restrict const  dfloat4 *  q4,
			     @restrict dfloat4 *  rhsq4){
  
  for(int eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){  // for all elements

    @shared dfloat s_U[p_NblockV][p_Np];
    @shared dfloat s_V[p_NblockV][p_Np];
    @shared dfloat s_R[p_NblockV][p_Np];

    @shared dfloat s_cubRfluxr[p_NblockV][p_cubNp];
    @shared dfloat s_cubRfluxs[p_NblockV][p_cubNp];
    @shared dfloat s_cubUfluxr[p_NblockV][p_cubNp];
    @shared dfloat s_cubUfluxs[p_NblockV][p_cubNp];
    @shared dfloat s_cubVfluxr[p_NblockV][p_cubNp];
    @shared dfloat s_cubVfluxs[p_NblockV][p_cubNp];

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_maxVolumeNodes;++n;@inner(0)){     // for all nodes in this element
	int e = eo+es; // element in block
	if(e<Nelements){
	  if(n<p_Np){
	    const int id = e*p_Np + n;
	    const dfloat4 q4n = q4[id];
	    s_R[es][n] = q4n.x;      	    
	    s_U[es][n] = q4n.y;
	    s_V[es][n] = q4n.z;
	  }
	}
      }
    }
    
    // make sure all node data is loaded into @shared
    @barrier("local");

    // interpolate to cubature
    for(int es=0;es<p_NblockV;++es;@inner(1)){ // for all elements in block
      for(int n=0;n<p_maxVolumeNodes;++n;@inner(0)){    
	int e = eo+es; // element in block
	if(e<Nelements){	 
	  if(n<p_cubNp){

	    // prefetch geometric factors (constant on triangle)
	    const dfloat drdx = vgeo[e*p_Nvgeo + RXID];
	    const dfloat drdy = vgeo[e*p_Nvgeo + RYID];
	    const dfloat dsdx = vgeo[e*p_Nvgeo + SXID];
	    const dfloat dsdy = vgeo[e*p_Nvgeo + SYID];

	    dfloat cubR = 0.f, cubU = 0.f, cubV = 0.f;
	    
	    for(int m=0;m<p_Np;++m){
	      cubR += cubInterpT[m*p_cubNp+n]*s_R[es][m];		      
	      cubU += cubInterpT[m*p_cubNp+n]*s_U[es][m];
	      cubV += cubInterpT[m*p_cubNp+n]*s_V[es][m];
	    }
	    
	    // (dphidx, U) + (dphidy, V)
	    s_cubRfluxr[es][n] = drdx*cubU + drdy*cubV;
	    s_cubRfluxs[es][n] = dsdx*cubU + dsdy*cubV;
	    
	    s_cubUfluxr[es][n] = drdx*(cubU*cubU/cubR + p_RT*cubR) + drdy*(cubU*cubV/cubR);
	    s_cubUfluxs[es][n] = dsdx*(cubU*cubU/cubR + p_RT*cubR) + dsdy*(cubU*cubV/cubR);

	    s_cubVfluxr[es][n] = drdx*(cubU*cubV/cubR) + drdy*(cubV*cubV/cubR + p_RT*cubR);
	    s_cubVfluxs[es][n] = dsdx*(cubU*cubV/cubR) + dsdy*(cubV*cubV/cubR + p_RT*cubR);

	  }
	}
      }
    }
    
    @barrier("local");

    // weak derivatives
    for(int es=0;es<p_NblockV;++es;@inner(1)){ // for all elements in block
      for(int n=0;n<p_maxVolumeNodes;++n;@inner(0)){    
	int e = eo+es; // element in block
	if(e<Nelements){	 
	  if(n<p_Np){ // output at W&B nodes

	    // compute weak 'r' and 's' derivatives of volume fluxes at node n
	    dfloat rhsUr = 0, rhsVr = 0, rhsRr = 0;
	    dfloat rhsUs = 0, rhsVs = 0, rhsRs = 0;
	    
	    #pragma unroll p_cubNp
	      for(int i=0;i<p_cubNp;++i){
		// load data at node i of element e
#if 1
		const dfloat Drni = cubDrWT[i*p_Np+n];
		const dfloat Dsni = cubDsWT[i*p_Np+n];
#else
		const dfloat Drni = cubDrWT[i+n*p_cubNp];
		const dfloat Dsni = cubDsWT[i+n*p_cubNp];
#endif
		//		printf("Drni=%g Dsni=%g\n", Drni, Dsni);
		
		rhsRr += Drni*s_cubRfluxr[es][i];
		rhsUr += Drni*s_cubUfluxr[es][i];
		rhsVr += Drni*s_cubVfluxr[es][i];
			        
		rhsRs += Dsni*s_cubRfluxs[es][i];
		rhsUs += Dsni*s_cubUfluxs[es][i];
		rhsVs += Dsni*s_cubVfluxs[es][i];
	      }
	    
	    // store acoustics rhs contributions from weak differentiation
	    const int id = e*p_Np + n;
	    dfloat4 rhsq4n;
	    rhsq4n.x = rhsRr+rhsRs;
	    rhsq4n.y = rhsUr+rhsUs;
	    rhsq4n.z = rhsVr+rhsVs;
	    rhsq4[id] = rhsq4n;
	  }
	}
      }
    }
  }
}

@kernel void eulerVolume2D_c1(const int Nelements,
			     @restrict const  dfloat *  vgeo,
			     @restrict const  dfloat *  cubInterpT,
			     @restrict const  dfloat *  cubDrWT,
			     @restrict const  dfloat *  cubDsWT,
			     @restrict const  dfloat4 *  q4,
			     @restrict dfloat4 *  rhsq4){
  
  for(int eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){  // for all elements

    @shared dfloat s_U[p_NblockV][p_Np];
    @shared dfloat s_V[p_NblockV][p_Np];
    @shared dfloat s_R[p_NblockV][p_Np];

    @shared dfloat s_cubRfluxr[p_NblockV][p_cubNp];
    @shared dfloat s_cubRfluxs[p_NblockV][p_cubNp];
    @shared dfloat s_cubUfluxr[p_NblockV][p_cubNp];
    @shared dfloat s_cubUfluxs[p_NblockV][p_cubNp];
    @shared dfloat s_cubVfluxr[p_NblockV][p_cubNp];
    @shared dfloat s_cubVfluxs[p_NblockV][p_cubNp];

    @shared dfloat s_cubDrWT[p_cubNp][p_Np];
    @shared dfloat s_cubDsWT[p_cubNp][p_Np];
    @shared dfloat s_cubInterpT[p_Np][p_cubNp];
    
    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_maxVolumeNodes;++n;@inner(0)){     // for all nodes in this element
	
	int t = n + es*p_maxVolumeNodes;
	while(t<p_cubNp*p_Np){
	  s_cubDrWT[0][t] = cubDrWT[t];
	  s_cubDsWT[0][t] = cubDsWT[t];
	  s_cubInterpT[0][t] = cubInterpT[t];
	  t += p_NblockV*p_maxVolumeNodes;
	}
	
	
	int e = eo+es; // element in block
#if 0
	if(e<Nelements){
	  if(n<p_Np){
	    const int id = e*p_Np + n;
	    const dfloat4 q4n = q4[id];
	    s_R[es][n] = q4n.x;      	    
	    s_U[es][n] = q4n.y;
	    s_V[es][n] = q4n.z;
	  }
	}
#else
	// read contiguous blocks
	t = n + es*p_maxVolumeNodes;
	if(t<p_Np*p_NblockV && (eo*p_Np + t)<Nelements*p_Np){
	  const dfloat4 q4n = q4[eo*p_Np+t];
	  s_R[0][t] = q4n.x;      	    
	  s_U[0][t] = q4n.y;
	  s_V[0][t] = q4n.z;
	}
#endif
      }
    }
    
    // make sure all node data is loaded into @shared
    @barrier("local");

    // interpolate to cubature
    for(int es=0;es<p_NblockV;++es;@inner(1)){ // for all elements in block
      for(int n=0;n<p_maxVolumeNodes;++n;@inner(0)){    
	int e = eo+es; // element in block
	if(e<Nelements){	 
	  if(n<p_cubNp){

	    // prefetch geometric factors (constant on triangle)
	    const dfloat drdx = vgeo[e*p_Nvgeo + RXID];
	    const dfloat drdy = vgeo[e*p_Nvgeo + RYID];
	    const dfloat dsdx = vgeo[e*p_Nvgeo + SXID];
	    const dfloat dsdy = vgeo[e*p_Nvgeo + SYID];

	    dfloat cubR = 0.f, cubU = 0.f, cubV = 0.f;

	    #pragma unroll p_Np
	    for(int m=0;m<p_Np;++m){
#if 0
	      cubR += cubInterpT[m*p_cubNp+n]*s_R[es][m];		      
	      cubU += cubInterpT[m*p_cubNp+n]*s_U[es][m];
	      cubV += cubInterpT[m*p_cubNp+n]*s_V[es][m];
#else
	      const dfloat cImn = s_cubInterpT[m][n];
	      cubR += cImn*s_R[es][m];		      
	      cubU += cImn*s_U[es][m];
	      cubV += cImn*s_V[es][m];
#endif
	    }

	    const dfloat invcubR = 1.f/cubR;

	    // (dphidx, U) + (dphidy, V)
	    const dfloat fluxRx = cubU, fluxRy = cubV;
	    s_cubRfluxr[es][n] = drdx*fluxRx + drdy*fluxRy;
	    s_cubRfluxs[es][n] = dsdx*fluxRx + dsdy*fluxRy;

	    const dfloat fluxUx = cubU*cubU*invcubR + p_RT*cubR;
	    const dfloat fluxUy = cubV*cubU*invcubR;
	    s_cubUfluxr[es][n] = drdx*fluxUx + drdy*fluxUy;
	    s_cubUfluxs[es][n] = dsdx*fluxUx + dsdy*fluxUy;

	    const dfloat fluxVx = cubV*cubU*invcubR;
	    const dfloat fluxVy = cubV*cubV*invcubR + p_RT*cubR;
	    s_cubVfluxr[es][n] = drdx*fluxVx + drdy*fluxVy;
	    s_cubVfluxs[es][n] = dsdx*fluxVx + dsdy*fluxVy;

	  }
	}
      }
    }
    
    @barrier("local");

    // weak derivatives
    for(int es=0;es<p_NblockV;++es;@inner(1)){ // for all elements in block
      for(int n=0;n<p_maxVolumeNodes;++n;@inner(0)){    
	int e = eo+es; // element in block
	if(e<Nelements){	 
	  if(n<p_Np){ // output at W&B nodes

	    // compute weak 'r' and 's' derivatives of volume fluxes at node n
	    dfloat rhsU = 0, rhsV = 0, rhsR = 0;

	    #pragma unroll p_cubNp
	      for(int i=0;i<p_cubNp;++i){
		// load data at node i of element e
#if 0
		const dfloat Drni = cubDrWT[i*p_Np+n];		
		const dfloat Dsni = cubDsWT[i*p_Np+n];
#else
		const dfloat Drni = s_cubDrWT[i][n];		
		const dfloat Dsni = s_cubDsWT[i][n];		
#endif
		rhsR += Drni*s_cubRfluxr[es][i];
		rhsU += Drni*s_cubUfluxr[es][i];
		rhsV += Drni*s_cubVfluxr[es][i];
	      }

	    #pragma unroll p_cubNp
	      for(int i=0;i<p_cubNp;++i){
		const dfloat Drni = s_cubDrWT[i][n];		
		const dfloat Dsni = s_cubDsWT[i][n];		
		rhsR += Dsni*s_cubRfluxs[es][i];
		rhsU += Dsni*s_cubUfluxs[es][i];
		rhsV += Dsni*s_cubVfluxs[es][i];
	      }
	    s_R[es][n] = rhsR;
	    s_U[es][n] = rhsU;
	    s_V[es][n] = rhsV;
	  }
	}
      }
    }

    @barrier("local");
    
    for(int es=0;es<p_NblockV;++es;@inner(1)){ // for all elements in block
      for(int n=0;n<p_maxVolumeNodes;++n;@inner(0)){    
	
	int t = n + es*p_maxVolumeNodes;
	if(t<p_Np*p_NblockV && (eo*p_Np + t)<Nelements*p_Np){
	  dfloat4 rhsq4n;
	  rhsq4n.x = s_R[0][t];
	  rhsq4n.y = s_U[0][t];
	  rhsq4n.z = s_V[0][t];
	  rhsq4[eo*p_Np+t] = rhsq4n;
	}
      }
    }
  }
}



@kernel void eulerVolume2D_c2(const int Nelements,
			  @restrict const  dfloat *  vgeo,
			  @restrict const  dfloat *  cubInterpT,
			  @restrict const  dfloat *  cubDrWT,
			  @restrict const  dfloat *  cubDsWT,
			  @restrict const  dfloat4 *  q4,
			  @restrict dfloat4 *  rhsq4){
  
  for(int eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){  // for all elements

    @shared dfloat s_U[p_NblockV][p_Np];
    @shared dfloat s_V[p_NblockV][p_Np];
    @shared dfloat s_R[p_NblockV][p_Np];

    @shared dfloat s_cubRfluxr[p_NblockV][p_cubNp];
    @shared dfloat s_cubRfluxs[p_NblockV][p_cubNp];
    @shared dfloat s_cubUfluxr[p_NblockV][p_cubNp];
    @shared dfloat s_cubUfluxs[p_NblockV][p_cubNp];
    @shared dfloat s_cubVfluxr[p_NblockV][p_cubNp];
    @shared dfloat s_cubVfluxs[p_NblockV][p_cubNp];

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_maxVolumeNodes;++n;@inner(0)){     // for all nodes in this element
	
	// read contiguous blocks
	int t = n + es*p_maxVolumeNodes;

	if(t<p_Np*p_NblockV && (eo*p_Np + t)<Nelements*p_Np){
	  const dfloat4 q4n = q4[eo*p_Np+t];
	  s_R[0][t] = q4n.x;      	    
	  s_U[0][t] = q4n.y;
	  s_V[0][t] = q4n.z;
	}
      }
    }
    
    // make sure all node data is loaded into @shared
    @barrier("local");

    // interpolate to cubature
    for(int es=0;es<p_NblockV;++es;@inner(1)){ // for all elements in block
      for(int n=0;n<p_maxVolumeNodes;++n;@inner(0)){    
	int e = eo+es; // element in block
	if(e<Nelements){	 
	  if(n<p_cubNp){
	    
	    // prefetch geometric factors (constant on triangle)
	    const dfloat drdx = vgeo[e*p_Nvgeo + RXID];
	    const dfloat drdy = vgeo[e*p_Nvgeo + RYID];
	    const dfloat dsdx = vgeo[e*p_Nvgeo + SXID];
	    const dfloat dsdy = vgeo[e*p_Nvgeo + SYID];

	    dfloat cubR = 0.f, cubU = 0.f, cubV = 0.f;

	    #pragma unroll p_Np
	    for(int m=0;m<p_Np;++m){
	      const dfloat cImn = cubInterpT[m*p_cubNp+n];
	      cubR += cImn*s_R[es][m];		      
	      cubU += cImn*s_U[es][m];
	      cubV += cImn*s_V[es][m];
	    }
	    
	    const dfloat invcubR = 1.f/cubR;
	    
	    // (dphidx, U) + (dphidy, V)
	    const dfloat fluxRx = cubU, fluxRy = cubV;
	    s_cubRfluxr[es][n] = drdx*fluxRx + drdy*fluxRy;
	    s_cubRfluxs[es][n] = dsdx*fluxRx + dsdy*fluxRy;

	    const dfloat fluxUx = cubU*cubU*invcubR + p_RT*cubR;
	    const dfloat fluxUy = cubV*cubU*invcubR;
	    s_cubUfluxr[es][n] = drdx*fluxUx + drdy*fluxUy;
	    s_cubUfluxs[es][n] = dsdx*fluxUx + dsdy*fluxUy;
	    
	    const dfloat fluxVx = cubV*cubU*invcubR;
	    const dfloat fluxVy = cubV*cubV*invcubR + p_RT*cubR;
	    s_cubVfluxr[es][n] = drdx*fluxVx + drdy*fluxVy;
	    s_cubVfluxs[es][n] = dsdx*fluxVx + dsdy*fluxVy;

	  }
	}
      }
    }
    
    @barrier("local");

    // weak derivatives
    for(int es=0;es<p_NblockV;++es;@inner(1)){ // for all elements in block
      for(int n=0;n<p_maxVolumeNodes;++n;@inner(0)){    
	int e = eo+es; // element in block
	if(e<Nelements){	 
	  if(n<p_Np){ // output at W&B nodes

	    // compute weak 'r' and 's' derivatives of volume fluxes at node n
	    dfloat rhsU = 0, rhsV = 0, rhsR = 0;

	    #pragma unroll p_cubNp
	      for(int i=0;i<p_cubNp;++i){
		// load data at node i of element e
		const dfloat Drni = cubDrWT[i*p_Np+n];		

		rhsR += Drni*s_cubRfluxr[es][i];
		rhsU += Drni*s_cubUfluxr[es][i];
		rhsV += Drni*s_cubVfluxr[es][i];
	      }

	    #pragma unroll p_cubNp
	      for(int i=0;i<p_cubNp;++i){
		const dfloat Dsni = cubDsWT[i*p_Np+n];

		rhsR += Dsni*s_cubRfluxs[es][i];
		rhsU += Dsni*s_cubUfluxs[es][i];
		rhsV += Dsni*s_cubVfluxs[es][i];
	      }
	    s_R[es][n] = rhsR;
	    s_U[es][n] = rhsU;
	    s_V[es][n] = rhsV;
	  }
	}
      }
    }

    @barrier("local");
    
    for(int es=0;es<p_NblockV;++es;@inner(1)){ // for all elements in block
      for(int n=0;n<p_maxVolumeNodes;++n;@inner(0)){    
	
	int t = n + es*p_maxVolumeNodes;
	if(t<p_Np*p_NblockV && (eo*p_Np + t)<Nelements*p_Np){
	  dfloat4 rhsq4n;
	  rhsq4n.x = s_R[0][t];
	  rhsq4n.y = s_U[0][t];
	  rhsq4n.z = s_V[0][t];
	  rhsq4[eo*p_Np+t] = rhsq4n;
	}
      }
    }
  }
}


// c3: only use p_NblockV x p_Np inner iterations
@kernel void eulerVolume2D_c3(const int Nelements,
			  @restrict const  dfloat *  vgeo,
			  @restrict const  dfloat *  cubInterpT,
			  @restrict const  dfloat *  cubDrWT,
			  @restrict const  dfloat *  cubDsWT,
			  @restrict const  dfloat4 *  q4,
			  @restrict dfloat4 *  rhsq4){
  
  for(int eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){  // for all elements

    @shared dfloat s_U[p_NblockV][p_Np];
    @shared dfloat s_V[p_NblockV][p_Np];
    @shared dfloat s_R[p_NblockV][p_Np];

    @shared dfloat s_cubRfluxr[p_NblockV][p_cubNp];
    @shared dfloat s_cubRfluxs[p_NblockV][p_cubNp];
    @shared dfloat s_cubUfluxr[p_NblockV][p_cubNp];
    @shared dfloat s_cubUfluxs[p_NblockV][p_cubNp];
    @shared dfloat s_cubVfluxr[p_NblockV][p_cubNp];
    @shared dfloat s_cubVfluxs[p_NblockV][p_cubNp];

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element
	int e = eo+es; // element in block
	// read contiguous blocks
	if(e<Nelements){
	  const dfloat4 q4n = q4[e*p_Np+n];
	  s_R[es][n] = q4n.x;      	    
	  s_U[es][n] = q4n.y;
	  s_V[es][n] = q4n.z;
	}
      }
    }
    
    // make sure all node data is loaded into @shared
    @barrier("local");

    // interpolate to cubature (assume Np<=cubNp
    for(int es=0;es<p_NblockV;++es;@inner(1)){ // for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){    
	int e = eo+es; // element in block
	if(e<Nelements){
	  
	  // prefetch geometric factors (constant on triangle)
	  const dfloat drdx = vgeo[e*p_Nvgeo + RXID];
	  const dfloat drdy = vgeo[e*p_Nvgeo + RYID];
	  const dfloat dsdx = vgeo[e*p_Nvgeo + SXID];
	  const dfloat dsdy = vgeo[e*p_Nvgeo + SYID];	 

	  // interpolate to cubature nodes in groups of p_Np
	  for(int c=n;c<p_cubNp;c+=p_Np){

	    dfloat cubR = 0.f, cubU = 0.f, cubV = 0.f;
	    
	    #pragma unroll p_Np
	      for(int m=0;m<p_Np;++m){
		const dfloat cImn = cubInterpT[m*p_cubNp+c];
		cubR += cImn*s_R[es][m];		      
		cubU += cImn*s_U[es][m];
		cubV += cImn*s_V[es][m];
	      }
	    
	    const dfloat invcubR = 1.f/cubR;
	    
	    // (dphidx, U) + (dphidy, V)
	    const dfloat fluxRx = cubU, fluxRy = cubV;
	    s_cubRfluxr[es][c] = drdx*fluxRx + drdy*fluxRy;
	    s_cubRfluxs[es][c] = dsdx*fluxRx + dsdy*fluxRy;
	    
	    const dfloat fluxUx = cubU*cubU*invcubR + p_RT*cubR;
	    const dfloat fluxUy = cubV*cubU*invcubR;
	    s_cubUfluxr[es][c] = drdx*fluxUx + drdy*fluxUy;
	    s_cubUfluxs[es][c] = dsdx*fluxUx + dsdy*fluxUy;
	    
	    const dfloat fluxVx = cubV*cubU*invcubR;
	    const dfloat fluxVy = cubV*cubV*invcubR + p_RT*cubR;
	    s_cubVfluxr[es][c] = drdx*fluxVx + drdy*fluxVy;
	    s_cubVfluxs[es][c] = dsdx*fluxVx + dsdy*fluxVy;
	    
	  }
	}
      }
    }
    
    @barrier("local");
    
    // weak derivatives
    for(int es=0;es<p_NblockV;++es;@inner(1)){ // for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){    
	int e = eo+es; // element in block
	if(e<Nelements){	 
	  
	  // compute weak 'r' and 's' derivatives of volume fluxes at node n
	  dfloat rhsU = 0, rhsV = 0, rhsR = 0;
	  
	  #pragma unroll p_cubNp
	    for(int i=0;i<p_cubNp;++i){
	      // load data at node i of element e
	      const dfloat Drni = cubDrWT[i*p_Np+n];		
	      
	      rhsR += Drni*s_cubRfluxr[es][i];
	      rhsU += Drni*s_cubUfluxr[es][i];
	      rhsV += Drni*s_cubVfluxr[es][i];

	      const dfloat Dsni = cubDsWT[i*p_Np+n];
	      
	      rhsR += Dsni*s_cubRfluxs[es][i];
	      rhsU += Dsni*s_cubUfluxs[es][i];
	      rhsV += Dsni*s_cubVfluxs[es][i];
	    }

	  dfloat4 rhsq4n;
	  rhsq4n.x = rhsR;
	  rhsq4n.y = rhsU;
	  rhsq4n.z = rhsV;
	  rhsq4[e*p_Np+n] = rhsq4n;
	}
      }
    }
  }
}

// c4: only use p_NblockV x p_Np inner iterations
@kernel void eulerVolume2D_c4(const int Nelements,
			  @restrict const  dfloat *  vgeo,
			  @restrict const  dfloat *  cubInterpT,
			  @restrict const  dfloat *  cubDrWT,
			  @restrict const  dfloat *  cubDsWT,
			  @restrict const  dfloat4 *  q4,
			  @restrict dfloat4 *  rhsq4){
  
  for(int eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){  // for all elements

    @shared dfloat s_U[p_NblockV][p_Np];
    @shared dfloat s_V[p_NblockV][p_Np];
    @shared dfloat s_R[p_NblockV][p_Np];

    @shared dfloat s_cubRfluxr[p_NblockV][p_Np];
    @shared dfloat s_cubRfluxs[p_NblockV][p_Np];
    @shared dfloat s_cubUfluxr[p_NblockV][p_Np];
    @shared dfloat s_cubUfluxs[p_NblockV][p_Np];
    @shared dfloat s_cubVfluxr[p_NblockV][p_Np];
    @shared dfloat s_cubVfluxs[p_NblockV][p_Np];

    @exclusive dfloat rhsR, rhsU, rhsV;
    
    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element
	int e = eo+es; // element in block
	// read contiguous blocks
	if(e<Nelements){
	  const dfloat4 q4n = q4[e*p_Np+n];
	  s_R[es][n] = q4n.x;      	    
	  s_U[es][n] = q4n.y;
	  s_V[es][n] = q4n.z;
	}

	rhsR = 0.f;
	rhsU = 0.f;
	rhsV = 0.f;
      }
    }
    
    // interpolate to cubature nodes in groups of p_Np
    for(int co=0;co<p_cubNp;co+=p_Np){
      
      // make sure all node data is loaded into @shared
      @barrier("local");
      
      // interpolate to cubature (assume Np<=cubNp
      for(int es=0;es<p_NblockV;++es;@inner(1)){ // for all elements in block
	for(int n=0;n<p_Np;++n;@inner(0)){
	  int e = eo+es; // element in block
	  if(e<Nelements){

	    if(co+n<p_cubNp){

	      const dfloat drdx = vgeo[e*p_Nvgeo + RXID];
	      const dfloat drdy = vgeo[e*p_Nvgeo + RYID];
	      const dfloat dsdx = vgeo[e*p_Nvgeo + SXID];
	      const dfloat dsdy = vgeo[e*p_Nvgeo + SYID];
	      
	      dfloat cubR = 0.f, cubU = 0.f, cubV = 0.f;
	      
	      #pragma unroll p_Np
		for(int m=0;m<p_Np;++m){
		  const dfloat cImn = cubInterpT[m*p_cubNp+n+co];
		  cubR += cImn*s_R[es][m];		      
		  cubU += cImn*s_U[es][m];
		  cubV += cImn*s_V[es][m];
		}
	      
	      const dfloat invcubR = 1.f/cubR;
	      
	      // (dphidx, U) + (dphidy, V)
	      const dfloat fluxRx = cubU;
	      const dfloat fluxRy = cubV;
	      s_cubRfluxr[es][n] = drdx*fluxRx + drdy*fluxRy;
	      s_cubRfluxs[es][n] = dsdx*fluxRx + dsdy*fluxRy;
	      
	      const dfloat fluxUx = cubU*cubU*invcubR + p_RT*cubR;
	      const dfloat fluxUy = cubV*cubU*invcubR;
	      s_cubUfluxr[es][n] = drdx*fluxUx + drdy*fluxUy;
	      s_cubUfluxs[es][n] = dsdx*fluxUx + dsdy*fluxUy;
	      
	      const dfloat fluxVx = cubV*cubU*invcubR;
	      const dfloat fluxVy = cubV*cubV*invcubR + p_RT*cubR;
	      s_cubVfluxr[es][n] = drdx*fluxVx + drdy*fluxVy;
	      s_cubVfluxs[es][n] = dsdx*fluxVx + dsdy*fluxVy;
	      
	    }
	  }
	}
      }
      
      @barrier("local");
      
      // weak derivatives
      for(int es=0;es<p_NblockV;++es;@inner(1)){ 
	for(int n=0;n<p_Np;++n;@inner(0)){    
	  int e = eo+es; 
	  if(e<Nelements){	 
	    for(int i=0;i<p_Np;++i){
	      if(i+co<p_cubNp){
		// load data at node i of element e
		const dfloat Drni = cubDrWT[(i+co)*p_Np+n];		
		const dfloat Dsni = cubDsWT[(i+co)*p_Np+n];

		rhsR += Drni*s_cubRfluxr[es][i];
		rhsU += Drni*s_cubUfluxr[es][i];
		rhsV += Drni*s_cubVfluxr[es][i];
		
		rhsR += Dsni*s_cubRfluxs[es][i];
		rhsU += Dsni*s_cubUfluxs[es][i];
		rhsV += Dsni*s_cubVfluxs[es][i];
	      }
	    }
	  }
	}
      }
    } // end of Np blocked Ncub loop
    
    for(int es=0;es<p_NblockV;++es;@inner(1)){ // for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){    
	int e = eo+es; // element in block
	if(e<Nelements){	 
	  dfloat4 rhsq4n;

	  rhsq4n.x = rhsR;
	  rhsq4n.y = rhsU;
	  rhsq4n.z = rhsV;
	  rhsq4[e*p_Np+n] = rhsq4n;
	}
      }
    }
  }
}



// only use p_NblockV x p_Np inner iterations
@kernel void eulerVolume2D(const int Nelements,
			  @restrict const  dfloat *  vgeo,
			  @restrict const  dfloat *  cubInterpT,
			  @restrict const  dfloat *  cubDrWT,
			  @restrict const  dfloat *  cubDsWT,
			  @restrict const  dfloat4 *  q4,
			  @restrict dfloat4 *  rhsq4){
  
  for(int eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){  // for all elements

    @shared dfloat s_U[p_NblockV][p_Np];
    @shared dfloat s_V[p_NblockV][p_Np];
    @shared dfloat s_R[p_NblockV][p_Np];

    @shared dfloat s_cubRflux[p_NblockV][p_Np];
    @shared dfloat s_cubUflux[p_NblockV][p_Np];
    @shared dfloat s_cubVflux[p_NblockV][p_Np];

    @exclusive dfloat rhsR, rhsU, rhsV;

    @exclusive dfloat cubRfluxs;
    @exclusive dfloat cubUfluxs;
    @exclusive dfloat cubVfluxs;
    
    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element
	int e = eo+es; // element in block
	// read contiguous blocks
	if(e<Nelements){
	  const dfloat4 q4n = q4[e*p_Np+n];
	  s_R[es][n] = q4n.x;      	    
	  s_U[es][n] = q4n.y;
	  s_V[es][n] = q4n.z;
	  rhsR = 0.f;
	  rhsU = 0.f;
	  rhsV = 0.f;
	}
      }
    }
    
    // interpolate to cubature nodes in groups of p_Np
    for(int co=0;co<p_cubNp;co+=p_Np){
      
      // make sure all node data is loaded into @shared
      @barrier("local");
      
      // interpolate to cubature (assume Np<=cubNp
      for(int es=0;es<p_NblockV;++es;@inner(1)){ // for all elements in block
	for(int n=0;n<p_Np;++n;@inner(0)){
	  int e = eo+es; // element in block
	  if(e<Nelements){

	    if(co+n<p_cubNp){

	      const dfloat drdx = vgeo[e*p_Nvgeo + RXID];
	      const dfloat drdy = vgeo[e*p_Nvgeo + RYID];
	      const dfloat dsdx = vgeo[e*p_Nvgeo + SXID];
	      const dfloat dsdy = vgeo[e*p_Nvgeo + SYID];
	      
	      dfloat cubR = 0.f, cubU = 0.f, cubV = 0.f;
	      
	      #pragma unroll p_Np
		for(int m=0;m<p_Np;++m){
		  const dfloat cImn = cubInterpT[m*p_cubNp+n+co];
		  cubR += cImn*s_R[es][m];		      
		  cubU += cImn*s_U[es][m];
		  cubV += cImn*s_V[es][m];
		}
	      
	      const dfloat invcubR = 1.f/cubR;

	      // (dphidx, U) + (dphidy, V)
	      const dfloat fluxRx = cubU;
	      const dfloat fluxRy = cubV;
	      const dfloat cubRfluxr = drdx*fluxRx + drdy*fluxRy;
	      cubRfluxs = dsdx*fluxRx + dsdy*fluxRy;
	      
	      const dfloat fluxUx = cubU*cubU*invcubR + p_RT*cubR;
	      const dfloat fluxUy = cubV*cubU*invcubR;
	      const dfloat cubUfluxr = drdx*fluxUx + drdy*fluxUy;
	      cubUfluxs = dsdx*fluxUx + dsdy*fluxUy;
	      
	      const dfloat fluxVx = cubV*cubU*invcubR;
	      const dfloat fluxVy = cubV*cubV*invcubR + p_RT*cubR;
	      const dfloat cubVfluxr = drdx*fluxVx + drdy*fluxVy;
	      cubVfluxs = dsdx*fluxVx + dsdy*fluxVy;

	      s_cubRflux[es][n] = cubRfluxr;
	      s_cubUflux[es][n] = cubUfluxr;
	      s_cubVflux[es][n] = cubVfluxr;
	    }
	  }
	}
      }
      
      @barrier("local");
      
      // weak derivatives
      for(int es=0;es<p_NblockV;++es;@inner(1)){ 
	for(int n=0;n<p_Np;++n;@inner(0)){    
	  int e = eo+es; 
	  if(e<Nelements){	 
	    for(int i=0;i<p_Np;++i){
	      if(i+co<p_cubNp){
		// load data at node i of element e
		const dfloat Drni = cubDrWT[(i+co)*p_Np+n];		
		
		rhsR += Drni*s_cubRflux[es][i];
		rhsU += Drni*s_cubUflux[es][i];
		rhsV += Drni*s_cubVflux[es][i];
	      }
	    }
	  }
	}
      }

      @barrier("local");

      for(int es=0;es<p_NblockV;++es;@inner(1)){ 
	for(int n=0;n<p_Np;++n;@inner(0)){    
	  int e = eo+es; 
	  if(e<Nelements){	 
	    s_cubRflux[es][n] = cubRfluxs;
	    s_cubUflux[es][n] = cubUfluxs;
	    s_cubVflux[es][n] = cubVfluxs;
	  }
	}
      }

      @barrier("local");
      
      // weak 's' derivatives
      for(int es=0;es<p_NblockV;++es;@inner(1)){ 
	for(int n=0;n<p_Np;++n;@inner(0)){    
	  int e = eo+es; 
	  if(e<Nelements){	 
	    for(int i=0;i<p_Np;++i){
	      if(i+co<p_cubNp){
		// load data at node i of element e
		const dfloat Dsni = cubDsWT[(i+co)*p_Np+n];      
		rhsR += Dsni*s_cubRflux[es][i];
		rhsU += Dsni*s_cubUflux[es][i];
		rhsV += Dsni*s_cubVflux[es][i];
	      }
	    }
	  }
	}
      }
    } // end of Np blocked Ncub loop
    
    for(int es=0;es<p_NblockV;++es;@inner(1)){ // for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){    
	int e = eo+es; // element in block
	if(e<Nelements){	 
	  dfloat4 rhsq4n;
	  rhsq4n.x = rhsR;	
	  rhsq4n.y = rhsU;
	  rhsq4n.z = rhsV;
	  rhsq4[e*p_Np+n] = rhsq4n;
	}
      }
    }
  }
}

