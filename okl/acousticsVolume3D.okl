#define RXID 0  
#define RYID 1  
#define RZID 2  
#define SXID 3
#define SYID 4
#define SZID 5
#define TXID 6
#define TYID 7
#define TZID 8

// function to compute collocation differentiation
// contributions to nodal DG rhs for acoustics
@kernel void acousticsVolume3D_o0(const int Nelements,
				     @restrict const  dfloat *  vgeo,
				     @restrict const  dfloat *  DrT,
				     @restrict const  dfloat *  DsT,
				     @restrict const  dfloat *  DtT,
				     @restrict const  dfloat *  q,
				     @restrict dfloat *  rhsq){
  
  for(int e=0;e<Nelements;++e;@outer(0)){  // for all elements
    for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element

      // prefetch geometric factors (constant on triangle)
      const dfloat drdx = vgeo[e*p_Nvgeo + RXID];
      const dfloat drdy = vgeo[e*p_Nvgeo + RYID];
      const dfloat drdz = vgeo[e*p_Nvgeo + RZID];
      const dfloat dsdx = vgeo[e*p_Nvgeo + SXID];
      const dfloat dsdy = vgeo[e*p_Nvgeo + SYID];
      const dfloat dsdz = vgeo[e*p_Nvgeo + SZID];
      const dfloat dtdx = vgeo[e*p_Nvgeo + TXID];
      const dfloat dtdy = vgeo[e*p_Nvgeo + TYID];
      const dfloat dtdz = vgeo[e*p_Nvgeo + TZID];
      
      // compute 'r', 's', and 't' derivatives of (u,v,w,p) at node n
      dfloat dudr = 0, duds = 0, dudt = 0;
      dfloat dvdr = 0, dvds = 0, dvdt = 0;
      dfloat dwdr = 0, dwds = 0, dwdt = 0;
      dfloat dpdr = 0, dpds = 0, dpdt = 0;
      
      for(int i=0;i<p_Np;++i){
	// load data at node i of element e
	const int id = p_Nfields*(e*p_Np + i);
	const dfloat u = q[id+0], v = q[id+1], w = q[id+2], p = q[id+3];

 	const dfloat Drni = DrT[n+i*p_Np];
	const dfloat Dsni = DsT[n+i*p_Np];
	const dfloat Dtni = DtT[n+i*p_Np];

	// compute 'r', 's', and 't' derivatives of (u,v,w,p) at node n
	dudr += Drni*u; duds += Dsni*u; dudt += Dtni*u;
	dvdr += Drni*v; dvds += Dsni*v; dvdt += Dtni*v;
	dwdr += Drni*w; dwds += Dsni*w; dwdt += Dtni*w;
	dpdr += Drni*p;	dpds += Dsni*p; dpdt += Dtni*p;
      }

      // chain rule
      const dfloat dudx = drdx*dudr + dsdx*duds + dtdx*dudt;
      const dfloat dvdy = drdy*dvdr + dsdy*dvds + dtdy*dvdt;
      const dfloat dwdz = drdz*dwdr + dsdz*dwds + dtdz*dwdt;
      const dfloat dpdx = drdx*dpdr + dsdx*dpds + dtdx*dpdt;
      const dfloat dpdy = drdy*dpdr + dsdy*dpds + dtdy*dpdt;
      const dfloat dpdz = drdz*dpdr + dsdz*dpds + dtdz*dpdt;
      
      // store acoustics rhs contributions from collocation differentiation
      const int id = p_Nfields*(e*p_Np + n);
      rhsq[id+0] = -dpdx;
      rhsq[id+1] = -dpdy;
      rhsq[id+2] = -dpdz;
      rhsq[id+3] = -dudx-dvdy-dwdz;
    }
  }
}



// o1: float4s
@kernel void acousticsVolume3D_o1(const int Nelements,
				     @restrict const  dfloat *  vgeo,
				     @restrict const  dfloat *  DrT,
				     @restrict const  dfloat *  DsT,
				     @restrict const  dfloat *  DtT,
				     @restrict const  dfloat4 *  q4,
				     @restrict dfloat4 *  rhsq4){
  
  for(int e=0;e<Nelements;++e;@outer(0)){  // for all elements
    for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element

      // prefetch geometric factors (constant on triangle)
      const dfloat drdx = vgeo[e*p_Nvgeo + RXID];
      const dfloat drdy = vgeo[e*p_Nvgeo + RYID];
      const dfloat drdz = vgeo[e*p_Nvgeo + RZID];
      const dfloat dsdx = vgeo[e*p_Nvgeo + SXID];
      const dfloat dsdy = vgeo[e*p_Nvgeo + SYID];
      const dfloat dsdz = vgeo[e*p_Nvgeo + SZID];
      const dfloat dtdx = vgeo[e*p_Nvgeo + TXID];
      const dfloat dtdy = vgeo[e*p_Nvgeo + TYID];
      const dfloat dtdz = vgeo[e*p_Nvgeo + TZID];
      
      // compute 'r', 's', and 't' derivatives of (u,v,w,p) at node n
      dfloat dudr = 0, duds = 0, dudt = 0;
      dfloat dvdr = 0, dvds = 0, dvdt = 0;
      dfloat dwdr = 0, dwds = 0, dwdt = 0;
      dfloat dpdr = 0, dpds = 0, dpdt = 0;      
      
      for(int i=0;i<p_Np;++i){
	// load data at node i of element e
	const int id = e*p_Np + i;
	const dfloat4 q4i = q4[id];
	const dfloat u = q4i.x, v = q4i.y, w = q4i.z, p = q4i.w;

 	const dfloat Drni = DrT[n+i*p_Np];
	const dfloat Dsni = DsT[n+i*p_Np];
	const dfloat Dtni = DtT[n+i*p_Np];

	// differentiate (u,v,p) with respect to 'r', 's', and 't'
	dudr += Drni*u; duds += Dsni*u; dudt += Dtni*u;
	dvdr += Drni*v; dvds += Dsni*v; dvdt += Dtni*v;
	dwdr += Drni*w; dwds += Dsni*w; dwdt += Dtni*w;
	dpdr += Drni*p;	dpds += Dsni*p; dpdt += Dtni*p;
      }

      // chain rule
      const dfloat dudx = drdx*dudr + dsdx*duds + dtdx*dudt;
      const dfloat dvdy = drdy*dvdr + dsdy*dvds + dtdy*dvdt;
      const dfloat dwdz = drdz*dwdr + dsdz*dwds + dtdz*dwdt;
      const dfloat dpdx = drdx*dpdr + dsdx*dpds + dtdx*dpdt;
      const dfloat dpdy = drdy*dpdr + dsdy*dpds + dtdy*dpdt;
      const dfloat dpdz = drdz*dpdr + dsdz*dpds + dtdz*dpdt;
      
      // store acoustics rhs contributions from collocation differentiation
      const int id = e*p_Np + n;
      dfloat4 rhsq4n;
      rhsq4n.x = -dpdx;
      rhsq4n.y = -dpdy;
      rhsq4n.z = -dpdz;
      rhsq4n.w = -dudx-dvdy-dwdz;
      rhsq4[id] = rhsq4n;
    }
  }
}



// o2: load q into @shared
@kernel void acousticsVolume3D_o2(const int Nelements,
				     @restrict const  dfloat *  vgeo,
				     @restrict const  dfloat *  DrT,
				     @restrict const  dfloat *  DsT,
				     @restrict const  dfloat *  DtT,
				     @restrict const  dfloat4 *  q4,
				     @restrict dfloat4 *  rhsq4){
  
  for(int e=0;e<Nelements;++e;@outer(0)){  // for all elements

    @shared dfloat s_u[p_Np], s_v[p_Np], s_w[p_Np], s_p[p_Np];
    
    for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element
      const int id = e*p_Np + n;
      const dfloat4 q4n = q4[id];
      s_u[n] = q4n.x;
      s_v[n] = q4n.y;
      s_w[n] = q4n.z;
      s_p[n] = q4n.w;
    }

    // make sure all node data is loaded into @shared
    @barrier("local");
    
    for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element

      // prefetch geometric factors (constant on triangle)
      const dfloat drdx = vgeo[e*p_Nvgeo + RXID];
      const dfloat drdy = vgeo[e*p_Nvgeo + RYID];
      const dfloat drdz = vgeo[e*p_Nvgeo + RZID];
      const dfloat dsdx = vgeo[e*p_Nvgeo + SXID];
      const dfloat dsdy = vgeo[e*p_Nvgeo + SYID];
      const dfloat dsdz = vgeo[e*p_Nvgeo + SZID];
      const dfloat dtdx = vgeo[e*p_Nvgeo + TXID];
      const dfloat dtdy = vgeo[e*p_Nvgeo + TYID];
      const dfloat dtdz = vgeo[e*p_Nvgeo + TZID];

      // compute 'r', 's', and 't' derivatives of (u,v,w,p) at node n
      dfloat dudr = 0, duds = 0, dudt = 0;
      dfloat dvdr = 0, dvds = 0, dvdt = 0;
      dfloat dwdr = 0, dwds = 0, dwdt = 0;
      dfloat dpdr = 0, dpds = 0, dpdt = 0;
      
      for(int i=0;i<p_Np;++i){
	// load data at node i of element e
 	const dfloat Drni = DrT[n+i*p_Np];
	const dfloat Dsni = DsT[n+i*p_Np];
	const dfloat Dtni = DtT[n+i*p_Np];

	// differentiate (u,v,p) with respect to 'r' and 's'
	dudr += Drni*s_u[i]; duds += Dsni*s_u[i]; dudt += Dtni*s_u[i];
	dvdr += Drni*s_v[i]; dvds += Dsni*s_v[i]; dvdt += Dtni*s_v[i];
	dpdr += Drni*s_p[i]; dpds += Dsni*s_p[i]; dpdt += Dtni*s_p[i];
      }

      // chain rule
      const dfloat dudx = drdx*dudr + dsdx*duds + dtdx*dudt;
      const dfloat dvdy = drdy*dvdr + dsdy*dvds + dtdy*dvdt;
      const dfloat dwdz = drdz*dwdr + dsdz*dwds + dtdz*dwdt;
      const dfloat dpdx = drdx*dpdr + dsdx*dpds + dtdx*dpdt;
      const dfloat dpdy = drdy*dpdr + dsdy*dpds + dtdy*dpdt;
      const dfloat dpdz = drdz*dpdr + dsdz*dpds + dtdz*dpdt;
      
      // store acoustics rhs contributions from collocation differentiation
      const int id = e*p_Np + n;
      dfloat4 rhsq4n;
      rhsq4n.x = -dpdx;
      rhsq4n.y = -dpdy;
      rhsq4n.z = -dpdz;
      rhsq4n.w = -dudx-dvdy-dwdz;
      rhsq4[id] = rhsq4n;
    }
  }
}

// o3: multiple elements for each outer iteration
@kernel void acousticsVolume3D_o3(const int Nelements,
				     @restrict const  dfloat *  vgeo,
				     @restrict const  dfloat *  DrT,
				     @restrict const  dfloat *  DsT,
				     @restrict const  dfloat *  DtT,
				     @restrict const  dfloat4 *  q4,
				     @restrict dfloat4 *  rhsq4){
  
  for(int eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){  // for all elements

    @shared dfloat s_u[p_NblockV][p_Np];
    @shared dfloat s_v[p_NblockV][p_Np];
    @shared dfloat s_w[p_NblockV][p_Np];
    @shared dfloat s_p[p_NblockV][p_Np];

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element

	int e = eo+es; // element in block
	if(e<Nelements){
	  const int id = e*p_Np + n;
	  const dfloat4 q4n = q4[id];
	  s_u[es][n] = q4n.x;
	  s_v[es][n] = q4n.y;
	  s_w[es][n] = q4n.z;
	  s_p[es][n] = q4n.w;
	}
      }
    }

    // make sure all node data is loaded into @shared
    @barrier("local");

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element
	
	int e = eo+es; // element in block
	if(e<Nelements){
	  
	  // prefetch geometric factors (constant on triangle)
	  const dfloat drdx = vgeo[e*p_Nvgeo + RXID];
	  const dfloat drdy = vgeo[e*p_Nvgeo + RYID];
	  const dfloat drdz = vgeo[e*p_Nvgeo + RZID];
	  const dfloat dsdx = vgeo[e*p_Nvgeo + SXID];
	  const dfloat dsdy = vgeo[e*p_Nvgeo + SYID];
	  const dfloat dsdz = vgeo[e*p_Nvgeo + SZID];
	  const dfloat dtdx = vgeo[e*p_Nvgeo + TXID];
	  const dfloat dtdy = vgeo[e*p_Nvgeo + TYID];
	  const dfloat dtdz = vgeo[e*p_Nvgeo + TZID];

	  // compute 'r', 's', and 't' derivatives of (u,v,w,p) at node n
	  dfloat dudr = 0, duds = 0, dudt = 0;
	  dfloat dvdr = 0, dvds = 0, dvdt = 0;
	  dfloat dwdr = 0, dwds = 0, dwdt = 0;
	  dfloat dpdr = 0, dpds = 0, dpdt = 0;
	  
	  for(int i=0;i<p_Np;++i){
	    // load data at node i of element e
	    const dfloat Drni = DrT[n+i*p_Np];
	    const dfloat Dsni = DsT[n+i*p_Np];
	    const dfloat Dtni = DtT[n+i*p_Np];
	    
	    // differentiate (u,v,p) with respect to 'r' and 's'
	    dudr += Drni*s_u[es][i]; duds += Dsni*s_u[es][i]; dudt += Dtni*s_u[es][i];
	    dvdr += Drni*s_v[es][i]; dvds += Dsni*s_v[es][i]; dvdt += Dtni*s_v[es][i];
	    dpdr += Drni*s_p[es][i]; dpds += Dsni*s_p[es][i]; dpdt += Dtni*s_p[es][i];
	  }

	  // chain rule
	  const dfloat dudx = drdx*dudr + dsdx*duds + dtdx*dudt;
	  const dfloat dvdy = drdy*dvdr + dsdy*dvds + dtdy*dvdt;
	  const dfloat dwdz = drdz*dwdr + dsdz*dwds + dtdz*dwdt;
	  const dfloat dpdx = drdx*dpdr + dsdx*dpds + dtdx*dpdt;
	  const dfloat dpdy = drdy*dpdr + dsdy*dpds + dtdy*dpdt;
	  const dfloat dpdz = drdz*dpdr + dsdz*dpds + dtdz*dpdt;
	  
	  // store acoustics rhs contributions from collocation differentiation
	  const int id = e*p_Np + n;
	  dfloat4 rhsq4n;
	  rhsq4n.x = -dpdx;
	  rhsq4n.y = -dpdy;
	  rhsq4n.z = -dpdz;
	  rhsq4n.w = -dudx-dvdy-dwdz;
	  rhsq4[id] = rhsq4n;
	}
      }
    }
  }
}

// o4: unroll 
@kernel void acousticsVolume3D_o4(const int Nelements,
				     @restrict const  dfloat *  vgeo,
				     @restrict const  dfloat *  DrT,
				     @restrict const  dfloat *  DsT,
				     @restrict const  dfloat *  DtT,
				     @restrict const  dfloat4 *  q4,
				     @restrict dfloat4 *  rhsq4){
  
  for(int eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){  // for all elements

    @shared dfloat s_u[p_NblockV][p_Np];
    @shared dfloat s_v[p_NblockV][p_Np];
    @shared dfloat s_w[p_NblockV][p_Np];
    @shared dfloat s_p[p_NblockV][p_Np];

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element

	int e = eo+es; // element in block
	if(e<Nelements){
	  const int id = e*p_Np + n;
	  const dfloat4 q4n = q4[id];
	  s_u[es][n] = q4n.x;
	  s_v[es][n] = q4n.y;
	  s_w[es][n] = q4n.z;
	  s_p[es][n] = q4n.w;
	}
      }
    }

    // make sure all node data is loaded into @shared
    @barrier("local");

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element
	
	int e = eo+es; // element in block
	if(e<Nelements){
	  
	  // prefetch geometric factors (constant on triangle)
	  const dfloat drdx = vgeo[e*p_Nvgeo + RXID];
	  const dfloat drdy = vgeo[e*p_Nvgeo + RYID];
	  const dfloat drdz = vgeo[e*p_Nvgeo + RZID];
	  const dfloat dsdx = vgeo[e*p_Nvgeo + SXID];
	  const dfloat dsdy = vgeo[e*p_Nvgeo + SYID];
	  const dfloat dsdz = vgeo[e*p_Nvgeo + SZID];
	  const dfloat dtdx = vgeo[e*p_Nvgeo + TXID];
	  const dfloat dtdy = vgeo[e*p_Nvgeo + TYID];
	  const dfloat dtdz = vgeo[e*p_Nvgeo + TZID];
	  
	  // compute 'r', 's', and 't' derivatives of (u,v,w,p) at node n
	  dfloat dudr = 0, duds = 0, dudt = 0;
	  dfloat dvdr = 0, dvds = 0, dvdt = 0;
	  dfloat dwdr = 0, dwds = 0, dwdt = 0;
	  dfloat dpdr = 0, dpds = 0, dpdt = 0;
	  
	  #pragma unroll p_Np
	    for(int i=0;i<p_Np;++i){
	      // load data at node i of element e
	      const dfloat Drni = DrT[n+i*p_Np];
	      const dfloat Dsni = DsT[n+i*p_Np];
	      const dfloat Dtni = DtT[n+i*p_Np];
	    
	      // differentiate (u,v,p) with respect to 'r' and 's'
	      dudr += Drni*s_u[es][i]; duds += Dsni*s_u[es][i]; dudt += Dtni*s_u[es][i];
	      dvdr += Drni*s_v[es][i]; dvds += Dsni*s_v[es][i]; dvdt += Dtni*s_v[es][i];
	      dpdr += Drni*s_p[es][i]; dpds += Dsni*s_p[es][i]; dpdt += Dtni*s_p[es][i];
	    }

	  // chain rule
	  const dfloat dudx = drdx*dudr + dsdx*duds + dtdx*dudt;
	  const dfloat dvdy = drdy*dvdr + dsdy*dvds + dtdy*dvdt;
	  const dfloat dwdz = drdz*dwdr + dsdz*dwds + dtdz*dwdt;
	  const dfloat dpdx = drdx*dpdr + dsdx*dpds + dtdx*dpdt;
	  const dfloat dpdy = drdy*dpdr + dsdy*dpds + dtdy*dpdt;
	  const dfloat dpdz = drdz*dpdr + dsdz*dpds + dtdz*dpdt;
	  
	  // store acoustics rhs contributions from collocation differentiation
	  const int id = e*p_Np + n;
	  dfloat4 rhsq4n;
	  rhsq4n.x = -dpdx;
	  rhsq4n.y = -dpdy;
	  rhsq4n.z = -dpdz;
	  rhsq4n.w = -dudx-dvdy-dwdz;
	  rhsq4[id] = rhsq4n;
	}
      }
    }
  }
}

// o5: DrT,Ds into @shared
@kernel void acousticsVolume3D_o5(const int Nelements,
				     @restrict const  dfloat *  vgeo,
				     @restrict const  dfloat *  DrT,
				     @restrict const  dfloat *  DsT,
				     @restrict const  dfloat *  DtT,
				     @restrict const  dfloat4 *  q4,
				     @restrict dfloat4 *  rhsq4){
  
  for(int eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){  // for all elements

    @shared dfloat s_u[p_NblockV][p_Np];
    @shared dfloat s_v[p_NblockV][p_Np];
    @shared dfloat s_w[p_NblockV][p_Np];
    @shared dfloat s_p[p_NblockV][p_Np];

    @shared dfloat s_DrT[p_Np][p_Np];
    @shared dfloat s_DsT[p_Np][p_Np];
    @shared dfloat s_DtT[p_Np][p_Np];

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element
	// prefetch DrT, Ds into @shared
	int t = n + es*p_Np;
	while(t<p_Np*p_Np){
	  s_DrT[0][t] = DrT[t];
	  s_DsT[0][t] = DsT[t];
	  s_DtT[0][t] = DtT[t];
	  t += p_Np*p_NblockV;
	}
	
	int e = eo+es; // element in block
	if(e<Nelements){
	  const int id = e*p_Np + n;
	  const dfloat4 q4n = q4[id];
	  s_u[es][n] = q4n.x;
	  s_v[es][n] = q4n.y;
	  s_w[es][n] = q4n.z;
	  s_p[es][n] = q4n.w;
	}
      }
    }

    // make sure all node data is loaded into @shared
    @barrier("local");

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element
	
	int e = eo+es; // element in block
	if(e<Nelements){
	  
	  // prefetch geometric factors (constant on triangle)
	  const dfloat drdx = vgeo[e*p_Nvgeo + RXID];
	  const dfloat drdy = vgeo[e*p_Nvgeo + RYID];
	  const dfloat drdz = vgeo[e*p_Nvgeo + RZID];
	  const dfloat dsdx = vgeo[e*p_Nvgeo + SXID];
	  const dfloat dsdy = vgeo[e*p_Nvgeo + SYID];
	  const dfloat dsdz = vgeo[e*p_Nvgeo + SZID];
	  const dfloat dtdx = vgeo[e*p_Nvgeo + TXID];
	  const dfloat dtdy = vgeo[e*p_Nvgeo + TYID];
	  const dfloat dtdz = vgeo[e*p_Nvgeo + TZID];
	  
	  // compute 'r', 's', and 't' derivatives of (u,v,w,p) at node n
	  dfloat dudr = 0, duds = 0, dudt = 0;
	  dfloat dvdr = 0, dvds = 0, dvdt = 0;
	  dfloat dwdr = 0, dwds = 0, dwdt = 0;
	  dfloat dpdr = 0, dpds = 0, dpdt = 0;
	  
	  #pragma unroll p_Np
	  for(int i=0;i<p_Np;++i){
	    // load data at node i of element e
	    const dfloat Drni = s_DrT[i][n];
	    const dfloat Dsni = s_DsT[i][n];	  
	    const dfloat Dtni = s_DtT[i][n];
	    
	    // differentiate (u,v,p) with respect to 'r' and 's'
	    dudr += Drni*s_u[es][i]; duds += Dsni*s_u[es][i]; dudt += Dtni*s_u[es][i];
	    dvdr += Drni*s_v[es][i]; dvds += Dsni*s_v[es][i]; dvdt += Dtni*s_v[es][i];
	    dpdr += Drni*s_p[es][i]; dpds += Dsni*s_p[es][i]; dpdt += Dtni*s_p[es][i];
	  }

	  // chain rule
	  const dfloat dudx = drdx*dudr + dsdx*duds + dtdx*dudt;
	  const dfloat dvdy = drdy*dvdr + dsdy*dvds + dtdy*dvdt;
	  const dfloat dwdz = drdz*dwdr + dsdz*dwds + dtdz*dwdt;
	  const dfloat dpdx = drdx*dpdr + dsdx*dpds + dtdx*dpdt;
	  const dfloat dpdy = drdy*dpdr + dsdy*dpds + dtdy*dpdt;
	  const dfloat dpdz = drdz*dpdr + dsdz*dpds + dtdz*dpdt;

	  // store acoustics rhs contributions from collocation differentiation
	  const int id = e*p_Np + n;
	  dfloat4 rhsq4n;
	  rhsq4n.x = -dpdx;
	  rhsq4n.y = -dpdy;
	  rhsq4n.z = -dpdz;
	  rhsq4n.w = -dudx-dvdy-dwdz;
	  rhsq4[id] = rhsq4n;
	}
      }
    }
  }
}


// o6: vgeo in @shared
@kernel void acousticsVolume3D_o6(const int Nelements,
				     @restrict const  dfloat *  vgeo,
				     @restrict const  dfloat *  DrT,
				     @restrict const  dfloat *  DsT,
				     @restrict const  dfloat *  DtT,
				     @restrict const  dfloat4 *  q4,
				     @restrict dfloat4 *  rhsq4){
  
  for(int eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){  // for all elements

    @shared dfloat s_u[p_NblockV][p_Np];
    @shared dfloat s_v[p_NblockV][p_Np];
    @shared dfloat s_w[p_NblockV][p_Np];
    @shared dfloat s_p[p_NblockV][p_Np];

    @shared dfloat s_DrT[p_Np][p_Np];
    @shared dfloat s_DsT[p_Np][p_Np];
    @shared dfloat s_DtT[p_Np][p_Np];

    @shared dfloat s_vgeo[p_NblockV][p_Nvgeo];
    
    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element
	// prefetch DrT, Ds into @shared
	int t = n + es*p_Np;
	while(t<p_Np*p_Np){
	  s_DrT[0][t] = DrT[t];
	  s_DsT[0][t] = DsT[t];
	  s_DtT[0][t] = DtT[t];

	  t += p_Np*p_NblockV;
	}

	t = n+es*p_Np;
	while(t<p_Nvgeo*p_NblockV){
	  if(eo*p_Nvgeo+t<p_Nvgeo*Nelements)
	    s_vgeo[0][t] = vgeo[eo*p_Nvgeo+t];
	  t += p_Np*p_NblockV;
	}

	int e = eo+es; // element in block
	if(e<Nelements){
	  const int id = e*p_Np + n;
	  const dfloat4 q4n = q4[id];
	  s_u[es][n] = q4n.x;
	  s_v[es][n] = q4n.y;
	  s_w[es][n] = q4n.z;
	  s_p[es][n] = q4n.w;
	}
      }
    }

    // make sure all node data is loaded into @shared
    @barrier("local");

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element
	
	int e = eo+es; // element in block
	if(e<Nelements){
	  
	  // prefetch geometric factors (constant on triangle)
	  const dfloat drdx = vgeo[e*p_Nvgeo + RXID];
	  const dfloat drdy = vgeo[e*p_Nvgeo + RYID];
	  const dfloat drdz = vgeo[e*p_Nvgeo + RZID];
	  const dfloat dsdx = vgeo[e*p_Nvgeo + SXID];
	  const dfloat dsdy = vgeo[e*p_Nvgeo + SYID];
	  const dfloat dsdz = vgeo[e*p_Nvgeo + SZID];
	  const dfloat dtdx = vgeo[e*p_Nvgeo + TXID];
	  const dfloat dtdy = vgeo[e*p_Nvgeo + TYID];
	  const dfloat dtdz = vgeo[e*p_Nvgeo + TZID];
	  
	  // compute 'r', 's', and 't' derivatives of (u,v,w,p) at node n
	  dfloat dudr = 0, duds = 0, dudt = 0;
	  dfloat dvdr = 0, dvds = 0, dvdt = 0;
	  dfloat dwdr = 0, dwds = 0, dwdt = 0;
	  dfloat dpdr = 0, dpds = 0, dpdt = 0;

	  #pragma unroll p_Np
	    for(int i=0;i<p_Np;++i){
	      const dfloat Drni = s_DrT[i][n];
	      
	      // differentiate (u,v,p) with respect to 'r' and 's'
	      dudr += Drni*s_u[es][i]; 
	      dvdr += Drni*s_v[es][i];
	      dwdr += Drni*s_w[es][i];
	      dpdr += Drni*s_p[es][i];
	    }
	  
	  #pragma unroll p_Np
	    for(int i=0;i<p_Np;++i){
	      
	      const dfloat Dsni = s_DsT[i][n];
	      
	      duds += Dsni*s_u[es][i];	    
	      dvds += Dsni*s_v[es][i];
	      dwds += Dsni*s_w[es][i];
	      dpds += Dsni*s_p[es][i];
	    }

	  #pragma unroll p_Np
	    for(int i=0;i<p_Np;++i){
	      
	      const dfloat Dtni = s_DtT[i][n];
	      
	      dudt += Dtni*s_u[es][i];	    
	      dvdt += Dtni*s_v[es][i];
	      dwdt += Dtni*s_w[es][i];
	      dpdt += Dtni*s_p[es][i];
	    }

	  // chain rule
	  const dfloat dudx = drdx*dudr + dsdx*duds + dtdx*dudt;
	  const dfloat dvdy = drdy*dvdr + dsdy*dvds + dtdy*dvdt;
	  const dfloat dwdz = drdz*dwdr + dsdz*dwds + dtdz*dwdt;
	  const dfloat dpdx = drdx*dpdr + dsdx*dpds + dtdx*dpdt;
	  const dfloat dpdy = drdy*dpdr + dsdy*dpds + dtdy*dpdt;
	  const dfloat dpdz = drdz*dpdr + dsdz*dpds + dtdz*dpdt;
	  
	  // store acoustics rhs contributions from collocation differentiation
	  const int id = e*p_Np + n;
	  dfloat4 rhsq4n;
	  rhsq4n.x = -dpdx;
	  rhsq4n.y = -dpdy;
	  rhsq4n.z = -dpdz;
	  rhsq4n.w = -dudx-dvdy-dwdz;
	  rhsq4[id] = rhsq4n;
	}
      }
    }
  }
}



