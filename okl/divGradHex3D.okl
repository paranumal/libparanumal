
//written by KS
//purpose: split the divergence and gradient into separate @kernels
//COLLOCATION ONLY IN THIS FILE SO NO INTERPOLATION (!)
//developement started Oct 25th 2017



@kernel void gradientHex3D_e0(const int Nelements,
                             @restrict const  int *  elementList,
                             @restrict const  dfloat *  gjGeo,
                             @restrict const  dfloat *  gjD,
                             @restrict const  dfloat *  gjI,
                             const dfloat lambda,
                             @restrict const  dfloat *  q,
                             @restrict dfloat *  gradq,
                             @restrict dfloat *  Aq){

	for(int e=0; e<Nelements; ++e; @outer(0)) {

		@shared dfloat s_D[p_gjNq][p_Nq+p_gllPad];

		@exclusive dfloat r_q[p_Nq];

		@shared dfloat s_Ixxq[p_Nq][p_Nq+p_gllPad];
		@shared dfloat s_Dxxq[p_Nq][p_Nq+p_gllPad];

		@shared dfloat s_IxDq[p_Nq][p_gjNq+p_gjPad];
		@shared dfloat s_IxIq[p_Nq][p_gjNq+p_gjPad];
		@shared dfloat s_DxIq[p_Nq][p_gjNq+p_gjPad];

		@exclusive int emap;
		@exclusive dfloat r_G00, r_G01, r_G02; 
		@exclusive dfloat r_G10, r_G11, r_G12; 
		@exclusive dfloat r_G20, r_G21, r_G22, r_GwJ;
		@exclusive dfloat r_u;

		// prefetch D and I matrices and zero register storage
		for(int b=0; b<p_gjNq; ++b; @inner(1)) {
			for(int a=0; a<p_gjNq; ++a; @inner(0)) {
				const int t = a + p_gjNq*b;

				if(a<p_Nq && b<p_gjNq) {
					s_D[b][a] = gjD[b*p_Nq+a];
				}

				emap = elementList[e];

				if(a<p_Nq && b<p_Nq) {

					#pragma unroll p_Nq
					for(int c=0; c<p_Nq; ++c) {
						r_q[c] = q[emap*p_Np+c*p_Nq2+b*p_Nq+a];
					}
				}
			}
		}

		// scan through k slices

		for(int k=0; k<p_gjNq; ++k) {

			optBarrier(localMemFence);

			// prefetch slice
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int a=0; a<p_gjNq; ++a; @inner(0)) {

					const int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + b*p_gjNq + a;

					r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
					r_G00 = gjGeo[base+p_G00ID*p_gjNp];
					r_G01 = gjGeo[base+p_G01ID*p_gjNp];
					r_G02 = gjGeo[base+p_G02ID*p_gjNp];

					r_G11 = gjGeo[base+p_G11ID*p_gjNp];
					r_G12 = gjGeo[base+p_G12ID*p_gjNp];
					r_G22 = gjGeo[base+p_G22ID*p_gjNp];
					// extra geofactors' fetching goeas HERE.


					// assumes w*J built into G entries

					

						dfloat Iqk = 0, Dqk = 0;

						#pragma unroll p_Nq
						for(int c=0; c<p_Nq; ++c) {
							
							r_u += s_D[k][c]*qcba;
						}
						
					
				}
			}

			optBarrier(localMemFence);

			// interpolate and differentiate in 'r' direction
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {

					if(b<p_Nq) {

						dfloat IxDq= 0, IxIq = 0, DxIq = 0;

						#pragma unroll p_Nq
						for(int a=0; a<p_Nq; ++a) {
						
							const dfloat Dia = s_D[i][a];
							const dfloat Ixxqba = s_Ixxq[b][a];
							IxDq += Dia*Ixxqba;
							IxIq += Iia*Ixxqba;
							DxIq += Iia*s_Dxxq[b][a];
						}

						s_IxDq[b][i] = IxDq;
						s_IxIq[b][i] = IxIq;
						s_DxIq[b][i] = DxIq;
					}
				}
			}

			optBarrier(localMemFence);

			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {

					dfloat qr = 0, qs = 0, qt = 0, qI = 0;

					// interpolate and differentiate in 's' direction
					#pragma unroll p_Nq
					for(int n=0; n<p_Nq; ++n) {
						const dfloat Ijn = s_I[j][n];
						const dfloat Djn = s_D[j][n];
						qr += Ijn*s_IxDq[n][i];
						qt += Ijn*s_DxIq[n][i];
						qI += Ijn*s_IxIq[n][i];
						qs += Djn*s_IxIq[n][i];
					}

					// apply chain rule (notice the swtich of indices in i,j)
					// should bundle these
					const int base = e*p_gjNp*4 + 4*k*p_gjNq*p_gjNq + j*p_gjNq + i;
					gradq[base+0*p_gjNq2] = r_G00*qr + r_G01*qs + r_G02*qt;
					gradq[base+1*p_gjNq2] = r_G01*qr + r_G12*qs + r_G12*qt;
					gradq[base+2*p_gjNq2] = r_G02*qr + r_G21*qs + r_G22*qt;
					gradq[base+3*p_gjNq2] = r_GwJ*qI*lambda;
				}
			}
		}
	}
}
