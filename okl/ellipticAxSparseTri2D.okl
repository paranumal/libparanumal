@kernel void ellipticAxTri2D_v0(const int Nelements,
             @restrict const  int   *  elementList,
             @restrict const  dfloat *  ggeo,
             @restrict const char4  *  IndT,
             @restrict const  dfloat *  Srr,
             @restrict const  dfloat *  Srs,
             @restrict const  dfloat *  Sss,
             @restrict const  dfloat *  MM,
             const dfloat lambda,
             @restrict const  dfloat *  q,
             @restrict dfloat *  Aq){

  // needs p_NnodesV (nodes per thread) and p_NblockV (elements per chunk) defined
  for(int eo=0;eo<Nelements;eo+=p_NnodesV*p_NblockV;@outer(0)){
    @shared dfloat s_q[p_NnodesV][p_NblockV][p_Np];
    @shared dfloat s_ggeo[p_NnodesV][p_NblockV][p_Nggeo];

    for(int es=0;es<p_NblockV;++es;@inner(1)){
      for(int n=0;n<p_Np;++n;@inner(0)){
        
        // coalesced read of ggeo 
        int t = n + p_Np*es;
        while(t<p_NnodesV*p_NblockV*p_Nggeo && eo*p_Nggeo+t<Nelements*p_Nggeo){          
          s_ggeo[0][0][t] = ggeo[eo*p_Nggeo+t];
          t += p_Np*p_NblockV;
        }
        
        #pragma unroll p_NnodesV
          for(int et=0;et<p_NnodesV;++et){
            const int e = eo + es + et*p_NblockV;
            if(e<Nelements){
              //prefetch q
              const int id = n + e*p_Np;
              s_q[et][es][n] = q[id];
            }
          }
      }
    }

    @barrier("local");

    for(int es=0;es<p_NblockV;++es;@inner(1)){
      for(int n=0;n<p_Np;++n;@inner(0)){

        // do this part irrespective of e
        dfloat r_qrr[p_NnodesV];
        dfloat r_qrs[p_NnodesV];
        dfloat r_qss[p_NnodesV];

        #pragma unroll p_NnodesV
          for(int et=0;et<p_NnodesV;++et){
            r_qrr[et] = 0;
            r_qrs[et] = 0;
            r_qss[et] = 0;
          }

        
        #pragma unroll p_SparseNnzPerRow/4
          for (int k=0;k<p_SparseNnzPerRow/4;k++) {
            const char4 Indn = IndT[n + p_Np*k]; 
            const char *pt_Indn = (char*) &Indn;
              
            int idk;

            #pragma unroll 4 //seems inefficient
              for (int k2=0; k2<4; k2++){
              idk = pt_Indn[k2];

              if(!idk) break;
                    
              --idk;

              // assume Srr, Srs, Sss are stored as a row-major matrix with maxNnzPerRow rows and Np columns
              const int id = n + (k2+4*k)*p_Np;
              // 3 loads from global (probably L1 for NnodesV*6 flops)
              const dfloat Srr_nk = Srr[id];
              const dfloat Srs_nk = Srs[id];
              const dfloat Sss_nk = Sss[id];

              #pragma unroll p_NnodesV
                for(int et=0;et<p_NnodesV;++et){
                  // fetch from @shared (for reuse three times)
                  // 6 flops per 8 bytes
                  const dfloat r_qk = s_q[et][es][idk];
                        
                  r_qrr[et] += Srr_nk*r_qk;
                  r_qrs[et] += Srs_nk*r_qk;
                  r_qss[et] += Sss_nk*r_qk;
                }
              }
            if(!idk) break;
          }
        
        // this part has to check for element index validity
        #pragma unroll p_NnodesV
          for(int et=0;et<p_NnodesV;++et){
            const int e = eo + es + et*p_NblockV;
            
            if (e<Nelements) {
              dfloat res1 = s_ggeo[et][es][p_G00ID]*r_qrr[et];
              res1 += s_ggeo[et][es][p_G01ID]*r_qrs[et];
              res1 += s_ggeo[et][es][p_G11ID]*r_qss[et];
              
              const int id = n + e*p_Np;
              Aq[id] = res1;
            }
          }
      }
    }
  }
}

@kernel void ellipticPartialAxTri2D_v0(const int Nelements,
                                      @restrict const  int   *  elementList,
                                      @restrict const  dfloat *  ggeo,
                                      @restrict const char4  *  IndT,
                                      @restrict const  dfloat *  Srr,
                                      @restrict const  dfloat *  Srs,
                                      @restrict const  dfloat *  Sss,
                                      @restrict const  dfloat *  MM,
                                      const dfloat lambda,
                                      @restrict const  dfloat *  q,
                                      @restrict dfloat *  Aq){

  // needs p_NnodesV (nodes per thread) and p_NblockV (elements per chunk) defined

  for(int eo=0;eo<Nelements;eo+=p_NnodesV*p_NblockV;@outer(0)){
    @shared int s_elements[p_NnodesV][p_NblockV];
    @shared dfloat s_q[p_NnodesV][p_NblockV][p_Np];

    for(int es=0;es<p_NblockV;++es;@inner(1)){
      for(int n=0;n<p_Np;++n;@inner(0)){
        int t = n + es*p_Np;
        while(t<p_NblockV*p_NnodesV){
          const int e = eo + t;
          if(e<Nelements)
            s_elements[0][t] = elementList[e];
          t+=p_Np*p_NblockV;
        }
      }
    }

    @barrier("local");

    for(int es=0;es<p_NblockV;++es;@inner(1)){
      for(int n=0;n<p_Np;++n;@inner(0)){
      
        #pragma unroll p_NnodesV
          for(int et=0;et<p_NnodesV;++et){
            const int e = eo + es + et*p_NblockV;
            if(e<Nelements){
              //prefetch q
              const int element = s_elements[et][es];
              const int id = n + element*p_Np;
              s_q[et][es][n] = q[id];
            }
          }
      }
    }

    @barrier("local");

    for(int es=0;es<p_NblockV;++es;@inner(1)){
      for(int n=0;n<p_Np;++n;@inner(0)){

        // do this part irrespective of e
        dfloat r_qrr[p_NnodesV];
        dfloat r_qrs[p_NnodesV];
        dfloat r_qss[p_NnodesV];

        #pragma unroll p_NnodesV
          for(int et=0;et<p_NnodesV;++et){
            r_qrr[et] = 0;
            r_qrs[et] = 0;
            r_qss[et] = 0;
          }

        
        #pragma unroll p_SparseNnzPerRow/4
          for (int k=0;k<( ((int)p_SparseNnzPerRow/4));k++) {
            const char4 Indn = IndT[n + p_Np*k]; 
            const char *pt_Indn = (char*) &Indn;
                  
            #pragma unroll 4 //seems inefficient
              for (int k2=0; k2<4; k2++){
                int idk = pt_Indn[k2];
                          
                //printf("thread %d, idk = %d\n", n,idk);

                if(!idk) break;
                      
                --idk;

                // assume Srr, Srs, Sss are stored as a row-major matrix with maxNnzPerRow rows and Np columns
                const int id = n + (k2+4*k)*p_Np;
                // 3 loads from global (probably L1 for NnodesV*6 flops)
                const dfloat Srr_nk = Srr[id];
                const dfloat Srs_nk = Srs[id];
                const dfloat Sss_nk = Sss[id];

                //printf("thread %d, idk = %d, Srr = %f, Srs = %f, Sss = %f \n", n,idk, Srr_nk,Srs_nk,Sss_nk);

                #pragma unroll p_NnodesV
                  for(int et=0;et<p_NnodesV;++et){
                    const int e = eo + es + et*p_NblockV;
                    // fetch from @shared (for reuse three times)
                    // 6 flops per 8 bytes
                    const dfloat r_qk = s_q[et][es][idk];
                          
                    r_qrr[et] += Srr_nk*r_qk;
                    r_qrs[et] += Srs_nk*r_qk;
                    r_qss[et] += Sss_nk*r_qk;
                  }
              }
          }
        
        // this part has to check for element index validity
        #pragma unroll p_NnodesV
          for(int et=0;et<p_NnodesV;++et){
            const int e = eo + es + et*p_NblockV;

            if (e<Nelements) {
              const int element = s_elements[et][es];

              const int gid = element*p_Nggeo;
              const dfloat Grr = ggeo[gid + p_G00ID];
              const dfloat Grs = ggeo[gid + p_G01ID];
              const dfloat Gss = ggeo[gid + p_G11ID];
    
              dfloat res1 = Grr*r_qrr[et];
              res1 += Grs*r_qrs[et];
              res1 += Gss*r_qss[et];

              const int id = n + element*p_Np;
              Aq[id] = res1;
            }
          }
      }
    }
  }
}