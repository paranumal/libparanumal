
void boundaryConditions2D(int bc, dfloat time, dfloat x, dfloat y,
        dfloat uM, dfloat vM, dfloat pM,
        dfloat *uP, dfloat *vP, dfloat *pP){

  if(1){ //bc==1){
    // assert Neumann for pressure and no penetration for velocity
    *uP = -uM;
    *vP = -vM;
    *pP = pM;
  }
  if(0){ //bc==2){
    dfloat dx = 1.f/sqrt(2.f);
    dfloat dy = 1.f/sqrt(2.f);
    dfloat omega = 10*M_PI;
    dfloat wave = cos(omega*(time-(x*dx+y*dy)));
    dfloat uI = dx*wave;
    dfloat vI = dy*wave;
    dfloat pI = wave;

    // scattered field wall
    *uP = -uM -2.f*uI;
    *vP = -vM -2.f*vI;
    *pP = pM;
  }
}

@kernel void acousticsbbdgMRABPmlSurfaceP2D(const int pmlNelements,
           @restrict const  int   *  pmlElementIds,
           @restrict const  int   *  pmlIds,
           @restrict const  dfloat *  sgeo,
           @restrict const  dfloat *  L0vals,
           @restrict const  int   *  ELids,
           @restrict const  dfloat *  ELvals,
           @restrict const  int   *  vmapM,
           @restrict const  int   *  mapP,
           @restrict const  int   *  EToB,
           const dfloat time,
           @restrict const  dfloat *  x,
           @restrict const  dfloat *  y,
           @restrict const  dfloat *  q,
           @restrict const  dfloat *  pmlq,
           @restrict const  dfloat *  fQM,
           @restrict const  dfloat *  fQP,
           @restrict dfloat       *  rhsq,
           @restrict dfloat       *  pmlrhsq,
           const int   rhsShift){

  // for all elements
  for(int eo=0;eo<pmlNelements;eo+=p_NblockS;@outer(0)){

    // @shared storage for flux terms
    @shared dfloat s_fluxu[p_NblockS][p_Nfp*p_Nfaces];
    @shared dfloat s_fluxv[p_NblockS][p_Nfp*p_Nfaces];
    @shared dfloat s_fluxpx[p_NblockS][p_Nfp*p_Nfaces];
    @shared dfloat s_fluxpy[p_NblockS][p_Nfp*p_Nfaces];
    @shared dfloat s_fluxu_copy[p_NblockS][p_Nfp*p_Nfaces];
    @shared dfloat s_fluxv_copy[p_NblockS][p_Nfp*p_Nfaces];
    @shared dfloat s_fluxpx_copy[p_NblockS][p_Nfp*p_Nfaces];
    @shared dfloat s_fluxpy_copy[p_NblockS][p_Nfp*p_Nfaces];

    // for all face nodes of all elements
    for(int es=0;es<p_NblockS;++es;@inner(1)){
      for(int n=0;n<p_maxNodes;++n;@inner(0)){ // maxNodes = max(Nfp*Nfaces,Np)
        const int et = eo + es;
        if(et<pmlNelements){
          const int e = pmlElementIds[et];
          if(n<p_Nfp*p_Nfaces){

            // find face that owns this node
            const int face = n/p_Nfp;
            const int iid  = n%p_Nfp;

            // load surface geofactors for this face
            const int sid = p_Nsgeo*(e*p_Nfaces+face);
            const dfloat nx   = sgeo[sid+p_NXID];
            const dfloat ny   = sgeo[sid+p_NYID];
            const dfloat sJ   = sgeo[sid+p_SJID];
            const dfloat invJ = sgeo[sid+p_IJID];

            // indices of negative and positive traces of face node
            const int id  = e*p_NfpMax*p_Nfaces + face*p_NfpMax + iid;
            const int idM = id*p_Nfields;
            const int idP = mapP[id]*p_Nfields;

            // load negative and positive trace node values of q
            const dfloat uM = fQM[idM+0], vM = fQM[idM+1], pM = fQM[idM+2];
                  dfloat uP = fQP[idP+0], vP = fQP[idP+1], pP = fQP[idP+2];

            // apply boundary condition
            const int bc = EToB[face+p_Nfaces*e];
            if(bc>0)  {
              const int idB = vmapM[id];
              boundaryConditions2D(bc, time, x[idB], y[idB], uM, vM, pM, &uP, &vP, &pP);
            }

            // compute (q^* - q^-)
            const dfloat duS = 0.5*(uP-uM) + p_Lambda2*(-nx)*(pP-pM);
            const dfloat dvS = 0.5*(vP-vM) + p_Lambda2*(-ny)*(pP-pM);
            const dfloat dpS = 0.5*(pP-pM) + p_Lambda2*(-nx*(uP-uM)-ny*(vP-vM));

            // evaluate "flux" terms: (sJ/J)*(A*nx+B*ny)*(q^* - q^-)
            s_fluxu[es][n] = invJ*sJ*(-nx*dpS);
            s_fluxv[es][n] = invJ*sJ*(-ny*dpS);
            s_fluxpx[es][n] = invJ*sJ*(-nx*duS);
            s_fluxpy[es][n] = invJ*sJ*(-ny*dvS);
          }
        }
      }
    }

    // wait for all @shared memory writes of the previous inner loop to complete
    @barrier("local");

    // apply L0 to fluxes. use fact that L0 = tridiagonal in 2D
    for(int es=0;es<p_NblockS;++es;@inner(1)){
      for(int n=0;n<p_maxNodes;++n;@inner(0)){
        int et = eo + es;
        if(et<pmlNelements){
          if(n<p_Nfp*p_Nfaces){
            const int id = n % p_Nfp;  // warning: redundant reads
            const dfloat L0val = L0vals[id+p_Nfp];

            dfloat utmpflux = L0val * s_fluxu[es][n];
            dfloat vtmpflux = L0val * s_fluxv[es][n];
            dfloat pxtmpflux = L0val * s_fluxpx[es][n];
            dfloat pytmpflux = L0val * s_fluxpy[es][n];

            if (id > 0){
              utmpflux += L0vals[id]*s_fluxu[es][n-1]; // add previous term
              vtmpflux += L0vals[id]*s_fluxv[es][n-1]; // add previous term
              pxtmpflux += L0vals[id]*s_fluxpx[es][n-1]; // add previous term
              pytmpflux += L0vals[id]*s_fluxpy[es][n-1]; // add previous term
            }
            if (id < p_Nfp-1){
              utmpflux += L0vals[id+2*p_Nfp]*s_fluxu[es][n+1];// add next term
              vtmpflux += L0vals[id+2*p_Nfp]*s_fluxv[es][n+1];// add next term
              pxtmpflux += L0vals[id+2*p_Nfp]*s_fluxpx[es][n+1];// add next term
              pytmpflux += L0vals[id+2*p_Nfp]*s_fluxpy[es][n+1];// add next term
            }
            s_fluxu_copy[es][n] = utmpflux;
            s_fluxv_copy[es][n] = vtmpflux;
            s_fluxpx_copy[es][n] = pxtmpflux;
            s_fluxpy_copy[es][n] = pytmpflux;
          }
        }
      }
    }

    @barrier("local");

    // apply lift reduction and accumulate RHS
    for(int es=0;es<p_NblockS;++es;@inner(1)){
      for(int n=0;n<p_maxNodes;++n;@inner(0)){
        int et = eo + es;
        if(et<pmlNelements){
          if(n<p_Np){
            const int e  = pmlElementIds[et];
            const int pmlId  = pmlIds[et];
            const int rhsId = 3*p_Nfields*(p_NpMax*e + n) + p_Nfields*rhsShift;
            const int pmlrhsId = 3*p_pmlNfields*(p_NpMax*pmlId + n) + p_pmlNfields*rhsShift;

            // load RHS
            dfloat rhsqnu = rhsq[rhsId+0];
            dfloat rhsqnv = rhsq[rhsId+1];
            dfloat rhsqnpx = pmlrhsq[pmlrhsId+0];
            dfloat rhsqnpy = pmlrhsq[pmlrhsId+1];

            // rhs += LIFT*((sJ/J)*(A*nx+B*ny)*(q^* - q^-))
            #pragma unroll p_max_EL_nnz
            for (int m = 0; m < p_max_EL_nnz; ++m){
              const int   id    = n + m*p_Np;
              const dfloat ELval = ELvals[id];
              const int   ELid  = ELids[id];
              rhsqnu += ELval * s_fluxu_copy[es][ELid];
              rhsqnv += ELval * s_fluxv_copy[es][ELid];
              rhsqnpx += ELval * s_fluxpx_copy[es][ELid];
              rhsqnpy += ELval * s_fluxpy_copy[es][ELid];
            }

            // store incremented rhs
            rhsq[rhsId+0] = rhsqnu;
            rhsq[rhsId+1] = rhsqnv;
            pmlrhsq[pmlrhsId+0] = rhsqnpx;
            pmlrhsq[pmlrhsId+1] = rhsqnpy;
          }
        }
      }
    }
  }
}
