
// compute div(NU)  = div(uxu) in collocation way (weak form)
@kernel void insSubCycleVolumeHex3D(const dlong Nelements,
                                   @restrict const  dfloat *  vgeo,
                                   @restrict const  dfloat *  D,
                                   @restrict const  dfloat *  U,
                                   @restrict const  dfloat *  V,
                                   @restrict const  dfloat *  W,
                                   @restrict const  dfloat *  Ud,
                                   @restrict const  dfloat *  Vd,
                                   @restrict const  dfloat *  Wd,
                                         @restrict dfloat *  NU,
                                         @restrict dfloat *  NV,
                                         @restrict dfloat *  NW){

  for(dlong e=0; e<Nelements; ++e; @outer(0)) {

    @shared dfloat s_F11[p_Nq][p_Nq];
    @shared dfloat s_F12[p_Nq][p_Nq];
    @shared dfloat s_F13[p_Nq][p_Nq];
    @shared dfloat s_F21[p_Nq][p_Nq];
    @shared dfloat s_F22[p_Nq][p_Nq];
    @shared dfloat s_F23[p_Nq][p_Nq];
    @shared dfloat s_F31[p_Nq][p_Nq];
    @shared dfloat s_F32[p_Nq][p_Nq];
    @shared dfloat s_F33[p_Nq][p_Nq];

    @shared dfloat s_D[p_Nq][p_Nq];

    @exclusive dfloat r_NU[p_Nq], r_NV[p_Nq], r_NW[p_Nq];

    for(int j=0;j<p_Nq;++j;@inner(1)){ 
      for(int i=0;i<p_Nq;++i;@inner(0)){
        const int id = i+j*p_Nq;
        s_D[0][id] = D[id];

        #pragma unroll p_Nq
          for(int k=0;k<p_Nq;++k){         
            r_NU[k] = 0.;
            r_NV[k] = 0.;
            r_NW[k] = 0.;
          }
      }
    }

    @barrier("local");

    #pragma unroll p_Nq
    for(int k=0;k<p_Nq;++k){ 

      //fetch slice
      for(int j=0;j<p_Nq;++j;@inner(1)){ 
        for(int i=0;i<p_Nq;++i;@inner(0)){
          const dlong gid = e*p_Np*p_Nvgeo+ k*p_Nq*p_Nq + j*p_Nq +i;
          const dfloat drdx = vgeo[gid + p_RXID*p_Np];
          const dfloat drdy = vgeo[gid + p_RYID*p_Np];
          const dfloat drdz = vgeo[gid + p_RZID*p_Np];
          const dfloat dsdx = vgeo[gid + p_SXID*p_Np];
          const dfloat dsdy = vgeo[gid + p_SYID*p_Np];
          const dfloat dsdz = vgeo[gid + p_SZID*p_Np];
          const dfloat dtdx = vgeo[gid + p_TXID*p_Np];
          const dfloat dtdy = vgeo[gid + p_TYID*p_Np];
          const dfloat dtdz = vgeo[gid + p_TZID*p_Np];
          const dfloat JW   = vgeo[gid + p_JWID*p_Np];

          const dlong id = e*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
          const dfloat Un = U[id];
          const dfloat Vn = V[id];
          const dfloat Wn = W[id];
          const dfloat Udn = Ud[id];
          const dfloat Vdn = Vd[id];
          const dfloat Wdn = Wd[id];

          const dfloat cUn = JW*(drdx*Un+drdy*Vn+drdz*Wn);
          const dfloat cVn = JW*(dsdx*Un+dsdy*Vn+dsdz*Wn);
          const dfloat cWn = JW*(dtdx*Un+dtdy*Vn+dtdz*Wn);

          s_F11[j][i] = cUn*Udn;
          s_F12[j][i] = cVn*Udn;
          s_F13[j][i] = cWn*Udn;
          s_F21[j][i] = cUn*Vdn;
          s_F22[j][i] = cVn*Vdn;
          s_F23[j][i] = cWn*Vdn;
          s_F31[j][i] = cUn*Wdn;
          s_F32[j][i] = cVn*Wdn;
          s_F33[j][i] = cWn*Wdn;
        }
      }

      @barrier("local");

      for(int j=0;j<p_Nq;++j;@inner(1)){ 
        for(int i=0;i<p_Nq;++i;@inner(0)){
          #pragma unroll p_Nq
            for (int n=0;n<p_Nq;n++) {
              const dfloat Dr = s_D[n][i];
              const dfloat Ds = s_D[n][j];
              const dfloat Dt = s_D[k][n];
              r_NU[k] += Dr*s_F11[j][n];
              r_NV[k] += Dr*s_F21[j][n];
              r_NW[k] += Dr*s_F31[j][n];

              r_NU[k] += Ds*s_F12[n][i];
              r_NV[k] += Ds*s_F22[n][i];
              r_NW[k] += Ds*s_F32[n][i];

              r_NU[n] += Dt*s_F13[j][i];
              r_NV[n] += Dt*s_F23[j][i];
              r_NW[n] += Dt*s_F33[j][i];
            }
        }
      }

      @barrier("local");
    } //k loop

    //write out
    for(int j=0;j<p_Nq;++j;@inner(1)){ 
      for(int i=0;i<p_Nq;++i;@inner(0)){
        #pragma unroll p_Nq
          for(int k=0;k<p_Nq;++k){
            const dlong gid = e*p_Np*p_Nvgeo+ k*p_Nq*p_Nq + j*p_Nq +i;
            const dfloat invJW = vgeo[gid + p_IJWID*p_Np];

            const dlong id = e*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
            NU[id] = -invJW*r_NU[k];
            NV[id] = -invJW*r_NV[k];
            NW[id] = -invJW*r_NW[k];
          }
      }
    }
  }
}


#define surfaceTerms(sk,face,m, i, j)                                   \
{                                                                       \
  const dlong  idM = vmapM[sk];                                         \
  const dlong  idP = vmapP[sk];                                         \
                                                                        \
  const dfloat nx = sgeo[sk*p_Nsgeo+p_NXID];                            \
  const dfloat ny = sgeo[sk*p_Nsgeo+p_NYID];                            \
  const dfloat nz = sgeo[sk*p_Nsgeo+p_NZID];                            \
  const dfloat sJ = sgeo[sk*p_Nsgeo+p_SJID];                            \
  const dfloat invWJ = sgeo[sk*p_Nsgeo+p_WIJID];                        \
                                                                        \
  const dfloat uM  = U[idM],  vM  = V[idM],  wM  = W[idM];              \
  const dfloat uP  = U[idP],  vP  = V[idP],  wP  = W[idP];              \
  const dfloat udM = Ud[idM], vdM = Vd[idM], wdM = Wd[idM];             \
        dfloat udP = Ud[idP], vdP = Vd[idP], wdP = Wd[idP];             \
                                                                        \
  const int bc = EToB[face+p_Nfaces*e];                                 \
  if(bc>0) {                                                            \
    insVelocityDirichletConditions3D(bc, time, x[vmapM[sk]], y[vmapM[sk]], z[vmapM[sk]], nx, ny, nz, uM, vM, wM, &udP, &vdP, &wdP); \
    udP *= bScale;                                                      \
    vdP *= bScale;                                                      \
    wdP *= bScale;                                                      \
  }                                                                     \
                                                                        \
  const dfloat unM   = fabs(nx*uM + ny*vM + nz*wM);                 \
  const dfloat unP   = fabs(nx*uP + ny*vP + nz*wP);                 \
  const dfloat unMax = (unM > unP) ? unM : unP;                         \
                                                                        \
  const dfloat sc = invWJ * sJ;                                         \
  s_fluxNU[m][j][i] = sc*(.5f*(nx*(uP*udP + uM*udM)                     \
                             + ny*(vP*udP + vM*udM)                     \
                             + nz*(wP*udP + wM*udM)  + unMax*(udM-udP) )); \
  s_fluxNV[m][j][i] = sc*(.5f*(nx*(uP*vdP + uM*vdM)                     \
                             + ny*(vP*vdP + vM*vdM)                     \
                             + nz*(wP*vdP + wM*vdM)  + unMax*(vdM-vdP) )); \
  s_fluxNW[m][j][i] = sc*(.5f*(nx*(uP*wdP + uM*wdM)                     \
                             + ny*(vP*wdP + vM*wdM)                     \
                             + nz*(wP*wdP + wM*wdM)  + unMax*(wdM-wdP) )); \
}

@kernel void insSubCycleSurfaceHex3D(const dlong Nelements,
                                    @restrict const  dfloat *  sgeo,
                                    @restrict const  dlong  *  vmapM,
                                    @restrict const  dlong  *  vmapP,
                                    @restrict const  int    *  EToB,
                                    const dfloat bScale,
                                    const dfloat time,
                                    @restrict const  dfloat *  x,
                                    @restrict const  dfloat *  y,
                                    @restrict const  dfloat *  z,
                                    @restrict const  dfloat *  U,
                                    @restrict const  dfloat *  V,
                                    @restrict const  dfloat *  W,
                                    @restrict const  dfloat *  Ud,
                                    @restrict const  dfloat *  Vd,
                                    @restrict const  dfloat *  Wd,
                                          @restrict dfloat *  NU,
                                          @restrict dfloat *  NV,
                                          @restrict dfloat *  NW){

  // for all elements
  for(dlong e=0;e<Nelements;e++;@outer(0)){
    // @shared storage for flux terms
    @shared dfloat s_fluxNU[2][p_Nq][p_Nq];
    @shared dfloat s_fluxNV[2][p_Nq][p_Nq];
    @shared dfloat s_fluxNW[2][p_Nq][p_Nq];

    @exclusive dfloat r_NU[p_Nq], r_NV[p_Nq], r_NW[p_Nq];

    // for all face nodes of all elements
    // face 0 & 5
    for(int j=0;j<p_Nq;++j;@inner(1)){
      for(int i=0;i<p_Nq;++i;@inner(0)){
        #pragma unroll p_Nq
        for(int k=0;k<p_Nq;++k){
          r_NU[k] = 0.;
          r_NV[k] = 0.;
          r_NW[k] = 0.;
        }

        const dlong sk0 = e*p_Nfp*p_Nfaces + 0*p_Nfp + i + j*p_Nq;
        const dlong sk5 = e*p_Nfp*p_Nfaces + 5*p_Nfp + i + j*p_Nq;

        surfaceTerms(sk0,0,0,i,j);
        surfaceTerms(sk5,5,1,i,j);
      }
    }

    @barrier("local");

    // face 0 & 5
    for(int j=0;j<p_Nq;++j;@inner(1)){
      for(int i=0;i<p_Nq;++i;@inner(0)){
        //face 0
        r_NU[0] += s_fluxNU[0][j][i];
        r_NV[0] += s_fluxNV[0][j][i];
        r_NW[0] += s_fluxNW[0][j][i];

        //face 5
        r_NU[p_Nq-1] += s_fluxNU[1][j][i];
        r_NV[p_Nq-1] += s_fluxNV[1][j][i];
        r_NW[p_Nq-1] += s_fluxNW[1][j][i];
      }
    }

    @barrier("local");    

    // face 1 & 3
    for(int k=0;k<p_Nq;++k;@inner(1)){
      for(int i=0;i<p_Nq;++i;@inner(0)){
        const dlong sk1 = e*p_Nfp*p_Nfaces + 1*p_Nfp + i + k*p_Nq;
        const dlong sk3 = e*p_Nfp*p_Nfaces + 3*p_Nfp + i + k*p_Nq;

        surfaceTerms(sk1,1,0,i,k);
        surfaceTerms(sk3,3,1,i,k);
      }
    }

    @barrier("local");

    // face 1 & 3
    for(int j=0;j<p_Nq;++j;@inner(1)){
      for(int i=0;i<p_Nq;++i;@inner(0)){
        if (j==0) {//face 1
          #pragma unroll p_Nq
          for (int n=0;n<p_Nq;n++) {
            r_NU[n] += s_fluxNU[0][n][i];
            r_NV[n] += s_fluxNV[0][n][i];
            r_NW[n] += s_fluxNW[0][n][i];
          }
        }
        if (j==p_Nq-1) {//face 3
          #pragma unroll p_Nq
          for (int n=0;n<p_Nq;n++) {
            r_NU[n] += s_fluxNU[1][n][i];
            r_NV[n] += s_fluxNV[1][n][i];
            r_NW[n] += s_fluxNW[1][n][i];
          }
        }
      }
    }

    @barrier("local");    

    // face 2 & 4
    for(int k=0;k<p_Nq;++k;@inner(1)){
      for(int j=0;j<p_Nq;++j;@inner(0)){
        const dlong sk2 = e*p_Nfp*p_Nfaces + 2*p_Nfp + j + k*p_Nq;
        const dlong sk4 = e*p_Nfp*p_Nfaces + 4*p_Nfp + j + k*p_Nq;

        surfaceTerms(sk2,2,0,j,k);
        surfaceTerms(sk4,4,1,j,k);
      }
    }

    @barrier("local");

    // face 2 & 4
    for(int j=0;j<p_Nq;++j;@inner(1)){
      for(int i=0;i<p_Nq;++i;@inner(0)){
        if (i==p_Nq-1) {//face 2
          #pragma unroll p_Nq
          for (int n=0;n<p_Nq;n++) {
            r_NU[n] += s_fluxNU[0][n][j];
            r_NV[n] += s_fluxNV[0][n][j];
            r_NW[n] += s_fluxNW[0][n][j];
          }
        }
        if (i==0) {//face 4
          #pragma unroll p_Nq
          for (int n=0;n<p_Nq;n++) {
            r_NU[n] += s_fluxNU[1][n][j];
            r_NV[n] += s_fluxNV[1][n][j];
            r_NW[n] += s_fluxNW[1][n][j];
          }
        }
      }
    }

    @barrier("local");   

    for(int j=0;j<p_Nq;++j;@inner(1)){
      for(int i=0;i<p_Nq;++i;@inner(0)){
        #pragma unroll p_Nq
        for(int k=0;k<p_Nq;++k){
          const dlong id = e*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

          NU[id] += r_NU[k];
          NV[id] += r_NV[k];
          NW[id] += r_NW[k];
        }
      }
    }
  }
}
#undef surfaceTerms

#if 0
/* ------------------Quadrature @kernels ----------------------------------*/
@kernel void insSubCycleCubatureVolumeHex3D(const dlong Nelements,
                                           @restrict const  dfloat *  vgeo,
                                           @restrict const  dfloat *  cubvgeo,
                                           @restrict const  dfloat *  cubD,
                                           @restrict const  dfloat *  cubInterpT,
                                           @restrict const  dfloat *  cubProjectT,
                                           @restrict const  dfloat *  U,
                                           @restrict const  dfloat *  V,
                                           @restrict const  dfloat *  W,
                                           @restrict const  dfloat *  Ud,
                                           @restrict const  dfloat *  Vd,
                                           @restrict const  dfloat *  Wd,
                                                 @restrict dfloat *  cU, //storage for interpolated fields
                                                 @restrict dfloat *  cV, //storage for interpolated fields
                                                 @restrict dfloat *  cW, //storage for interpolated fields
                                                 @restrict dfloat *  cUd, //storage for interpolated fields
                                                 @restrict dfloat *  cVd, //storage for interpolated fields
                                                 @restrict dfloat *  cWd, //storage for interpolated fields
                                                 @restrict dfloat *  NU,
                                                 @restrict dfloat *  NV,
                                                 @restrict dfloat *  NW){

  //----------------------------@kernel 1 interpolate velocity fields to quadrature points
  for(dlong e=0; e<Nelements; ++e; @outer(0)) {

    @shared dfloat s_U[p_Nq][p_cubNq];
    @shared dfloat s_V[p_Nq][p_cubNq];
    @shared dfloat s_W[p_Nq][p_cubNq];
    @shared dfloat s_cubInterpT[p_Nq][p_cubNq];

    @exclusive dfloat r_U[p_cubNq], r_V[p_cubNq], r_W[p_cubNq];

    for(int j=0;j<p_cubNq;++j;@inner(1)){
      for(int i=0;i<p_cubNq;++i;@inner(0)){
        const int id = i+j*p_cubNq;
        if (id<p_Nq*p_cubNq) {
          s_cubInterpT[0][id] = cubInterpT[id];
        }

        #pragma unroll p_cubNq
          for(int k=0;k<p_cubNq;++k){         
            r_U[k] = 0.;
            r_V[k] = 0.;
            r_W[k] = 0.;
          }
      }
    }

    @barrier("local");

    //read in and interpolate in k
    for(int j=0;j<p_cubNq;++j;@inner(1)){
      for(int i=0;i<p_cubNq;++i;@inner(0)){
        if (i<p_Nq && j<p_Nq) {
          #pragma unroll p_Nq
          for(int k=0;k<p_Nq;++k){
            const dlong id = e*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
            const dfloat uc = U[id];
            const dfloat vc = V[id];
            const dfloat wc = W[id];

            #pragma unroll p_cubNq
            for(int n=0;n<p_cubNq;++n){
              const dfloat Ik = s_cubInterpT[k][n];
              r_U[n] += Ik*uc;
              r_V[n] += Ik*vc;
              r_W[n] += Ik*wc;
            }
          }
        }
      }
    }

    @barrier("local");

    #pragma unroll p_cubNq
    for(int k=0;k<p_cubNq;++k){ 
      //load slice to @shared
      for(int j=0;j<p_cubNq;++j;@inner(1)){ 
        for(int i=0;i<p_cubNq;++i;@inner(0)){
          if (i<p_Nq && j<p_Nq) {
            s_U[j][i] = r_U[k];
            s_V[j][i] = r_V[k];
            s_W[j][i] = r_W[k];
          }
        }
      }

      @barrier("local");

      for(int j=0;j<p_cubNq;++j;@inner(1)){ 
        for(int i=0;i<p_cubNq;++i;@inner(0)){
          if(j<p_Nq){
            r_U[k] = 0; r_V[k] = 0; r_W[k] = 0;

            #pragma unroll p_Nq
            for (int n=0;n<p_Nq;n++) {
              const dfloat Ii = s_cubInterpT[n][i];
              r_U[k] += Ii*s_U[j][n];
              r_V[k] += Ii*s_V[j][n];
              r_W[k] += Ii*s_W[j][n];
            }
          }
        }
      }

      @barrier("local");

      for(int j=0;j<p_cubNq;++j;@inner(1)){ 
        for(int i=0;i<p_cubNq;++i;@inner(0)){
          if(j<p_Nq){
            s_U[j][i] = r_U[k];
            s_V[j][i] = r_V[k];
            s_W[j][i] = r_W[k];
          }
        }
      }

      @barrier("local");

      for(int j=0;j<p_cubNq;++j;@inner(1)){ 
        for(int i=0;i<p_cubNq;++i;@inner(0)){
          r_U[k] = 0; r_V[k] = 0; r_W[k] = 0;

          #pragma unroll p_Nq
          for (int n=0;n<p_Nq;n++) {
            const dfloat Ij = s_cubInterpT[n][j];
            r_U[k] += Ij*s_U[n][i];
            r_V[k] += Ij*s_V[n][i];
            r_W[k] += Ij*s_W[n][i];
          }

          const dlong id =e*p_cubNp + k*p_cubNq*p_cubNq + j*p_cubNq + i;
          cU[id] = r_U[k];
          cV[id] = r_V[k];
          cW[id] = r_W[k];
        }
      }
      @barrier("local");      
    }

    //read in and interpolate in k
    for(int j=0;j<p_cubNq;++j;@inner(1)){
      for(int i=0;i<p_cubNq;++i;@inner(0)){
        #pragma unroll p_cubNq
          for(int k=0;k<p_cubNq;++k){         
            r_U[k] = 0.;
            r_V[k] = 0.;
            r_W[k] = 0.;
          }

        if (i<p_Nq && j<p_Nq) {
          #pragma unroll p_Nq
          for(int k=0;k<p_Nq;++k){
            const dlong id = e*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
            const dfloat uc = Ud[id];
            const dfloat vc = Vd[id];
            const dfloat wc = Wd[id];

            #pragma unroll p_cubNq
            for(int n=0;n<p_cubNq;++n){
              const dfloat Ik = s_cubInterpT[k][n];
              r_U[n] += Ik*uc;
              r_V[n] += Ik*vc;
              r_W[n] += Ik*wc;
            }
          }
        }
      }
    }

    @barrier("local");

    #pragma unroll p_cubNq
    for(int k=0;k<p_cubNq;++k){ 
      //load slice to @shared
      for(int j=0;j<p_cubNq;++j;@inner(1)){ 
        for(int i=0;i<p_cubNq;++i;@inner(0)){
          if (i<p_Nq && j<p_Nq) {
            s_U[j][i] = r_U[k];
            s_V[j][i] = r_V[k];
            s_W[j][i] = r_W[k];
          }
        }
      }

      @barrier("local");

      for(int j=0;j<p_cubNq;++j;@inner(1)){ 
        for(int i=0;i<p_cubNq;++i;@inner(0)){
          if(j<p_Nq){
            r_U[k] = 0; r_V[k] = 0; r_W[k] = 0;

            #pragma unroll p_Nq
            for (int n=0;n<p_Nq;n++) {
              const dfloat Ii = s_cubInterpT[n][i];
              r_U[k] += Ii*s_U[j][n];
              r_V[k] += Ii*s_V[j][n];
              r_W[k] += Ii*s_W[j][n];
            }
          }
        }
      }

      @barrier("local");

      for(int j=0;j<p_cubNq;++j;@inner(1)){ 
        for(int i=0;i<p_cubNq;++i;@inner(0)){
          if(j<p_Nq){
            s_U[j][i] = r_U[k];
            s_V[j][i] = r_V[k];
            s_W[j][i] = r_W[k];
          }
        }
      }

      @barrier("local");

      for(int j=0;j<p_cubNq;++j;@inner(1)){ 
        for(int i=0;i<p_cubNq;++i;@inner(0)){
          r_U[k] = 0; r_V[k] = 0; r_W[k] = 0;

          #pragma unroll p_Nq
          for (int n=0;n<p_Nq;n++) {
            const dfloat Ij = s_cubInterpT[n][j];
            r_U[k] += Ij*s_U[n][i];
            r_V[k] += Ij*s_V[n][i];
            r_W[k] += Ij*s_W[n][i];
          }

          const dlong id =e*p_cubNp + k*p_cubNq*p_cubNq + j*p_cubNq + i;
          cUd[id] = r_U[k];
          cVd[id] = r_V[k];
          cWd[id] = r_W[k];
        }
      }
      @barrier("local");
    }
  }

  @barrier("global");

  //-----------------------------@kernel 2 do the reference divergence
  for(dlong e=0; e<Nelements; ++e; @outer(0)) {

    @shared dfloat s_F11[p_cubNq][p_cubNq];
    @shared dfloat s_F12[p_cubNq][p_cubNq];
    @shared dfloat s_F13[p_cubNq][p_cubNq];
    @shared dfloat s_F21[p_cubNq][p_cubNq];
    @shared dfloat s_F22[p_cubNq][p_cubNq];
    @shared dfloat s_F23[p_cubNq][p_cubNq];
    @shared dfloat s_F31[p_cubNq][p_cubNq];
    @shared dfloat s_F32[p_cubNq][p_cubNq];
    @shared dfloat s_F33[p_cubNq][p_cubNq];

    @shared dfloat s_cubD[p_cubNq][p_cubNq];

    @exclusive dfloat r_NU[p_cubNq], r_NV[p_cubNq], r_NW[p_cubNq];

    for(int j=0;j<p_cubNq;++j;@inner(1)){ 
      for(int i=0;i<p_cubNq;++i;@inner(0)){
        const int id = i+j*p_cubNq;
        s_cubD[0][id] = cubD[id];

        #pragma unroll p_cubNq
          for(int k=0;k<p_cubNq;++k){         
            r_NU[k] = 0.;
            r_NV[k] = 0.;
            r_NW[k] = 0.;
          }
      }
    }

    @barrier("local");

    #pragma unroll p_cubNq
    for(int k=0;k<p_cubNq;++k){ 

      //fetch slice
      for(int j=0;j<p_cubNq;++j;@inner(1)){ 
        for(int i=0;i<p_cubNq;++i;@inner(0)){
          const dlong gid = e*p_cubNp*p_Nvgeo+ k*p_cubNq*p_cubNq + j*p_cubNq +i;
          const dfloat drdx = cubvgeo[gid + p_RXID*p_cubNp];
          const dfloat drdy = cubvgeo[gid + p_RYID*p_cubNp];
          const dfloat drdz = cubvgeo[gid + p_RZID*p_cubNp];
          const dfloat dsdx = cubvgeo[gid + p_SXID*p_cubNp];
          const dfloat dsdy = cubvgeo[gid + p_SYID*p_cubNp];
          const dfloat dsdz = cubvgeo[gid + p_SZID*p_cubNp];
          const dfloat dtdx = cubvgeo[gid + p_TXID*p_cubNp];
          const dfloat dtdy = cubvgeo[gid + p_TYID*p_cubNp];
          const dfloat dtdz = cubvgeo[gid + p_TZID*p_cubNp];
          const dfloat JW   = cubvgeo[gid + p_JWID*p_cubNp];

          const dlong id =e*p_cubNp + k*p_cubNq*p_cubNq + j*p_cubNq + i;
          const dfloat Un = cU[id];
          const dfloat Vn = cV[id];
          const dfloat Wn = cW[id];
          const dfloat Udn = cUd[id];
          const dfloat Vdn = cVd[id];
          const dfloat Wdn = cWd[id];

          const dfloat cUn = JW*(drdx*Un+drdy*Vn+drdz*Wn);
          const dfloat cVn = JW*(dsdx*Un+dsdy*Vn+dsdz*Wn);
          const dfloat cWn = JW*(dtdx*Un+dtdy*Vn+dtdz*Wn);

          s_F11[j][i] = cUn*Udn;
          s_F12[j][i] = cVn*Udn;
          s_F13[j][i] = cWn*Udn;
          s_F21[j][i] = cUn*Vdn;
          s_F22[j][i] = cVn*Vdn;
          s_F23[j][i] = cWn*Vdn;
          s_F31[j][i] = cUn*Wdn;
          s_F32[j][i] = cVn*Wdn;
          s_F33[j][i] = cWn*Wdn;
        }
      }

      @barrier("local");

      for(int j=0;j<p_cubNq;++j;@inner(1)){ 
        for(int i=0;i<p_cubNq;++i;@inner(0)){
          #pragma unroll p_cubNq
            for (int n=0;n<p_cubNq;n++) {
              const dfloat Dr = s_cubD[n][i];
              const dfloat Ds = s_cubD[n][j];
              const dfloat Dt = s_cubD[k][n];
              r_NU[k] += Dr*s_F11[j][n];
              r_NV[k] += Dr*s_F21[j][n];
              r_NW[k] += Dr*s_F31[j][n];

              r_NU[k] += Ds*s_F12[n][i];
              r_NV[k] += Ds*s_F22[n][i];
              r_NW[k] += Ds*s_F32[n][i];

              r_NU[n] += Dt*s_F13[j][i];
              r_NV[n] += Dt*s_F23[j][i];
              r_NW[n] += Dt*s_F33[j][i];
            }
        }
      }

      @barrier("local");
    } //k loop

    //write out
    for(int j=0;j<p_cubNq;++j;@inner(1)){ 
      for(int i=0;i<p_cubNq;++i;@inner(0)){
        #pragma unroll p_cubNq
          for(int k=0;k<p_cubNq;++k){
            const dlong id =e*p_cubNp + k*p_cubNq*p_cubNq + j*p_cubNq + i;
            cU[id] = r_NU[k];
            cV[id] = r_NV[k];
            cW[id] = r_NW[k];
          }
      }
    }
  }

  @barrier("global");

  //---------------------------@kernel 3 project fluxes back to GLL grid
  for(dlong e=0; e<Nelements; ++e; @outer(0)) {
    @shared dfloat s_NU[p_cubNq][p_cubNq];
    @shared dfloat s_NV[p_cubNq][p_cubNq];
    @shared dfloat s_NW[p_cubNq][p_cubNq];
    @shared dfloat s_cubProjectT[p_cubNq][p_Nq];

    @exclusive dfloat r_NU[p_Nq], r_NV[p_Nq], r_NW[p_Nq];

    for(int j=0;j<p_cubNq;++j;@inner(1)){
      for(int i=0;i<p_cubNq;++i;@inner(0)){
        const int id = i+j*p_cubNq;
        if (id<p_Nq*p_cubNq) {
          s_cubProjectT[0][id] = cubProjectT[id];
        }
        
        #pragma unroll p_Nq
          for(int k=0;k<p_Nq;++k){         
            r_NU[k] = 0.;
            r_NV[k] = 0.;
            r_NW[k] = 0.;
          }
      }
    }

    @barrier("local");

    //read in and project in k
    for(int j=0;j<p_cubNq;++j;@inner(1)){
      for(int i=0;i<p_cubNq;++i;@inner(0)){
        #pragma unroll p_cubNq
        for(int k=0;k<p_cubNq;++k){
          const dlong id = e*p_cubNp + k*p_cubNq*p_cubNq + j*p_cubNq + i;
          const dfloat NUn = cU[id];
          const dfloat NVn = cV[id];
          const dfloat NWn = cW[id];

          #pragma unroll p_Nq
          for(int n=0;n<p_Nq;++n){
            const dfloat Pk = s_cubProjectT[k][n];
            r_NU[n] += Pk*NUn;
            r_NV[n] += Pk*NVn;
            r_NW[n] += Pk*NWn;
          }
        }
      }
    }

    @barrier("local");

    #pragma unroll p_Nq
    for(int k=0;k<p_Nq;++k){ 
      //load slice to @shared
      for(int j=0;j<p_cubNq;++j;@inner(1)){ 
        for(int i=0;i<p_cubNq;++i;@inner(0)){
          s_NU[j][i] = r_NU[k];
          s_NV[j][i] = r_NV[k];
          s_NW[j][i] = r_NW[k];
        }
      }

      @barrier("local");

      for(int j=0;j<p_cubNq;++j;@inner(1)){ 
        for(int i=0;i<p_cubNq;++i;@inner(0)){
          if(j<p_Nq){
            r_NU[k] = 0; r_NV[k] = 0; r_NW[k] = 0;

            #pragma unroll p_cubNq
            for (int n=0;n<p_cubNq;n++) {
              const dfloat Pj = s_cubProjectT[n][j];
              r_NU[k] += Pj*s_NU[n][i];
              r_NV[k] += Pj*s_NV[n][i];
              r_NW[k] += Pj*s_NW[n][i];
            }
          }
        }
      }

      @barrier("local");

      for(int j=0;j<p_cubNq;++j;@inner(1)){ 
        for(int i=0;i<p_cubNq;++i;@inner(0)){
          if(j<p_Nq){
            s_NU[j][i] = r_NU[k];
            s_NV[j][i] = r_NV[k];
            s_NW[j][i] = r_NW[k];
          }
        }
      }

      @barrier("local");

      for(int j=0;j<p_cubNq;++j;@inner(1)){ 
        for(int i=0;i<p_cubNq;++i;@inner(0)){
          if (i<p_Nq && j<p_Nq) {
            const dlong gid = e*p_Np*p_Nvgeo+ k*p_Nq*p_Nq + j*p_Nq +i;
            const dfloat invJW = vgeo[gid + p_IJWID*p_Np];

            r_NU[k] = 0; r_NV[k] = 0; r_NW[k] = 0;

            #pragma unroll p_cubNq
            for (int n=0;n<p_cubNq;n++) {
              const dfloat Pi = s_cubProjectT[n][i];
              r_NU[k] += Pi*s_NU[j][n];
              r_NV[k] += Pi*s_NV[j][n];
              r_NW[k] += Pi*s_NW[j][n];
            }

            const dlong id = e*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
            NU[id] = -invJW*r_NU[k];
            NV[id] = -invJW*r_NV[k];
            NW[id] = -invJW*r_NW[k];
          }
        }
      }
      @barrier("local");
    }
  }
}
#else 

//unified @kernel, but might use too much memory
@kernel void insSubCycleCubatureVolumeHex3D(const dlong Nelements,
                                           @restrict const  dfloat *  vgeo,
                                           @restrict const  dfloat *  cubvgeo,
                                           @restrict const  dfloat *  cubD,
                                           @restrict const  dfloat *  cubInterpT,
                                           @restrict const  dfloat *  cubProjectT,
                                           @restrict const  dfloat *  U,
                                           @restrict const  dfloat *  V,
                                           @restrict const  dfloat *  W,
                                           @restrict const  dfloat *  Ud,
                                           @restrict const  dfloat *  Vd,
                                           @restrict const  dfloat *  Wd,
                                                 @restrict dfloat *  cU, //storage for interpolated fields
                                                 @restrict dfloat *  cV, //storage for interpolated fields
                                                 @restrict dfloat *  cW, //storage for interpolated fields
                                                 @restrict dfloat *  cUd, //storage for interpolated fields
                                                 @restrict dfloat *  cVd, //storage for interpolated fields
                                                 @restrict dfloat *  cWd, //storage for interpolated fields
                                                 @restrict dfloat *  NU,
                                                 @restrict dfloat *  NV,
                                                 @restrict dfloat *  NW){

  //----------------------------@kernel 1 interpolate velocity fields to quadrature points
  for(dlong e=0; e<Nelements; ++e; @outer(0)) {

    @shared dfloat s_cubD[p_cubNq][p_cubNq];
    @shared dfloat s_cubInterpT[p_Nq][p_cubNq];
    @shared dfloat s_cubProjectT[p_cubNq][p_Nq];


    @shared dfloat s_F11[p_cubNq][p_cubNq];
    @shared dfloat s_F12[p_cubNq][p_cubNq];
    @shared dfloat s_F13[p_cubNq][p_cubNq];
    @shared dfloat s_F21[p_cubNq][p_cubNq];
    @shared dfloat s_F22[p_cubNq][p_cubNq];
    @shared dfloat s_F23[p_cubNq][p_cubNq];
    @shared dfloat s_F31[p_cubNq][p_cubNq];
    @shared dfloat s_F32[p_cubNq][p_cubNq];
    @shared dfloat s_F33[p_cubNq][p_cubNq];

    #define s_U s_F11
    #define s_V s_F12
    #define s_W s_F13
    #define s_Ud s_F21
    #define s_Vd s_F22
    #define s_Wd s_F23

    #define s_NU s_F31
    #define s_NV s_F32
    #define s_NW s_F33

    @exclusive dfloat r_U[p_cubNq], r_V[p_cubNq], r_W[p_cubNq];
    @exclusive dfloat r_Ud[p_cubNq], r_Vd[p_cubNq], r_Wd[p_cubNq];
    @exclusive dfloat r_NU[p_cubNq], r_NV[p_cubNq], r_NW[p_cubNq];

    for(int j=0;j<p_cubNq;++j;@inner(1)){
      for(int i=0;i<p_cubNq;++i;@inner(0)){
        const int id = i+j*p_cubNq;
        if (id<p_Nq*p_cubNq) {
          s_cubInterpT[0][id] = cubInterpT[id];
          s_cubProjectT[0][id] = cubProjectT[id];
        }
        s_cubD[0][id] = cubD[id];

        #pragma unroll p_cubNq
          for(int k=0;k<p_cubNq;++k){         
            r_U[k] = 0.;
            r_V[k] = 0.;
            r_W[k] = 0.;
            r_Ud[k] = 0.;
            r_Vd[k] = 0.;
            r_Wd[k] = 0.;
            r_NU[k] = 0.;
            r_NV[k] = 0.;
            r_NW[k] = 0.;
          }
      }
    }

    @barrier("local");

    //read in and interpolate in k
    for(int j=0;j<p_cubNq;++j;@inner(1)){
      for(int i=0;i<p_cubNq;++i;@inner(0)){
        if (i<p_Nq && j<p_Nq) {
          #pragma unroll p_Nq
          for(int k=0;k<p_Nq;++k){
            const dlong id = e*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
            const dfloat uc = U[id];
            const dfloat vc = V[id];
            const dfloat wc = W[id];
            const dfloat udc = Ud[id];
            const dfloat vdc = Vd[id];
            const dfloat wdc = Wd[id];

            #pragma unroll p_cubNq
            for(int n=0;n<p_cubNq;++n){
              const dfloat Ik = s_cubInterpT[k][n];
              r_U[n] += Ik*uc;
              r_V[n] += Ik*vc;
              r_W[n] += Ik*wc;
              r_Ud[n] += Ik*udc;
              r_Vd[n] += Ik*vdc;
              r_Wd[n] += Ik*wdc;
            }
          }
        }
      }
    }

    @barrier("local");

    #pragma unroll p_cubNq
    for(int k=0;k<p_cubNq;++k){ 
      //load slice to @shared
      for(int j=0;j<p_cubNq;++j;@inner(1)){ 
        for(int i=0;i<p_cubNq;++i;@inner(0)){
          if (i<p_Nq && j<p_Nq) {
            s_U[j][i] = r_U[k];
            s_V[j][i] = r_V[k];
            s_W[j][i] = r_W[k];
            s_Ud[j][i] = r_Ud[k];
            s_Vd[j][i] = r_Vd[k];
            s_Wd[j][i] = r_Wd[k];
          }
        }
      }

      @barrier("local");

      for(int j=0;j<p_cubNq;++j;@inner(1)){ 
        for(int i=0;i<p_cubNq;++i;@inner(0)){
          if(j<p_Nq){
            r_U[k] = 0; r_V[k] = 0; r_W[k] = 0;
            r_Ud[k] = 0; r_Vd[k] = 0; r_Wd[k] = 0;

            #pragma unroll p_Nq
            for (int n=0;n<p_Nq;n++) {
              const dfloat Ii = s_cubInterpT[n][i];
              r_U[k] += Ii*s_U[j][n];
              r_V[k] += Ii*s_V[j][n];
              r_W[k] += Ii*s_W[j][n];
              r_Ud[k] += Ii*s_Ud[j][n];
              r_Vd[k] += Ii*s_Vd[j][n];
              r_Wd[k] += Ii*s_Wd[j][n];
            }
          }
        }
      }

      @barrier("local");

      for(int j=0;j<p_cubNq;++j;@inner(1)){ 
        for(int i=0;i<p_cubNq;++i;@inner(0)){
          if(j<p_Nq){
            s_U[j][i] = r_U[k];
            s_V[j][i] = r_V[k];
            s_W[j][i] = r_W[k];
            s_Ud[j][i] = r_Ud[k];
            s_Vd[j][i] = r_Vd[k];
            s_Wd[j][i] = r_Wd[k];
          }
        }
      }

      @barrier("local");

      for(int j=0;j<p_cubNq;++j;@inner(1)){ 
        for(int i=0;i<p_cubNq;++i;@inner(0)){
          r_U[k] = 0; r_V[k] = 0; r_W[k] = 0;
          r_Ud[k] = 0; r_Vd[k] = 0; r_Wd[k] = 0;

          #pragma unroll p_Nq
          for (int n=0;n<p_Nq;n++) {
            const dfloat Ij = s_cubInterpT[n][j];
            r_U[k] += Ij*s_U[n][i];
            r_V[k] += Ij*s_V[n][i];
            r_W[k] += Ij*s_W[n][i];
            r_Ud[k] += Ij*s_Ud[n][i];
            r_Vd[k] += Ij*s_Vd[n][i];
            r_Wd[k] += Ij*s_Wd[n][i];
          }
        }
      }
      @barrier("local");      
    }


    #pragma unroll p_cubNq
    for(int k=0;k<p_cubNq;++k){ 

      //fetch slice
      for(int j=0;j<p_cubNq;++j;@inner(1)){ 
        for(int i=0;i<p_cubNq;++i;@inner(0)){
          const dlong gid = e*p_cubNp*p_Nvgeo+ k*p_cubNq*p_cubNq + j*p_cubNq +i;
          const dfloat drdx = cubvgeo[gid + p_RXID*p_cubNp];
          const dfloat drdy = cubvgeo[gid + p_RYID*p_cubNp];
          const dfloat drdz = cubvgeo[gid + p_RZID*p_cubNp];
          const dfloat dsdx = cubvgeo[gid + p_SXID*p_cubNp];
          const dfloat dsdy = cubvgeo[gid + p_SYID*p_cubNp];
          const dfloat dsdz = cubvgeo[gid + p_SZID*p_cubNp];
          const dfloat dtdx = cubvgeo[gid + p_TXID*p_cubNp];
          const dfloat dtdy = cubvgeo[gid + p_TYID*p_cubNp];
          const dfloat dtdz = cubvgeo[gid + p_TZID*p_cubNp];
          const dfloat JW   = cubvgeo[gid + p_JWID*p_cubNp];

          const dfloat Un = r_U[k];
          const dfloat Vn = r_V[k];
          const dfloat Wn = r_W[k];
          const dfloat Udn = r_Ud[k];
          const dfloat Vdn = r_Vd[k];
          const dfloat Wdn = r_Wd[k];

          const dfloat cUn = JW*(drdx*Un+drdy*Vn+drdz*Wn);
          const dfloat cVn = JW*(dsdx*Un+dsdy*Vn+dsdz*Wn);
          const dfloat cWn = JW*(dtdx*Un+dtdy*Vn+dtdz*Wn);

          s_F11[j][i] = cUn*Udn;
          s_F12[j][i] = cVn*Udn;
          s_F13[j][i] = cWn*Udn;
          s_F21[j][i] = cUn*Vdn;
          s_F22[j][i] = cVn*Vdn;
          s_F23[j][i] = cWn*Vdn;
          s_F31[j][i] = cUn*Wdn;
          s_F32[j][i] = cVn*Wdn;
          s_F33[j][i] = cWn*Wdn;
        }
      }

      @barrier("local");

      for(int j=0;j<p_cubNq;++j;@inner(1)){ 
        for(int i=0;i<p_cubNq;++i;@inner(0)){
          #pragma unroll p_cubNq
            for (int n=0;n<p_cubNq;n++) {
              const dfloat Dr = s_cubD[n][i];
              const dfloat Ds = s_cubD[n][j];
              const dfloat Dt = s_cubD[k][n];
              r_NU[k] += Dr*s_F11[j][n];
              r_NV[k] += Dr*s_F21[j][n];
              r_NW[k] += Dr*s_F31[j][n];

              r_NU[k] += Ds*s_F12[n][i];
              r_NV[k] += Ds*s_F22[n][i];
              r_NW[k] += Ds*s_F32[n][i];

              r_NU[n] += Dt*s_F13[j][i];
              r_NV[n] += Dt*s_F23[j][i];
              r_NW[n] += Dt*s_F33[j][i];
            }
        }
      }

      @barrier("local");
    } //k loop


    #pragma unroll p_cubNq
    for(int k=0;k<p_cubNq;++k){ 
      //load slice to @shared
      for(int j=0;j<p_cubNq;++j;@inner(1)){ 
        for(int i=0;i<p_cubNq;++i;@inner(0)){
          s_NU[j][i] = r_NU[k];
          s_NV[j][i] = r_NV[k];
          s_NW[j][i] = r_NW[k];
        }
      }

      @barrier("local");

      for(int j=0;j<p_cubNq;++j;@inner(1)){ 
        for(int i=0;i<p_cubNq;++i;@inner(0)){
          if(j<p_Nq){
            r_NU[k] = 0; r_NV[k] = 0; r_NW[k] = 0;

            #pragma unroll p_cubNq
            for (int n=0;n<p_cubNq;n++) {
              const dfloat Pj = s_cubProjectT[n][j];
              r_NU[k] += Pj*s_NU[n][i];
              r_NV[k] += Pj*s_NV[n][i];
              r_NW[k] += Pj*s_NW[n][i];
            }
          }
        }
      }

      @barrier("local");

      for(int j=0;j<p_cubNq;++j;@inner(1)){ 
        for(int i=0;i<p_cubNq;++i;@inner(0)){
          if(j<p_Nq){
            s_NU[j][i] = r_NU[k];
            s_NV[j][i] = r_NV[k];
            s_NW[j][i] = r_NW[k];
          }
        }
      }

      @barrier("local");

      for(int j=0;j<p_cubNq;++j;@inner(1)){ 
        for(int i=0;i<p_cubNq;++i;@inner(0)){
          if ((i<p_Nq) && (j<p_Nq)) {
            r_NU[k] = 0; r_NV[k] = 0; r_NW[k] = 0;

            #pragma unroll p_cubNq
            for (int n=0;n<p_cubNq;n++) {
              const dfloat Pi = s_cubProjectT[n][i];
              r_NU[k] += Pi*s_NU[j][n];
              r_NV[k] += Pi*s_NV[j][n];
              r_NW[k] += Pi*s_NW[j][n];
            }
          }
        }
      }
      
      @barrier("local");
    }

    //project in k and write out
    for(int j=0;j<p_cubNq;++j;@inner(1)){
      for(int i=0;i<p_cubNq;++i;@inner(0)){
        if ((i<p_Nq) && (j<p_Nq)) {
          #pragma unroll p_Nq
          for(int k=0;k<p_Nq;++k){    
            dfloat nu=0., nv=0., nw=0.; 

            #pragma unroll p_cubNq
            for(int n=0;n<p_cubNq;++n){
              const dfloat Pk = s_cubProjectT[n][k];
              nu += Pk*r_NU[n];
              nv += Pk*r_NV[n];
              nw += Pk*r_NW[n];
            }

            const dlong gid = e*p_Np*p_Nvgeo+ k*p_Nq*p_Nq + j*p_Nq +i;
            const dfloat invJW = vgeo[gid + p_IJWID*p_Np];

            const dlong id = e*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
            NU[id] = -invJW*nu;
            NV[id] = -invJW*nv;
            NW[id] = -invJW*nw;
          }
        }
      }
    }
  }
}
#endif 


#define quadSurfaceTerms(face)                           \
{                                                                       \
  for(int j=0;j<p_cubNq;++j;@inner(1)){\
    for(int i=0;i<p_cubNq;++i;@inner(0)){\
      if(i<p_Nq && j<p_Nq){\
        const dlong id  = e*p_Nfp*p_Nfaces + face*p_Nfp + j*p_Nq +i;\
        const dlong idM = vmapM[id];\
        const dlong idP = vmapP[id];\
        s_UM[j][i] = U[idM];\
        s_VM[j][i] = V[idM];\
        s_WM[j][i] = W[idM];\
        s_UP[j][i] = U[idP];\
        s_VP[j][i] = V[idP];\
        s_WP[j][i] = W[idP];\
      }\
    }\
  }\
\
  @barrier("local");\
\
  for(int j=0;j<p_cubNq;++j;@inner(1)){\
    for(int i=0;i<p_cubNq;++i;@inner(0)){\
      if (j<p_Nq) {\
        r_UMn = 0.; r_VMn = 0.; r_WMn = 0.;\
        r_UPn = 0.; r_VPn = 0.; r_WPn = 0.;\
        #pragma unroll p_Nq\
        for (int n=0;n<p_Nq;n++) {\
          const dfloat Ini = s_cubInterpT[n][i];\
          r_UMn  += Ini*s_UM[j][n];\
          r_VMn  += Ini*s_VM[j][n];\
          r_WMn  += Ini*s_WM[j][n];\
          r_UPn  += Ini*s_UP[j][n];\
          r_VPn  += Ini*s_VP[j][n];\
          r_WPn  += Ini*s_WP[j][n];\
        }\
      }\
    }\
  }\
\
  @barrier("local");\
\
  for(int j=0;j<p_cubNq;++j;@inner(1)){\
    for(int i=0;i<p_cubNq;++i;@inner(0)){\
      if (j<p_Nq) {\
        s_UM[j][i] = r_UMn;\
        s_VM[j][i] = r_VMn;\
        s_WM[j][i] = r_WMn;\
        s_UP[j][i] = r_UPn;\
        s_VP[j][i] = r_VPn;\
        s_WP[j][i] = r_WPn;\
      }\
    }\
  }\
\
  @barrier("local");\
\
  for(int j=0;j<p_cubNq;++j;@inner(1)){\
    for(int i=0;i<p_cubNq;++i;@inner(0)){\
      r_UMn = 0.; r_VMn = 0.; r_WMn = 0.;\
      r_UPn = 0.; r_VPn = 0.; r_WPn = 0.;\
      #pragma unroll p_Nq\
      for (int n=0;n<p_Nq;n++) {\
        const dfloat Inj = s_cubInterpT[n][j];\
        r_UMn += Inj*s_UM[n][i];\
        r_VMn += Inj*s_VM[n][i];\
        r_WMn += Inj*s_WM[n][i];\
        r_UPn += Inj*s_UP[n][i];\
        r_VPn += Inj*s_VP[n][i];\
        r_WPn += Inj*s_WP[n][i];\
      }\
    }\
  }\
\
  @barrier("local");\
\
  for(int j=0;j<p_cubNq;++j;@inner(1)){\
    for(int i=0;i<p_cubNq;++i;@inner(0)){\
      if(i<p_Nq && j<p_Nq){\
        const dlong id  = e*p_Nfp*p_Nfaces + face*p_Nfp + j*p_Nq +i;\
        const dlong idM = vmapM[id];\
        const dlong idP = vmapP[id];\
        s_UM[j][i] = Ud[idM];\
        s_VM[j][i] = Vd[idM];\
        s_WM[j][i] = Wd[idM];\
        s_UP[j][i] = Ud[idP];\
        s_VP[j][i] = Vd[idP];\
        s_WP[j][i] = Wd[idP];\
      }\
    }\
  }\
\
  @barrier("local");\
\
  for(int j=0;j<p_cubNq;++j;@inner(1)){\
    for(int i=0;i<p_cubNq;++i;@inner(0)){\
      if (j<p_Nq) {\
        r_UdMn = 0.; r_VdMn = 0.; r_WdMn = 0.;\
        r_UdPn = 0.; r_VdPn = 0.; r_WdPn = 0.;\
        #pragma unroll p_Nq\
        for (int n=0;n<p_Nq;n++) {\
          const dfloat Ini = s_cubInterpT[n][i];\
          r_UdMn  += Ini*s_UM[j][n];\
          r_VdMn  += Ini*s_VM[j][n];\
          r_WdMn  += Ini*s_WM[j][n];\
          r_UdPn  += Ini*s_UP[j][n];\
          r_VdPn  += Ini*s_VP[j][n];\
          r_WdPn  += Ini*s_WP[j][n];\
        }\
      }\
    }\
  }\
\
  @barrier("local");\
\
  for(int j=0;j<p_cubNq;++j;@inner(1)){\
    for(int i=0;i<p_cubNq;++i;@inner(0)){\
      if (j<p_Nq) {\
        s_UM[j][i] = r_UdMn;\
        s_VM[j][i] = r_VdMn;\
        s_WM[j][i] = r_WdMn;\
        s_UP[j][i] = r_UdPn;\
        s_VP[j][i] = r_VdPn;\
        s_WP[j][i] = r_WdPn;\
      }\
    }\
  }\
\
  @barrier("local");\
\
  for(int j=0;j<p_cubNq;++j;@inner(1)){\
    for(int i=0;i<p_cubNq;++i;@inner(0)){\
      r_UdMn = 0.; r_VdMn = 0.; r_WdMn = 0.;\
      r_UdPn = 0.; r_VdPn = 0.; r_WdPn = 0.;\
      #pragma unroll p_Nq\
      for (int n=0;n<p_Nq;n++) {\
        const dfloat Inj = s_cubInterpT[n][j];\
        r_UdMn += Inj*s_UM[n][i];\
        r_VdMn += Inj*s_VM[n][i];\
        r_WdMn += Inj*s_WM[n][i];\
        r_UdPn += Inj*s_UP[n][i];\
        r_VdPn += Inj*s_VP[n][i];\
        r_WdPn += Inj*s_WP[n][i];\
      }\
    }\
  }\
\
  @barrier("local");\
\
  for(int j=0;j<p_cubNq;++j;@inner(1)){\
    for(int i=0;i<p_cubNq;++i;@inner(0)){\
      const dlong sk = e*p_cubNfp*p_Nfaces + face*p_cubNfp + j*p_cubNq + i;\
      const dfloat nx = cubsgeo[sk*p_Nsgeo+p_NXID];\
      const dfloat ny = cubsgeo[sk*p_Nsgeo+p_NYID];\
      const dfloat nz = cubsgeo[sk*p_Nsgeo+p_NZID];\
      const dfloat WsJ = cubsgeo[sk*p_Nsgeo+p_WSJID];\
      const dfloat uM = r_UMn, vM = r_VMn, wM = r_WMn;\
      const dfloat uP = r_UPn, vP = r_VPn, wP = r_WPn;\
      const dfloat udM = r_UdMn, vdM = r_VdMn, wdM = r_WdMn;\
            dfloat udP = r_UdPn, vdP = r_VdPn, wdP = r_WdPn;\
\
      const int bc = EToB[face+p_Nfaces*e];\
      if(bc>0) {\
        insVelocityDirichletConditions3D(bc, time, intx[e*p_Nfaces*p_cubNfp + face*p_cubNfp + j*p_cubNq + i],\
                                                   inty[e*p_Nfaces*p_cubNfp + face*p_cubNfp + j*p_cubNq + i],\
                                                   intz[e*p_Nfaces*p_cubNfp + face*p_cubNfp + j*p_cubNq + i], nx, ny, nz, udM, vdM, wdM, &udP, &vdP, &wdP);\
        udP *= bScale;\
        vdP *= bScale;\
        wdP *= bScale;\
      }\
\
      const dfloat unM   = fabs(nx*uM + ny*vM + nz*wM);\
      const dfloat unP   = fabs(nx*uP + ny*vP + nz*wP);\
      const dfloat unMax = (unM > unP) ? unM : unP;\
\
      s_fluxNU[j][i] = WsJ*(.5f*(nx*(uP*udP + uM*udM)\
                               + ny*(vP*udP + vM*udM)\
                               + nz*(wP*udP + wM*udM)  + unMax*(udM-udP) ));\
      s_fluxNV[j][i] = WsJ*(.5f*(nx*(uP*vdP + uM*vdM)\
                               + ny*(vP*vdP + vM*vdM)\
                               + nz*(wP*vdP + wM*vdM)  + unMax*(vdM-vdP) ));\
      s_fluxNW[j][i] = WsJ*(.5f*(nx*(uP*wdP + uM*wdM)\
                               + ny*(vP*wdP + vM*wdM)\
                               + nz*(wP*wdP + wM*wdM)  + unMax*(wdM-wdP) ));\
    }\
  }\
\
  @barrier("local");\
\
  for(int j=0;j<p_cubNq;++j;@inner(1)){\
    for(int i=0;i<p_cubNq;++i;@inner(0)){\
      if (j<p_Nq) {\
        r_NUn = 0.; r_NVn = 0.; r_NWn = 0.;\
        #pragma unroll p_cubNq\
        for (int n=0;n<p_cubNq;n++) {\
          const dfloat Pnj = s_cubProjectT[n][j];\
          r_NUn  += Pnj*s_fluxNU[n][i];\
          r_NVn  += Pnj*s_fluxNV[n][i];\
          r_NWn  += Pnj*s_fluxNW[n][i];\
        }\
      }\
    }\
  }\
\
  @barrier("local");\
\
  for(int j=0;j<p_cubNq;++j;@inner(1)){\
    for(int i=0;i<p_cubNq;++i;@inner(0)){\
      if (j<p_Nq) {\
        s_fluxNU[j][i] = r_NUn;\
        s_fluxNV[j][i] = r_NVn;\
        s_fluxNW[j][i] = r_NWn;\
      }\
    }\
  }\
\
  for(int j=0;j<p_cubNq;++j;@inner(1)){\
    for(int i=0;i<p_cubNq;++i;@inner(0)){\
      if (j<p_Nq && i<p_Nq) {\
        r_NUn = 0.; r_NVn = 0.; r_NWn = 0.;\
        #pragma unroll p_cubNq\
        for(int n=0;n<p_cubNq;++n){\
          const dfloat Pni = s_cubProjectT[n][i];\
          r_NUn += Pni*s_fluxNU[j][n];\
          r_NVn += Pni*s_fluxNV[j][n];\
          r_NWn += Pni*s_fluxNW[j][n];\
        }\
      }\
    }\
  }\
\
  @barrier("local");\
\
  for(int j=0;j<p_cubNq;++j;@inner(1)){\
    for(int i=0;i<p_cubNq;++i;@inner(0)){\
      if (j<p_Nq && i<p_Nq) {\
        s_fluxNU[j][i] = r_NUn;\
        s_fluxNV[j][i] = r_NVn;\
        s_fluxNW[j][i] = r_NWn;\
      }\
    }\
  }\
}


@kernel void insSubCycleCubatureSurfaceHex3D(const dlong Nelements,
                                            @restrict const  dfloat *  vgeo,
                                            @restrict const  dfloat *  cubsgeo,
                                            @restrict const  dlong  *  vmapM,
                                            @restrict const  dlong  *  vmapP,
                                            @restrict const  int    *  EToB,
                                            @restrict const  dfloat *  cubInterpT,
                                            @restrict const  dfloat *  cubProjectT,
                                            const dfloat bScale,
                                            const dfloat time,
                                            @restrict const  dfloat *  intx,
                                            @restrict const  dfloat *  inty,
                                            @restrict const  dfloat *  intz,
                                            @restrict const  dfloat *  U,
                                            @restrict const  dfloat *  V,
                                            @restrict const  dfloat *  W,
                                            @restrict const  dfloat *  Ud,
                                            @restrict const  dfloat *  Vd,
                                            @restrict const  dfloat *  Wd,
                                                  @restrict dfloat *  NU,
                                                  @restrict dfloat *  NV,
                                                  @restrict dfloat *  NW){

  // for all elements
  for(dlong e=0;e<Nelements;e++;@outer(0)){
    // @shared storage for flux terms
    @exclusive dfloat r_NU[p_Nq], r_NV[p_Nq], r_NW[p_Nq];

    @shared dfloat s_UM[p_cubNq][p_cubNq];
    @shared dfloat s_VM[p_cubNq][p_cubNq];
    @shared dfloat s_WM[p_cubNq][p_cubNq];
    @shared dfloat s_UP[p_cubNq][p_cubNq];
    @shared dfloat s_VP[p_cubNq][p_cubNq];
    @shared dfloat s_WP[p_cubNq][p_cubNq];

    // reuse @shared memory buffers
    #define s_fluxNU s_UM
    #define s_fluxNV s_VM
    #define s_fluxNW s_WM

    @exclusive dfloat r_UMn, r_VMn, r_WMn;
    @exclusive dfloat r_UPn, r_VPn, r_WPn;
    @exclusive dfloat r_UdMn, r_VdMn, r_WdMn;
    @exclusive dfloat r_UdPn, r_VdPn, r_WdPn;

    #define r_NUn r_UMn
    #define r_NVn r_VMn
    #define r_NWn r_WMn

    @shared dfloat s_cubInterpT[p_Nq][p_cubNq];
    @shared dfloat s_cubProjectT[p_cubNq][p_Nq];

    // for all face nodes of all elements
    for(int j=0;j<p_cubNq;++j;@inner(1)){
      for(int i=0;i<p_cubNq;++i;@inner(0)){
        //zero out resulting surface contributions
        #pragma unroll p_Nq
        for(int k=0;k<p_Nq;++k){
          r_NU[k] = 0.;
          r_NV[k] = 0.;
          r_NW[k] = 0.;
        }

        //fetch reference operators
        const int id = i+j*p_cubNq;
        if (id<p_Nq*p_cubNq) {
          s_cubInterpT[0][id] = cubInterpT[id];
          s_cubProjectT[0][id] = cubProjectT[id];
        }
      }
    }

    @barrier("local");

    quadSurfaceTerms(0) //face 0

    @barrier("local");    

    //accumulate in register pencil
    for(int j=0;j<p_cubNq;++j;@inner(1)){
      for(int i=0;i<p_cubNq;++i;@inner(0)){
        if (j<p_Nq && i<p_Nq) {
          r_NU[0] += s_fluxNU[j][i];
          r_NV[0] += s_fluxNV[j][i];
          r_NW[0] += s_fluxNW[j][i];
        }
      }
    }

    @barrier("local");

    quadSurfaceTerms(5) //face 5

    @barrier("local");    

    //accumulate in register pencil
    for(int j=0;j<p_cubNq;++j;@inner(1)){
      for(int i=0;i<p_cubNq;++i;@inner(0)){
        if (j<p_Nq && i<p_Nq) {
          r_NU[p_Nq-1] += s_fluxNU[j][i];
          r_NV[p_Nq-1] += s_fluxNV[j][i];
          r_NW[p_Nq-1] += s_fluxNW[j][i];
        }
      }
    }

    @barrier("local");

    quadSurfaceTerms(1) //face 1

    @barrier("local");    

    //accumulate in register pencil
    for(int j=0;j<p_cubNq;++j;@inner(1)){
      for(int i=0;i<p_cubNq;++i;@inner(0)){
        if (j==0 && i<p_Nq) {//face 1
          #pragma unroll p_Nq
          for (int n=0;n<p_Nq;n++) {
            r_NU[n] += s_fluxNU[n][i];
            r_NV[n] += s_fluxNV[n][i];
            r_NW[n] += s_fluxNW[n][i];
          }
        }
      }
    }

    @barrier("local");

    quadSurfaceTerms(3) //face 3

    @barrier("local");    

    //accumulate in register pencil
    for(int j=0;j<p_cubNq;++j;@inner(1)){
      for(int i=0;i<p_cubNq;++i;@inner(0)){
        if (j==p_Nq-1 && i<p_Nq) {//face 3
          #pragma unroll p_Nq
          for (int n=0;n<p_Nq;n++) {
            r_NU[n] += s_fluxNU[n][i];
            r_NV[n] += s_fluxNV[n][i];
            r_NW[n] += s_fluxNW[n][i];
          }
        }
      }
    }

    @barrier("local");

    quadSurfaceTerms(2) //face 2

    @barrier("local");    

    //accumulate in register pencil
    for(int j=0;j<p_cubNq;++j;@inner(1)){
      for(int i=0;i<p_cubNq;++i;@inner(0)){
        if (j<p_Nq && i==p_Nq-1) {//face 2
          #pragma unroll p_Nq
          for (int n=0;n<p_Nq;n++) {
            r_NU[n] += s_fluxNU[n][j];
            r_NV[n] += s_fluxNV[n][j];
            r_NW[n] += s_fluxNW[n][j];
          }
        }
      }
    }

    @barrier("local");

    quadSurfaceTerms(4) //face 4

    @barrier("local");    

    //accumulate in register pencil
    for(int j=0;j<p_cubNq;++j;@inner(1)){
      for(int i=0;i<p_cubNq;++i;@inner(0)){
        if (j<p_Nq && i==0) {//face 4
          #pragma unroll p_Nq
          for (int n=0;n<p_Nq;n++) {
            r_NU[n] += s_fluxNU[n][j];
            r_NV[n] += s_fluxNV[n][j];
            r_NW[n] += s_fluxNW[n][j];
          }
        }
      }
    }

    @barrier("local");

    for(int j=0;j<p_cubNq;++j;@inner(1)){
      for(int i=0;i<p_cubNq;++i;@inner(0)){
        if(i<p_Nq && j<p_Nq){
          #pragma unroll p_Nq
          for(int k=0;k<p_Nq;++k){
            const dlong gid = e*p_Np*p_Nvgeo+ k*p_Nq*p_Nq + j*p_Nq +i;
            const dfloat invJW = vgeo[gid + p_IJWID*p_Np];

            const dlong id = e*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

            NU[id] += invJW*r_NU[k];
            NV[id] += invJW*r_NV[k];
            NW[id] += invJW*r_NW[k];
          }
        }
      }
    }
  }
}
#undef quadSurfaceTerms
