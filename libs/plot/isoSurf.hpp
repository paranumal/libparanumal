/*

The MIT License (MIT)

Copyright (c) 2017-2023 Tim Warburton, Noel Chalmers, Jesse Chan, Ali Karakus

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/


#ifndef ISOSURF_HPP
#define ISOSURF_HPP 1

#include "platform.hpp"
#include "mesh.hpp"
#include "settings.hpp"
#include "timer.hpp"

// simplify syntax
typedef std::string         stdS;
typedef std::vector<int>    vecI;
typedef std::vector<stdS>   vecS;
typedef unsigned int        uint;


#ifdef _MSC_VER

// NBN: declare globals, logging utils, typedefs
#include "D:/TW/SIM/src/SIM_globals.h"
#include "D:/TW/SIM/src/SIM_log.h"
#undef min
#undef max

#else

// TODO: expose stubb for simple logging scheme
void nnLOG(int n, const char* format_str, ...);
void nnMSG(int n, const char* format_str, ...);
void nnTRC(int n, const char* format_str, ...);

#endif

// forward
namespace iso {
  class MyMesh2;      // mesh object for managing isosurface
}

namespace libp {

  enum isoMode_t {
    ISO_MODE_SURF,    // general 3D isosurface
    ISO_MODE_PLANE    // axis-aligned planar slices
  };


class isoSurfSettings_t : public settings_t {
public:
  isoSurfSettings_t() = default;
  isoSurfSettings_t(comm_t _comm);
  virtual void report();
};


class isoSurf_t {
public:
  platform_t platform;
  isoSurfSettings_t settings;
  properties_t props;
  comm_t comm;

  bool  m_is3D;
  int   m_rank;
  int   m_nranks;

  isoSurf_t() : m_is3D(true), m_rank(0), m_nranks(1), m_isoMesh(nullptr) {}

  virtual void Setup(platform_t& _platform, isoSurfSettings_t& _settings,
                     const mesh_t& mesh, properties_t& kernelInfo,
                     comm_t _comm);

  void doPlot(const mesh_t& mesh, const deviceMemory<dfloat>& o_q,
              const deviceMemory<dfloat>& o_Vort, int plotnum);

  // mesh object for managing isosurface
  iso::MyMesh2*  m_isoMesh;

  // compact/smooth/decimate trimesh isosurface
  int cleanSurface(int Ntris_in, int Nvort);

  // extract final isosurface
  int extractTrimesh();

  bool loadTriFaces(int Ntris, int Nvort);

  // read/write trimesh data in .obj format
  // [MeshLab] help debug mesh operations
  bool loadTrimesh_obj(const std::string& fname);
  bool writeTrimesh_obj(const std::string& fname);

  // [gmsh] export isosurface in .msh format
  void writeGmsh(const mesh_t& mesh, stdS& fname, int tstep,
                 int N_offset, int E_offset, int plotnum,
                 double plottime, bool bBinary=false);

  // [paraview] export isosurface in .vtu format
  void WriteVTU(std::ofstream& out, double plot_time) const;

  // [paraview] enable merging of pieces from multiple ranks
  void WriteVTU_parallel(const std::string& filename, const MPI_Comm comm) const;

  // [paraview] write XML wrapper listing filenames of each piece
  void WritePVTU(std::ostream& out, const vecS& piece_names, double plot_time);

  // [paraview] manage export of isosurface at current simulation time
  stdS ExportVTU(const stdS& plot_dir, const stdS& base_name, 
                 double plot_time, uint plot_num, 
                 uint plot_digits, uint n_groups=0);

  //---------------------------------------------
  // options loaded from libP "settings" file
  //---------------------------------------------
  int     isoMode;        // general 3D surface, or axis-aligned slices

  int     isoField;       // select field used for isosurfing
  int     isoColorField;  // select field used for plot color
  int     isoNlevels;     // num. contour levels
  int     isoMaxNumTris;  // limit num tris generated by isoSurf kernel

  dfloat  isoMinVal;      // first contour level
  dfloat  isoMaxVal;      // last contour level
  dfloat  isoVoxelSize;   // grid voxel size for merging small triangles
  dfloat  isoVertexTol;   // tolerance for merging close vertices

  //---------------------------------------------
  // miscellaneous
  //---------------------------------------------
  int      isoMaxNtris;     // limit num tris generated by isosurf kernel
  int      isoMaxQData;     // num dfloat data for isoQ allocation

  int      plotNvort;       // num fields exported by vort/valib kernel
  int      plotNfields;     // = mesh.dim + plotNvort
                            //    {x,y,z} + {mag,valib}
  int      plotNthreads;    // max(Np, max(plotNp, plotNelements));

  dfloat   m_clipBox[2][3]; // improve clipping of exported isosurface
  stdS     m_isoFilename;   // 

  memory<dfloat> isoLevels;     // transfer level data to device
  deviceMemory<dfloat> o_isoLevels;

  memory<dfloat> isoQ;          // receive trimesh data from device
  deviceMemory<dfloat> o_isoQ;

  memory<int> isoNtris;         // receive Ntris from isosurf kernel
  deviceMemory<int> o_isoNtris;

  deviceMemory<dlong> o_plotEToV;
  deviceMemory<dfloat> o_plotInterp;

  memory<dfloat> iso_node_data; // storage for compacted isosurf data
  memory<int>    iso_tri_ids;

  kernel_t isoSurfaceKernel;    // [occa] extract isosurfaces
};

} // namespace libp

#endif
