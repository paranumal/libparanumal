/*

The MIT License (MIT)

Copyright (c) 2017-2023 Tim Warburton, Noel Chalmers, Jesse Chan, Ali Karakus

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

#include "isoCleaner.hpp"
#include "isoSurf.hpp"

// When decimating a trimesh isosurface (or planar isoslice), 
// we want to preserve vertex resolution in regions with 
// steep gradients. For a general isosurface, this means
// regions with either high surface curvature or high scalar 
// variation. For planar isoslices, only scalar variation 
// is of interest. 
// 
// When loading triangular fragments from the isoSurf kernel, 
// we calculate a scalar variance used later to help scale 
// the cost of removing vertices in regions of interest.

// Toggle reporting of scalar variance:
#define NBN_DBG_QCOST  0


// Routines defined in this file:
// 
// - cleanSurface(...)
// - extractTrimesh()
// - loadTriFaces(...)
//
// Read/write trimesh data in MeshLab ".obj" format
// 
// - loadTrimesh_obj(...)
// - writeTrimesh_obj(...)


using namespace iso;

namespace libp {

int isoSurf_t::cleanSurface(int Ntris_in, int Nvort)
{
  // Simplify either general isosurfaces 
  // or planar, axis-aligned isoslices

  static int plot_num = -1; ++plot_num;
  std::string plot_file;

#ifdef _MSC_VER
  std::string plot_dir("D:/NN/_in/");
#else
  std::string plot_dir("./");     // FIXME: output directory
#endif

  int rank = comm.rank();

  nnMSG(1, "[proc:%02d] isoSurf_t::cleanSurface(%d, %d)\n", rank, Ntris_in, Nvort);
  if (Ntris_in < 1) {
    nnMSG(1, "[proc:%02d] Zero tri-faces for proc %d\n", rank);
    return 0;
  }

#if (1)

  // Load triangles generated by isosurface kernel.
  loadTriFaces(Ntris_in, Nvort);

#else
  // [debug] load triangles from .obj format file.
  // stdS infile = nnSTR("IN_raw_middle_114k.obj");
  // stdS infile = nnSTR("TEST_middle_259506.obj");
  // stdS infile = nnSTR("ISO_raw_p1.obj");
  // loadTrimesh_obj(infile);
#endif

  iso::MyMesh2& m = (*m_isoMesh);
  if (m.FN() < 1) {
    nnMSG(1, "[proc:%02d] Zero tri-faces for proc %d\n", rank, rank);
    return 0;
  }

#if (0)
  //-------------------------------------------------------
  // 0: plot raw triangles generated by kernel
  //-------------------------------------------------------
  plot_file = plot_dir + nnSTR("0__%02d_Raw_p%d.obj", plot_num, rank);
  writeTrimesh_obj(plot_file);
#endif

  int mrg_vert = 0;
  int del_vert = 0, del_vert2 = 0, del_vert3 = 0;
  int non_manf = 0;
  int numVoxels = 100000; // not used

  nnMSG(1, "[proc:%02d] Input mesh  vn:%i fn:%i\n", rank, m.VN(), m.FN());
  float dx = m.m_bbox.DimX(), dy = m.m_bbox.DimY(), dz = m.m_bbox.DimZ();
  nnMSG(1, "[proc:%02d] Bounding box size: (X,Y,Z): (%0.2f, %0.2f, %0.2f)\n", rank, dx, dy, dz);

  timePoint_t wallTimeStart = Time();
  timePoint_t wallTime1, wallTime2, wallTime3, wallTime4, wallTime5, wallTime6, wallTime7;
  double elapsedTime = 0.0;

  //-------------------------------------------------------
  // 1: Clustering
  //-------------------------------------------------------
  iso::Clustering<iso::AverageColorCell> Grid;
  Grid.Init(m.m_bbox, numVoxels, isoVoxelSize);

  // TODO: consider 64-bit integers for grid
  // 32-bit INT_MAX : 2,147,483,647
  // 32-bit UINT_MAX: 4,294,967,295

  const Point3i& gs = Grid.Grid.siz;
  const CoordType& gv = Grid.Grid.voxel;
  const int64_t gs012 = gs[0]*gs[1]*gs[2];  // 32-bit overflow

  nnMSG(1, "[proc:%02d] Clustering triangles into %lld cells:\n"
           "          voxel grid: %i x %i x %i\n"
           "          voxel size: (%.4f x %.4f x %.4f) units\n",
    rank, gs012, gs[0],gs[1],gs[2], gv[0],gv[1],gv[2]);

  Grid.AddMesh_Clip(m, m_clipBox);  // load faces in clipped region
//Grid.AddMesh(m);                  // load all faces
  Grid.ExtractMesh(m);              // extract clustered faces

  wallTime1 = Time();
  elapsedTime = ElapsedTime(wallTimeStart, wallTime1);
  nnTRC(1, "[proc:%02d] time for: Clustering...... %8.2lf\n", rank, elapsedTime);

#if (0)
  plot_file = plot_dir + nnSTR("1__%02d_Cluster_p%d.obj", plot_num, rank);
  writeTrimesh_obj(plot_file);
#endif

  //-------------------------------------------------------
  // 2: MergeCloseVertex
  //-------------------------------------------------------
  mrg_vert = iso::MergeCloseVertex(m, this->isoVertexTol);

  wallTime2 = Time();
  elapsedTime = ElapsedTime(wallTime1, wallTime2);
  nnTRC(1, "[proc:%02d] time for: MergeCloseVert.. %8.2lf\n", rank, elapsedTime);

#if (0)
  plot_file = plot_dir + nnSTR("2__%02d_MergeClose_p%d.obj", plot_num, rank);
  writeTrimesh_obj(plot_file);
#endif

  //-------------------------------------------------------
  // 3: RemoveSmallConnectedComponents
  //-------------------------------------------------------
  // When cleaning planar "isoslices", assume each slice 
  // forms a fully connected component. In which case we
  // don't need to call "RemoveSmallConnectedComponents"

  if (this->isoMode != ISO_MODE_PLANE) {

    // 3a: build face-face adjacency info
    // 3b: remove connected clusters with < [N=25] faces
    // 3c: delete any unreferenced vertices
    FaceFace(m);
    std::pair<int, int> delInfo;  int minCC = 25;

    delInfo = iso::RemoveSmallConnectedComponents(m, minCC);
    del_vert = iso::RemoveUnreferencedVertex(m);

    wallTime3 = Time();
    elapsedTime = ElapsedTime(wallTime2, wallTime3);
    nnTRC(1, "[proc:%02d] time for: RemoveSmallCC:1. %8.2lf\n", rank, elapsedTime);

#if (0)
    plot_file = plot_dir + nnSTR("3__%02d_RemCC_25_p%d.obj", plot_num, rank);
    writeTrimesh_obj(plot_file);
#endif

    int Ncc = delInfo.first - delInfo.second;
    int Ndel = delInfo.second;
    nnMSG(1, "[proc:%02d] connected components : %5d remain\n"
               "                               : %5d deleted\n\n", rank, Ncc, Ndel);
  } 
  else {
    wallTime3 = Time(); // update time point 3
  }

  //-------------------------------------------------------
  // 4: RemoveNonManifoldFace
  //-------------------------------------------------------
  FaceFace(m);
  int non_man = iso::CountNonManifoldEdgeFF(m);
  if (non_man > 0) {

    // 4a: build face-face adjacency info
    // 4b: remove non-manifold faces
    // 4c: delete any unreferenced vertices
    // 4d: optionally, RemoveSmallConnectedComponents (again)
    FaceFace(m);
    non_manf = iso::RemoveNonManifoldFace(m);
    del_vert2 = iso::RemoveUnreferencedVertex(m);

    wallTime4 = Time();
    elapsedTime = ElapsedTime(wallTime3, wallTime4);
    nnTRC(1, "[proc:%02d] time for: RemoveNonMan.... %8.2lf\n", rank, elapsedTime);

#if (0)
    plot_file = plot_dir + nnSTR("4__%02d_RemNonMan_p%d.obj", plot_num, rank);
    writeTrimesh_obj(plot_file);
#endif


#if (0)
    // optionally, remove newly-created small tri clusters
    //=====================================================
    // FaceFace(m);
    // VertexFace(m);
    // 
    // delInfo = iso::RemoveSmallConnectedComponents(m, minCC);
    // del_vert3 = iso::RemoveUnreferencedVertex(m);
    // 
    // timePoint_t wallTime4b = Time();
    // elapsedTime = ElapsedTime(wallTime4, wallTime4b);
    // nnTRC(1, "[proc:%02d] time for: RemoveSmallCC:2. %8.2lf\n", rank, elapsedTime);
    // 
    // FaceFace(m);
    // VertexFace(m);
    // 
    // int nbn_CC2 = CountConnectedComponents(m);
    // nnMSG(1, "[proc:%02d]  $$$ nbn_CC2  %5d  (after RemoveNonManifoldFace)\n", rank, nbn_CC2);
    //=====================================================
#endif

  } else {
    wallTime4 = Time(); // update time point 4
  }

  //-------------------------------------------------------
  // 5. OrientCoherentlyMesh
  //-------------------------------------------------------
  // 5a: build face-face adjacency info
  // 5b: if (2-manifold), then orient mesh faces
  FaceFace(m);
  non_man = iso::CountNonManifoldEdgeFF(m);
  if (non_man > 0) {
    nnMSG(1, "[proc:%02d] Mesh has %d non 2-manifold faces (orienting requires manifold)\n", rank, non_man);
    wallTime5 = Time(); // update time point 5
  }
  else {
    // 5b. orient mesh faces coherently
    nnMSG(1, "[proc:%02d] Orienting mesh face normals\n", rank);

#if (0)
    // a. try to orient (assuming a single connected structure)
    bool oriented, orientable;
    iso::OrientCoherentlyMesh(m, oriented, orientable);
#else
    // b. try to orient each connected component
    iso::OrientConnectedComponents(m);
#endif

    wallTime5 = Time();
    elapsedTime = ElapsedTime(wallTime4, wallTime5);
    nnTRC(1, "[proc:%02d] time for: OrientCC........ %8.2lf\n", rank, elapsedTime);

#if (0)
    plot_file = plot_dir + nnSTR("5__%02d_Oriented_p%d.obj", plot_num, rank);
    writeTrimesh_obj(plot_file);
#endif

  }

  //-------------------------------------------------------
  // 6. TaubinSmooth
  //-------------------------------------------------------
  // No need to smooth planar "isoslices"
  if (this->isoMode != ISO_MODE_PLANE) {

    // update per-face border flags without topology info
    FaceBorderFromNone(m);

    int   smoothSteps = 10;
    float lambda =  0.500f;
    float     mu = -0.550f;
  //float     mu = -0.526f;
  //float     mu = -0.502f;

    iso::TaubinSmooth(m, smoothSteps, lambda, mu);

    // clear unused data
    iso::RemoveDuplicateVertex(m);
    iso::CompactFaceVector(m);
    iso::CompactVertexVector(m);

    wallTime6 = Time();
    elapsedTime = ElapsedTime(wallTime5, wallTime6);
    nnTRC(1, "[proc:%02d] time for: TaubinSmooth.... %8.2lf\n", rank, elapsedTime);

#if (0)
    plot_file = plot_dir + nnSTR("6__%02d_Smoothed_p%d.obj", plot_num, rank);
    writeTrimesh_obj(plot_file);
#endif

  } else {
    wallTime6 = Time(); // update time point 6
  }

  //-------------------------------------------------------
  // 7. Quadric edge collapse
  //-------------------------------------------------------
  if (1)
  {
    // update per-face border flags without topology info
    // FaceBorderFromNone(m);  // NBN: not needed?

    iso::UpdateBounding(m);

    // set target for final edge count
    float target_fac = 0.5;

    if (ISO_MODE_SURF == this->isoMode) {
      // choose target_fac to preserve as much isosurface curvature 
      // detail as required:
    //target_fac = 0.50;    // reduce #faces by 50%
      target_fac = 0.30;    // reduce #faces by 70%
    //target_fac = 0.20;    // reduce #faces by 80%
    } 
    else {
      // ISO_MODE_PLANE 
      // for (planar, axis-aligned) isoslices, preserve only those 
      // regions with steep gradient ("color")
    //target_fac = 0.20;    // reduce #faces by 80%
    //target_fac = 0.10;    // reduce #faces by 90%
      target_fac = 0.05;    // reduce #faces by 95%
    }

    iso::EdgeCollapse(m, target_fac); // decimate trimesh
    iso::CompactFaceVector(m);        // delete unused verts
    iso::CompactVertexVector(m);      // delete unused faces

    wallTime7 = Time();
    elapsedTime = ElapsedTime(wallTime6, wallTime7);
    nnTRC(1, "[proc:%02d] time for: QEdgeCollapse... %8.2lf\n", rank, elapsedTime);
    elapsedTime = ElapsedTime(wallTimeStart, wallTime7);
    nnTRC(1, "[proc:%02d] Reduced mesh, after Quadric edge collapse:\n"
             "  number of verts: %8d \n"
             "  number of faces: %8d \n"
             "       total time: %g \n\n", rank, m.VN(), m.FN(), elapsedTime);

#if (0)
    plot_file = plot_dir + nnSTR("7__%02d_QReduced_p%d.obj", plot_num, rank);
    writeTrimesh_obj(plot_file);
#endif

  }
  else {
    elapsedTime = ElapsedTime(wallTimeStart, wallTime6);
    nnMSG(1, "[proc:%02d] Reduced mesh, after clustering and merging:\n"
             "  number of verts: %8d \n"
             "  number of faces: %8d \n"
             "       total time: %g \n\n", rank, m.VN(), m.FN(), elapsedTime);
  }

  // return smoothed and simplified trimesh
  extractTrimesh();

#if (1)

  // Results after isosurface cleaning and smoothing
  nnTRC(1, "\n[proc:%02d] isoClean report: \n"
             "  final number of verts: %8d (%8d)\n"
             "  final number of faces: %8d (%8d)\n"
             "  ----------------------------------- \n"
             "  clustering voxel size: %0.5f \n"
             "  merged close vertices: %d \n"
             "  removed unused verts : %d + %d + %d\n"
             "  removed non-man faces: %d \n"
             "  ----------------------------------- \n",
    rank, m.VN(), m.vert.size(), m.FN(), m.face.size(),
    isoVoxelSize, mrg_vert,
    del_vert, del_vert2, del_vert3, non_manf);

#endif

  nnMSG(1, "[proc:%02d] isoSurf_t::cleanSurface() done.\n", rank);
  return 0;
}


int isoSurf_t::extractTrimesh()
{
  // return trimesh nodes (refN) 
  // and tri connectivity (refT)

  if (!m_isoMesh) return 0;

  const iso::MyMesh2& m = (*m_isoMesh);
  int Ntris_out = m.FN();       // number of tris in final trimesh
  int Nverts_out = m.VN();      // number of verts in final trimesh

  memory<dfloat>& refN = this->iso_node_data;   // ref.[N]odes
  memory<int>&    refT = this->iso_tri_ids;     // ref.[T]ris

  refT.realloc(Ntris_out * 3);  // 3 vertex/node ids per [T]ri face
  refN.realloc(Nverts_out * 4); // store {x,y,z,q} for each [N]ode

  // vector of ids of "non-deleted" (!IsD()) vertices
  vecI VertexId(m.vert.size());

  // load vertices
  int skN = 0, numvert = 0;
  for (auto vi = m.vert.begin(); vi != m.vert.end(); ++vi) {
    
    if (!(*vi).IsD()) {
      // this vertex is not "[D]eleted"
      VertexId[vi - m.vert.begin()] = numvert;  // id for this vert
      const CoordType& p = (*vi).cP();          // coords
      const ScalarType val = (*vi).cC();        // color

      refN[skN++] = p.X();
      refN[skN++] = p.Y();
      refN[skN++] = p.Z();
      refN[skN++] = val;

      numvert++;
    }
  }

  // load tri faces
  int skT = 0, ids[3] = { 0 };
  for (ConstFaceIterator fi = m.face.begin(); fi != m.face.end(); ++fi) {
    if (!(*fi).IsD()) {
      // this face is not "[D]eleted"
      const FaceType& f = (*fi);
      for (int j = 0; j < 3; ++j) {
        const VertexType* pv = f.cV(j);   // jth vertex for this face
        ids[j] = VertexId[Index(m, pv)];  // updated id for jth vertex
      }
      refT[skT++] = ids[0];
      refT[skT++] = ids[1];
      refT[skT++] = ids[2];
    }
  }

  return Ntris_out;
}


bool isoSurf_t::loadTriFaces(int Ntris, int Nvort)
{
  // Load triangles generated by isosurface kernel.
  // This input "tri-soup" contains 3 vertices for 
  // each face, many of which will be duplicates.
  if (Ntris < 1) { return false; }

  if (m_isoMesh) m_isoMesh->Clear();  // clear existing mesh
  else m_isoMesh = new MyMesh2;       // allocate new mesh
  MyMesh2& m = (*m_isoMesh);

  int Nverts = Ntris * 3;             // 3 verts per face

  m.vert.resize(Nverts);  m.m_vn = Nverts;
  m.face.resize(Ntris);   m.m_fn = Ntris;
  m.m_bbox.SetNull();

  nnMSG(1, "\n[proc:%02d] Loading raw trimesh from data\n"
           "          number of vertices: %7d\n"
           "          number of trifaces: %7d\n\n", m_rank, Nverts, Ntris);

  int nodesk = 0;
  const int dim = 3;                // mesh.dim;
  //-------------------------------------------------------
  //              3     2     3     // Nvort = 2 {qw,|v|}
  int stride = (dim + Nvort) * dim;
  int noff   = (dim + Nvort);       // {x,y,z} + {qw,|v|}
  //-------------------------------------------------------
  int v_count = 0, f_count = 0; CoordType p3;
  float x, y, z, val; int fid[3] = { 0 };

  for (int k = 0; k < Ntris; ++k) {

    int koff = nodesk + k*stride;  // offset to kth triangle

    // isoQ[] holds coord and color data for input triangles
    // isoQ[koff] points to 3*{(x,y,z),q,s} data for kth tri
    // The next 3 vertices define the kth triangle:
    for (int i=0; i<3; ++i) {
      x = isoQ[koff + 0];
      y = isoQ[koff + 1];
      z = isoQ[koff + 2];

      // select color for ith vertex:
    //val = isoQ[koff + 3];       // if (3), use Qw   (vorticity criterion)
      val = isoQ[koff + 4];       // if (4), use |v|  (vorticity magnitude)

      p3.SetCoord(x, y, z);
      m.vert[v_count].P() = p3;   // set vertex coords
      m.vert[v_count].C() = val;  // set vertex scalar
      fid[i] = v_count;           // ith vertex for this face
      ++v_count;
      m.m_bbox.Add(p3);           // update bounding box
      koff += noff;               // shift to next block: [x,y,z][q,s]
    }

    // load the vertices for the kth triangle 
    // as 3 pointers to the target vertices:
    m.face[f_count].V(0) = &(m.vert[fid[0]]);
    m.face[f_count].V(1) = &(m.vert[fid[1]]);
    m.face[f_count].V(2) = &(m.vert[fid[2]]);
    f_count++;  // next face
  }

  // When smoothing and decimating an isosurface trimesh, 
  // we want to preserve vertex resolution in regions with
  // steep gradients (high scalar variation). Here, we use 
  // that scalar variance to scale the cost (penalize) the 
  // removal of vertices in regions with steep gradients.
  // 
  // See also: penalizing the removal of border vertices.

  // NBN:
  // if using |vort| as "color", use variation above zero?
  // if using  rho   as "color", use variation above/below mean?

//bool use_delta_mean = true;     // using density as "color"  
  bool use_delta_mean = false;    // using |vort| as "color"
  {
    double minC = 1e6, maxC = -1e6, ci = 0, sum = 0.0;
    for (int i=0; i<Nverts; ++i) {
      ci = m.vert[i].cC();        // "color"
      minC = std::min(minC, ci);
      maxC = std::max(maxC, ci);
      sum += ci;
    }

    // general case
    double mean_c = sum / (double)Nverts;

    // NBN: if using density (rho) as "color", we can use
    // the variation from a known freestream value, e.g.,
    // double mean_c = 1.0;  // NBN: 

    double dc = 0.0, var = 0.0, max_var = 0.0;
    for (int i = 0; i < Nverts; ++i) {
      if (use_delta_mean) {
        dc = m.vert[i].cC() - mean_c;   // e.g. density above/below mean
      } else {
        dc = m.vert[i].cC() - minC;     // e.g. |vorticity| above zero
      }

      // For the quadric edge collapse routine, to preserve mesh 
      // resolution in regions of high scalar variation, we want 
      // to AMPLIFY any variation from the mean field value.

      var = fabs(dc);       // size of the variation.
      var *= 5.0;           // enhance small variations
      if (var > 1.0) {
        var *= var;         // only square if (var > 1)
      }
      m.vert[i].Q() = var;  // "variance"
      max_var = std::max(max_var, var);
    }

#if (NBN_DBG_QCOST)
    FILE* fp = fopen("vertex_cost__LOAD.txt", "w");
#endif

    // NBN: if (pp->ScaleIndependent), then "cost" gets scaled 
    // pp->ScaleFactor = 1e8 * pow(1.0 / m.m_bbox.Diag(), 6);
    // See near line 3641 in file .../isoCleaner.hpp

  //double cost = 0.0, COST_FAC =  2000.0, max_cost = 0.0;
  //double cost = 0.0, COST_FAC =  5000.0, max_cost = 0.0;
    double cost = 0.0, COST_FAC = 10000.0, max_cost = 0.0;

#if (NBN_DBG_QCOST)
    fprintf(fp, "COST_FAC: %0.2lf Nv: %d\n", COST_FAC, Nverts);
#endif

    max_var = std::max(max_var, 1.0);   // handle zero variance
    for (int i = 0; i < Nverts; ++i) {
      // scale the cost of quadric edge collapse (removal 
      // of this vertex) according to relative variance:
      cost = COST_FAC * (m.vert[i].Q() / max_var);
      m.vert[i].Q() = cost;

#if (NBN_DBG_QCOST)
      fprintf(fp, "%6d: %12.4e\n", i, cost);
#endif
      // cost should range in [0:COST_FAC]
      // max_cost should ~ equal COST_FAC
      max_cost = std::max(max_cost, cost);
    }

#if (NBN_DBG_QCOST)
    fprintf(fp, "\nmax_cost: %0.3e  max_var: %0.3e\n\n", max_cost, max_var);
    fclose(fp);
#endif
  }

  return true;
}


//---------------------------------------------------------
// I/O: read/write trimesh data in .obj format (MeshLab)
// 
// loadTrimesh_obj(const std::string& fname);
// writeTrimesh_obj(const std::string& fname);
//---------------------------------------------------------

bool isoSurf_t::loadTrimesh_obj(const std::string& fname)
{
  // Load trimesh data from .obj format file.
  // 
  // Assume .obj format:
  //
  // v  x y z
  // ...
  // ...
  // f  i j k
  // ...
  // ...
  // c  val
  // ...
  // ...

  std::ifstream in(fname);
  if (!in.good()) {
    nnMSG(1, "loadTrimesh_obj() - Failed to open input file %s\n", fname.c_str());
    return false;
  }

  if (m_isoMesh) m_isoMesh->Clear();  // clear existing mesh
  else m_isoMesh = new MyMesh2;       // allocate new mesh
  iso::MyMesh2& m = (*m_isoMesh);

  int MaxLine = 2047;
  char op = '\0', line_buffer[2048] = { '\0' };
  int v_count = 0, f_count = 0, c_count = 0, f0, f1, f2;
  float x, y, z, val;
  MyVertex2 v; MyFace2 t;

  //-----------------------------------
  // 1. count vertices and faces
  //-----------------------------------
  std::istringstream iss;
  while (!in.eof()) {
    in >> std::ws;
    if (in.peek() == '#') {
      in.ignore(MaxLine, '\n');
    }
    else if (in.getline(line_buffer, MaxLine, '\n').good()) {
      iss.clear(); iss.seekg(0);        // reset stringstream
      iss.str(line_buffer); iss >> op;  // reload stringstream
      switch (op) {
      case 'v': { v_count++; break; }
      case 'f': { f_count++; break; }
      case 'c': { c_count++; break; }
      default:  break;  // op not handled
      }
    }
  }
  nnMSG(1, "Loading trimesh from file: %s\n"
    "   vertices : %8d\n"
    "   triangles: %8d\n"
    "   (colors) : %8d\n", fname.c_str(), v_count, f_count, c_count);

  //-----------------------------------
  // 2. load vertices and faces
  //-----------------------------------

  // if we have a color for each vertex, load these 
  // colors as scalar values for the vertices:
  bool bUseColor = (v_count == c_count) ? true : false;
  int Nv = v_count;

  m.vert.resize(v_count); m.m_vn = v_count;
  m.face.resize(f_count); m.m_fn = f_count;

  in.clear(); in.seekg(0);              // reset the ifstream
  m.m_bbox.SetNull();                   // update bounding box on the fly
  CoordType p3;

  v_count = 0; f_count = 0; c_count = 0;      // reset counters
  while (!in.eof()) {
    in >> std::ws;
    if (in.peek() == '#') {
      in.ignore(MaxLine, '\n');
    }
    else if (in.getline(line_buffer, MaxLine, '\n').good()) {

      iss.clear(); iss.seekg(0);        // reset stringstream
      iss.str(line_buffer); iss >> op;  // reload stringstream

      switch (op) {
      case 'v': {
        iss >> x >> y >> z;             // load next vertex
        p3.SetCoord(x, y, z);
        m.vert[v_count++].P() = p3;
        m.m_bbox.Add(p3);               // update bounding box
        break;
      }

      case 'f': {                       // load next face
        iss >> f0 >> f1 >> f2;          // read 3 vertex ids
        --f0;  --f1; --f2;              // make ids 0-based
        if ((f0 == f1) || (f0 == f2) || (f1 == f2)) break;  // skip degenerate faces

        // check that the ids are valid
        assert((f0 >= 0) && (f0 < Nv) && (f1 >= 0) && (f1 < Nv) && (f2 >= 0) && (f2 < Nv));

        m.face[f_count].V(0) = &(m.vert[f0]);   // load the vertices for 
        m.face[f_count].V(1) = &(m.vert[f1]);   // this face as 3 pointers 
        m.face[f_count].V(2) = &(m.vert[f2]);   // to the target vertices.
        f_count++;
        break;
      }

      case 'c': {
        if (bUseColor) {
          iss >> val;
          m.vert[c_count].C() = val;  // color
          c_count++;
        }
        break;
      }
      default:  break;  // op not handled
      }
    }
  }

  // When smoothing and decimating an isosurface trimesh, 
  // we want to preserve vertex resolution in regions with
  // steep gradients (high scalar variation). Here, we use 
  // that scalar variance to scale the cost (penalize) the 
  // removal of vertices in regions with steep gradients.
  // 
  // See also: penalizing the removal of border vertices.

  // Notes:
  // When using |vort| as "color", use variation above zero
  // When using  rho   as "color", use variation above/below mean

  if (bUseColor)
  {
  //bool use_delta_mean = true;   // using density as "color"  
    bool use_delta_mean = false;  // using |vort| as "color"

    double minC = 1e6, maxC = -1e6, ci = 0, sum = 0.0;
    for (int i = 0; i < Nv; ++i) {
      ci = m.vert[i].cC();        // "color"
      minC = std::min(minC, ci);
      maxC = std::max(maxC, ci);
      sum += ci;
    }

    // general case
    double mean_c = sum / (double)Nv;

    // NBN: if using density (rho) as "color", we can use
    // the variation from a known freestream value, e.g.,
    // double mean_c = 1.0;  // NBN: 

    double dc = 0.0, var = 0.0, max_var = 0.0;
    for (int i = 0; i < Nv; ++i) {
      if (use_delta_mean) {
        dc = m.vert[i].cC() - mean_c;   // e.g. density above/below mean
      } else {
        dc = m.vert[i].cC() - minC;     // e.g. |vorticity| above zero
      }

      // For the quadric edge collapse routine, to preserve mesh 
      // resolution in regions of high scalar variation, we want 
      // to AMPLIFY any variation from the mean field value.

      var = fabs(dc);       // size of the variation.
      var *= 5.0;           // enhance small variations
      if (var > 1.0) {
        var = dc * dc;      // only square if (var > 1)
      }
      m.vert[i].Q() = var;  // "variance"
      max_var = std::max(max_var, var);
    }

#if (NBN_DBG_QCOST)
    FILE* fp = fopen("vertex_cost__LOAD.txt", "w");
#endif

    // NBN: if (pp->ScaleIndependent), then "cost" gets scaled 
    // pp->ScaleFactor = 1e8 * pow(1.0 / m.m_bbox.Diag(), 6);
    // See near line 3685 in file .../isoCleaner.hpp

  //double cost = 0.0, COST_FAC =  2000.0, max_cost = 0.0;
  //double cost = 0.0, COST_FAC =  5000.0, max_cost = 0.0;
    double cost = 0.0, COST_FAC = 10000.0, max_cost = 0.0;

#if (NBN_DBG_QCOST)
    fprintf(fp, "COST_FAC: %0.2lf Nv: %d\n", COST_FAC, Nv);
#endif

    max_var = std::max(max_var, 1.0);   // handle zero variance
    for (int i = 0; i < Nv; ++i) {
      // scale the cost of quadric edge collapse (removal 
      // of this vertex) according to relative variance:
      cost = COST_FAC * (m.vert[i].Q() / max_var);
      m.vert[i].Q() = cost;

#if (NBN_DBG_QCOST)
      fprintf(fp, "%6d: %12.4e\n", i, cost);
#endif
      // cost should range in [0:COST_FAC]
      // max_cost should ~ equal COST_FAC
      max_cost = std::max(max_cost, cost);
    }

#if (NBN_DBG_QCOST)
    fprintf(fp, "\nmax_cost: %0.3e  max_var: %0.3e\n\n", max_cost, max_var);
    fclose(fp);
#endif

  }
  else {
    //---------------------------------
    // not using per-vertex scalars
    //---------------------------------
    for (int i = 0; i < Nv; ++i) {
      m.vert[i].C() = 1.0f;   // give all vertices the same scalar
      m.vert[i].Q() = 1.0f;   // and the same edge removal cost
    }
  }

  return true;
}


bool isoSurf_t::writeTrimesh_obj(const std::string& fname)
{
  // write current trimesh in .obj format
  const iso::MyMesh2& m = (*m_isoMesh);

  int Nv = m.VN(), Nt = m.FN();
  if (Nt < 1) { return false; }

  FILE* fp = fopen(fname.c_str(), "w");
  if (!fp) {
    nnWARN("writeTrimesh_obj()", "can't open output file: %s.\n", fname.c_str());
    return false;
  }

  nnTRC(1, "[proc:%02d] Writing current trimesh to file: %s\n", m_rank, fname.c_str());

  // Note: the vertex and face arrays may include elements that are 
  // marked "Deleted" (which we do not write). To ensure correct 
  // vertex ids for each face, we build an array of "non-Deleted" 
  // ids, and use this array for the vertex ids of each face.
  // 
  // Note: mesh.vert.size() is the number of verts in the mesh,
  //  but: mesh.m_vn        is the count of verts to be written.

  // vector of ids of non-deleted vertices
  vecI VertexId(m.vert.size());

  fprintf(fp, "# vertices %d triangles %d\n", Nv, Nt);

  int numvert = 0;
  for (auto vi = m.vert.begin(); vi != m.vert.end(); ++vi) {
    if (!(*vi).IsD()) {
      VertexId[vi - m.vert.begin()] = numvert;  // id for this vert
      const CoordType& p = (*vi).cP();
      fprintf(fp, "v %10.6lf %10.6lf %10.6lf\n", (double)p.X(), (double)p.Y(), (double)p.Z());
      numvert++;
    }
  }
  fprintf(fp, "\n");

  int ids[3] = { 0 };
  for (ConstFaceIterator fi = m.face.begin(); fi != m.face.end(); ++fi) {
    if (!(*fi).IsD()) {
      const FaceType& f = (*fi);
      for (int j = 0; j < 3; ++j) {
        const VertexType* pv = f.cV(j);
        ids[j] = VertexId[Index(m, pv)] + 1;  // 1-based for .obj format
      }
      fprintf(fp, "f %7d %7d %7d\n", ids[0], ids[1], ids[2]);
    }
  }
  fclose(fp);
  return true;
}

} // end namespace libp
