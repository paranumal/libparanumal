

// compute div(NU)  = div(uxu) in collocation way (weak form)
@kernel void insAdvectionVolumeHex3D(const dlong Nelements,
                                     @restrict const  dfloat *  vgeo,
                                     @restrict const  dfloat *  D,
                                     const dlong offset,
                                     @restrict const  dfloat *  U,
                                           @restrict dfloat *  NU){

  for(dlong e=0; e<Nelements; ++e; @outer(0)) {

    @shared dfloat s_F11[p_Nq][p_Nq];
    @shared dfloat s_F12[p_Nq][p_Nq];
    @shared dfloat s_F13[p_Nq][p_Nq];
    @shared dfloat s_F21[p_Nq][p_Nq];
    @shared dfloat s_F22[p_Nq][p_Nq];
    @shared dfloat s_F23[p_Nq][p_Nq];
    @shared dfloat s_F31[p_Nq][p_Nq];
    @shared dfloat s_F32[p_Nq][p_Nq];
    @shared dfloat s_F33[p_Nq][p_Nq];

    @shared dfloat s_D[p_Nq][p_Nq];

    @exclusive dfloat r_NU[p_Nq], r_NV[p_Nq], r_NW[p_Nq];

    for(int j=0;j<p_Nq;++j;@inner(1)){ 
      for(int i=0;i<p_Nq;++i;@inner(0)){
        const int id = i+j*p_Nq;
        s_D[0][id] = D[id];

        #pragma unroll p_Nq
          for(int k=0;k<p_Nq;++k){         
            r_NU[k] = 0.;
            r_NV[k] = 0.;
            r_NW[k] = 0.;
          }
      }
    }

    @barrier("local");

    #pragma unroll p_Nq
    for(int k=0;k<p_Nq;++k){ 

      //fetch slice
      for(int j=0;j<p_Nq;++j;@inner(1)){ 
        for(int i=0;i<p_Nq;++i;@inner(0)){
          const dlong gid = e*p_Np*p_Nvgeo+ k*p_Nq*p_Nq + j*p_Nq +i;
          const dfloat drdx = vgeo[gid + p_RXID*p_Np];
          const dfloat drdy = vgeo[gid + p_RYID*p_Np];
          const dfloat drdz = vgeo[gid + p_RZID*p_Np];
          const dfloat dsdx = vgeo[gid + p_SXID*p_Np];
          const dfloat dsdy = vgeo[gid + p_SYID*p_Np];
          const dfloat dsdz = vgeo[gid + p_SZID*p_Np];
          const dfloat dtdx = vgeo[gid + p_TXID*p_Np];
          const dfloat dtdy = vgeo[gid + p_TYID*p_Np];
          const dfloat dtdz = vgeo[gid + p_TZID*p_Np];
          const dfloat JW   = vgeo[gid + p_JWID*p_Np];

          const dlong id = e*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
          const dfloat Un = U[id+0*offset];
          const dfloat Vn = U[id+1*offset];
          const dfloat Wn = U[id+2*offset];

          const dfloat cUn = JW*(drdx*Un+drdy*Vn+drdz*Wn);
          const dfloat cVn = JW*(dsdx*Un+dsdy*Vn+dsdz*Wn);
          const dfloat cWn = JW*(dtdx*Un+dtdy*Vn+dtdz*Wn);

          s_F11[j][i] = cUn*Un;
          s_F12[j][i] = cVn*Un;
          s_F13[j][i] = cWn*Un;
          s_F21[j][i] = cUn*Vn;
          s_F22[j][i] = cVn*Vn;
          s_F23[j][i] = cWn*Vn;
          s_F31[j][i] = cUn*Wn;
          s_F32[j][i] = cVn*Wn;
          s_F33[j][i] = cWn*Wn;
        }
      }

      @barrier("local");

      for(int j=0;j<p_Nq;++j;@inner(1)){ 
        for(int i=0;i<p_Nq;++i;@inner(0)){
          #pragma unroll p_Nq
            for (int n=0;n<p_Nq;n++) {
              const dfloat Dr = s_D[n][i];
              const dfloat Ds = s_D[n][j];
              const dfloat Dt = s_D[k][n];
              r_NU[k] += Dr*s_F11[j][n];
              r_NV[k] += Dr*s_F21[j][n];
              r_NW[k] += Dr*s_F31[j][n];

              r_NU[k] += Ds*s_F12[n][i];
              r_NV[k] += Ds*s_F22[n][i];
              r_NW[k] += Ds*s_F32[n][i];

              r_NU[n] += Dt*s_F13[j][i];
              r_NV[n] += Dt*s_F23[j][i];
              r_NW[n] += Dt*s_F33[j][i];
            }
        }
      }

      @barrier("local");
    } //k loop

    //write out
    for(int j=0;j<p_Nq;++j;@inner(1)){ 
      for(int i=0;i<p_Nq;++i;@inner(0)){
        #pragma unroll p_Nq
          for(int k=0;k<p_Nq;++k){
            const dlong gid = e*p_Np*p_Nvgeo+ k*p_Nq*p_Nq + j*p_Nq +i;
            const dfloat invJW = vgeo[gid + p_IJWID*p_Np];

            const dlong id = e*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
            NU[id+0*offset] = -invJW*r_NU[k];
            NU[id+1*offset] = -invJW*r_NV[k];
            NU[id+2*offset] = -invJW*r_NW[k];
          }
      }
    }
  }
}


#define surfaceTerms(sk,face,m, i, j)                                   \
{                                                                       \
  const dlong  idM = vmapM[sk];                                         \
  const dlong  idP = vmapP[sk];                                         \
                                                                        \
  const dfloat nx = sgeo[sk*p_Nsgeo+p_NXID];                            \
  const dfloat ny = sgeo[sk*p_Nsgeo+p_NYID];                            \
  const dfloat nz = sgeo[sk*p_Nsgeo+p_NZID];                            \
  const dfloat sJ = sgeo[sk*p_Nsgeo+p_SJID];                            \
  const dfloat invWJ = sgeo[sk*p_Nsgeo+p_WIJID];                        \
                                                                        \
  const dfloat uM = U[idM+0*offset], vM = U[idM+1*offset], wM = U[idM+2*offset]; \
        dfloat uP = U[idP+0*offset], vP = U[idP+1*offset], wP = U[idP+2*offset]; \
                                                                        \
  const int bc = EToB[face+p_Nfaces*e];                                 \
  if(bc>0) {                                                            \
    insVelocityDirichletConditions3D(bc, time, x[idM], y[idM], z[idM], nx, ny, nz, uM, vM, wM, &uP, &vP, &wP); \
  }                                                                     \
                                                                        \
  const dfloat unM   = fabs(nx*uM + ny*vM + nz*wM);                 \
  const dfloat unP   = fabs(nx*uP + ny*vP + nz*wP);                 \
  const dfloat unMax = (unM > unP) ? unM : unP;                         \
                                                                        \
  const dfloat sc = invWJ * sJ;                                         \
  s_fluxNU[m][j][i] = sc*(.5f*(nx*(uP*uP + uM*uM)                      \
                             + ny*(uP*vP + uM*vM)                      \
                             + nz*(uP*wP + uM*wM)  + unMax*(uM-uP) )); \
  s_fluxNV[m][j][i] = sc*(.5f*(nx*(vP*uP + vM*uM)                      \
                             + ny*(vP*vP + vM*vM)                      \
                             + nz*(vP*wP + vM*wM)  + unMax*(vM-vP) )); \
  s_fluxNW[m][j][i] = sc*(.5f*(nx*(wP*uP + wM*uM)                      \
                             + ny*(wP*vP + wM*vM)                      \
                             + nz*(wP*wP + wM*wM)  + unMax*(wM-wP) )); \
}

@kernel void insAdvectionSurfaceHex3D(const dlong Nelements,
                                      @restrict const  dfloat *  sgeo,
                                      @restrict const  dfloat *  LIFTT,
                                      @restrict const  dlong  *  vmapM,
                                      @restrict const  dlong  *  vmapP,
                                      @restrict const  int    *  EToB,
                                      const dfloat time,
                                      @restrict const  dfloat *  x,
                                      @restrict const  dfloat *  y,
                                      @restrict const  dfloat *  z,
                                      const dlong offset,
                                      @restrict const  dfloat *  U,
                                            @restrict dfloat *  NU){

  // for all elements
  for(dlong e=0;e<Nelements;e++;@outer(0)){
    // @shared storage for flux terms
    @shared dfloat s_fluxNU[2][p_Nq][p_Nq];
    @shared dfloat s_fluxNV[2][p_Nq][p_Nq];
    @shared dfloat s_fluxNW[2][p_Nq][p_Nq];

    @exclusive dfloat r_NU[p_Nq], r_NV[p_Nq], r_NW[p_Nq];

    // for all face nodes of all elements
    // face 0 & 5
    for(int j=0;j<p_Nq;++j;@inner(1)){
      for(int i=0;i<p_Nq;++i;@inner(0)){
        #pragma unroll p_Nq
        for(int k=0;k<p_Nq;++k){
          r_NU[k] = 0.;
          r_NV[k] = 0.;
          r_NW[k] = 0.;
        }

        const dlong sk0 = e*p_Nfp*p_Nfaces + 0*p_Nfp + i + j*p_Nq;
        const dlong sk5 = e*p_Nfp*p_Nfaces + 5*p_Nfp + i + j*p_Nq;

        surfaceTerms(sk0,0,0,i,j);
        surfaceTerms(sk5,5,1,i,j);
      }
    }

    @barrier("local");

    // face 0 & 5
    for(int j=0;j<p_Nq;++j;@inner(1)){
      for(int i=0;i<p_Nq;++i;@inner(0)){
        //face 0
        r_NU[0] += s_fluxNU[0][j][i];
        r_NV[0] += s_fluxNV[0][j][i];
        r_NW[0] += s_fluxNW[0][j][i];

        //face 5
        r_NU[p_Nq-1] += s_fluxNU[1][j][i];
        r_NV[p_Nq-1] += s_fluxNV[1][j][i];
        r_NW[p_Nq-1] += s_fluxNW[1][j][i];
      }
    }

    @barrier("local");    

    // face 1 & 3
    for(int k=0;k<p_Nq;++k;@inner(1)){
      for(int i=0;i<p_Nq;++i;@inner(0)){
        const dlong sk1 = e*p_Nfp*p_Nfaces + 1*p_Nfp + i + k*p_Nq;
        const dlong sk3 = e*p_Nfp*p_Nfaces + 3*p_Nfp + i + k*p_Nq;

        surfaceTerms(sk1,1,0,i,k);
        surfaceTerms(sk3,3,1,i,k);
      }
    }

    @barrier("local");

    // face 1 & 3
    for(int j=0;j<p_Nq;++j;@inner(1)){
      for(int i=0;i<p_Nq;++i;@inner(0)){
        if (j==0) {//face 1
          #pragma unroll p_Nq
          for (int n=0;n<p_Nq;n++) {
            r_NU[n] += s_fluxNU[0][n][i];
            r_NV[n] += s_fluxNV[0][n][i];
            r_NW[n] += s_fluxNW[0][n][i];
          }
        }
        if (j==p_Nq-1) {//face 3
          #pragma unroll p_Nq
          for (int n=0;n<p_Nq;n++) {
            r_NU[n] += s_fluxNU[1][n][i];
            r_NV[n] += s_fluxNV[1][n][i];
            r_NW[n] += s_fluxNW[1][n][i];
          }
        }
      }
    }

    @barrier("local");    

    // face 2 & 4
    for(int k=0;k<p_Nq;++k;@inner(1)){
      for(int j=0;j<p_Nq;++j;@inner(0)){
        const dlong sk2 = e*p_Nfp*p_Nfaces + 2*p_Nfp + j + k*p_Nq;
        const dlong sk4 = e*p_Nfp*p_Nfaces + 4*p_Nfp + j + k*p_Nq;

        surfaceTerms(sk2,2,0,j,k);
        surfaceTerms(sk4,4,1,j,k);
      }
    }

    @barrier("local");

    // face 2 & 4
    for(int j=0;j<p_Nq;++j;@inner(1)){
      for(int i=0;i<p_Nq;++i;@inner(0)){
        if (i==p_Nq-1) {//face 2
          #pragma unroll p_Nq
          for (int n=0;n<p_Nq;n++) {
            r_NU[n] += s_fluxNU[0][n][j];
            r_NV[n] += s_fluxNV[0][n][j];
            r_NW[n] += s_fluxNW[0][n][j];
          }
        }
        if (i==0) {//face 4
          #pragma unroll p_Nq
          for (int n=0;n<p_Nq;n++) {
            r_NU[n] += s_fluxNU[1][n][j];
            r_NV[n] += s_fluxNV[1][n][j];
            r_NW[n] += s_fluxNW[1][n][j];
          }
        }
      }
    }

    @barrier("local");   

    for(int j=0;j<p_Nq;++j;@inner(1)){
      for(int i=0;i<p_Nq;++i;@inner(0)){
        #pragma unroll p_Nq
        for(int k=0;k<p_Nq;++k){
          const dlong id = e*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

          NU[id+0*offset] += r_NU[k];
          NU[id+1*offset] += r_NV[k];
          NU[id+2*offset] += r_NW[k];
        }
      }
    }
  }
}
#undef surfaceTerms

#if 0
/* ------------------Quadrature @kernels ----------------------------------*/
@kernel void insAdvectionCubatureVolumeHex3D(const dlong Nelements,
                                             @restrict const  dfloat *  vgeo,
                                             @restrict const  dfloat *  cubvgeo,
                                             @restrict const  dfloat *  cubD,
                                             @restrict const  dfloat *  cubInterpT,
                                             @restrict const  dfloat *  cubProjectT,
                                             const dlong offset,
                                             @restrict const  dfloat *  U,
                                                   @restrict dfloat *  cU, //storage for interpolated fields
                                                   @restrict dfloat *  NU){

  //----------------------------@kernel 1 interpolate velocity fields to quadrature points
  for(dlong e=0; e<Nelements; ++e; @outer(0)) {

    @shared dfloat s_U[p_Nq][p_cubNq];
    @shared dfloat s_V[p_Nq][p_cubNq];
    @shared dfloat s_W[p_Nq][p_cubNq];
    @shared dfloat s_cubInterpT[p_Nq][p_cubNq];

    @exclusive dfloat r_U[p_cubNq], r_V[p_cubNq], r_W[p_cubNq];

    for(int j=0;j<p_cubNq;++j;@inner(1)){
      for(int i=0;i<p_cubNq;++i;@inner(0)){
        const int id = i+j*p_cubNq;
        if (id<p_Nq*p_cubNq) {
          s_cubInterpT[0][id] = cubInterpT[id];
        }

        #pragma unroll p_cubNq
          for(int k=0;k<p_cubNq;++k){         
            r_U[k] = 0.;
            r_V[k] = 0.;
            r_W[k] = 0.;
          }
      }
    }

    @barrier("local");

    //read in and interpolate in k
    for(int j=0;j<p_cubNq;++j;@inner(1)){
      for(int i=0;i<p_cubNq;++i;@inner(0)){
        if (i<p_Nq && j<p_Nq) {
          #pragma unroll p_Nq
          for(int k=0;k<p_Nq;++k){
            const dlong id = e*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
            const dfloat uc = U[id+0*offset];
            const dfloat vc = U[id+1*offset];
            const dfloat wc = U[id+2*offset];

            #pragma unroll p_cubNq
            for(int n=0;n<p_cubNq;++n){
              const dfloat Ik = s_cubInterpT[k][n];
              r_U[n] += Ik*uc;
              r_V[n] += Ik*vc;
              r_W[n] += Ik*wc;
            }
          }
        }
      }
    }

    @barrier("local");

    #pragma unroll p_cubNq
    for(int k=0;k<p_cubNq;++k){ 
      //load slice to @shared
      for(int j=0;j<p_cubNq;++j;@inner(1)){ 
        for(int i=0;i<p_cubNq;++i;@inner(0)){
          if (i<p_Nq && j<p_Nq) {
            s_U[j][i] = r_U[k];
            s_V[j][i] = r_V[k];
            s_W[j][i] = r_W[k];
          }
        }
      }

      @barrier("local");

      for(int j=0;j<p_cubNq;++j;@inner(1)){ 
        for(int i=0;i<p_cubNq;++i;@inner(0)){
          if(j<p_Nq){
            r_U[k] = 0; r_V[k] = 0; r_W[k] = 0;

            #pragma unroll p_Nq
            for (int n=0;n<p_Nq;n++) {
              const dfloat Ii = s_cubInterpT[n][i];
              r_U[k] += Ii*s_U[j][n];
              r_V[k] += Ii*s_V[j][n];
              r_W[k] += Ii*s_W[j][n];
            }
          }
        }
      }

      @barrier("local");

      for(int j=0;j<p_cubNq;++j;@inner(1)){ 
        for(int i=0;i<p_cubNq;++i;@inner(0)){
          if(j<p_Nq){
            s_U[j][i] = r_U[k];
            s_V[j][i] = r_V[k];
            s_W[j][i] = r_W[k];
          }
        }
      }

      @barrier("local");

      for(int j=0;j<p_cubNq;++j;@inner(1)){ 
        for(int i=0;i<p_cubNq;++i;@inner(0)){
          r_U[k] = 0; r_V[k] = 0; r_W[k] = 0;

          #pragma unroll p_Nq
          for (int n=0;n<p_Nq;n++) {
            const dfloat Ij = s_cubInterpT[n][j];
            r_U[k] += Ij*s_U[n][i];
            r_V[k] += Ij*s_V[n][i];
            r_W[k] += Ij*s_W[n][i];
          }

          const dlong id = e*p_cubNp + k*p_cubNq*p_cubNq + j*p_cubNq + i;
          cU[id+0*offset] = r_U[k];
          cU[id+1*offset] = r_V[k];
          cU[id+2*offset] = r_W[k];
        }
      }
      @barrier("local");
    }
  }

  @barrier("global");

  //-----------------------------@kernel 2 do the reference divergence
  for(dlong e=0; e<Nelements; ++e; @outer(0)) {

    @shared dfloat s_F11[p_cubNq][p_cubNq];
    @shared dfloat s_F12[p_cubNq][p_cubNq];
    @shared dfloat s_F13[p_cubNq][p_cubNq];
    @shared dfloat s_F21[p_cubNq][p_cubNq];
    @shared dfloat s_F22[p_cubNq][p_cubNq];
    @shared dfloat s_F23[p_cubNq][p_cubNq];
    @shared dfloat s_F31[p_cubNq][p_cubNq];
    @shared dfloat s_F32[p_cubNq][p_cubNq];
    @shared dfloat s_F33[p_cubNq][p_cubNq];

    @shared dfloat s_cubD[p_cubNq][p_cubNq];

    @exclusive dfloat r_NU[p_cubNq], r_NV[p_cubNq], r_NW[p_cubNq];

    for(int j=0;j<p_cubNq;++j;@inner(1)){ 
      for(int i=0;i<p_cubNq;++i;@inner(0)){
        const int id = i+j*p_cubNq;
        s_cubD[0][id] = cubD[id];

        #pragma unroll p_cubNq
          for(int k=0;k<p_cubNq;++k){         
            r_NU[k] = 0.;
            r_NV[k] = 0.;
            r_NW[k] = 0.;
          }
      }
    }

    @barrier("local");

    #pragma unroll p_cubNq
    for(int k=0;k<p_cubNq;++k){ 

      //fetch slice
      for(int j=0;j<p_cubNq;++j;@inner(1)){ 
        for(int i=0;i<p_cubNq;++i;@inner(0)){
          const dlong gid = e*p_cubNp*p_Nvgeo+ k*p_cubNq*p_cubNq + j*p_cubNq +i;
          const dfloat drdx = cubvgeo[gid + p_RXID*p_cubNp];
          const dfloat drdy = cubvgeo[gid + p_RYID*p_cubNp];
          const dfloat drdz = cubvgeo[gid + p_RZID*p_cubNp];
          const dfloat dsdx = cubvgeo[gid + p_SXID*p_cubNp];
          const dfloat dsdy = cubvgeo[gid + p_SYID*p_cubNp];
          const dfloat dsdz = cubvgeo[gid + p_SZID*p_cubNp];
          const dfloat dtdx = cubvgeo[gid + p_TXID*p_cubNp];
          const dfloat dtdy = cubvgeo[gid + p_TYID*p_cubNp];
          const dfloat dtdz = cubvgeo[gid + p_TZID*p_cubNp];
          const dfloat JW   = cubvgeo[gid + p_JWID*p_cubNp];

          const dlong id = e*p_cubNp + k*p_cubNq*p_cubNq + j*p_cubNq + i;
          const dfloat Un = cU[id+0*offset];
          const dfloat Vn = cU[id+1*offset];
          const dfloat Wn = cU[id+2*offset];

          const dfloat cUn = JW*(drdx*Un+drdy*Vn+drdz*Wn);
          const dfloat cVn = JW*(dsdx*Un+dsdy*Vn+dsdz*Wn);
          const dfloat cWn = JW*(dtdx*Un+dtdy*Vn+dtdz*Wn);

          s_F11[j][i] = cUn*Un;
          s_F12[j][i] = cVn*Un;
          s_F13[j][i] = cWn*Un;
          s_F21[j][i] = cUn*Vn;
          s_F22[j][i] = cVn*Vn;
          s_F23[j][i] = cWn*Vn;
          s_F31[j][i] = cUn*Wn;
          s_F32[j][i] = cVn*Wn;
          s_F33[j][i] = cWn*Wn;
        }
      }

      @barrier("local");

      for(int j=0;j<p_cubNq;++j;@inner(1)){ 
        for(int i=0;i<p_cubNq;++i;@inner(0)){
          #pragma unroll p_cubNq
            for (int n=0;n<p_cubNq;n++) {
              const dfloat Dr = s_cubD[n][i];
              const dfloat Ds = s_cubD[n][j];
              const dfloat Dt = s_cubD[k][n];
              r_NU[k] += Dr*s_F11[j][n];
              r_NV[k] += Dr*s_F21[j][n];
              r_NW[k] += Dr*s_F31[j][n];

              r_NU[k] += Ds*s_F12[n][i];
              r_NV[k] += Ds*s_F22[n][i];
              r_NW[k] += Ds*s_F32[n][i];

              r_NU[n] += Dt*s_F13[j][i];
              r_NV[n] += Dt*s_F23[j][i];
              r_NW[n] += Dt*s_F33[j][i];
            }
        }
      }

      @barrier("local");
    } //k loop

    //write out
    for(int j=0;j<p_cubNq;++j;@inner(1)){ 
      for(int i=0;i<p_cubNq;++i;@inner(0)){
        #pragma unroll p_cubNq
          for(int k=0;k<p_cubNq;++k){
            const dlong id = e*p_cubNp + k*p_cubNq*p_cubNq + j*p_cubNq + i;
            cU[id+0*offset] = r_NU[k];
            cU[id+1*offset] = r_NV[k];
            cU[id+2*offset] = r_NW[k];
          }
      }
    }
  }

  @barrier("global");

  //---------------------------@kernel 3 project fluxes back to GLL grid
  for(dlong e=0; e<Nelements; ++e; @outer(0)) {
    @shared dfloat s_NU[p_cubNq][p_cubNq];
    @shared dfloat s_NV[p_cubNq][p_cubNq];
    @shared dfloat s_NW[p_cubNq][p_cubNq];
    @shared dfloat s_cubProjectT[p_cubNq][p_Nq];

    @exclusive dfloat r_NU[p_Nq], r_NV[p_Nq], r_NW[p_Nq];

    for(int j=0;j<p_cubNq;++j;@inner(1)){
      for(int i=0;i<p_cubNq;++i;@inner(0)){
        const int id = i+j*p_cubNq;
        if (id<p_Nq*p_cubNq) {
          s_cubProjectT[0][id] = cubProjectT[id];
        }
        
        #pragma unroll p_Nq
          for(int k=0;k<p_Nq;++k){         
            r_NU[k] = 0.;
            r_NV[k] = 0.;
            r_NW[k] = 0.;
          }
      }
    }

    @barrier("local");

    //read in and project in k
    for(int j=0;j<p_cubNq;++j;@inner(1)){
      for(int i=0;i<p_cubNq;++i;@inner(0)){
        #pragma unroll p_cubNq
        for(int k=0;k<p_cubNq;++k){
          const dlong id = e*p_cubNp + k*p_cubNq*p_cubNq + j*p_cubNq + i;
          const dfloat NUn = cU[id+0*offset];
          const dfloat NVn = cU[id+1*offset];
          const dfloat NWn = cU[id+2*offset];

          #pragma unroll p_Nq
          for(int n=0;n<p_Nq;++n){
            const dfloat Pk = s_cubProjectT[k][n];
            r_NU[n] += Pk*NUn;
            r_NV[n] += Pk*NVn;
            r_NW[n] += Pk*NWn;
          }
        }
      }
    }

    @barrier("local");

    #pragma unroll p_Nq
    for(int k=0;k<p_Nq;++k){ 
      //load slice to @shared
      for(int j=0;j<p_cubNq;++j;@inner(1)){ 
        for(int i=0;i<p_cubNq;++i;@inner(0)){
          s_NU[j][i] = r_NU[k];
          s_NV[j][i] = r_NV[k];
          s_NW[j][i] = r_NW[k];
        }
      }

      @barrier("local");

      for(int j=0;j<p_cubNq;++j;@inner(1)){ 
        for(int i=0;i<p_cubNq;++i;@inner(0)){
          if(j<p_Nq){
            r_NU[k] = 0; r_NV[k] = 0; r_NW[k] = 0;

            #pragma unroll p_cubNq
            for (int n=0;n<p_cubNq;n++) {
              const dfloat Pj = s_cubProjectT[n][j];
              r_NU[k] += Pj*s_NU[n][i];
              r_NV[k] += Pj*s_NV[n][i];
              r_NW[k] += Pj*s_NW[n][i];
            }
          }
        }
      }

      @barrier("local");

      for(int j=0;j<p_cubNq;++j;@inner(1)){ 
        for(int i=0;i<p_cubNq;++i;@inner(0)){
          if(j<p_Nq){
            s_NU[j][i] = r_NU[k];
            s_NV[j][i] = r_NV[k];
            s_NW[j][i] = r_NW[k];
          }
        }
      }

      @barrier("local");

      for(int j=0;j<p_cubNq;++j;@inner(1)){ 
        for(int i=0;i<p_cubNq;++i;@inner(0)){
          if (i<p_Nq && j<p_Nq) {
            const dlong gid = e*p_Np*p_Nvgeo+ k*p_Nq*p_Nq + j*p_Nq +i;
            const dfloat invJW = vgeo[gid + p_IJWID*p_Np];

            r_NU[k] = 0; r_NV[k] = 0; r_NW[k] = 0;

            #pragma unroll p_cubNq
            for (int n=0;n<p_cubNq;n++) {
              const dfloat Pi = s_cubProjectT[n][i];
              r_NU[k] += Pi*s_NU[j][n];
              r_NV[k] += Pi*s_NV[j][n];
              r_NW[k] += Pi*s_NW[j][n];
            }

            const dlong id = e*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
            NU[id+0*offset] = -invJW*r_NU[k];
            NU[id+1*offset] = -invJW*r_NV[k];
            NU[id+2*offset] = -invJW*r_NW[k];
          }
        }
      }
      @barrier("local");
    }
  }
}
#else

//unified @kernel, but might use too much memory
@kernel void insAdvectionCubatureVolumeHex3D(const dlong Nelements,
                                             @restrict const  dfloat *  vgeo,
                                             @restrict const  dfloat *  cubvgeo,
                                             @restrict const  dfloat *  cubD,
                                             @restrict const  dfloat *  cubInterpT,
                                             @restrict const  dfloat *  cubProjectT,
                                             const dlong offset,
                                             @restrict const  dfloat *  U,
                                                   @restrict dfloat *  cU, //storage for interpolated fields
                                                   @restrict dfloat *  NU){

  //----------------------------@kernel 1 interpolate velocity fields to quadrature points
  for(dlong e=0; e<Nelements; ++e; @outer(0)) {

    @shared dfloat s_cubD[p_cubNq][p_cubNq];
    @shared dfloat s_cubInterpT[p_Nq][p_cubNq];
    @shared dfloat s_cubProjectT[p_cubNq][p_Nq];


    @shared dfloat s_F11[p_cubNq][p_cubNq];
    @shared dfloat s_F12[p_cubNq][p_cubNq];
    @shared dfloat s_F13[p_cubNq][p_cubNq];
    @shared dfloat s_F21[p_cubNq][p_cubNq];
    @shared dfloat s_F22[p_cubNq][p_cubNq];
    @shared dfloat s_F23[p_cubNq][p_cubNq];
    @shared dfloat s_F31[p_cubNq][p_cubNq];
    @shared dfloat s_F32[p_cubNq][p_cubNq];
    @shared dfloat s_F33[p_cubNq][p_cubNq];

    #define s_U s_F11
    #define s_V s_F12
    #define s_W s_F13

    #define s_NU s_F11
    #define s_NV s_F12
    #define s_NW s_F13

    @exclusive dfloat r_cU[p_cubNq], r_cV[p_cubNq], r_cW[p_cubNq];
    @exclusive dfloat r_NU[p_cubNq], r_NV[p_cubNq], r_NW[p_cubNq];

    for(int j=0;j<p_cubNq;++j;@inner(1)){
      for(int i=0;i<p_cubNq;++i;@inner(0)){
        const int id = i+j*p_cubNq;
        if (id<p_Nq*p_cubNq) {
          s_cubInterpT[0][id] = cubInterpT[id];
          s_cubProjectT[0][id] = cubProjectT[id];
        }
        s_cubD[0][id] = cubD[id];

        #pragma unroll p_cubNq
          for(int k=0;k<p_cubNq;++k){         
            r_cU[k] = 0.;
            r_cV[k] = 0.;
            r_cW[k] = 0.;
            r_NU[k] = 0.;
            r_NV[k] = 0.;
            r_NW[k] = 0.;
          }
      }
    }

    @barrier("local");

    //read in and interpolate in k
    for(int j=0;j<p_cubNq;++j;@inner(1)){
      for(int i=0;i<p_cubNq;++i;@inner(0)){
        if (i<p_Nq && j<p_Nq) {
          #pragma unroll p_Nq
          for(int k=0;k<p_Nq;++k){
            const dlong id = e*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
            const dfloat uc = U[id+0*offset];
            const dfloat vc = U[id+1*offset];
            const dfloat wc = U[id+2*offset];

            #pragma unroll p_cubNq
            for(int n=0;n<p_cubNq;++n){
              const dfloat Ik = s_cubInterpT[k][n];
              r_cU[n] += Ik*uc;
              r_cV[n] += Ik*vc;
              r_cW[n] += Ik*wc;
            }
          }
        }
      }
    }

    @barrier("local");

    #pragma unroll p_cubNq
    for(int k=0;k<p_cubNq;++k){ 
      //load slice to @shared
      for(int j=0;j<p_cubNq;++j;@inner(1)){ 
        for(int i=0;i<p_cubNq;++i;@inner(0)){
          if (i<p_Nq && j<p_Nq) {
            s_U[j][i] = r_cU[k];
            s_V[j][i] = r_cV[k];
            s_W[j][i] = r_cW[k];
          }
        }
      }

      @barrier("local");

      for(int j=0;j<p_cubNq;++j;@inner(1)){ 
        for(int i=0;i<p_cubNq;++i;@inner(0)){
          if(j<p_Nq){
            r_cU[k] = 0; r_cV[k] = 0; r_cW[k] = 0;

            #pragma unroll p_Nq
            for (int n=0;n<p_Nq;n++) {
              const dfloat Ii = s_cubInterpT[n][i];
              r_cU[k] += Ii*s_U[j][n];
              r_cV[k] += Ii*s_V[j][n];
              r_cW[k] += Ii*s_W[j][n];
            }
          }
        }
      }

      @barrier("local");

      for(int j=0;j<p_cubNq;++j;@inner(1)){ 
        for(int i=0;i<p_cubNq;++i;@inner(0)){
          if(j<p_Nq){
            s_U[j][i] = r_cU[k];
            s_V[j][i] = r_cV[k];
            s_W[j][i] = r_cW[k];
          }
        }
      }

      @barrier("local");

      for(int j=0;j<p_cubNq;++j;@inner(1)){ 
        for(int i=0;i<p_cubNq;++i;@inner(0)){
          r_cU[k] = 0; r_cV[k] = 0; r_cW[k] = 0;

          #pragma unroll p_Nq
          for (int n=0;n<p_Nq;n++) {
            const dfloat Ij = s_cubInterpT[n][j];
            r_cU[k] += Ij*s_U[n][i];
            r_cV[k] += Ij*s_V[n][i];
            r_cW[k] += Ij*s_W[n][i];
          }
        }
      }

      @barrier("local");      
    }

    #pragma unroll p_cubNq
    for(int k=0;k<p_cubNq;++k){ 

      //fetch slice
      for(int j=0;j<p_cubNq;++j;@inner(1)){ 
        for(int i=0;i<p_cubNq;++i;@inner(0)){
          const dlong gid = e*p_cubNp*p_Nvgeo+ k*p_cubNq*p_cubNq + j*p_cubNq +i;
          const dfloat drdx = cubvgeo[gid + p_RXID*p_cubNp];
          const dfloat drdy = cubvgeo[gid + p_RYID*p_cubNp];
          const dfloat drdz = cubvgeo[gid + p_RZID*p_cubNp];
          const dfloat dsdx = cubvgeo[gid + p_SXID*p_cubNp];
          const dfloat dsdy = cubvgeo[gid + p_SYID*p_cubNp];
          const dfloat dsdz = cubvgeo[gid + p_SZID*p_cubNp];
          const dfloat dtdx = cubvgeo[gid + p_TXID*p_cubNp];
          const dfloat dtdy = cubvgeo[gid + p_TYID*p_cubNp];
          const dfloat dtdz = cubvgeo[gid + p_TZID*p_cubNp];
          const dfloat JW   = cubvgeo[gid + p_JWID*p_cubNp];

          const dfloat Un = r_cU[k];
          const dfloat Vn = r_cV[k];
          const dfloat Wn = r_cW[k];

          const dfloat cUn = JW*(drdx*Un+drdy*Vn+drdz*Wn);
          const dfloat cVn = JW*(dsdx*Un+dsdy*Vn+dsdz*Wn);
          const dfloat cWn = JW*(dtdx*Un+dtdy*Vn+dtdz*Wn);

          s_F11[j][i] = cUn*Un;
          s_F12[j][i] = cVn*Un;
          s_F13[j][i] = cWn*Un;
          s_F21[j][i] = cUn*Vn;
          s_F22[j][i] = cVn*Vn;
          s_F23[j][i] = cWn*Vn;
          s_F31[j][i] = cUn*Wn;
          s_F32[j][i] = cVn*Wn;
          s_F33[j][i] = cWn*Wn;
        }
      }

      @barrier("local");

      for(int j=0;j<p_cubNq;++j;@inner(1)){ 
        for(int i=0;i<p_cubNq;++i;@inner(0)){
          #pragma unroll p_cubNq
            for (int n=0;n<p_cubNq;n++) {
              const dfloat Dr = s_cubD[n][i];
              const dfloat Ds = s_cubD[n][j];
              const dfloat Dt = s_cubD[k][n];
              r_NU[k] += Dr*s_F11[j][n];
              r_NV[k] += Dr*s_F21[j][n];
              r_NW[k] += Dr*s_F31[j][n];

              r_NU[k] += Ds*s_F12[n][i];
              r_NV[k] += Ds*s_F22[n][i];
              r_NW[k] += Ds*s_F32[n][i];

              r_NU[n] += Dt*s_F13[j][i];
              r_NV[n] += Dt*s_F23[j][i];
              r_NW[n] += Dt*s_F33[j][i];
            }
        }
      }

      @barrier("local");
    } //k loop

    #pragma unroll p_cubNq
    for(int k=0;k<p_cubNq;++k){ 
      //load slice to @shared
      for(int j=0;j<p_cubNq;++j;@inner(1)){ 
        for(int i=0;i<p_cubNq;++i;@inner(0)){
          s_NU[j][i] = r_NU[k];
          s_NV[j][i] = r_NV[k];
          s_NW[j][i] = r_NW[k];
        }
      }

      @barrier("local");

      for(int j=0;j<p_cubNq;++j;@inner(1)){ 
        for(int i=0;i<p_cubNq;++i;@inner(0)){
          if(j<p_Nq){
            r_NU[k] = 0; r_NV[k] = 0; r_NW[k] = 0;

            #pragma unroll p_cubNq
            for (int n=0;n<p_cubNq;n++) {
              const dfloat Pj = s_cubProjectT[n][j];
              r_NU[k] += Pj*s_NU[n][i];
              r_NV[k] += Pj*s_NV[n][i];
              r_NW[k] += Pj*s_NW[n][i];
            }
          }
        }
      }

      @barrier("local");

      for(int j=0;j<p_cubNq;++j;@inner(1)){ 
        for(int i=0;i<p_cubNq;++i;@inner(0)){
          if(j<p_Nq){
            s_NU[j][i] = r_NU[k];
            s_NV[j][i] = r_NV[k];
            s_NW[j][i] = r_NW[k];
          }
        }
      }

      @barrier("local");

      for(int j=0;j<p_cubNq;++j;@inner(1)){ 
        for(int i=0;i<p_cubNq;++i;@inner(0)){
          if ((i<p_Nq) && (j<p_Nq)) {
            r_NU[k] = 0; r_NV[k] = 0; r_NW[k] = 0;

            #pragma unroll p_cubNq
            for (int n=0;n<p_cubNq;n++) {
              const dfloat Pi = s_cubProjectT[n][i];
              r_NU[k] += Pi*s_NU[j][n];
              r_NV[k] += Pi*s_NV[j][n];
              r_NW[k] += Pi*s_NW[j][n];
            }
          }
        }
      }
      
      @barrier("local");
    }

    //project in k and write out
    for(int j=0;j<p_cubNq;++j;@inner(1)){
      for(int i=0;i<p_cubNq;++i;@inner(0)){
        if ((i<p_Nq) && (j<p_Nq)) {
          #pragma unroll p_Nq
          for(int k=0;k<p_Nq;++k){    
            dfloat nu=0., nv=0., nw=0.; 

            #pragma unroll p_cubNq
            for(int n=0;n<p_cubNq;++n){
              const dfloat Pk = s_cubProjectT[n][k];
              nu += Pk*r_NU[n];
              nv += Pk*r_NV[n];
              nw += Pk*r_NW[n];
            }

            const dlong gid = e*p_Np*p_Nvgeo+ k*p_Nq*p_Nq + j*p_Nq +i;
            const dfloat invJW = vgeo[gid + p_IJWID*p_Np];

            const dlong id = e*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
            NU[id+0*offset] = -invJW*nu;
            NU[id+1*offset] = -invJW*nv;
            NU[id+2*offset] = -invJW*nw;
          }
        }
      }
    }
  }
}
#endif

#define quadSurfaceTerms(face)						\
  {									\
    for(int j=0;j<p_cubNq;++j;@inner(1)){				\
      for(int i=0;i<p_cubNq;++i;@inner(0)){				\
	if(i<p_Nq && j<p_Nq){						\
	  const dlong id  = e*p_Nfp*p_Nfaces + face*p_Nfp + j*p_Nq +i;	\
	  const dlong idM = vmapM[id];					\
	  const dlong idP = vmapP[id];					\
	  s_UM[j][i] = U[idM+0*offset];					\
	  s_VM[j][i] = U[idM+1*offset];					\
	  s_WM[j][i] = U[idM+2*offset];					\
	  s_UP[j][i] = U[idP+0*offset];					\
	  s_VP[j][i] = U[idP+1*offset];					\
	  s_WP[j][i] = U[idP+2*offset];					\
	}								\
      }									\
    }									\
									\
    @barrier("local");							\
									\
    for(int j=0;j<p_cubNq;++j;@inner(1)){				\
      for(int i=0;i<p_cubNq;++i;@inner(0)){				\
	if (j<p_Nq) {							\
	  r_UMn = 0.; r_VMn = 0.; r_WMn = 0.;				\
	  r_UPn = 0.; r_VPn = 0.; r_WPn = 0.;				\
	  for (int n=0;n<p_Nq;n++) {					\
	    const dfloat Ini = s_cubInterpT[n][i];			\
	    r_UMn  += Ini*s_UM[j][n];					\
	    r_VMn  += Ini*s_VM[j][n];					\
	    r_WMn  += Ini*s_WM[j][n];					\
	    r_UPn  += Ini*s_UP[j][n];					\
	    r_VPn  += Ini*s_VP[j][n];					\
	    r_WPn  += Ini*s_WP[j][n];					\
	  }								\
	}								\
      }									\
    }									\
									\
    @barrier("local");							\
									\
    for(int j=0;j<p_cubNq;++j;@inner(1)){				\
      for(int i=0;i<p_cubNq;++i;@inner(0)){				\
	if (j<p_Nq) {							\
	  s_UM[j][i] = r_UMn;						\
	  s_VM[j][i] = r_VMn;						\
	  s_WM[j][i] = r_WMn;						\
	  s_UP[j][i] = r_UPn;						\
	  s_VP[j][i] = r_VPn;						\
	  s_WP[j][i] = r_WPn;						\
	}								\
      }									\
    }									\
									\
    @barrier("local");							\
									\
    for(int j=0;j<p_cubNq;++j;@inner(1)){				\
      for(int i=0;i<p_cubNq;++i;@inner(0)){				\
	r_UMn = 0.; r_VMn = 0.; r_WMn = 0.;				\
	r_UPn = 0.; r_VPn = 0.; r_WPn = 0.;				\
	for (int n=0;n<p_Nq;n++) {					\
	  const dfloat Inj = s_cubInterpT[n][j];			\
	  r_UMn += Inj*s_UM[n][i];					\
	  r_VMn += Inj*s_VM[n][i];					\
	  r_WMn += Inj*s_WM[n][i];					\
	  r_UPn += Inj*s_UP[n][i];					\
	  r_VPn += Inj*s_VP[n][i];					\
	  r_WPn += Inj*s_WP[n][i];					\
	}								\
      }									\
    }									\
									\
    @barrier("local");							\
									\
    for(int j=0;j<p_cubNq;++j;@inner(1)){				\
      for(int i=0;i<p_cubNq;++i;@inner(0)){				\
	const dlong sk = e*p_cubNfp*p_Nfaces + face*p_cubNfp + j*p_cubNq + i; \
	const dfloat nx = cubsgeo[sk*p_Nsgeo+p_NXID];			\
	const dfloat ny = cubsgeo[sk*p_Nsgeo+p_NYID];			\
	const dfloat nz = cubsgeo[sk*p_Nsgeo+p_NZID];			\
	const dfloat WsJ = cubsgeo[sk*p_Nsgeo+p_WSJID];			\
	const dfloat uM = r_UMn, vM = r_VMn, wM = r_WMn;		\
	dfloat uP = r_UPn, vP = r_VPn, wP = r_WPn;			\
									\
	const int bc = EToB[face+p_Nfaces*e];				\
	if(bc>0) {							\
	  insVelocityDirichletConditions3D(bc, time, intx[e*p_Nfaces*p_cubNfp + face*p_cubNfp + j*p_cubNq + i],	\
					   inty[e*p_Nfaces*p_cubNfp + face*p_cubNfp + j*p_cubNq + i], \
					   intz[e*p_Nfaces*p_cubNfp + face*p_cubNfp + j*p_cubNq + i], nx, ny, nz, uM, vM, wM, &uP, &vP, &wP); \
	}								\
									\
	const dfloat unM   = fabs(nx*uM + ny*vM + nz*wM);		\
	const dfloat unP   = fabs(nx*uP + ny*vP + nz*wP);		\
	const dfloat unMax = (unM > unP) ? unM : unP;			\
									\
	s_fluxNU[j][i] = WsJ*(.5f*(nx*(uP*uP + uM*uM)			\
				   + ny*(uP*vP + uM*vM)			\
				   + nz*(uP*wP + uM*wM)  + unMax*(uM-uP) )); \
	s_fluxNV[j][i] = WsJ*(.5f*(nx*(vP*uP + vM*uM)			\
				   + ny*(vP*vP + vM*vM)			\
				   + nz*(vP*wP + vM*wM)  + unMax*(vM-vP) )); \
	s_fluxNW[j][i] = WsJ*(.5f*(nx*(wP*uP + wM*uM)			\
				   + ny*(wP*vP + wM*vM)			\
				   + nz*(wP*wP + wM*wM)  + unMax*(wM-wP) )); \
      }									\
    }									\
									\
    @barrier("local");							\
									\
    for(int j=0;j<p_cubNq;++j;@inner(1)){				\
      for(int i=0;i<p_cubNq;++i;@inner(0)){				\
	if (j<p_Nq) {							\
	  r_NUn = 0.; r_NVn = 0.; r_NWn = 0.;				\
	  for (int n=0;n<p_cubNq;n++) {					\
	    const dfloat Pnj = s_cubProjectT[n][j];			\
	    r_NUn  += Pnj*s_fluxNU[n][i];				\
	    r_NVn  += Pnj*s_fluxNV[n][i];				\
	    r_NWn  += Pnj*s_fluxNW[n][i];				\
	  }								\
	}								\
      }									\
    }									\
									\
    @barrier("local");							\
									\
    for(int j=0;j<p_cubNq;++j;@inner(1)){				\
      for(int i=0;i<p_cubNq;++i;@inner(0)){				\
	if (j<p_Nq) {							\
	  s_fluxNU[j][i] = r_NUn;					\
	  s_fluxNV[j][i] = r_NVn;					\
	  s_fluxNW[j][i] = r_NWn;					\
	}								\
      }									\
    }									\
    @barrier("local");							\
									\
    for(int j=0;j<p_cubNq;++j;@inner(1)){				\
      for(int i=0;i<p_cubNq;++i;@inner(0)){				\
	if (j<p_Nq && i<p_Nq) {						\
	  r_NUn = 0.; r_NVn = 0.; r_NWn = 0.;				\
	  for(int n=0;n<p_cubNq;++n){					\
	    const dfloat Pni = s_cubProjectT[n][i];			\
	    r_NUn += Pni*s_fluxNU[j][n];				\
	    r_NVn += Pni*s_fluxNV[j][n];				\
	    r_NWn += Pni*s_fluxNW[j][n];				\
	  }								\
	}								\
      }									\
    }									\
									\
    @barrier("local");							\
									\
    for(int j=0;j<p_cubNq;++j;@inner(1)){				\
      for(int i=0;i<p_cubNq;++i;@inner(0)){				\
	if (j<p_Nq && i<p_Nq) {						\
	  s_fluxNU[j][i] = r_NUn;					\
	  s_fluxNV[j][i] = r_NVn;					\
	  s_fluxNW[j][i] = r_NWn;					\
	}								\
      }									\
    }									\
  }

@kernel void insAdvectionCubatureSurfaceHex3D(const dlong Nelements,
                                            @restrict const  dfloat *  vgeo,
                                            @restrict const  dfloat *  sgeo,
                                            @restrict const  dfloat *  cubsgeo,
                                            @restrict const  dfloat *  intInterpT,
                                            @restrict const  dfloat *  intLIFTT,
                                            @restrict const  dfloat *  cubInterpT,
                                            @restrict const  dfloat *  cubProjectT,
                                            @restrict const  dlong  *  vmapM,
                                            @restrict const  dlong  *  vmapP,
                                            @restrict const  int    *  EToB,
                                            const dfloat time,
                                            @restrict const  dfloat *  intx,
                                            @restrict const  dfloat *  inty,
                                            @restrict const  dfloat *  intz,
                                            const dlong offset,
                                            @restrict const  dfloat *  U,
                                                  @restrict dfloat *  NU){

  // for all elements
  for(dlong e=0;e<Nelements;e++;@outer(0)){
    // @shared storage for flux terms
    @exclusive dfloat r_NU[p_Nq], r_NV[p_Nq], r_NW[p_Nq];

    @shared dfloat s_UM[p_cubNq][p_cubNq];
    @shared dfloat s_VM[p_cubNq][p_cubNq];
    @shared dfloat s_WM[p_cubNq][p_cubNq];
    @shared dfloat s_UP[p_cubNq][p_cubNq];
    @shared dfloat s_VP[p_cubNq][p_cubNq];
    @shared dfloat s_WP[p_cubNq][p_cubNq];

    // reuse @shared memory buffers
    #define s_fluxNU s_UM
    #define s_fluxNV s_VM
    #define s_fluxNW s_WM
    
    @exclusive dfloat r_UMn, r_VMn, r_WMn;
    @exclusive dfloat r_UPn, r_VPn, r_WPn;

    #define r_NUn r_UMn
    #define r_NVn r_VMn
    #define r_NWn r_WMn

    @shared dfloat s_cubInterpT[p_Nq][p_cubNq];
    @shared dfloat s_cubProjectT[p_cubNq][p_Nq];

    // for all face nodes of all elements
    for(int j=0;j<p_cubNq;++j;@inner(1)){
      for(int i=0;i<p_cubNq;++i;@inner(0)){
        //zero out resulting surface contributions
        #pragma unroll p_Nq
        for(int k=0;k<p_Nq;++k){
          r_NU[k] = 0.;
          r_NV[k] = 0.;
          r_NW[k] = 0.;
        }

        //fetch reference operators
        const int id = i+j*p_cubNq;
        if (id<p_Nq*p_cubNq) {
          s_cubInterpT[0][id] = cubInterpT[id];
          s_cubProjectT[0][id] = cubProjectT[id];
        }
      }
    }

    @barrier("local");

    quadSurfaceTerms(0) //face 0

    @barrier("local");    

    //accumulate in register pencil
    for(int j=0;j<p_cubNq;++j;@inner(1)){
      for(int i=0;i<p_cubNq;++i;@inner(0)){
        if (j<p_Nq && i<p_Nq) {
          r_NU[0] += s_fluxNU[j][i];
          r_NV[0] += s_fluxNV[j][i];
          r_NW[0] += s_fluxNW[j][i];
        }
      }
    }

    @barrier("local");

    quadSurfaceTerms(5) //face 5

    @barrier("local");    

    //accumulate in register pencil
    for(int j=0;j<p_cubNq;++j;@inner(1)){
      for(int i=0;i<p_cubNq;++i;@inner(0)){
        if (j<p_Nq && i<p_Nq) {
          r_NU[p_Nq-1] += s_fluxNU[j][i];
          r_NV[p_Nq-1] += s_fluxNV[j][i];
          r_NW[p_Nq-1] += s_fluxNW[j][i];
        }
      }
    }

    @barrier("local");

    quadSurfaceTerms(1) //face 1

    @barrier("local");    

    //accumulate in register pencil
    for(int j=0;j<p_cubNq;++j;@inner(1)){
      for(int i=0;i<p_cubNq;++i;@inner(0)){
        if (j==0 && i<p_Nq) {//face 1
          #pragma unroll p_Nq
          for (int n=0;n<p_Nq;n++) {
            r_NU[n] += s_fluxNU[n][i];
            r_NV[n] += s_fluxNV[n][i];
            r_NW[n] += s_fluxNW[n][i];
          }
        }
      }
    }

    @barrier("local");

    quadSurfaceTerms(3) //face 3

    @barrier("local");    

    //accumulate in register pencil
    for(int j=0;j<p_cubNq;++j;@inner(1)){
      for(int i=0;i<p_cubNq;++i;@inner(0)){
        if (j==p_Nq-1 && i<p_Nq) {//face 3
          #pragma unroll p_Nq
          for (int n=0;n<p_Nq;n++) {
            r_NU[n] += s_fluxNU[n][i];
            r_NV[n] += s_fluxNV[n][i];
            r_NW[n] += s_fluxNW[n][i];
          }
        }
      }
    }

    @barrier("local");

    quadSurfaceTerms(2) //face 2

    @barrier("local");    

    //accumulate in register pencil
    for(int j=0;j<p_cubNq;++j;@inner(1)){
      for(int i=0;i<p_cubNq;++i;@inner(0)){
        if (j<p_Nq && i==p_Nq-1) {//face 2
          #pragma unroll p_Nq
          for (int n=0;n<p_Nq;n++) {
            r_NU[n] += s_fluxNU[n][j];
            r_NV[n] += s_fluxNV[n][j];
            r_NW[n] += s_fluxNW[n][j];
          }
        }
      }
    }

    @barrier("local");

    quadSurfaceTerms(4) //face 4

    @barrier("local");    

    //accumulate in register pencil
    for(int j=0;j<p_cubNq;++j;@inner(1)){
      for(int i=0;i<p_cubNq;++i;@inner(0)){
        if (j<p_Nq && i==0) {//face 4
          #pragma unroll p_Nq
          for (int n=0;n<p_Nq;n++) {
            r_NU[n] += s_fluxNU[n][j];
            r_NV[n] += s_fluxNV[n][j];
            r_NW[n] += s_fluxNW[n][j];
          }
        }
      }
    }

    @barrier("local");

    for(int j=0;j<p_cubNq;++j;@inner(1)){
      for(int i=0;i<p_cubNq;++i;@inner(0)){
        if(i<p_Nq && j<p_Nq){
          #pragma unroll p_Nq
          for(int k=0;k<p_Nq;++k){
            const dlong gid = e*p_Np*p_Nvgeo+ k*p_Nq*p_Nq + j*p_Nq +i;
            const dfloat invJW = vgeo[gid + p_IJWID*p_Np];

            const dlong id = e*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

            NU[id+0*offset] += invJW*r_NU[k];
            NU[id+1*offset] += invJW*r_NV[k];
            NU[id+2*offset] += invJW*r_NW[k];
          }
        }
      }
    }
  }
}
#undef quadSurfaceTerms
