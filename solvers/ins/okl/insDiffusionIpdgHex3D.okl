
#define surfaceTerms(sk, face,m, i, j)                                  \
{                                                                     \
  const dlong  idM = vmapM[sk];                                       \
  const dlong  idP = vmapP[sk];                                       \
                                                                      \
  const dfloat nx  = sgeo[sk*p_Nsgeo+p_NXID];                         \
  const dfloat ny  = sgeo[sk*p_Nsgeo+p_NYID];                         \
  const dfloat nz  = sgeo[sk*p_Nsgeo+p_NZID];                         \
  const dfloat WsJ = sgeo[sk*p_Nsgeo+p_WSJID];                        \
  const dfloat hinv= sgeo[sk*p_Nsgeo+p_IHID];                         \
                                                                      \
  const dfloat4 gradqM = GU[idM+fld*fieldOffset];                     \
        dfloat4 gradqP = GU[idP+fld*fieldOffset];                     \
                                                                      \
  const int bc = EToB[face+p_Nfaces*emap];                            \
  if(bc>0) {                                                          \
    dfloat4 UM[p_NVfields]; \
    dfloat4 UP[p_NVfields]; \
\
    for (int f=0;f<p_NVfields;f++) {\
      UM[f].x = 0.;               \
      UM[f].y = 0.;               \
      UM[f].z = 0.;               \
      UM[f].w = 0.;               \
    }\
    UM[fld] = gradqM;\
\
    insVelocityDirichletConditions3D(bc, time, x[idM], y[idM], z[idM], nx, ny, nz, UM[0].w, UM[1].w, UM[2].w, &(UP[0].w), &(UP[1].w), &(UP[2].w));\
    insVelocityNeumannConditions3D(bc, time, x[idM], y[idM], z[idM], nx, ny, nz, UM[0].x, UM[0].y, UM[0].z, UM[1].x, UM[1].y, UM[1].z, UM[2].x, UM[2].y, UM[2].z, &(UP[0].x), &(UP[0].y), &(UP[0].z), &(UP[1].x), &(UP[1].y), &(UP[1].z), &(UP[2].x), &(UP[2].y), &(UP[2].z));\
    gradqP = 2*UP[fld] - gradqM;\
  }                                                                   \
                                                                      \
  const dfloat dq = gradqP.w - gradqM.w;                              \
                                                                      \
  s_dqdx[m][j][i] = 0.5f*WsJ*nx*dq;                                   \
  s_dqdy[m][j][i] = 0.5f*WsJ*ny*dq;                                   \
  s_dqdz[m][j][i] = 0.5f*WsJ*nz*dq;                                   \
                                                                      \
  s_Lq[m][j][i] = -0.5f*WsJ*(nx*(gradqP.x+gradqM.x) +                 \
                             ny*(gradqP.y+gradqM.y) +                 \
                             nz*(gradqP.z+gradqM.z) +                 \
                             tau*hinv*dq);                            \
}


@kernel void insDiffusionIpdgHex3D(const dlong Nelements,
                                @restrict const  dlong *  elementList,
                                @restrict const  dlong *  vmapM,
                                @restrict const  dlong *  vmapP,
                                const dfloat nu,
                                const dfloat tau,
                                @restrict const  dfloat *  vgeo,
                                @restrict const  dfloat *  sgeo,
                                @restrict const  int   *  EToB,
                                const dfloat time,
                                @restrict const  dfloat *  x,
                                @restrict const  dfloat *  y,
                                @restrict const  dfloat *  z,
                                const dlong fieldOffset,
                                @restrict const  dfloat *  D,
                                @restrict const  dfloat *  LIFTT,
                                @restrict const  dfloat4 *  GU,
                                      @restrict dfloat  *  LU){
  

  for(dlong e=0;e<Nelements;++e;@outer(0)){
    
    @shared dfloat s_dqdx[2][p_Nq][p_Nq];
    @shared dfloat s_dqdy[2][p_Nq][p_Nq];
    @shared dfloat s_dqdz[2][p_Nq][p_Nq];
    @shared dfloat s_Lq[2][p_Nq][p_Nq];

    @shared dfloat s_D[p_Nq][p_Nq];
    
    @exclusive dfloat r_dqdx[p_Nq], r_dqdy[p_Nq], r_dqdz[p_Nq], r_Lq[p_Nq];
    @exclusive dfloat r_dqdt;

    @exclusive dlong emap;


    #pragma unroll p_NVfields
    for (int fld=0; fld<p_NVfields; fld++) {

      @barrier("local");

      // loop over slabs
      for(int j=0;j<p_Nq;++j;@inner(1)){
        for(int i=0;i<p_Nq;++i;@inner(0)){
          emap = elementList[e];

          #pragma unroll p_Nq
          for(int k=0;k<p_Nq;++k){
            // assume that this stores (p, px, py, pz) as dfloat4
            const dfloat4 gradqn = GU[emap*p_Np+k*p_Nq*p_Nq+j*p_Nq+i+fld*fieldOffset];
            const dlong gid = i + j*p_Nq + k*p_Nq*p_Nq + emap*p_Np*p_Nvgeo;     
            const dfloat JW = vgeo[gid + p_JWID*p_Np];

            r_dqdx[k] = JW*gradqn.x;
            r_dqdy[k] = JW*gradqn.y;
            r_dqdz[k] = JW*gradqn.z;
            r_Lq[k] = 0.0;
          }
            
          s_D[j][i] = D[j*p_Nq+i];
        }
      }
      
      @barrier("local");

      // face 0 & 5
      for(int j=0;j<p_Nq;++j;@inner(1)){
        for(int i=0;i<p_Nq;++i;@inner(0)){
          const dlong sk0 = emap*p_Nfp*p_Nfaces + 0*p_Nfp + j*p_Nq + i ;
          const dlong sk5 = emap*p_Nfp*p_Nfaces + 5*p_Nfp + j*p_Nq + i ;             

          surfaceTerms(sk0,0,0,i,j);
          surfaceTerms(sk5,5,1,i,j); 
        }
      }

      @barrier("local");

      // face 0 & 5
      for(int j=0;j<p_Nq;++j;@inner(1)){
        for(int i=0;i<p_Nq;++i;@inner(0)){
          //face 0
          r_dqdx[0] += s_dqdx[0][j][i];
          r_dqdy[0] += s_dqdy[0][j][i];
          r_dqdz[0] += s_dqdz[0][j][i];
          r_Lq  [0] += s_Lq  [0][j][i];

          //face 5
          r_dqdx[p_Nq-1] += s_dqdx[1][j][i];
          r_dqdy[p_Nq-1] += s_dqdy[1][j][i];
          r_dqdz[p_Nq-1] += s_dqdz[1][j][i];
          r_Lq  [p_Nq-1] += s_Lq  [1][j][i];
        }
      }

      @barrier("local");

      // face 1 & 3
      for(int k=0;k<p_Nq;++k;@inner(1)){
        for(int i=0;i<p_Nq;++i;@inner(0)){
          const dlong sk1 = emap*p_Nfp*p_Nfaces + 1*p_Nfp + k*p_Nq + i ;
          const dlong sk3 = emap*p_Nfp*p_Nfaces + 3*p_Nfp + k*p_Nq + i ;

          surfaceTerms(sk1,1,0,i,k);
          surfaceTerms(sk3,3,1,i,k); 
        }
      }

      @barrier("local");

      // face 1 & 3
      for(int j=0;j<p_Nq;++j;@inner(1)){
        for(int i=0;i<p_Nq;++i;@inner(0)){
          if (j==0) {//face 1
            #pragma unroll p_Nq
            for (int k=0;k<p_Nq;k++) {
              r_dqdx[k] += s_dqdx[0][k][i];
              r_dqdy[k] += s_dqdy[0][k][i];
              r_dqdz[k] += s_dqdz[0][k][i];
              r_Lq  [k] += s_Lq  [0][k][i];
            }
          }
          if (j==p_Nq-1) {//face 3
            #pragma unroll p_Nq
            for (int k=0;k<p_Nq;k++) {
              r_dqdx[k] += s_dqdx[1][k][i];
              r_dqdy[k] += s_dqdy[1][k][i];
              r_dqdz[k] += s_dqdz[1][k][i];
              r_Lq  [k] += s_Lq  [1][k][i];
            }
          }
        }
      }

      @barrier("local");    

      // face 2 & 4
      for(int k=0;k<p_Nq;++k;@inner(1)){
        for(int j=0;j<p_Nq;++j;@inner(0)){

          const dlong sk2 = emap*p_Nfp*p_Nfaces + 2*p_Nfp + k*p_Nq + j ;
          const dlong sk4 = emap*p_Nfp*p_Nfaces + 4*p_Nfp + k*p_Nq + j ;
          
          surfaceTerms(sk2,2,0,j,k);
          surfaceTerms(sk4,4,1,j,k); 
        }
      }

      @barrier("local");

      // face 2 & 4
      for(int j=0;j<p_Nq;++j;@inner(1)){
        for(int i=0;i<p_Nq;++i;@inner(0)){
          if (i==p_Nq-1) {//face 2
            #pragma unroll p_Nq
            for (int k=0;k<p_Nq;k++) {
              r_dqdx[k] += s_dqdx[0][k][j];
              r_dqdy[k] += s_dqdy[0][k][j];
              r_dqdz[k] += s_dqdz[0][k][j];
              r_Lq  [k] += s_Lq  [0][k][j];
            }
          }
          if (i==0) {//face 4
            #pragma unroll p_Nq
            for (int k=0;k<p_Nq;k++) {
              r_dqdx[k] += s_dqdx[1][k][j];
              r_dqdy[k] += s_dqdy[1][k][j];
              r_dqdz[k] += s_dqdz[1][k][j];
              r_Lq  [k] += s_Lq  [1][k][j];
            }
          }
        }
      }

      @barrier("local");

      //layer by layer
      #pragma unroll p_Nq
      for(int k=0;k<p_Nq;++k){
        for(int j=0;j<p_Nq;++j;@inner(1)){
          for(int i=0;i<p_Nq;++i;@inner(0)){

            const dlong gid = i + j*p_Nq + k*p_Nq*p_Nq + emap*p_Np*p_Nvgeo;     

            const dfloat drdx = vgeo[gid + p_RXID*p_Np];
            const dfloat drdy = vgeo[gid + p_RYID*p_Np];
            const dfloat drdz = vgeo[gid + p_RZID*p_Np];
            
            const dfloat dsdx = vgeo[gid + p_SXID*p_Np];
            const dfloat dsdy = vgeo[gid + p_SYID*p_Np];
            const dfloat dsdz = vgeo[gid + p_SZID*p_Np];

            const dfloat dtdx = vgeo[gid + p_TXID*p_Np];
            const dfloat dtdy = vgeo[gid + p_TYID*p_Np];
            const dfloat dtdz = vgeo[gid + p_TZID*p_Np];

            const dfloat dqdx = r_dqdx[k];
            const dfloat dqdy = r_dqdy[k];
            const dfloat dqdz = r_dqdz[k];
            
            s_dqdx[0][j][i] = (drdx*dqdx + drdy*dqdy + drdz*dqdz);
            s_dqdy[0][j][i] = (dsdx*dqdx + dsdy*dqdy + dsdz*dqdz);
            r_dqdt = (dtdx*dqdx + dtdy*dqdy + dtdz*dqdz);
          }
        }

        @barrier("local");

        for(int j=0;j<p_Nq;++j;@inner(1)){
          for(int i=0;i<p_Nq;++i;@inner(0)){
            dfloat dr = 0, ds = 0;

            #pragma unroll p_Nq
            for(int n=0;n<p_Nq;++n){
              dr += s_D[n][i]*s_dqdx[0][j][n];
              r_Lq[n] += s_D[k][n]*r_dqdt; // DT(m,k)*ut(i,j,k,e)
              ds += s_D[n][j]*s_dqdy[0][n][i];
            }
            
            r_Lq[k] += dr + ds;
          }
        }

        @barrier("local");
      }

      for(int j=0;j<p_Nq;++j;@inner(1)){
        for(int i=0;i<p_Nq;++i;@inner(0)){

          #pragma unroll p_Nq        
          for(int k=0;k<p_Nq;++k){
            const dlong gid = emap*p_Np*p_Nvgeo+ j*p_Nq +i;
            const dfloat invJW = vgeo[gid + p_IJWID*p_Np];

            const dlong id = emap*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
            LU[id+fld*fieldOffset] = -nu*invJW*r_Lq[k];
          }
        }
      }
    }
  }
}

