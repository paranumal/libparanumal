@kernel void ellAXPY(const dlong   numRows,
        const int             nnzPerRow,
        const dlong             strideLength,
        const dfloat           alpha,
        const dfloat           beta,
        @restrict const  dlong  * cols,
        @restrict const  dfloat * coefs,
        @restrict const  dfloat * x,
              @restrict dfloat * y){

  // y = alpha * A * x + beta * y
  for(dlong i=0;i<numRows;++i;@tile(256,@outer,@inner)){

    if(i < numRows){
      const dfloat betay = beta*y[i];

      dfloat result = 0.;
      for(int c=0; c<nnzPerRow; c++){
        // location in the memory
        const dlong address = c*strideLength+i;

        // access column index
        const dlong col = cols[address];

        if (col >-1) {
          const dfloat coeffn = coefs[address];
          const dfloat xn = x[col];

          result += coeffn*xn;
        }
      }
      y[i] = alpha*result + betay;//beta*y[row];
    }
  }
}

@kernel void ellZeqAXPY(const dlong   numRows,
           const int   nnzPerRow,
           const dlong   strideLength,
           const dfloat   alpha,
           const dfloat   beta,
           @restrict const  dlong  * cols,
           @restrict const  dfloat * coefs,
           @restrict const  dfloat * x,
           @restrict const  dfloat * y,
                 @restrict dfloat * z){

  // z = alpha * A * x + beta * y
  for(dlong i=0;i<numRows;++i;@tile(256,@outer,@inner)){
    if(i < numRows){
      dfloat result = 0.;
      for(int c=0; c<nnzPerRow; c++){
        // location in the memory
        const dlong address = c*strideLength+i;

        // access column index
        const dlong col = cols[address];

        // dont access coefs[address] if col is -ve
        if(col > -1) result += coefs[address]*x[col];
      }
      z[i] = alpha*result + beta*y[i];
    }
  }
}

@kernel void ellJacobi(const dlong   numRows,
           const int   nnzPerRow,
           const dlong   strideLength,
           @restrict const  dlong  * cols,
           @restrict const  dfloat * coefs,
           @restrict const  dfloat * x,
           @restrict const  dfloat * r,
                 @restrict dfloat * z){

  // z = r - (A-D)*x
  for(dlong i=0;i<numRows;++i;@tile(256,@outer,@inner)){
    if(i < numRows){
      dfloat result = r[i];

      // skip the first stride since it corresponds to diag
      for(int c=1; c<nnzPerRow; c++){
        // location in the memory
        const dlong address = c*strideLength+i;

        // access column index
        const dlong col = cols[address];

        // dont access coefs[address] or x[col] if col is -ve
        if(col > -1) result -= coefs[address]*x[col];
      }
      z[i] = result;
    }
  }
}

