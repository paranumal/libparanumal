// compute Nphi =  div(u*Phi) on cubature points
@kernel void mppfPhaseFieldAdvectionCubatureVolumeTri2D(const dlong Nelements,
                                                        @restrict const  dfloat *  vgeo,
                                                        @restrict const  dfloat *  cubvgeo,
                                                        @restrict const  dfloat *  cubDmatrices,
                                                        @restrict const  dfloat *  cubInterpT,
                                                        @restrict const  dfloat *  cubProjectT,
                                                                  const  dlong     offset,
                                                        @restrict const  dfloat *  U,
                                                        @restrict        dfloat *  cU,
                                                        @restrict const  dfloat *  Phi, 
                                                        @restrict        dfloat *  NPhi){

  for(dlong eo=0;eo<Nelements;eo+=p_cubNblockV;@outer(0)){  // for all elements

    // Hold Flux Vector on Shared, use symmetry f21 = f12
    @shared dfloat s_U[p_cubNblockV][p_Np];
    @shared dfloat s_V[p_cubNblockV][p_Np];
    @shared dfloat s_Phi[p_cubNblockV][p_Np];
    //
    @shared dfloat s_cFr[p_cubNblockV][p_cubNp];
    @shared dfloat s_cFs[p_cubNblockV][p_cubNp];

    @exclusive dlong  e; 
    
    for(int es=0;es<p_cubNblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_maxNodesVolumeCub;++n;@inner(0)){  // for all nodes in this element
      	e = eo+es; // element in block
      	if(e<Nelements && n<p_Np){
        	  const dlong id = e*p_Np+n;
        	  s_U[es][n]   = U[id + 0*offset];
        	  s_V[es][n]   = U[id + 1*offset];
            s_Phi[es][n] = Phi[id];
        } 
      }
    }

    @barrier("local");

    for(int es=0;es<p_cubNblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_maxNodesVolumeCub;++n;@inner(0)){     // for all nodes in this element
      	// const dlong e = eo+es; // element in block
      	if(e<Nelements && n<p_cubNp){
          // prefetch geometric factors (constant on triangle)
          const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
          const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
          const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
          const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];

          dfloat cu = 0.f, cv = 0.f, cphi = 0.f;
          #pragma unroll p_Np
          for(int m=0;m<p_Np;++m){
            dfloat cI = cubInterpT[n+m*p_cubNp];
            cu    += cI*s_U[es][m];
            cv    += cI*s_V[es][m];
            cphi  += cI*s_Phi[es][m]; 
          }
          s_cFr[es][n] = cphi*(drdx*cu + drdy*cv);
          s_cFs[es][n] = cphi*(dsdx*cu + dsdy*cv);
      	 }
      }
    }

    // Make sure all node data is loaded into shared
    @barrier("local");

    for(int es=0;es<p_cubNblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_maxNodesVolumeCub;++n;@inner(0)){     // for all nodes in this element
      	// const dlong  e = eo+es; 
      	if(e<Nelements && n<p_Np){	  	  
      	  // compute 'r' and 's' derivatives of (q_m) at node n
      	  dfloat dfdr = 0.f, dfds = 0.f; 
      	  #pragma unroll (p_cubNp)
      	    for(int m=0;m<p_cubNp;++m){
              dfdr += cubDmatrices[n+m*p_Np]*s_cFr[es][m];
              dfds += cubDmatrices[n+m*p_Np]*s_cFs[es][m];
      	    }
      	  // Update
      	  NPhi[e*p_Np+n] = -(dfdr + dfds); // note  change in sign, weakly implemented  
      	}
      }
    }

  }
}



@kernel void mppfPhaseFieldAdvectionCubatureSurfaceTri2D(const dlong Nelements,
                                                        @restrict const  dfloat * vgeo,
                                                        @restrict const dfloat * sgeo,
                                                        @restrict const dfloat * cubsgeo,
                                                        @restrict const dfloat * intInterpT, // interpolate to integration nodes
                                                        @restrict const dfloat * intLIFTT, // lift from integration to interpolation nodes
                                                        @restrict const dfloat * cubInterpT, 
                                                        @restrict const dfloat * cubProjectT, 
                                                        @restrict const dlong  * vmapM,
                                                        @restrict const dlong  * vmapP,
                                                        @restrict const int *    EToB,
                                                                  const dfloat   time,
                                                        @restrict const dfloat * intx, 
                                                        @restrict const dfloat * inty,
                                                        @restrict const dfloat * intz,
                                                                  const dlong    offset,
                                                        @restrict const dfloat * U,
                                                        @restrict const dfloat * Phi,
                                                        @restrict       dfloat * NPhi){

  // for all elements
  for(dlong eo=0;eo<Nelements;eo+=p_cubNblockS;@outer(0)){

    // shared storage for flux terms
    @shared dfloat s_UM[p_cubNblockS][p_NfacesNfp];
    @shared dfloat s_VM[p_cubNblockS][p_NfacesNfp];
    @shared dfloat s_UP[p_cubNblockS][p_NfacesNfp];
    @shared dfloat s_VP[p_cubNblockS][p_NfacesNfp];
    //
    @shared dfloat s_PhiM[p_cubNblockS][p_NfacesNfp];
    @shared dfloat s_PhiP[p_cubNblockS][p_NfacesNfp];
    //
    @shared dfloat s_fluxPhi[p_cubNblockS][p_intNfpNfaces];

    @exclusive dlong e; 

    // for all face nodes of all elements
    for(int es=0;es<p_cubNblockS;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
        e = eo + es;
        if(e<Nelements && n<p_NfacesNfp){
          const dlong id  = e*p_Nfp*p_Nfaces + n;
          const dlong idM = vmapM[id];
          const dlong idP = vmapP[id];

          // load negative and positive trace node values of velocity
          s_UM[es][n] = U[idM+0*offset];
          s_VM[es][n] = U[idM+1*offset];
          s_UP[es][n] = U[idP+0*offset];
          s_VP[es][n] = U[idP+1*offset];
          //
          s_PhiM[es][n] = Phi[idM];
          s_PhiP[es][n] = Phi[idP];
      }
      }
    }

    @barrier("local");

    // interpolate to surface integration nodes
    for(int es=0;es<p_cubNblockS;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 
        if(e<Nelements && n<p_intNfpNfaces){
            const int face = n/p_intNfp; // find face that owns this integration node

            // load surface geofactors for this face
            const int sid     = p_Nsgeo*(e*p_Nfaces+face);
            const dfloat nx   = sgeo[sid+p_NXID];
            const dfloat ny   = sgeo[sid+p_NYID];
            const dfloat sJ   = sgeo[sid+p_SJID];
            const dfloat invJ = sgeo[sid+p_IJID];

            dfloat um    = 0.f, vm    = 0.f;
            dfloat up    = 0.f, vp    = 0.f;
            dfloat phim  = 0.f, phip  = 0.f;

            // local block interpolation (face nodes to integration nodes)
            #pragma unroll p_Nfp
            for(int m=0;m<p_Nfp;++m){
              const dfloat iInm = intInterpT[n+m*p_intNfpNfaces];
              const int fm = face*p_Nfp+m;
              um += iInm*s_UM[es][fm];
              vm += iInm*s_VM[es][fm];
              //
              up += iInm*s_UP[es][fm];
              vp += iInm*s_VP[es][fm];
              //
              phim += iInm*s_PhiM[es][fm];
              phip += iInm*s_PhiP[es][fm];
            }

            // apply boundary condition
            int bc = EToB[face+p_Nfaces*e];
            if(bc>0){
              // phip = phim; // Currently use this baoundary, change later !!!!! 
              mppfPhaseFieldDirichletConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp],inty[n+e*p_Nfaces*p_intNfp] , nx, ny,phim, &phip);
            }

            // Find max normal velocity on the face
            dfloat unM   = fabs(nx*um + ny*vm);
            dfloat unP   = fabs(nx*up + ny*vp);    
            dfloat unMax = (unM > unP) ? unM : unP;

            // evaluate "flux" terms: LLF
            const dfloat sc = invJ * sJ ; 
            s_fluxPhi[es][n] = sc*(.5f*(nx*(up*phip + um*phim) + ny*(vp*phip + vm*phim) 
                                           + unMax*(phim-phip) ));
          }
      }
    }

    // wait for all @shared memory writes of the previous @inner( )loop to complete
    @barrier("local");

    // lift from surface integration to volume nodes
    for(int es=0;es<p_cubNblockS;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
        if(e<Nelements && n<p_Np ){
            int id = n + p_Np*e;
            // prefetch volume rhs
            dfloat rhs = NPhi[id];

            #pragma unroll p_intNfpNfaces
            for(int m=0;m<(p_intNfp*p_Nfaces);++m){
              rhs += intLIFTT[n+m*p_Np]*s_fluxPhi[es][m];
            }
            NPhi[id] = rhs;
          }
      }
    }
  }
}
