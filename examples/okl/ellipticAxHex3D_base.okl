

@kernel void ellipticAxHex3D_Ref2D10(const dlong Nelements,
                                    @restrict const  dfloat *  ggeo,
                                    @restrict const  dfloat *  D,
                                    const dfloat lambda,
                                    @restrict const  dfloat *  q,
                                          @restrict dfloat *  Aq){

  for(dlong e=0; e<Nelements; ++e; @outer(0)){

    @shared dfloat s_D[p_Nq][p_Nq];
    @shared dfloat s_q[p_Nq][p_Nq];

    @shared dfloat s_Gqr[p_Nq][p_Nq];
    @shared dfloat s_Gqs[p_Nq][p_Nq];

    @exclusive dfloat r_qt, r_Gqt, r_Auk;
    @exclusive dfloat r_q[p_Nq]; // register array to hold u(i,j,0:N) private to thread
    @exclusive dfloat r_Aq[p_Nq];// array for results Au(i,j,0:N)

    dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;

    // array of threads
    for(int j=0;j<p_Nq;++j;@inner(1)){
      for(int i=0;i<p_Nq;++i;@inner(0)){
        //load D into local memory
        // s_D[i][j] = d \phi_i at node j
        s_D[j][i] = D[p_Nq*j+i]; // D is column major

        // load pencil of u into register
        const dlong base = i + j*p_Nq + e*p_Np;
        for(int k = 0; k < p_Nq; k++) {
          r_q[k] = q[base + k*p_Nq*p_Nq]; // prefetch operation
          r_Aq[k] = 0.f; // zero the accumulator
        }
      }
    }

    // Layer by layer
    #pragma unroll p_Nq
      for(int k = 0;k < p_Nq; k++){
        for(int j=0;j<p_Nq;++j;@inner(1)){
          for(int i=0;i<p_Nq;++i;@inner(0)){

            // prefetch geometric factors
            const dlong gbase = e*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

            r_G00 = ggeo[gbase+p_G00ID*p_Np];
            r_G01 = ggeo[gbase+p_G01ID*p_Np];
            r_G02 = ggeo[gbase+p_G02ID*p_Np];

            r_G11 = ggeo[gbase+p_G11ID*p_Np];
            r_G12 = ggeo[gbase+p_G12ID*p_Np];
            r_G22 = ggeo[gbase+p_G22ID*p_Np];

            r_GwJ = ggeo[gbase+p_GWJID*p_Np];
          }
        }

        @barrier("local");

        for(int j=0;j<p_Nq;++j;@inner(1)){
          for(int i=0;i<p_Nq;++i;@inner(0)){

            // share u(:,:,k)
            s_q[j][i] = r_q[k];

            r_qt = 0;

            #pragma unroll p_Nq
              for(int m = 0; m < p_Nq; m++) {
                r_qt += s_D[k][m]*r_q[m];
              }
          }
        }

        @barrier("local");

        for(int j=0;j<p_Nq;++j;@inner(1)){
          for(int i=0;i<p_Nq;++i;@inner(0)){

            dfloat qr = 0.f;
            dfloat qs = 0.f;

            #pragma unroll p_Nq
              for(int m = 0; m < p_Nq; m++) {
                qr += s_D[i][m]*s_q[j][m];
                qs += s_D[j][m]*s_q[m][i];
              }

            s_Gqs[j][i] = (r_G01*qr + r_G11*qs + r_G12*r_qt);
            s_Gqr[j][i] = (r_G00*qr + r_G01*qs + r_G02*r_qt);

            // put this here for a performance bump
            r_Gqt = (r_G02*qr + r_G12*qs + r_G22*r_qt);
            r_Auk = r_GwJ*lambda*r_q[k];
          }
        }

        @barrier("local");

        for(int j=0;j<p_Nq;++j;@inner(1)){
          for(int i=0;i<p_Nq;++i;@inner(0)){

            #pragma unroll p_Nq
              for(int m = 0; m < p_Nq; m++){
                r_Auk   += s_D[m][j]*s_Gqs[m][i];
                r_Aq[m] += s_D[k][m]*r_Gqt; // DT(m,k)*ut(i,j,k,e)
                r_Auk   += s_D[m][i]*s_Gqr[j][m];
              }

            r_Aq[k] += r_Auk;
          }
        }
      }

    // write out

    for(int j=0;j<p_Nq;++j;@inner(1)){
      for(int i=0;i<p_Nq;++i;@inner(0)){
        #pragma unroll p_Nq
          for(int k = 0; k < p_Nq; k++){
            const dlong id = e*p_Np +k*p_Nq*p_Nq+ j*p_Nq + i;
            Aq[id] = r_Aq[k];
          }
      }
    }
  }
}


@kernel void ellipticPartialAxHex3D_Ref2D10(const dlong Nelements,
                                    @restrict const  dlong  *  elementList,
                                    @restrict const  dfloat *  ggeo,
                                    @restrict const  dfloat *  D,
                                    const dfloat lambda,
                                    @restrict const  dfloat *  q,
                                          @restrict dfloat *  Aq){

  for(dlong e=0; e<Nelements; ++e; @outer(0)){

    @shared dfloat s_D[p_Nq][p_Nq];
    @shared dfloat s_q[p_Nq][p_Nq];

    @shared dfloat s_Gqr[p_Nq][p_Nq];
    @shared dfloat s_Gqs[p_Nq][p_Nq];

    @exclusive dfloat r_qt, r_Gqt, r_Auk;
    @exclusive dfloat r_q[p_Nq]; // register array to hold u(i,j,0:N) private to thread
    @exclusive dfloat r_Aq[p_Nq];// array for results Au(i,j,0:N)

    @exclusive dlong element;

    dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;

    // array of threads
    for(int j=0;j<p_Nq;++j;@inner(1)){
      for(int i=0;i<p_Nq;++i;@inner(0)){
        //load D into local memory
        // s_D[i][j] = d \phi_i at node j
        s_D[j][i] = D[p_Nq*j+i]; // D is column major

        // load pencil of u into register
        element = elementList[e];
        const dlong base = i + j*p_Nq + element*p_Np;
        for(int k = 0; k < p_Nq; k++) {
          r_q[k] = q[base + k*p_Nq*p_Nq]; // prefetch operation
          r_Aq[k] = 0.f; // zero the accumulator
        }
      }
    }

    // Layer by layer
    #pragma unroll p_Nq
      for(int k = 0;k < p_Nq; k++){
        for(int j=0;j<p_Nq;++j;@inner(1)){
          for(int i=0;i<p_Nq;++i;@inner(0)){

            // prefetch geometric factors
            const dlong gbase = element*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

            r_G00 = ggeo[gbase+p_G00ID*p_Np];
            r_G01 = ggeo[gbase+p_G01ID*p_Np];
            r_G02 = ggeo[gbase+p_G02ID*p_Np];

            r_G11 = ggeo[gbase+p_G11ID*p_Np];
            r_G12 = ggeo[gbase+p_G12ID*p_Np];
            r_G22 = ggeo[gbase+p_G22ID*p_Np];

            r_GwJ = ggeo[gbase+p_GWJID*p_Np];
          }
        }

        @barrier("local");

        for(int j=0;j<p_Nq;++j;@inner(1)){
          for(int i=0;i<p_Nq;++i;@inner(0)){

            // share u(:,:,k)
            s_q[j][i] = r_q[k];

            r_qt = 0;

            #pragma unroll p_Nq
              for(int m = 0; m < p_Nq; m++) {
                r_qt += s_D[k][m]*r_q[m];
              }
          }
        }

        @barrier("local");

        for(int j=0;j<p_Nq;++j;@inner(1)){
          for(int i=0;i<p_Nq;++i;@inner(0)){

            dfloat qr = 0.f;
            dfloat qs = 0.f;

            #pragma unroll p_Nq
              for(int m = 0; m < p_Nq; m++) {
                qr += s_D[i][m]*s_q[j][m];
                qs += s_D[j][m]*s_q[m][i];
              }

            s_Gqs[j][i] = (r_G01*qr + r_G11*qs + r_G12*r_qt);
            s_Gqr[j][i] = (r_G00*qr + r_G01*qs + r_G02*r_qt);

            // put this here for a performance bump
            r_Gqt = (r_G02*qr + r_G12*qs + r_G22*r_qt);
            r_Auk = r_GwJ*lambda*r_q[k];
          }
        }

        @barrier("local");

        for(int j=0;j<p_Nq;++j;@inner(1)){
          for(int i=0;i<p_Nq;++i;@inner(0)){

            #pragma unroll p_Nq
              for(int m = 0; m < p_Nq; m++){
                r_Auk   += s_D[m][j]*s_Gqs[m][i];
                r_Aq[m] += s_D[k][m]*r_Gqt; // DT(m,k)*ut(i,j,k,e)
                r_Auk   += s_D[m][i]*s_Gqr[j][m];
              }

            r_Aq[k] += r_Auk;
          }
        }
      }

    // write out

    for(int j=0;j<p_Nq;++j;@inner(1)){
      for(int i=0;i<p_Nq;++i;@inner(0)){
        #pragma unroll p_Nq
          for(int k = 0; k < p_Nq; k++){
            const dlong id = element*p_Np +k*p_Nq*p_Nq+ j*p_Nq + i;
            Aq[id] = r_Aq[k];
          }
      }
    }
  }
}



#if 0
// hex @kernel for screened coulomb potential mat-vec
#define cubeThreads                             \
  for(int k=0; k<p_Nq; ++k; @inner(2))            \
    for(int j=0; j<p_Nq; ++j; @inner(1))          \
      for(int i=0; i<p_Nq; ++i; @inner(0))


// cube thread version
@kernel void ellipticAxHex3D_e0(const dlong Nelements,
                               @restrict const  dfloat *  ggeo,
                               @restrict const  dfloat *  D,
                               const dfloat lambda,
                               @restrict const  dfloat *  q,
                               @restrict dfloat *  Aq){

  for(dlong e=0; e<Nelements; ++e; @outer(0)) {

    @shared dfloat s_q[p_Nq][p_Nq][p_Nq];
    @shared dfloat s_D[p_Nq][p_Nq];

    @exclusive dfloat r_qr, r_qs, r_qt, r_Aq;
    @exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;

    // prefetch q(:,:,:,e) to @shared
    cubeThreads {
      const dlong base = i + j*p_Nq + k*p_Nq*p_Nq + e*p_Np;

      s_q[k][j][i] = q[base];

      if(k==0) // fetch D to @shared
      s_D[j][i] = D[j*p_Nq+i];
    }

    @barrier("local");

    cubeThreads {

      const dlong base = e*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

      // assumes w*J built into G entries
      r_GwJ = ggeo[base+p_GWJID*p_Np];

      r_G00 = ggeo[base+p_G00ID*p_Np];
      r_G01 = ggeo[base+p_G01ID*p_Np];
      r_G02 = ggeo[base+p_G02ID*p_Np];

      r_G11 = ggeo[base+p_G11ID*p_Np];
      r_G12 = ggeo[base+p_G12ID*p_Np];
      r_G22 = ggeo[base+p_G22ID*p_Np];

      dfloat qr = 0.f, qs = 0.f, qt = 0.f;

      for(int n=0; n<p_Nq; ++n) {
      qr += s_D[i][n]*s_q[k][j][n];
        qs += s_D[j][n]*s_q[k][n][i];
        qt += s_D[k][n]*s_q[n][j][i];
      }

      r_qr = qr; r_qs = qs; r_qt = qt;

      r_Aq = r_GwJ*lambda*s_q[k][j][i];
    }

    // r term ----->
    @barrier("local");

    cubeThreads {
      s_q[k][j][i] = r_G00*r_qr + r_G01*r_qs + r_G02*r_qt;
    }

    @barrier("local");

    cubeThreads {
      dfloat tmp = 0.f;
      for(int n=0; n<p_Nq; ++n)
      tmp += s_D[n][i]*s_q[k][j][n];

      r_Aq += tmp;
    }

    // s term ---->
    @barrier("local");

    cubeThreads {
      s_q[k][j][i] = r_G01*r_qr + r_G11*r_qs + r_G12*r_qt;
    }

    @barrier("local");

    cubeThreads {
      dfloat tmp = 0.f;
      for(int n=0; n<p_Nq; ++n)
      tmp += s_D[n][j]*s_q[k][n][i];

      r_Aq += tmp;
    }

    // t term ---->
    @barrier("local");

    cubeThreads {
      s_q[k][j][i] = r_G02*r_qr + r_G12*r_qs + r_G22*r_qt;
    }

    @barrier("local");

    cubeThreads {
      dfloat tmp = 0.f;
      for(int n=0; n<p_Nq; ++n)
      tmp += s_D[n][k]*s_q[n][j][i];

      r_Aq += tmp;

      dlong base = e*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
      Aq[base] = r_Aq;
    }
  }
}

//e0a - element list
@kernel void ellipticAxHex3D_e0a(const dlong Nelements,
                                @restrict const  dlong *  elementList,
                                @restrict const  dfloat *  ggeo,
                                @restrict const  dfloat *  D,
                                const dfloat lambda,
                                @restrict const  dfloat *  q,
                                @restrict dfloat *  Aq){

  for(dlong e=0; e<Nelements; ++e; @outer(0)) {

    @shared dfloat s_q[p_Nq][p_Nq][p_Nq];
    @shared dfloat s_D[p_Nq][p_Nq];

    @exclusive dfloat r_qr, r_qs, r_qt, r_Aq;
    @exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;

    // prefetch q(:,:,:,e) to @shared
    cubeThreads {
      const dlong base = i + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np;

      s_q[k][j][i] = q[base];

      if(k==0) // fetch D to @shared
      s_D[j][i] = D[j*p_Nq+i];
    }

    @barrier("local");

    cubeThreads {

      const dlong base = elementList[e]*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

      // assumes w*J built into G entries
      r_GwJ = ggeo[base+p_GWJID*p_Np];

      r_G00 = ggeo[base+p_G00ID*p_Np];
      r_G01 = ggeo[base+p_G01ID*p_Np];
      r_G02 = ggeo[base+p_G02ID*p_Np];

      r_G11 = ggeo[base+p_G11ID*p_Np];
      r_G12 = ggeo[base+p_G12ID*p_Np];
      r_G22 = ggeo[base+p_G22ID*p_Np];

      dfloat qr = 0.f, qs = 0.f, qt = 0.f;

      for(int n=0; n<p_Nq; ++n) {
      qr += s_D[i][n]*s_q[k][j][n];
        qs += s_D[j][n]*s_q[k][n][i];
        qt += s_D[k][n]*s_q[n][j][i];
      }

      r_qr = qr; r_qs = qs; r_qt = qt;

      r_Aq = r_GwJ*lambda*s_q[k][j][i];
    }

    // r term ----->
    @barrier("local");

    cubeThreads {
      s_q[k][j][i] = r_G00*r_qr + r_G01*r_qs + r_G02*r_qt;
    }

    @barrier("local");

    cubeThreads {
      dfloat tmp = 0.f;
      for(int n=0; n<p_Nq; ++n)
      tmp += s_D[n][i]*s_q[k][j][n];

      r_Aq += tmp;
    }

    // s term ---->
    @barrier("local");

    cubeThreads {
      s_q[k][j][i] = r_G01*r_qr + r_G11*r_qs + r_G12*r_qt;
    }

    @barrier("local");

    cubeThreads {
      dfloat tmp = 0.f;
      for(int n=0; n<p_Nq; ++n)
      tmp += s_D[n][j]*s_q[k][n][i];

      r_Aq += tmp;
    }

    // t term ---->
    @barrier("local");

    cubeThreads {
      s_q[k][j][i] = r_G02*r_qr + r_G12*r_qs + r_G22*r_qt;
    }

    @barrier("local");

    cubeThreads {
      dfloat tmp = 0.f;
      for(int n=0; n<p_Nq; ++n)
      tmp += s_D[n][k]*s_q[n][j][i];

      r_Aq += tmp;

      dlong base =  elementList[e]*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
      Aq[base] = r_Aq;
    }
  }
}//e0a end
#endif
