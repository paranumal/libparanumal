

@kernel void acousticsMRABPmlUpdateP3D(const int pmlNelements,
           @restrict const  int   *  pmlElementIds,
           @restrict const  int   *  pmlIds,
           @restrict const  int   *  N,
           const dfloat dt,
           const dfloat a1,
           const dfloat a2,
           const dfloat a3,
           @restrict const  int   *  EToE,
           @restrict const  dfloat *  BBLower,
           @restrict const  int   *  BBRaiseids,
           @restrict const  dfloat *  BBRaiseVals,  
           @restrict const  int   *  vmapM,
           @restrict const  dfloat *  rhsq,
           @restrict const  dfloat *  pmlrhsq,
           @restrict dfloat *  q,
           @restrict dfloat *  pmlq,
           @restrict dfloat *  fQM,
           @restrict dfloat *  fQP,
           const int   rhsShift){

  for(int et=0;et<pmlNelements;++et;@outer(0)){  // for all elements
    @shared dfloat s_q[p_Np*p_Nfields];

    @shared dfloat s_un[p_Nfaces*p_Nfp];
    @shared dfloat s_vn[p_Nfaces*p_Nfp];
    @shared dfloat s_wn[p_Nfaces*p_Nfp];
    @shared dfloat s_pn[p_Nfaces*p_Nfp];

    @shared dfloat s_unp[p_Nfaces*p_Nfpp1];
    @shared dfloat s_vnp[p_Nfaces*p_Nfpp1];
    @shared dfloat s_wnp[p_Nfaces*p_Nfpp1];
    @shared dfloat s_pnp[p_Nfaces*p_Nfpp1];

    for(int n=0; n < p_maxNodes; ++n; @inner(0)){
      if (n < p_Np){
        const int e = pmlElementIds[et];
        const int pmlId = pmlIds[et];

        const int id = p_Nfields*(e*p_NpMax + n);
        const int pid = p_pmlNfields*(pmlId*p_NpMax + n);

        const int rhsId1 = 3*id + ((rhsShift+0)%3)*p_Nfields;
        const int rhsId2 = 3*id + ((rhsShift+1)%3)*p_Nfields;
        const int rhsId3 = 3*id + ((rhsShift+2)%3)*p_Nfields;
        const int pmlrhsId1 = 3*pid + ((rhsShift+0)%3)*p_pmlNfields;
        const int pmlrhsId2 = 3*pid + ((rhsShift+1)%3)*p_pmlNfields;
        const int pmlrhsId3 = 3*pid + ((rhsShift+2)%3)*p_pmlNfields;

        const dfloat px = pmlq[pid+0] + dt*(a1*pmlrhsq[pmlrhsId1+0] + a2*pmlrhsq[pmlrhsId2+0] + a3*pmlrhsq[pmlrhsId3+0]);
        const dfloat py = pmlq[pid+1] + dt*(a1*pmlrhsq[pmlrhsId1+1] + a2*pmlrhsq[pmlrhsId2+1] + a3*pmlrhsq[pmlrhsId3+1]);
        const dfloat pz = pmlq[pid+2] + dt*(a1*pmlrhsq[pmlrhsId1+2] + a2*pmlrhsq[pmlrhsId2+2] + a3*pmlrhsq[pmlrhsId3+2]);

        s_q[p_Nfields*n+0] = q[id+0] + dt*(a1*rhsq[rhsId1+0] + a2*rhsq[rhsId2+0] + a3*rhsq[rhsId3+0]);
        s_q[p_Nfields*n+1] = q[id+1] + dt*(a1*rhsq[rhsId1+1] + a2*rhsq[rhsId2+1] + a3*rhsq[rhsId3+1]);
        s_q[p_Nfields*n+2] = q[id+2] + dt*(a1*rhsq[rhsId1+2] + a2*rhsq[rhsId2+2] + a3*rhsq[rhsId3+2]);
        s_q[p_Nfields*n+3] = px+py+pz;

        //write update
        pmlq[pid+0] = px;
        pmlq[pid+1] = py;
        pmlq[pid+2] = pz;
        q[id+0] = s_q[p_Nfields*n+0];
        q[id+1] = s_q[p_Nfields*n+1];
        q[id+2] = s_q[p_Nfields*n+2];
        q[id+3] = s_q[p_Nfields*n+3];
      }
    }
    @barrier("local");

    for(int n=0; n < p_maxNodes; ++n; @inner(0)){ 
      if (n<p_Nfaces*p_Nfp) {
        const int e = pmlElementIds[et];
        const int f = n / p_Nfp;
        const int iid = n % p_Nfp;
        const int id  = e*p_NfpMax*p_Nfaces + f*p_NfpMax + iid;
        const int qidM = p_Nfields*(vmapM[id]-e*p_NpMax);
        const int qid   = p_Nfields*id;

        //gather negative traces
        s_un[n] = s_q[qidM+0];
        s_vn[n] = s_q[qidM+1];
        s_wn[n] = s_q[qidM+2];
        s_pn[n] = s_q[qidM+3];

        //write negative traces
        fQM[qid+0] = s_un[n];
        fQM[qid+1] = s_vn[n];
        fQM[qid+2] = s_wn[n];
        fQM[qid+3] = s_pn[n];
      }
    }

    @barrier("local");    

    for(int n=0; n < p_maxNodes; ++n; @inner(0)){        
      if (n < p_Nfp*p_Nfaces){
        const int e = pmlElementIds[et];
        const int f = n / p_Nfp;
              int id = n % p_Nfp;

        int eP = EToE[e*p_Nfaces+f];
        if (eP < 0) eP = e;
        const int NP = N[eP];

        if (NP > p_N) { 
          while (id<p_Nfpp1) {
            s_unp[f*p_Nfpp1+id] = 0.0;
            s_vnp[f*p_Nfpp1+id] = 0.0;
            s_wnp[f*p_Nfpp1+id] = 0.0;
            s_pnp[f*p_Nfpp1+id] = 0.0;
            #pragma unroll 3
            for (int m=0;m<3;m++){ //apply raise operator sparsly
              const dfloat BBRaiseVal = BBRaiseVals[3*id+m];
              const int BBRaiseid = BBRaiseids[3*id+m] + f*p_Nfp;
              s_unp[f*p_Nfpp1+id] += BBRaiseVal*s_un[BBRaiseid];
              s_vnp[f*p_Nfpp1+id] += BBRaiseVal*s_vn[BBRaiseid];
              s_wnp[f*p_Nfpp1+id] += BBRaiseVal*s_wn[BBRaiseid];
              s_pnp[f*p_Nfpp1+id] += BBRaiseVal*s_pn[BBRaiseid];
            }
            
            //write positive trace
            const int qid = p_Nfields*(e*p_NfpMax*p_Nfaces + f*p_NfpMax + id);
            fQP[qid+0] = s_unp[f*p_Nfpp1+id];
            fQP[qid+1] = s_vnp[f*p_Nfpp1+id];
            fQP[qid+2] = s_wnp[f*p_Nfpp1+id];
            fQP[qid+3] = s_pnp[f*p_Nfpp1+id];

            id += p_Nfp;
          }
        } else if (NP < p_N) { 
          if (id < p_Nfpm1) {
            s_unp[f*p_Nfpp1+id] = 0.0;
            s_vnp[f*p_Nfpp1+id] = 0.0;
            s_wnp[f*p_Nfpp1+id] = 0.0;
            s_pnp[f*p_Nfpp1+id] = 0.0;
            #pragma unroll p_Nfp
            for (int m=0;m<p_Nfp;m++){
              s_unp[f*p_Nfpp1+id] += BBLower[p_Nfp*id+m]*s_un[f*p_Nfp + m];
              s_vnp[f*p_Nfpp1+id] += BBLower[p_Nfp*id+m]*s_vn[f*p_Nfp + m];
              s_wnp[f*p_Nfpp1+id] += BBLower[p_Nfp*id+m]*s_wn[f*p_Nfp + m];
              s_pnp[f*p_Nfpp1+id] += BBLower[p_Nfp*id+m]*s_pn[f*p_Nfp + m];
            }

            //write positive trace
            const int qid = p_Nfields*(e*p_NfpMax*p_Nfaces + f*p_NfpMax + id);
            fQP[qid+0] = s_unp[f*p_Nfpp1+id];
            fQP[qid+1] = s_vnp[f*p_Nfpp1+id];
            fQP[qid+2] = s_wnp[f*p_Nfpp1+id];
            fQP[qid+3] = s_pnp[f*p_Nfpp1+id];
          }
        } else { //equal order neighbor
          //write positive trace
          const int qid = p_Nfields*(e*p_NfpMax*p_Nfaces + f*p_NfpMax + id);
          fQP[qid+0] = s_un[n];
          fQP[qid+1] = s_vn[n];
          fQP[qid+2] = s_wn[n];
          fQP[qid+3] = s_pn[n];
        }        
      }
    }
  }
}

@kernel void acousticsMRABPmlTraceUpdateP3D(const int pmlNelements,
           @restrict const  int   *  pmlElementIds,
           @restrict const  int   *  pmlIds,
           @restrict const  int   *  N,
           const dfloat dt,
           const dfloat a1,
           const dfloat a2,
           const dfloat a3,
           @restrict const  int   *  EToE,
           @restrict const  dfloat *  BBLower,
           @restrict const  int   *  BBRaiseids,
           @restrict const  dfloat *  BBRaiseVals,  
           @restrict const  int   *  vmapM,
           @restrict const  dfloat *  rhsq,
           @restrict const  dfloat *  pmlrhsq,
           @restrict const  dfloat *  q,
           @restrict const  dfloat *  pmlq,
           @restrict dfloat *  fQM,
           @restrict dfloat *  fQP,
           const int   rhsShift){

  for(int et=0;et<pmlNelements;++et;@outer(0)){  // for all elements
    @shared dfloat s_q[p_Np*p_Nfields];

    @shared dfloat s_un[p_Nfaces*p_Nfp];
    @shared dfloat s_vn[p_Nfaces*p_Nfp];
    @shared dfloat s_wn[p_Nfaces*p_Nfp];
    @shared dfloat s_pn[p_Nfaces*p_Nfp];

    @shared dfloat s_unp[p_Nfaces*p_Nfpp1];
    @shared dfloat s_vnp[p_Nfaces*p_Nfpp1];
    @shared dfloat s_wnp[p_Nfaces*p_Nfpp1];
    @shared dfloat s_pnp[p_Nfaces*p_Nfpp1];

    for(int n=0; n < p_maxNodes; ++n; @inner(0)){
      if (n < p_Np){
        const int e = pmlElementIds[et];
        const int pmlId = pmlIds[et];

        const int id = p_Nfields*(e*p_NpMax + n);
        const int pid = p_pmlNfields*(pmlId*p_NpMax + n);

        const int rhsId1 = 3*id + ((rhsShift+0)%3)*p_Nfields;
        const int rhsId2 = 3*id + ((rhsShift+1)%3)*p_Nfields;
        const int rhsId3 = 3*id + ((rhsShift+2)%3)*p_Nfields;
        const int pmlrhsId1 = 3*pid + ((rhsShift+0)%3)*p_pmlNfields;
        const int pmlrhsId2 = 3*pid + ((rhsShift+1)%3)*p_pmlNfields;
        const int pmlrhsId3 = 3*pid + ((rhsShift+2)%3)*p_pmlNfields;

        const dfloat px = pmlq[pid+0] + dt*(a1*pmlrhsq[pmlrhsId1+0] + a2*pmlrhsq[pmlrhsId2+0] + a3*pmlrhsq[pmlrhsId3+0]);
        const dfloat py = pmlq[pid+1] + dt*(a1*pmlrhsq[pmlrhsId1+1] + a2*pmlrhsq[pmlrhsId2+1] + a3*pmlrhsq[pmlrhsId3+1]);
        const dfloat pz = pmlq[pid+2] + dt*(a1*pmlrhsq[pmlrhsId1+2] + a2*pmlrhsq[pmlrhsId2+2] + a3*pmlrhsq[pmlrhsId3+2]);

        s_q[p_Nfields*n+0] = q[id+0] + dt*(a1*rhsq[rhsId1+0] + a2*rhsq[rhsId2+0] + a3*rhsq[rhsId3+0]);
        s_q[p_Nfields*n+1] = q[id+1] + dt*(a1*rhsq[rhsId1+1] + a2*rhsq[rhsId2+1] + a3*rhsq[rhsId3+1]);
        s_q[p_Nfields*n+2] = q[id+2] + dt*(a1*rhsq[rhsId1+2] + a2*rhsq[rhsId2+2] + a3*rhsq[rhsId3+2]);
        s_q[p_Nfields*n+3] = px+py+pz;
      }
    }
    @barrier("local");

    for(int n=0; n < p_maxNodes; ++n; @inner(0)){ 
      if (n<p_Nfaces*p_Nfp) {
        const int e = pmlElementIds[et];
        const int f = n / p_Nfp;
        const int iid = n % p_Nfp;
        const int id  = e*p_NfpMax*p_Nfaces + f*p_NfpMax + iid;
        const int qidM = p_Nfields*(vmapM[id]-e*p_NpMax);
        const int qid   = p_Nfields*id;

        //gather negative traces
        s_un[n] = s_q[qidM+0];
        s_vn[n] = s_q[qidM+1];
        s_wn[n] = s_q[qidM+2];
        s_pn[n] = s_q[qidM+3];

        //write negative traces
        fQM[qid+0] = s_un[n];
        fQM[qid+1] = s_vn[n];
        fQM[qid+2] = s_wn[n];
        fQM[qid+3] = s_pn[n];
      }
    }

    @barrier("local");    

    for(int n=0; n < p_maxNodes; ++n; @inner(0)){        
      if (n < p_Nfp*p_Nfaces){
        const int e = pmlElementIds[et];
        const int f = n / p_Nfp;
              int id = n % p_Nfp;

        int eP = EToE[e*p_Nfaces+f];
        if (eP < 0) eP = e;
        const int NP = N[eP];

        if (NP > p_N) { 
          while (id<p_Nfpp1) {
            s_unp[f*p_Nfpp1+id] = 0.0;
            s_vnp[f*p_Nfpp1+id] = 0.0;
            s_wnp[f*p_Nfpp1+id] = 0.0;
            s_pnp[f*p_Nfpp1+id] = 0.0;
            #pragma unroll 3
            for (int m=0;m<3;m++){ //apply raise operator sparsly
              const dfloat BBRaiseVal = BBRaiseVals[3*id+m];
              const int BBRaiseid = BBRaiseids[3*id+m] + f*p_Nfp;
              s_unp[f*p_Nfpp1+id] += BBRaiseVal*s_un[BBRaiseid];
              s_vnp[f*p_Nfpp1+id] += BBRaiseVal*s_vn[BBRaiseid];
              s_wnp[f*p_Nfpp1+id] += BBRaiseVal*s_wn[BBRaiseid];
              s_pnp[f*p_Nfpp1+id] += BBRaiseVal*s_pn[BBRaiseid];
            }
            
            //write positive trace
            const int qid = p_Nfields*(e*p_NfpMax*p_Nfaces + f*p_NfpMax + id);
            fQP[qid+0] = s_unp[f*p_Nfpp1+id];
            fQP[qid+1] = s_vnp[f*p_Nfpp1+id];
            fQP[qid+2] = s_wnp[f*p_Nfpp1+id];
            fQP[qid+3] = s_pnp[f*p_Nfpp1+id];

            id += p_Nfp;
          }
        } else if (NP < p_N) { 
          if (id < p_Nfpm1) {
            s_unp[f*p_Nfpp1+id] = 0.0;
            s_vnp[f*p_Nfpp1+id] = 0.0;
            s_wnp[f*p_Nfpp1+id] = 0.0;
            s_pnp[f*p_Nfpp1+id] = 0.0;
            #pragma unroll p_Nfp
            for (int m=0;m<p_Nfp;m++){
              s_unp[f*p_Nfpp1+id] += BBLower[p_Nfp*id+m]*s_un[f*p_Nfp + m];
              s_vnp[f*p_Nfpp1+id] += BBLower[p_Nfp*id+m]*s_vn[f*p_Nfp + m];
              s_wnp[f*p_Nfpp1+id] += BBLower[p_Nfp*id+m]*s_wn[f*p_Nfp + m];
              s_pnp[f*p_Nfpp1+id] += BBLower[p_Nfp*id+m]*s_pn[f*p_Nfp + m];
            }

            //write positive trace
            const int qid = p_Nfields*(e*p_NfpMax*p_Nfaces + f*p_NfpMax + id);
            fQP[qid+0] = s_unp[f*p_Nfpp1+id];
            fQP[qid+1] = s_vnp[f*p_Nfpp1+id];
            fQP[qid+2] = s_wnp[f*p_Nfpp1+id];
            fQP[qid+3] = s_pnp[f*p_Nfpp1+id];
          }
        } else { //equal order neighbor
          //write positive trace
          const int qid = p_Nfields*(e*p_NfpMax*p_Nfaces + f*p_NfpMax + id);
          fQP[qid+0] = s_un[n];
          fQP[qid+1] = s_vn[n];
          fQP[qid+2] = s_wn[n];
          fQP[qid+3] = s_pn[n];
        }        
      }
    }
  }
}

@kernel void acousticsMRABPmlUpdateP3D_wadg(const int pmlNelements,
           @restrict const  int   *  pmlElementIds,
           @restrict const  int   *  pmlIds,
           @restrict const  int   *  N,
           const dfloat dt,
           const dfloat a1,
           const dfloat a2,
           const dfloat a3,
           @restrict const  dfloat *  cubInterp,
           @restrict const  dfloat *  cubProject,
           @restrict const  dfloat *  c2,
           @restrict const  int   *  EToE,
           @restrict const  dfloat *  BBLower,
           @restrict const  int   *  BBRaiseids,
           @restrict const  dfloat *  BBRaiseVals,  
           @restrict const  int   *  vmapM,
           @restrict dfloat *  rhsq,
           @restrict dfloat *  pmlrhsq,
           @restrict dfloat *  q,
           @restrict dfloat *  pmlq,
           @restrict dfloat *  fQM,
           @restrict dfloat *  fQP,
           const int   rhsShift){

  for(int et=0;et<pmlNelements;++et;@outer(0)){  // for all elements
    @shared dfloat s_q[p_Np*p_Nfields];
    @shared dfloat s_p[p_cubNp];

    @shared dfloat s_un[p_Nfaces*p_Nfp];
    @shared dfloat s_vn[p_Nfaces*p_Nfp];
    @shared dfloat s_wn[p_Nfaces*p_Nfp];
    @shared dfloat s_pn[p_Nfaces*p_Nfp];

    @shared dfloat s_unp[p_Nfaces*p_Nfpp1];
    @shared dfloat s_vnp[p_Nfaces*p_Nfpp1];
    @shared dfloat s_wnp[p_Nfaces*p_Nfpp1];
    @shared dfloat s_pnp[p_Nfaces*p_Nfpp1];

    for(int n=0; n < p_maxCubNodes; ++n; @inner(0)){
      if (n < p_Np){
        const int e = pmlElementIds[et];
        const int pmlId = pmlIds[et];

        const int id = p_Nfields*(e*p_NpMax + n);
        const int pid = p_pmlNfields*(pmlId*p_NpMax + n);

        const int rhsId1 = 3*id + ((rhsShift+0)%3)*p_Nfields;
        const int rhsId2 = 3*id + ((rhsShift+1)%3)*p_Nfields;
        const int rhsId3 = 3*id + ((rhsShift+2)%3)*p_Nfields;
        const int pmlrhsId1 = 3*pid + ((rhsShift+0)%3)*p_pmlNfields;
        const int pmlrhsId2 = 3*pid + ((rhsShift+1)%3)*p_pmlNfields;
        const int pmlrhsId3 = 3*pid + ((rhsShift+2)%3)*p_pmlNfields;

        const dfloat px = pmlq[pid+0] + dt*(a1*pmlrhsq[pmlrhsId1+0] + a2*pmlrhsq[pmlrhsId2+0] + a3*pmlrhsq[pmlrhsId3+0]);
        const dfloat py = pmlq[pid+1] + dt*(a1*pmlrhsq[pmlrhsId1+1] + a2*pmlrhsq[pmlrhsId2+1] + a3*pmlrhsq[pmlrhsId3+1]);
        const dfloat pz = pmlq[pid+2] + dt*(a1*pmlrhsq[pmlrhsId1+2] + a2*pmlrhsq[pmlrhsId2+2] + a3*pmlrhsq[pmlrhsId3+2]);

        s_q[p_Nfields*n+0] = q[id+0] + dt*(a1*rhsq[rhsId1+0] + a2*rhsq[rhsId2+0] + a3*rhsq[rhsId3+0]);
        s_q[p_Nfields*n+1] = q[id+1] + dt*(a1*rhsq[rhsId1+1] + a2*rhsq[rhsId2+1] + a3*rhsq[rhsId3+1]);
        s_q[p_Nfields*n+2] = q[id+2] + dt*(a1*rhsq[rhsId1+2] + a2*rhsq[rhsId2+2] + a3*rhsq[rhsId3+2]);
        s_q[p_Nfields*n+3] = px+py+pz;

        //write update
        pmlq[pid+0] = px;
        pmlq[pid+1] = py;
        pmlq[pid+2] = pz;
        q[id+0] = s_q[p_Nfields*n+0];
        q[id+1] = s_q[p_Nfields*n+1];
        q[id+2] = s_q[p_Nfields*n+2];
      }
    }
    @barrier("local");

    // Interpolate p to cubature nodes
    for(int n=0;n<p_maxCubNodes;++n;@inner(0)){
      if (n<p_cubNp) {
        const int e = pmlElementIds[et];
        // Prefetch value of c2
        const dfloat c2n = c2[n + e*p_cubNpMax];

        s_p[n] = 0.f;
        for (int i=0;i<p_Np;++i){
          s_p[n] += cubInterp[n + i*p_cubNp] * s_q[p_Nfields*i+3];
        }
        // Multiply result by wavespeed c2 at cubature node
        s_p[n] *= c2n;
      }
    }
    @barrier("local");

    // Project result back down
    for(int n=0;n<p_maxCubNodes;++n;@inner(0)){
      if (n < p_Np){
        const int e = pmlElementIds[et];
        const int id = p_Nfields*(e*p_NpMax + n);

        // Project scaled rhs down
        dfloat c2p = 0.f;
        for (int i=0;i<p_cubNp;++i){
          c2p += cubProject[n + i*p_Np] * s_p[i];
        }

        s_q[p_Nfields*n+3] = c2p;
        q[id+3] = c2p;
      }
    }
    @barrier("local");

    for(int n=0; n < p_maxCubNodes; ++n; @inner(0)){ 
      if (n<p_Nfaces*p_Nfp) {
        const int e = pmlElementIds[et];
        const int f = n / p_Nfp;
        const int iid = n % p_Nfp;
        const int id  = e*p_NfpMax*p_Nfaces + f*p_NfpMax + iid;
        const int qidM = p_Nfields*(vmapM[id]-e*p_NpMax);
        const int qid   = p_Nfields*id;

        //gather negative traces
        s_un[n] = s_q[qidM+0];
        s_vn[n] = s_q[qidM+1];
        s_wn[n] = s_q[qidM+2];
        s_pn[n] = s_q[qidM+3];

        //write negative traces
        fQM[qid+0] = s_un[n];
        fQM[qid+1] = s_vn[n];
        fQM[qid+2] = s_wn[n];
        fQM[qid+3] = s_pn[n];
      }
    }

    @barrier("local");    

    for(int n=0; n < p_maxCubNodes; ++n; @inner(0)){        
      if (n < p_Nfp*p_Nfaces){
        const int e = pmlElementIds[et];
        const int f = n / p_Nfp;
              int id = n % p_Nfp;

        int eP = EToE[e*p_Nfaces+f];
        if (eP < 0) eP = e;
        const int NP = N[eP];

        if (NP > p_N) { 
          while (id<p_Nfpp1) {
            s_unp[f*p_Nfpp1+id] = 0.0;
            s_vnp[f*p_Nfpp1+id] = 0.0;
            s_wnp[f*p_Nfpp1+id] = 0.0;
            s_pnp[f*p_Nfpp1+id] = 0.0;
            #pragma unroll 3
            for (int m=0;m<3;m++){ //apply raise operator sparsly
              const dfloat BBRaiseVal = BBRaiseVals[3*id+m];
              const int BBRaiseid = BBRaiseids[3*id+m] + f*p_Nfp;
              s_unp[f*p_Nfpp1+id] += BBRaiseVal*s_un[BBRaiseid];
              s_vnp[f*p_Nfpp1+id] += BBRaiseVal*s_vn[BBRaiseid];
              s_wnp[f*p_Nfpp1+id] += BBRaiseVal*s_wn[BBRaiseid];
              s_pnp[f*p_Nfpp1+id] += BBRaiseVal*s_pn[BBRaiseid];
            }
            
            //write positive trace
            const int qid = p_Nfields*(e*p_NfpMax*p_Nfaces + f*p_NfpMax + id);
            fQP[qid+0] = s_unp[f*p_Nfpp1+id];
            fQP[qid+1] = s_vnp[f*p_Nfpp1+id];
            fQP[qid+2] = s_wnp[f*p_Nfpp1+id];
            fQP[qid+3] = s_pnp[f*p_Nfpp1+id];

            id += p_Nfp;
          }
        } else if (NP < p_N) { 
          if (id < p_Nfpm1) {
            s_unp[f*p_Nfpp1+id] = 0.0;
            s_vnp[f*p_Nfpp1+id] = 0.0;
            s_wnp[f*p_Nfpp1+id] = 0.0;
            s_pnp[f*p_Nfpp1+id] = 0.0;
            #pragma unroll p_Nfp
            for (int m=0;m<p_Nfp;m++){
              s_unp[f*p_Nfpp1+id] += BBLower[p_Nfp*id+m]*s_un[f*p_Nfp + m];
              s_vnp[f*p_Nfpp1+id] += BBLower[p_Nfp*id+m]*s_vn[f*p_Nfp + m];
              s_wnp[f*p_Nfpp1+id] += BBLower[p_Nfp*id+m]*s_wn[f*p_Nfp + m];
              s_pnp[f*p_Nfpp1+id] += BBLower[p_Nfp*id+m]*s_pn[f*p_Nfp + m];
            }

            //write positive trace
            const int qid = p_Nfields*(e*p_NfpMax*p_Nfaces + f*p_NfpMax + id);
            fQP[qid+0] = s_unp[f*p_Nfpp1+id];
            fQP[qid+1] = s_vnp[f*p_Nfpp1+id];
            fQP[qid+2] = s_wnp[f*p_Nfpp1+id];
            fQP[qid+3] = s_pnp[f*p_Nfpp1+id];
          }
        } else { //equal order neighbor
          //write positive trace
          const int qid = p_Nfields*(e*p_NfpMax*p_Nfaces + f*p_NfpMax + id);
          fQP[qid+0] = s_un[n];
          fQP[qid+1] = s_vn[n];
          fQP[qid+2] = s_wn[n];
          fQP[qid+3] = s_pn[n];
        }        
      }
    }
  }
}

@kernel void acousticsMRABPmlTraceUpdateP3D_wadg(const int pmlNelements,
           @restrict const  int   *  pmlElementIds,
           @restrict const  int   *  pmlIds,
           @restrict const  int   *  N,
           const dfloat dt,
           const dfloat a1,
           const dfloat a2,
           const dfloat a3,
           @restrict const  dfloat *  cubInterp,
           @restrict const  dfloat *  cubProject,
           @restrict const  dfloat *  c2,
           @restrict const  int   *  EToE,
           @restrict const  dfloat *  BBLower,
           @restrict const  int   *  BBRaiseids,
           @restrict const  dfloat *  BBRaiseVals,  
           @restrict const  int   *  vmapM,
           @restrict const  dfloat *  rhsq,
           @restrict const  dfloat *  pmlrhsq,
           @restrict const  dfloat *  q,
           @restrict const  dfloat *  pmlq,
           @restrict dfloat *  fQM,
           @restrict dfloat *  fQP,
           const int   rhsShift){

  for(int et=0;et<pmlNelements;++et;@outer(0)){  // for all elements
    @shared dfloat s_q[p_Np*p_Nfields];
    @shared dfloat s_p[p_cubNp];

    @shared dfloat s_un[p_Nfaces*p_Nfp];
    @shared dfloat s_vn[p_Nfaces*p_Nfp];
    @shared dfloat s_wn[p_Nfaces*p_Nfp];
    @shared dfloat s_pn[p_Nfaces*p_Nfp];

    @shared dfloat s_unp[p_Nfaces*p_Nfpp1];
    @shared dfloat s_vnp[p_Nfaces*p_Nfpp1];
    @shared dfloat s_wnp[p_Nfaces*p_Nfpp1];
    @shared dfloat s_pnp[p_Nfaces*p_Nfpp1];

    for(int n=0; n < p_maxCubNodes; ++n; @inner(0)){
      if (n < p_Np){
        const int e = pmlElementIds[et];
        const int pmlId = pmlIds[et];

        const int id = p_Nfields*(e*p_NpMax + n);
        const int pid = p_pmlNfields*(pmlId*p_NpMax + n);

        const int rhsId1 = 3*id + ((rhsShift+0)%3)*p_Nfields;
        const int rhsId2 = 3*id + ((rhsShift+1)%3)*p_Nfields;
        const int rhsId3 = 3*id + ((rhsShift+2)%3)*p_Nfields;
        const int pmlrhsId1 = 3*pid + ((rhsShift+0)%3)*p_pmlNfields;
        const int pmlrhsId2 = 3*pid + ((rhsShift+1)%3)*p_pmlNfields;
        const int pmlrhsId3 = 3*pid + ((rhsShift+2)%3)*p_pmlNfields;

        const dfloat px = pmlq[pid+0] + dt*(a1*pmlrhsq[pmlrhsId1+0] + a2*pmlrhsq[pmlrhsId2+0] + a3*pmlrhsq[pmlrhsId3+0]);
        const dfloat py = pmlq[pid+1] + dt*(a1*pmlrhsq[pmlrhsId1+1] + a2*pmlrhsq[pmlrhsId2+1] + a3*pmlrhsq[pmlrhsId3+1]);
        const dfloat pz = pmlq[pid+2] + dt*(a1*pmlrhsq[pmlrhsId1+2] + a2*pmlrhsq[pmlrhsId2+2] + a3*pmlrhsq[pmlrhsId3+2]);

        s_q[p_Nfields*n+0] = q[id+0] + dt*(a1*rhsq[rhsId1+0] + a2*rhsq[rhsId2+0] + a3*rhsq[rhsId3+0]);
        s_q[p_Nfields*n+1] = q[id+1] + dt*(a1*rhsq[rhsId1+1] + a2*rhsq[rhsId2+1] + a3*rhsq[rhsId3+1]);
        s_q[p_Nfields*n+2] = q[id+2] + dt*(a1*rhsq[rhsId1+2] + a2*rhsq[rhsId2+2] + a3*rhsq[rhsId3+2]);
        s_q[p_Nfields*n+3] = px+py+pz;
      }
    }
    @barrier("local");

    // Interpolate p to cubature nodes
    for(int n=0;n<p_maxCubNodes;++n;@inner(0)){
      if (n<p_cubNp) {
        const int e = pmlElementIds[et];
        // Prefetch value of c2
        const dfloat c2n = c2[n + e*p_cubNp];

        s_p[n] = 0.f;
        for (int i=0;i<p_Np;++i){
          s_p[n] += cubInterp[n + i*p_cubNp] * s_q[p_Nfields*i+3];
        }
        // Multiply result by wavespeed c2 at cubature node
        s_p[n] *= c2n;
      }
    }
    @barrier("local");

    // Project result back down
    for(int n=0;n<p_maxCubNodes;++n;@inner(0)){
      if (n < p_Np){
        // Project scaled rhs down
        dfloat c2p = 0.f;
        for (int i=0;i<p_cubNp;++i){
          c2p += cubProject[n + i*p_Np] * s_p[i];
        }
        s_q[p_Nfields*n+3] = c2p;
      }
    }
    @barrier("local");

    for(int n=0; n < p_maxCubNodes; ++n; @inner(0)){ 
      if (n<p_Nfaces*p_Nfp) {
        const int e = pmlElementIds[et];
        const int f = n / p_Nfp;
        const int iid = n % p_Nfp;
        const int id  = e*p_NfpMax*p_Nfaces + f*p_NfpMax + iid;
        const int qidM = p_Nfields*(vmapM[id]-e*p_NpMax);
        const int qid   = p_Nfields*id;

        //gather negative traces
        s_un[n] = s_q[qidM+0];
        s_vn[n] = s_q[qidM+1];
        s_wn[n] = s_q[qidM+2];
        s_pn[n] = s_q[qidM+3];

        //write negative traces
        fQM[qid+0] = s_un[n];
        fQM[qid+1] = s_vn[n];
        fQM[qid+2] = s_wn[n];
        fQM[qid+3] = s_pn[n];
      }
    }

    @barrier("local");    

    for(int n=0; n < p_maxCubNodes; ++n; @inner(0)){        
      if (n < p_Nfp*p_Nfaces){
        const int e = pmlElementIds[et];
        const int f = n / p_Nfp;
              int id = n % p_Nfp;

        int eP = EToE[e*p_Nfaces+f];
        if (eP < 0) eP = e;
        const int NP = N[eP];

        if (NP > p_N) { 
          while (id<p_Nfpp1) {
            s_unp[f*p_Nfpp1+id] = 0.0;
            s_vnp[f*p_Nfpp1+id] = 0.0;
            s_wnp[f*p_Nfpp1+id] = 0.0;
            s_pnp[f*p_Nfpp1+id] = 0.0;
            #pragma unroll 3
            for (int m=0;m<3;m++){ //apply raise operator sparsly
              const dfloat BBRaiseVal = BBRaiseVals[3*id+m];
              const int BBRaiseid = BBRaiseids[3*id+m] + f*p_Nfp;
              s_unp[f*p_Nfpp1+id] += BBRaiseVal*s_un[BBRaiseid];
              s_vnp[f*p_Nfpp1+id] += BBRaiseVal*s_vn[BBRaiseid];
              s_wnp[f*p_Nfpp1+id] += BBRaiseVal*s_wn[BBRaiseid];
              s_pnp[f*p_Nfpp1+id] += BBRaiseVal*s_pn[BBRaiseid];
            }
            
            //write positive trace
            const int qid = p_Nfields*(e*p_NfpMax*p_Nfaces + f*p_NfpMax + id);
            fQP[qid+0] = s_unp[f*p_Nfpp1+id];
            fQP[qid+1] = s_vnp[f*p_Nfpp1+id];
            fQP[qid+2] = s_wnp[f*p_Nfpp1+id];
            fQP[qid+3] = s_pnp[f*p_Nfpp1+id];

            id += p_Nfp;
          }
        } else if (NP < p_N) { 
          if (id < p_Nfpm1) {
            s_unp[f*p_Nfpp1+id] = 0.0;
            s_vnp[f*p_Nfpp1+id] = 0.0;
            s_wnp[f*p_Nfpp1+id] = 0.0;
            s_pnp[f*p_Nfpp1+id] = 0.0;
            #pragma unroll p_Nfp
            for (int m=0;m<p_Nfp;m++){
              s_unp[f*p_Nfpp1+id] += BBLower[p_Nfp*id+m]*s_un[f*p_Nfp + m];
              s_vnp[f*p_Nfpp1+id] += BBLower[p_Nfp*id+m]*s_vn[f*p_Nfp + m];
              s_wnp[f*p_Nfpp1+id] += BBLower[p_Nfp*id+m]*s_wn[f*p_Nfp + m];
              s_pnp[f*p_Nfpp1+id] += BBLower[p_Nfp*id+m]*s_pn[f*p_Nfp + m];
            }

            //write positive trace
            const int qid = p_Nfields*(e*p_NfpMax*p_Nfaces + f*p_NfpMax + id);
            fQP[qid+0] = s_unp[f*p_Nfpp1+id];
            fQP[qid+1] = s_vnp[f*p_Nfpp1+id];
            fQP[qid+2] = s_wnp[f*p_Nfpp1+id];
            fQP[qid+3] = s_pnp[f*p_Nfpp1+id];
          }
        } else { //equal order neighbor
          //write positive trace
          const int qid = p_Nfields*(e*p_NfpMax*p_Nfaces + f*p_NfpMax + id);
          fQP[qid+0] = s_un[n];
          fQP[qid+1] = s_vn[n];
          fQP[qid+2] = s_wn[n];
          fQP[qid+3] = s_pn[n];
        }        
      }
    }
  }
}
