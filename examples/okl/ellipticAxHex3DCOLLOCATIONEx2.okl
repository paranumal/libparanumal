
#define cubeThreads                             \
	for(int k=0; k<p_Nq; ++k; @inner(2))            \
		for(int j=0; j<p_Nq; ++j; @inner(1))          \
			for(int i=0; i<p_Nq; ++i; @inner(0))

//this is just  for 3D threads, do not expect this to work with N>9
#if p_Nq==8 || p_Nq==16
#define p_gllPad 1
#else
#define p_gllPad 0
#endif

//baseline - as unoptimized as possible


@kernel void ellipticAxHex3D_Ref3D0(int Nelements,
                                   int *  elementList,
                                   dfloat * ggeo,
                                   dfloat *  D,
                                   dfloat lambda,
                                   dfloat *  q,
                                   dfloat *  Aq,
                                   dfloat * Aqtemp){
                                   
	for(int e=0; e<Nelements; ++e; @outer(0)) {
	
		//	@shared dfloat q[p_Nq][p_Nq][p_Nq];
		@shared dfloat s_D[p_Nq][p_Nq];
		
		@exclusive dfloat r_qr, r_qs, r_qt;
		
		cubeThreads {
		  //int base = i + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np;
		  
		  
		  
		  if(k==0) // fetch D to @shared
		  s_D[j][i] = D[j*p_Nq+i];
		}
		
		@barrier("local");
		
		cubeThreads {
		
		  int base = elementList[e]*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
		  dfloat  GwJ;
		  // assumes w*J built into G entries
		  GwJ = ggeo[base+p_GWJID*p_Np];
		  
		  
		  
		  
		  
		  dfloat qr = 0.f, qs = 0.f, qt = 0.f;
		  
		  for(int n=0; n<p_Nq; ++n) {
		  //i + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np;
		  qr += s_D[i][n]*q[n + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np];
			  qs += s_D[j][n]*q[i + n*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np];
			  qt += s_D[k][n]*q[i + j*p_Nq + n*p_Nq*p_Nq + elementList[e]*p_Np];
		  }
		  
		  r_qr = qr; r_qs = qs; r_qt = qt;
		  
		  Aq[i + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np] = GwJ*lambda*q[i + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np];
		}
		
		// r term ----->
		@barrier("local");
		
		cubeThreads {
		  dfloat G00, G01, G02;
		  int base = elementList[e]*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
		  
		  G00 = ggeo[base+p_G00ID*p_Np];
		  G01 = ggeo[base+p_G01ID*p_Np];
		  G02 = ggeo[base+p_G02ID*p_Np];
		  Aqtemp[i + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np] = G00*r_qr + G01*r_qs + G02*r_qt;
		  // if (e==0)
		  // printf("q[%d][%d][%d] = %15.15f\n", k, j, i,q[i + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np]);
		}
		
		@barrier("local");
		
		cubeThreads {
		  dfloat tmp = 0.f;
		  for(int n=0; n<p_Nq; ++n)
		  tmp += s_D[n][i]* Aqtemp[n + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np];
		  
		  Aq[i + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np] += tmp;
		}
		
		// s term ---->
		@barrier("local");
		
		cubeThreads {
		  dfloat G01, G11, G12;
		  int base = elementList[e]*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
		  
		  G01 = ggeo[base+p_G01ID*p_Np];
		  G11 = ggeo[base+p_G11ID*p_Np];
		  G12 = ggeo[base+p_G12ID*p_Np];
		  Aqtemp[i + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np] = G01*r_qr + G11*r_qs + G12*r_qt;
		}
		
		@barrier("local");
		
		cubeThreads {
		  dfloat tmp = 0.f;
		  for(int n=0; n<p_Nq; ++n)
		  tmp += s_D[n][j]* Aqtemp[i + n*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np];
		  
		  Aq[i + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np] += tmp;
		}
		
		@barrier("local");
		cubeThreads {
		  dfloat G02, G12, G22;
		  int base = elementList[e]*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
		  
		  G02 = ggeo[base+p_G02ID*p_Np];
		  G12 = ggeo[base+p_G12ID*p_Np];
		  G22 = ggeo[base+p_G22ID*p_Np];
		  Aqtemp[i + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np] = G02*r_qr + G12*r_qs + G22*r_qt;
		}
		
		@barrier("local");
		
		cubeThreads {
		  dfloat tmp = 0.f;
		  for(int n=0; n<p_Nq; ++n)
		  tmp += s_D[n][k]* Aqtemp[i + j*p_Nq + n*p_Nq*p_Nq + elementList[e]*p_Np];
		  
		  Aq[i + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np] += tmp;
		  
		}
	}
}

//consrt variables, loop unrolling
@kernel void ellipticAxHex3D_Ref3D1(const int Nelements,
                                   @restrict const  int *  elementList,
                                   @restrict const  dfloat *  ggeo,
                                   @restrict const  dfloat *  D,
                                   const dfloat lambda,
                                   @restrict const  dfloat *  q,
                                   @restrict dfloat *  Aq,
                                   @restrict dfloat *  Aqtemp){
                                   
	for(int e=0; e<Nelements; ++e; @outer(0)) {
	
		//	@shared dfloat q[p_Nq][p_Nq][p_Nq];
		@shared dfloat s_D[p_Nq][p_Nq];
		
		@exclusive dfloat r_qr, r_qs, r_qt;
		
		cubeThreads {
		  //int base = i + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np;
		  
		  
		  
		  if(k==0) // fetch D to @shared
		  s_D[j][i] = D[j*p_Nq+i];
		}
		
		@barrier("local");
		
		cubeThreads {
		
		  const int base = elementList[e]*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
		  dfloat  GwJ;
		  // assumes w*J built into G entries
		  GwJ = ggeo[base+p_GWJID*p_Np];
		  
		  
		  
		  
		  
		  dfloat qr = 0.f, qs = 0.f, qt = 0.f;
		  
		  for(int n=0; n<p_Nq; ++n) {
		  //i + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np;
		  qr += s_D[i][n]*q[n + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np];
			  qs += s_D[j][n]*q[i + n*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np];
			  qt += s_D[k][n]*q[i + j*p_Nq + n*p_Nq*p_Nq + elementList[e]*p_Np];
		  }
		  
		  r_qr = qr; r_qs = qs; r_qt = qt;
		  
		  Aq[i + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np] = GwJ*lambda*q[i + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np];
		}
		
		// r term ----->
		@barrier("local");
		
		cubeThreads {
		  dfloat G00, G01, G02;
		  const int base = elementList[e]*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
		  
		  G00 = ggeo[base+p_G00ID*p_Np];
		  G01 = ggeo[base+p_G01ID*p_Np];
		  G02 = ggeo[base+p_G02ID*p_Np];
		  Aqtemp[i + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np] = G00*r_qr + G01*r_qs + G02*r_qt;
		  // if (e==0)
		  // printf("q[%d][%d][%d] = %15.15f\n", k, j, i,q[i + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np]);
		}
		
		@barrier("local");
		
		cubeThreads {
		  dfloat tmp = 0.f;
		  for(int n=0; n<p_Nq; ++n)
		  tmp += s_D[n][i]* Aqtemp[n + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np];
		  
		  Aq[i + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np] += tmp;
		}
		
		// s term ---->
		@barrier("local");
		
		cubeThreads {
		  dfloat G01, G11, G12;
		  const int base = elementList[e]*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
		  
		  G01 = ggeo[base+p_G01ID*p_Np];
		  G11 = ggeo[base+p_G11ID*p_Np];
		  G12 = ggeo[base+p_G12ID*p_Np];
		  Aqtemp[i + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np] = G01*r_qr + G11*r_qs + G12*r_qt;
		}
		
		@barrier("local");
		
		cubeThreads {
		  dfloat tmp = 0.f;
		  for(int n=0; n<p_Nq; ++n)
		  tmp += s_D[n][j]* Aqtemp[i + n*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np];
		  
		  Aq[i + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np] += tmp;
		}
		
		@barrier("local");
		cubeThreads {
		  dfloat G02, G12, G22;
		  const int base = elementList[e]*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
		  
		  G02 = ggeo[base+p_G02ID*p_Np];
		  G12 = ggeo[base+p_G12ID*p_Np];
		  G22 = ggeo[base+p_G22ID*p_Np];
		  Aqtemp[i + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np] = G02*r_qr + G12*r_qs + G22*r_qt;
		}
		
		@barrier("local");
		
		cubeThreads {
		  dfloat tmp = 0.f;
		  for(int n=0; n<p_Nq; ++n)
		  tmp += s_D[n][k]* Aqtemp[i + j*p_Nq + n*p_Nq*p_Nq + elementList[e]*p_Np];
		  
		  Aq[i + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np] += tmp;
		  
		}
	}
}
//geofactors in registers, fetched ONCE

@kernel void ellipticAxHex3D_Ref3D2(const int Nelements,
                                   @restrict const  int *  elementList,
                                   @restrict const  dfloat *  ggeo,
                                   @restrict const  dfloat *  D,
                                   const dfloat lambda,
                                   @restrict const  dfloat *  q,
                                   @restrict dfloat *  Aq,
                                   @restrict dfloat *  Aqtemp){
                                   
	for(int e=0; e<Nelements; ++e; @outer(0)) {
	
		//	@shared dfloat q[p_Nq][p_Nq][p_Nq];
		@shared dfloat s_D[p_Nq][p_Nq];
		@exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;
		@exclusive dfloat r_qr, r_qs, r_qt;
		
		cubeThreads {
		  //int base = i + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np;
		  
		  
		  
		  if(k==0) // fetch D to @shared
		  s_D[j][i] = D[j*p_Nq+i];
		}
		
		@barrier("local");
		
		cubeThreads {
		
		  const int base = elementList[e]*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
		  dfloat  GwJ;
		  // assumes w*J built into G entries
		  r_GwJ = ggeo[base+p_GWJID*p_Np];
		  
		  r_G00 = ggeo[base+p_G00ID*p_Np];
		  r_G01 = ggeo[base+p_G01ID*p_Np];
		  r_G02 = ggeo[base+p_G02ID*p_Np];
		  
		  r_G11 = ggeo[base+p_G11ID*p_Np];
		  r_G12 = ggeo[base+p_G12ID*p_Np];
		  r_G22 = ggeo[base+p_G22ID*p_Np];
		  
		  
		  
		  
		  
		  dfloat qr = 0.f, qs = 0.f, qt = 0.f;
		  
		  for(int n=0; n<p_Nq; ++n) {
		  //i + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np;
		  qr += s_D[i][n]*q[n + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np];
			  qs += s_D[j][n]*q[i + n*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np];
			  qt += s_D[k][n]*q[i + j*p_Nq + n*p_Nq*p_Nq + elementList[e]*p_Np];
		  }
		  
		  r_qr = qr; r_qs = qs; r_qt = qt;
		  
		  Aq[i + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np] = r_GwJ*lambda*q[i + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np];
		}
		
		// r term ----->
		@barrier("local");
		
		cubeThreads {
		
		
		  Aqtemp[i + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np] = r_G00*r_qr + r_G01*r_qs + r_G02*r_qt;
		  // if (e==0)
		  // printf("q[%d][%d][%d] = %15.15f\n", k, j, i,q[i + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np]);
		}
		
		@barrier("local");
		
		cubeThreads {
		  dfloat tmp = 0.f;
		  for(int n=0; n<p_Nq; ++n)
		  tmp += s_D[n][i]* Aqtemp[n + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np];
		  
		  Aq[i + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np] += tmp;
		}
		
		// s term ---->
		@barrier("local");
		
		cubeThreads {
		
		  Aqtemp[i + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np] = r_G01*r_qr + r_G11*r_qs + r_G12*r_qt;
		}
		
		@barrier("local");
		
		cubeThreads {
		  dfloat tmp = 0.f;
		  for(int n=0; n<p_Nq; ++n)
		  tmp += s_D[n][j]* Aqtemp[i + n*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np];
		  
		  Aq[i + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np] += tmp;
		}
		
		@barrier("local");
		cubeThreads {
		  dfloat G02, G12, G22;
		  const int base = elementList[e]*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
		  
		  G02 = ggeo[base+p_G02ID*p_Np];
		  G12 = ggeo[base+p_G12ID*p_Np];
		  G22 = ggeo[base+p_G22ID*p_Np];
		  Aqtemp[i + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np] = r_G02*r_qr + r_G12*r_qs + r_G22*r_qt;
		}
		
		@barrier("local");
		
		cubeThreads {
		  dfloat tmp = 0.f;
		  for(int n=0; n<p_Nq; ++n)
		  tmp += s_D[n][k]* Aqtemp[i + j*p_Nq + n*p_Nq*p_Nq + elementList[e]*p_Np];
		  
		  Aq[i + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np] += tmp;
		  
		}
	}
}

//register variable instead of writing directly to Aq
@kernel void ellipticAxHex3D_Ref3D3(const int Nelements,
                                   @restrict const  int *  elementList,
                                   @restrict const  dfloat *  ggeo,
                                   @restrict const  dfloat *  D,
                                   const dfloat lambda,
                                   @restrict const  dfloat *  q,
                                   @restrict dfloat *  Aq,
                                   @restrict dfloat *  Aqtemp){
                                   
	for(int e=0; e<Nelements; ++e; @outer(0)) {
	
		//	@shared dfloat q[p_Nq][p_Nq][p_Nq];
		@shared dfloat s_D[p_Nq][p_Nq];
		@exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;
		@exclusive dfloat r_qr, r_qs, r_qt, r_Aq;
		
		cubeThreads {
		  //int base = i + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np;
		  
		  
		  
		  if(k==0) // fetch D to @shared
		  s_D[j][i] = D[j*p_Nq+i];
		}
		
		@barrier("local");
		
		cubeThreads {
		
		  const int base = elementList[e]*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
		  dfloat  GwJ;
		  // assumes w*J built into G entries
		  r_GwJ = ggeo[base+p_GWJID*p_Np];
		  
		  r_G00 = ggeo[base+p_G00ID*p_Np];
		  r_G01 = ggeo[base+p_G01ID*p_Np];
		  r_G02 = ggeo[base+p_G02ID*p_Np];
		  
		  r_G11 = ggeo[base+p_G11ID*p_Np];
		  r_G12 = ggeo[base+p_G12ID*p_Np];
		  r_G22 = ggeo[base+p_G22ID*p_Np];
		  
		  
		  
		  
		  
		  dfloat qr = 0.f, qs = 0.f, qt = 0.f;
		  
		  for(int n=0; n<p_Nq; ++n) {
		  //i + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np;
		  qr += s_D[i][n]*q[n + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np];
			  qs += s_D[j][n]*q[i + n*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np];
			  qt += s_D[k][n]*q[i + j*p_Nq + n*p_Nq*p_Nq + elementList[e]*p_Np];
		  }
		  
		  r_qr = qr; r_qs = qs; r_qt = qt;
		  
		  r_Aq = r_GwJ*lambda*q[i + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np];
		}
		
		// r term ----->
		@barrier("local");
		
		cubeThreads {
		
		
		  Aqtemp[i + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np] = r_G00*r_qr + r_G01*r_qs + r_G02*r_qt;
		  // if (e==0)
		  // printf("q[%d][%d][%d] = %15.15f\n", k, j, i,q[i + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np]);
		}
		
		@barrier("local");
		
		cubeThreads {
		  dfloat tmp = 0.f;
		  for(int n=0; n<p_Nq; ++n)
		  tmp += s_D[n][i]* Aqtemp[n + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np];
		  
		  r_Aq += tmp;
		}
		
		// s term ---->
		@barrier("local");
		
		cubeThreads {
		
		  Aqtemp[i + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np] = r_G01*r_qr + r_G11*r_qs + r_G12*r_qt;
		}
		
		@barrier("local");
		
		cubeThreads {
		  dfloat tmp = 0.f;
		  for(int n=0; n<p_Nq; ++n)
		  tmp += s_D[n][j]* Aqtemp[i + n*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np];
		  
		  r_Aq += tmp;
		}
		
		@barrier("local");
		cubeThreads {
		  dfloat G02, G12, G22;
		  const int base = elementList[e]*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
		  
		  G02 = ggeo[base+p_G02ID*p_Np];
		  G12 = ggeo[base+p_G12ID*p_Np];
		  G22 = ggeo[base+p_G22ID*p_Np];
		  Aqtemp[i + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np]  = r_G02*r_qr + r_G12*r_qs + r_G22*r_qt;
		}
		
		@barrier("local");
		
		cubeThreads {
		  dfloat tmp = 0.f;
		  for(int n=0; n<p_Nq; ++n)
		  tmp += s_D[n][k]* Aqtemp[i + j*p_Nq + n*p_Nq*p_Nq + elementList[e]*p_Np];
		  
		  r_Aq+=tmp;
		  
		  
		  Aq[i + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np] = r_Aq;
		  
		}
	}
}


//q in @shared
@kernel void ellipticAxHex3D_Ref3D4(const int Nelements,
                                   @restrict const  int *  elementList,
                                   @restrict const  dfloat *  ggeo,
                                   @restrict const  dfloat *  D,
                                   const dfloat lambda,
                                   @restrict const  dfloat *  q,
                                   @restrict dfloat *  Aq,
                                   @restrict dfloat *  Aqtemp){
                                   
	for(int e=0; e<Nelements; ++e; @outer(0)) {
	
		@shared dfloat s_q[p_Nq][p_Nq][p_Nq];
		@shared dfloat s_D[p_Nq][p_Nq];
		
		@exclusive dfloat r_qr, r_qs, r_qt, r_Aq;
		@exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;
		
		// prefetch q(:,:,:,e) to @shared
		cubeThreads {
		  const int base = i + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np;
		  
		  s_q[k][j][i] = q[base];
		  
		  if(k==0) // fetch D to @shared
		  s_D[j][i] = D[j*p_Nq+i];
		}
		
		@barrier("local");
		
		cubeThreads {
		
		  const int base = elementList[e]*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
		  
		  // assumes w*J built into G entries
		  r_GwJ = ggeo[base+p_GWJID*p_Np];
		  
		  r_G00 = ggeo[base+p_G00ID*p_Np];
		  r_G01 = ggeo[base+p_G01ID*p_Np];
		  r_G02 = ggeo[base+p_G02ID*p_Np];
		  
		  r_G11 = ggeo[base+p_G11ID*p_Np];
		  r_G12 = ggeo[base+p_G12ID*p_Np];
		  r_G22 = ggeo[base+p_G22ID*p_Np];
		  
		  dfloat qr = 0.f, qs = 0.f, qt = 0.f;
		  #pragma unroll p_Nq
		  for(int n=0; n<p_Nq; ++n) {
		  qr += s_D[i][n]*s_q[k][j][n];
			  qs += s_D[j][n]*s_q[k][n][i];
			  qt += s_D[k][n]*s_q[n][j][i];
		  }
		  
		  r_qr = qr; r_qs = qs; r_qt = qt;
		  
		  r_Aq = r_GwJ*lambda*s_q[k][j][i];
		  
		}
		
		// r term ----->
		@barrier("local");
		
		cubeThreads {
		  s_q[k][j][i] = r_G00*r_qr + r_G01*r_qs + r_G02*r_qt;
		}
		
		@barrier("local");
		
		cubeThreads {
		  dfloat tmp = 0.f;
		  #pragma unroll p_Nq
		  for(int n=0; n<p_Nq; ++n)
		  tmp += s_D[n][i]*s_q[k][j][n];
		  
		  r_Aq += tmp;
		  
		}
		
		// s term ---->
		@barrier("local");
		
		cubeThreads {
		  s_q[k][j][i] = r_G01*r_qr + r_G11*r_qs + r_G12*r_qt;
		}
		
		@barrier("local");
		
		cubeThreads {
		  dfloat tmp = 0.f;
		  #pragma unroll p_Nq
		  for(int n=0; n<p_Nq; ++n)
		  tmp += s_D[n][j]*s_q[k][n][i];
		  
		  r_Aq += tmp;
		  int base2 =  elementList[e]*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
		  Aq[base2] = r_Aq;
		}
		
		// t term ---->
		@barrier("local");
		
		cubeThreads {
		  s_q[k][j][i] = r_G02*r_qr + r_G12*r_qs + r_G22*r_qt;
		}
		
		@barrier("local");
		
		cubeThreads {
		  dfloat tmp = 0.f;
		  #pragma unroll p_Nq
		  for(int n=0; n<p_Nq; ++n)
		  tmp += s_D[n][k]*s_q[n][j][i];
		  
		  r_Aq += tmp;
		  
		  int base =  elementList[e]*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
		  Aq[base] = r_Aq;
		}
	}
}
//Ref5: version with multiple @shared arrays

@kernel void ellipticAxHex3D_Ref3D5(const int Nelements,
                                   @restrict const  int *  elementList,
                                   @restrict const  dfloat *  ggeo,
                                   @restrict const  dfloat *  D,
                                   const dfloat lambda,
                                   @restrict const  dfloat *  q,
                                   @restrict dfloat *  Aq,
                                   @restrict dfloat *  Aqtemp){
                                   
	for(int e=0; e<Nelements; ++e; @outer(0)) {
	
		@shared dfloat s_q[p_Nq][p_Nq][p_Nq];
		@shared dfloat s_q1[p_Nq][p_Nq][p_Nq];
		@shared dfloat s_q2[p_Nq][p_Nq][p_Nq];
		@shared dfloat s_q3[p_Nq][p_Nq][p_Nq];
		@shared dfloat s_D[p_Nq][p_Nq];
		
		@exclusive dfloat r_qr, r_qs, r_qt, r_Aq;
		@exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;
		
		// prefetch q(:,:,:,e) to @shared
		cubeThreads {
		  const int base = i + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np;
		  
		  s_q[k][j][i] = q[base];
		  
		  if(k==0) // fetch D to @shared
		  s_D[j][i] = D[j*p_Nq+i];
		}
		
		@barrier("local");
		
		cubeThreads {
		
		  const int base = elementList[e]*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
		  
		  // assumes w*J built into G entries
		  r_GwJ = ggeo[base+p_GWJID*p_Np];
		  
		  r_G00 = ggeo[base+p_G00ID*p_Np];
		  r_G01 = ggeo[base+p_G01ID*p_Np];
		  r_G02 = ggeo[base+p_G02ID*p_Np];
		  
		  r_G11 = ggeo[base+p_G11ID*p_Np];
		  r_G12 = ggeo[base+p_G12ID*p_Np];
		  r_G22 = ggeo[base+p_G22ID*p_Np];
		  
		  dfloat qr = 0.f, qs = 0.f, qt = 0.f;
		  #pragma unroll p_Nq
		  for(int n=0; n<p_Nq; ++n) {
		  qr += s_D[i][n]*s_q[k][j][n];
			  qs += s_D[j][n]*s_q[k][n][i];
			  qt += s_D[k][n]*s_q[n][j][i];
		  }
		  r_qr = qr; r_qs = qs; r_qt = qt;
		  s_q1[k][j][i] = r_G00*r_qr + r_G01*r_qs + r_G02*r_qt;
		  s_q2[k][j][i] = r_G01*r_qr + r_G11*r_qs + r_G12*r_qt;
		  s_q3[k][j][i] = r_G02*r_qr + r_G12*r_qs + r_G22*r_qt;
		  
		  
		  
		  r_Aq = r_GwJ*lambda*s_q[k][j][i];
		  
		}
		
		// r term ----->
		@barrier("local");
		
		
		cubeThreads {
		  dfloat tmp = 0.f;
		  #pragma unroll p_Nq
		  for(int n=0; n<p_Nq; ++n){
		  tmp += s_D[n][i]*s_q1[k][j][n];
			  tmp += s_D[n][j]*s_q2[k][n][i];
			  tmp += s_D[n][k]*s_q3[n][j][i];
		  }
		  r_Aq += tmp;
		  int base =  elementList[e]*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
		  Aq[base] = r_Aq;
		}
	}
}


@kernel void ellipticAxHex3D_e0a(const int Nelements,
                                @restrict const  int *  elementList,
                                @restrict const  dfloat *  ggeo,
                                @restrict const  dfloat *  D,
                                const dfloat lambda,
                                @restrict const  dfloat *  q,
                                @restrict dfloat *  Aq){
                                
	for(int e=0; e<Nelements; ++e; @outer(0)) {
	
		@shared dfloat s_q[p_Nq][p_Nq][p_Nq];
		@shared dfloat s_D[p_Nq][p_Nq];
		
		@exclusive dfloat r_qr, r_qs, r_qt, r_Aq;
		@exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;
		
		// prefetch q(:,:,:,e) to @shared
		cubeThreads {
		  const int base = i + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np;
		  
		  s_q[k][j][i] = q[base];
		  
		  if(k==0) // fetch D to @shared
		  s_D[j][i] = D[j*p_Nq+i];
		}
		
		@barrier("local");
		
		cubeThreads {
		
		  const int base = elementList[e]*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
		  
		  // assumes w*J built into G entries
		  r_GwJ = ggeo[base+p_GWJID*p_Np];
		  
		  r_G00 = ggeo[base+p_G00ID*p_Np];
		  r_G01 = ggeo[base+p_G01ID*p_Np];
		  r_G02 = ggeo[base+p_G02ID*p_Np];
		  
		  r_G11 = ggeo[base+p_G11ID*p_Np];
		  r_G12 = ggeo[base+p_G12ID*p_Np];
		  r_G22 = ggeo[base+p_G22ID*p_Np];
		  
		  dfloat qr = 0.f, qs = 0.f, qt = 0.f;
		  #pragma unroll p_Nq
		  for(int n=0; n<p_Nq; ++n) {
		  qr += s_D[i][n]*s_q[k][j][n];
			  qs += s_D[j][n]*s_q[k][n][i];
			  qt += s_D[k][n]*s_q[n][j][i];
		  }
		  
		  r_qr = qr; r_qs = qs; r_qt = qt;
		  
		  r_Aq = r_GwJ*lambda*s_q[k][j][i];
		  
		}
		
		// r term ----->
		@barrier("local");
		
		cubeThreads {
		  s_q[k][j][i] = r_G00*r_qr + r_G01*r_qs + r_G02*r_qt;
		}
		
		@barrier("local");
		
		cubeThreads {
		  dfloat tmp = 0.f;
		  #pragma unroll p_Nq
		  for(int n=0; n<p_Nq; ++n)
		  tmp += s_D[n][i]*s_q[k][j][n];
		  
		  r_Aq += tmp;
		  
		}
		
		// s term ---->
		@barrier("local");
		
		cubeThreads {
		  s_q[k][j][i] = r_G01*r_qr + r_G11*r_qs + r_G12*r_qt;
		}
		
		@barrier("local");
		
		cubeThreads {
		  dfloat tmp = 0.f;
		  #pragma unroll p_Nq
		  for(int n=0; n<p_Nq; ++n)
		  tmp += s_D[n][j]*s_q[k][n][i];
		  
		  r_Aq += tmp;
		  int base2 =  elementList[e]*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
		  Aq[base2] = r_Aq;
		}
		
		// t term ---->
		@barrier("local");
		
		cubeThreads {
		  s_q[k][j][i] = r_G02*r_qr + r_G12*r_qs + r_G22*r_qt;
		}
		
		@barrier("local");
		
		cubeThreads {
		  dfloat tmp = 0.f;
		  #pragma unroll p_Nq
		  for(int n=0; n<p_Nq; ++n)
		  tmp += s_D[n][k]*s_q[n][j][i];
		  
		  r_Aq += tmp;
		  
		  int base =  elementList[e]*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
		  Aq[base] = r_Aq;
		}
	}
}