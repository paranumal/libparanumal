// Only difference with boltzmannVolume2D is size of rhsq and shifting
@kernel void boltzmannVolume2D(const int Nelements,
            @restrict const  int *  elementIds,
            const dfloat ramp,
            const dfloat drampdt,
            const int nrhs,
            const int shift,
            @restrict const  dfloat *  vgeo,
            @restrict const  dfloat *  DrT,
            @restrict const  dfloat *  DsT,
            @restrict const  dfloat *  q,
                  @restrict dfloat *  rhsq){  
  for(int eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){  // for all elements

    @shared dfloat s_q[p_NblockV][p_Nfields][p_Np];
    @exclusive int e;

  for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
    for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element

      int et = eo+es; // element in block

      if(et<Nelements){
        e = elementIds[et];
        const int id = p_Nfields*(e*p_Np + n);
        
        #pragma unroll p_Nfields
        for(int fld=0; fld<p_Nfields;++fld){
          s_q[es][fld][n] = q[id+fld];
        }

      }
    }
  }

    // make sure all node data is loaded into @shared
    @barrier("local");

  for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
    for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element 
      int et = eo+es; // element in block
      if(et<Nelements){   
        // prefetch geometric factors (constant on triangle)
        const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
        const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
        const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
        const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];

        // compute 'r' and 's' derivatives of (q_m) at node n
        dfloat r_dqdr[p_Nfields], r_dqds[p_Nfields]; 
        dfloat r_dqdx[p_Nfields], r_dqdy[p_Nfields];
        dfloat r_rhsq[p_Nfields];
        
        #pragma unroll p_Nfields
        for(int fld=0; fld<p_Nfields;++fld){
          r_dqdr[fld] = 0.f, r_dqds[fld] = 0.f;
          r_dqdx[fld] = 0.f, r_dqdy[fld] = 0.f;
          r_rhsq[fld] = 0.f;
         }

        #pragma unroll p_Np
        for(int i=0;i<p_Np;++i){
          const dfloat Drni = DrT[n+i*p_Np];
          const dfloat Dsni = DsT[n+i*p_Np];
          #pragma unroll p_Nfields
          for(int fld=0; fld<p_Nfields;++fld){
           r_dqdr[fld] += Drni*s_q[es][fld][i];
           r_dqds[fld] += Dsni*s_q[es][fld][i];
         }
        }
      
        // Compute derivatives in physical coordinates 
        #pragma unroll p_Nfields
        for(int fld=0; fld<p_Nfields;++fld){
          r_dqdx[fld] = drdx*r_dqdr[fld] + dsdx*r_dqds[fld];
          r_dqdy[fld] = drdy*r_dqdr[fld] + dsdy*r_dqds[fld];
        }

         // transport operator
        r_rhsq[0] = -p_sqrtRT*(r_dqdx[1] + r_dqdy[2]);
        r_rhsq[1] = -p_sqrtRT*(r_dqdx[0] + p_sqrt2*r_dqdx[4] + r_dqdy[3]); 
        r_rhsq[2] = -p_sqrtRT*(r_dqdx[3] + r_dqdy[0] + p_sqrt2*r_dqdy[5]); 
        r_rhsq[3] = -p_sqrtRT*(r_dqdx[2] + r_dqdy[1]);   
        r_rhsq[4] = -p_sqrtRT*p_sqrt2*r_dqdx[1];     
        r_rhsq[5] = -p_sqrtRT*p_sqrt2*r_dqdy[2];        

        // BGK relaxation approximation to the Boltzmann collision operator
        r_rhsq[3] -= p_tauInv*(s_q[es][3][n] - (s_q[es][1][n]*s_q[es][2][n]/s_q[es][0][n]));
        r_rhsq[4] -= p_tauInv*(s_q[es][4][n] - p_invsqrt2*(s_q[es][1][n]*s_q[es][1][n]/s_q[es][0][n]));
        r_rhsq[5] -= p_tauInv*(s_q[es][5][n] - p_invsqrt2*(s_q[es][2][n]*s_q[es][2][n]/s_q[es][0][n]));

        // Add mean flow forcing
        r_rhsq[1] += drampdt*p_q2bar;
        r_rhsq[2] += drampdt*p_q3bar;
        r_rhsq[3] += 2.f*ramp*drampdt*p_q4bar;
        r_rhsq[4] += 2.f*ramp*drampdt*p_q5bar;
        r_rhsq[5] += 2.f*ramp*drampdt*p_q6bar;

         //Update 
        const int id = p_Nfields*(e*p_Np + n);
        const int rhsId = nrhs*id + p_Nfields*shift;
       
        for(int fld=0; fld<p_Nfields;++fld){
          rhsq[rhsId + fld] = r_rhsq[fld];
        }
      }
    }
  }
}
}


// Original @kernel!!!!!
@kernel void boltzmannPmlVolume2D(const int pmlNelements,
              @restrict const  int *  pmlElementIds,
              @restrict const  int *  pmlIds,
              const dfloat ramp,
              const dfloat drampdt,
              const int nrhs, 
              const int shift,
              @restrict const  dfloat *  vgeo,
              @restrict const  dfloat *  pmlSigmaX,
              @restrict const  dfloat *  pmlSigmaY,
              @restrict const  dfloat *  DrT,
              @restrict const  dfloat *  DsT,
              @restrict const  dfloat *  q,
              @restrict const  dfloat *  pmlqx,
              @restrict const  dfloat *  pmlqy,
                    @restrict dfloat *  rhsq,
                    @restrict dfloat *  pmlrhsqx,
                    @restrict dfloat *  pmlrhsqy){
  
  for(int eo=0;eo<pmlNelements;eo+=p_NblockV;@outer(0)){  // for all elements

    @shared dfloat s_q[p_NblockV][p_Nfields][p_Np];
    @exclusive int e, pmlId;

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element

      int et = eo+es; // element in block
      if(et<pmlNelements){
        e     = pmlElementIds[et];
        pmlId = pmlIds[et];

        const int id = p_Nfields*(e*p_Np + n);

        #pragma unroll p_Nfields
        for(int fld=0; fld<p_Nfields;++fld){
          s_q[es][fld][n] = q[id+fld];
        }
      }
     }
    }

    // make sure all node data is loaded into @shared
    @barrier("local");

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element 
       int et = eo+es; // element in block
       if(et<pmlNelements){  

        // prefetch geometric factors 
        const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
        const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
        const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
        const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];
        
        // Prefetch sigma
        const dfloat sigmaxe = pmlSigmaX[pmlId*p_Np+n];
        const dfloat sigmaye = pmlSigmaY[pmlId*p_Np+n];

        // Pack register variables into arrays 
        dfloat r_pmlqx[p_Nfields], r_pmlqy[p_Nfields];
        dfloat r_dqdr[p_Nfields],  r_dqds[p_Nfields];
        dfloat r_dqdx[p_Nfields],  r_dqdy[p_Nfields];
        dfloat r_Aqx[p_Nfields],   r_Bqy[p_Nfields];
        dfloat r_N[p_Nfields];
        
        // Initialize
        #pragma unroll p_Nfields
        for(int fld=0; fld<p_Nfields; ++fld){
          r_pmlqx[fld] = 0.f, r_pmlqy[fld] = 0.f; 
          r_dqdr[fld]  = 0.f, r_dqds[fld]  = 0.f; 
          r_dqdx[fld]  = 0.f, r_dqdy[fld]  = 0.f; 
          r_N[fld]     = 0.f; 
        }
    
       
       // Read from global
        const int pid = p_Nfields*(pmlId*p_Np + n);

        #pragma unroll p_Nfields
        for(int fld=0; fld<p_Nfields; ++fld){
          r_pmlqx[fld] = pmlqx[pid+fld]; 
          r_pmlqy[fld] = pmlqy[pid+fld]; 
        }


        // Compute Derivatives
        #pragma unroll p_Np
        for(int i=0;i<p_Np;++i){
          const dfloat Drni = DrT[n+i*p_Np];
          const dfloat Dsni = DsT[n+i*p_Np];
          #pragma unroll p_Nfields
          for(int fld=0; fld<p_Nfields; ++fld){
            r_dqdr[fld] += Drni*s_q[es][fld][i];
            r_dqds[fld] += Dsni*s_q[es][fld][i];
          }
        }
        
        #pragma unroll p_Nfields
        for(int fld=0; fld<p_Nfields; ++fld){
          r_dqdx[fld] = drdx*r_dqdr[fld] + dsdx*r_dqds[fld];
          r_dqdy[fld] = drdy*r_dqdr[fld] + dsdy*r_dqds[fld];
        }
  
        // Compute volume flux for q, qx and qy
        // A*dQ/dx
        r_Aqx[0] = -p_sqrtRT*(r_dqdx[1]);
        r_Aqx[1] = -p_sqrtRT*(r_dqdx[0] + p_sqrt2*r_dqdx[4]);  
        r_Aqx[2] = -p_sqrtRT*(r_dqdx[3]);
        r_Aqx[3] = -p_sqrtRT*(r_dqdx[2]);
        r_Aqx[4] = -p_sqrtRT*p_sqrt2*r_dqdx[1];      
        r_Aqx[5] =  0.f;
        // B*dQ/dy
        r_Bqy[0] = -p_sqrtRT*(r_dqdy[2]);
        r_Bqy[1] = -p_sqrtRT*(r_dqdy[3]);  
        r_Bqy[2] = -p_sqrtRT*(r_dqdy[0] + p_sqrt2*r_dqdy[5]);  
        r_Bqy[3] = -p_sqrtRT*(r_dqdy[1]);    
        r_Bqy[4] =  0.f;
        r_Bqy[5] = -p_sqrtRT*p_sqrt2*r_dqdy[2];  

        // N(q) + mean flow forcing 
        r_N[0] = 0.f;
        r_N[1] = drampdt*p_q2bar;
        r_N[2] = drampdt*p_q3bar;
        r_N[3] = 2.f*ramp*drampdt*p_q4bar -p_tauInv*(s_q[es][3][n]-(s_q[es][1][n]*s_q[es][2][n]/s_q[es][0][n]));
        r_N[4] = 2.f*ramp*drampdt*p_q5bar -p_tauInv*(s_q[es][4][n]-(p_invsqrt2*s_q[es][1][n]*s_q[es][1][n]/s_q[es][0][n]));
        r_N[5] = 2.f*ramp*drampdt*p_q6bar -p_tauInv*(s_q[es][5][n]-(p_invsqrt2*s_q[es][2][n]*s_q[es][2][n]/s_q[es][0][n]));

     
     
        const dfloat msigmaxe = sigmaxe + sigmaye*p_pmlAlpha;
        const dfloat msigmaye = sigmaye + sigmaxe*p_pmlAlpha; 

        // Update
        const int id       = p_Nfields*(e*p_Np + n);
        const int rhsId    = nrhs*id + p_Nfields*shift;
        const int pmlrhsId = nrhs*p_Nfields*(pmlId*p_Np + n) + p_Nfields*shift; 

        #pragma unroll p_Nfields
        for(int fld=0; fld<p_Nfields; ++fld){
          pmlrhsqx[pmlrhsId + fld] = -msigmaxe*r_pmlqx[fld]  + r_Aqx[fld];
          pmlrhsqy[pmlrhsId + fld] = -msigmaye*r_pmlqy[fld]  + r_Bqy[fld];
          //
          rhsq[rhsId +fld] = -msigmaxe*r_pmlqx[fld] - msigmaye*r_pmlqy[fld] + r_Aqx[fld] + r_Bqy[fld] + r_N[fld];
         
        }

      }
    }
  }
  
}
}


// Only difference with boltzmannVolume2D is size of rhsq and shifting
@kernel void boltzmannVolumeCub2D(const int Nelements,
            @restrict const  int *  elementIds,
            const dfloat ramp,
            const dfloat drampdt,
            const int nrhs,
            const int shift,
            @restrict const  dfloat *  vgeo,
            @restrict const  dfloat *  DrT,
            @restrict const  dfloat *  DsT,
            @restrict const  dfloat *  q,
                  @restrict dfloat *  rhsq){
  
  for(int eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){  // for all elements

    @shared dfloat s_q[p_NblockV][p_Nfields][p_Np];
    @exclusive int e;

  for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
    for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element

      int et = eo+es; // element in block

      if(et<Nelements){
        e = elementIds[et];
        const int id = p_Nfields*(e*p_Np + n);
        #pragma unroll p_Nfields
        for(int fld=0; fld<p_Nfields;++fld){
          s_q[es][fld][n] = q[id+fld];
        }

      }
    }
  }

    // make sure all node data is loaded into @shared
    @barrier("local");

  for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
    for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element 
      int et = eo+es; // element in block
      if(et<Nelements){   
        // prefetch geometric factors (constant on triangle)
        const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
        const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
        const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
        const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];

        // compute 'r' and 's' derivatives of (q_m) at node n
        dfloat r_dqdr[p_Nfields], r_dqds[p_Nfields]; 
        dfloat r_dqdx[p_Nfields], r_dqdy[p_Nfields];
        dfloat r_rhsq[p_Nfields];
        
        #pragma unroll p_Nfields
        for(int fld=0; fld<p_Nfields;++fld){
          r_dqdr[fld] = 0.f, r_dqds[fld] = 0.f;
          r_dqdx[fld] = 0.f, r_dqdy[fld] = 0.f;
          r_rhsq[fld] = 0.f;
         }

        #pragma unroll p_Np
        for(int i=0;i<p_Np;++i){
          const dfloat Drni = DrT[n+i*p_Np];
          const dfloat Dsni = DsT[n+i*p_Np];
          #pragma unroll p_Nfields
          for(int fld=0; fld<p_Nfields;++fld){
           r_dqdr[fld] += Drni*s_q[es][fld][i];
           r_dqds[fld] += Dsni*s_q[es][fld][i];
         }
        }
      
        // Compute derivatives in physical coordinates 
        #pragma unroll p_Nfields
        for(int fld=0; fld<p_Nfields;++fld){
          r_dqdx[fld] = drdx*r_dqdr[fld] + dsdx*r_dqds[fld];
          r_dqdy[fld] = drdy*r_dqdr[fld] + dsdy*r_dqds[fld];
        }

         // transport operator
        r_rhsq[0] = -p_sqrtRT*(r_dqdx[1] + r_dqdy[2]);
        r_rhsq[1] = -p_sqrtRT*(r_dqdx[0] + p_sqrt2*r_dqdx[4] + r_dqdy[3]); 
        r_rhsq[2] = -p_sqrtRT*(r_dqdx[3] + r_dqdy[0] + p_sqrt2*r_dqdy[5]); 
        r_rhsq[3] = -p_sqrtRT*(r_dqdx[2] + r_dqdy[1]);   
        r_rhsq[4] = -p_sqrtRT*p_sqrt2*r_dqdx[1];     
        r_rhsq[5] = -p_sqrtRT*p_sqrt2*r_dqdy[2];        

        
        // Add mean flow forcing
        r_rhsq[1] += drampdt*p_q2bar;
        r_rhsq[2] += drampdt*p_q3bar;
        r_rhsq[3] += 2.f*ramp*drampdt*p_q4bar;
        r_rhsq[4] += 2.f*ramp*drampdt*p_q5bar;
        r_rhsq[5] += 2.f*ramp*drampdt*p_q6bar;

         //Update 
        const int id = p_Nfields*(e*p_Np + n);
        const int rhsId = nrhs*id + p_Nfields*shift;
       
        for(int fld=0; fld<p_Nfields;++fld){
          rhsq[rhsId + fld] = r_rhsq[fld];
        }
      }
    }
  }
}
}




@kernel void boltzmannPmlVolumeCub2D(const int pmlNelements,
              @restrict const  int *  pmlElementIds,
              @restrict const  int *  pmlIds,
              const dfloat ramp,
              const dfloat drampdt,
              const int nrhs, 
              const int shift,
              @restrict const  dfloat *  vgeo,
              @restrict const  dfloat *  pmlSigmaX, // unused just for keeping the same structure in timeSteppers
              @restrict const  dfloat *  pmlSigmaY, // unused just for keeping the same structure in timeSteppers
              @restrict const  dfloat *  DrT,
              @restrict const  dfloat *  DsT,
              @restrict const  dfloat *  q,
              @restrict const  dfloat *  pmlqx,
              @restrict const  dfloat *  pmlqy,
                    @restrict dfloat *  rhsq,
                    @restrict dfloat *  pmlrhsqx,
                    @restrict dfloat *  pmlrhsqy){
  
  for(int eo=0;eo<pmlNelements;eo+=p_NblockV;@outer(0)){  // for all elements

    @shared dfloat s_q[p_NblockV][p_Nfields][p_Np];
    @exclusive int e, pmlId;

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element

      int et = eo+es; // element in block
      if(et<pmlNelements){
        e     = pmlElementIds[et];
        pmlId = pmlIds[et];

        const int id = p_Nfields*(e*p_Np + n);
        #pragma unroll p_Nfields
        for(int fld=0; fld<p_Nfields;++fld){
          s_q[es][fld][n] = q[id+fld];
        }
      }
     }
    }

    // make sure all node data is loaded into @shared
    @barrier("local");

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element 
       int et = eo+es; // element in block
       if(et<pmlNelements){  

        // prefetch geometric factors 
        const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
        const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
        const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
        const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];
        
        // Pack register variables into arrays 
        // dfloat r_pmlqx[p_Nfields], r_pmlqy[p_Nfields];
        dfloat r_dqdr[p_Nfields],  r_dqds[p_Nfields];
        dfloat r_dqdx[p_Nfields],  r_dqdy[p_Nfields];
        dfloat r_Aqx[p_Nfields],   r_Bqy[p_Nfields];
        dfloat r_N[p_Nfields];
        
        // Initialize
        #pragma unroll p_Nfields
        for(int fld=0; fld<p_Nfields; ++fld){
          //r_pmlqx[fld] = 0.f, r_pmlqy[fld] = 0.f; 
          r_dqdr[fld]  = 0.f, r_dqds[fld]  = 0.f; 
          r_dqdx[fld]  = 0.f, r_dqdy[fld]  = 0.f; 
          r_N[fld]     = 0.f; 
        }
    
        // Compute Derivatives
        #pragma unroll p_Np
        for(int i=0;i<p_Np;++i){
          const dfloat Drni = DrT[n+i*p_Np];
          const dfloat Dsni = DsT[n+i*p_Np];
          #pragma unroll p_Nfields
          for(int fld=0; fld<p_Nfields; ++fld){
            r_dqdr[fld] += Drni*s_q[es][fld][i];
            r_dqds[fld] += Dsni*s_q[es][fld][i];
          }
        }
        
        #pragma unroll p_Nfields
        for(int fld=0; fld<p_Nfields; ++fld){
          r_dqdx[fld] = drdx*r_dqdr[fld] + dsdx*r_dqds[fld];
          r_dqdy[fld] = drdy*r_dqdr[fld] + dsdy*r_dqds[fld];
        }
  
        // Compute volume flux for q, qx and qy
        // A*dQ/dx
        r_Aqx[0] = -p_sqrtRT*(r_dqdx[1]);
        r_Aqx[1] = -p_sqrtRT*(r_dqdx[0] + p_sqrt2*r_dqdx[4]);  
        r_Aqx[2] = -p_sqrtRT*(r_dqdx[3]);
        r_Aqx[3] = -p_sqrtRT*(r_dqdx[2]);
        r_Aqx[4] = -p_sqrtRT*p_sqrt2*r_dqdx[1];      
        r_Aqx[5] =  0.f;
        // B*dQ/dy
        r_Bqy[0] = -p_sqrtRT*(r_dqdy[2]);
        r_Bqy[1] = -p_sqrtRT*(r_dqdy[3]);  
        r_Bqy[2] = -p_sqrtRT*(r_dqdy[0] + p_sqrt2*r_dqdy[5]);  
        r_Bqy[3] = -p_sqrtRT*(r_dqdy[1]);    
        r_Bqy[4] =  0.f;
        r_Bqy[5] = -p_sqrtRT*p_sqrt2*r_dqdy[2];  

        // mean flow forcing 
        r_N[0] = 0.f;
        r_N[1] = drampdt*p_q2bar;
        r_N[2] = drampdt*p_q3bar;
        r_N[3] = 2.f*ramp*drampdt*p_q4bar;
        r_N[4] = 2.f*ramp*drampdt*p_q5bar;
        r_N[5] = 2.f*ramp*drampdt*p_q6bar;
 
        // Update
        const int id       = p_Nfields*(e*p_Np + n);
        const int rhsId    = nrhs*id + p_Nfields*shift;
        const int pmlrhsId = nrhs*p_Nfields*(pmlId*p_Np + n) + p_Nfields*shift; 
        
        #pragma unroll p_Nfields
        for(int fld=0; fld<p_Nfields; ++fld){
          pmlrhsqx[pmlrhsId + fld] =  r_Aqx[fld];
          pmlrhsqy[pmlrhsId + fld] =  r_Bqy[fld];
          rhsq[rhsId +fld] =  r_Aqx[fld] + r_Bqy[fld] + r_N[fld];
         
        }

      }
    }
  }
  
}
}


@kernel void boltzmannIMEXPmlVolumeCub2D(const int pmlNelements,
              @restrict const  int *  pmlElementIds,
              @restrict const  int *  pmlIds,
              const dfloat ramp,
              const dfloat drampdt,
              const int nrhs, 
              const int shift,
              @restrict const  dfloat *  vgeo,
              @restrict const  dfloat *  pmlSigmaX, // unused just for keeping the same structure in timeSteppers
              @restrict const  dfloat *  pmlSigmaY, // unused just for keeping the same structure in timeSteppers
              @restrict const  dfloat *  DrT,
              @restrict const  dfloat *  DsT,
              @restrict const  dfloat *  q,
              @restrict const  dfloat *  pmlqx,
              @restrict const  dfloat *  pmlqy,
                    @restrict dfloat *  rhsq,
                    @restrict dfloat *  pmlrhsqx,
                    @restrict dfloat *  pmlrhsqy){
  
  for(int eo=0;eo<pmlNelements;eo+=p_NblockV;@outer(0)){  // for all elements

    @shared dfloat s_q[p_NblockV][p_Nfields][p_Np];
    @exclusive int e, pmlId;

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element

      int et = eo+es; // element in block
      if(et<pmlNelements){
        e     = pmlElementIds[et];
        pmlId = pmlIds[et];

        const int id = p_Nfields*(e*p_Np + n);
        #pragma unroll p_Nfields
        for(int fld=0; fld<p_Nfields;++fld){
          s_q[es][fld][n] = q[id+fld];
        }
      }
     }
    }

    // make sure all node data is loaded into @shared
    @barrier("local");

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element 
       int et = eo+es; // element in block
       if(et<pmlNelements){  

        // prefetch geometric factors 
        const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
        const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
        const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
        const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];
        
        // Pack register variables into arrays 
        // dfloat r_pmlqx[p_Nfields], r_pmlqy[p_Nfields];
        dfloat r_dqdr[p_Nfields],  r_dqds[p_Nfields];
        dfloat r_dqdx[p_Nfields],  r_dqdy[p_Nfields];
        dfloat r_Aqx[p_Nfields],   r_Bqy[p_Nfields];
        dfloat r_N[p_Nfields];
        
        // Initialize
        #pragma unroll p_Nfields
        for(int fld=0; fld<p_Nfields; ++fld){
          //r_pmlqx[fld] = 0.f, r_pmlqy[fld] = 0.f; 
          r_dqdr[fld]  = 0.f, r_dqds[fld]  = 0.f; 
          r_dqdx[fld]  = 0.f, r_dqdy[fld]  = 0.f; 
          r_N[fld]     = 0.f; 
        }
    
        // Compute Derivatives
        #pragma unroll p_Np
        for(int i=0;i<p_Np;++i){
          const dfloat Drni = DrT[n+i*p_Np];
          const dfloat Dsni = DsT[n+i*p_Np];
          #pragma unroll p_Nfields
          for(int fld=0; fld<p_Nfields; ++fld){
            r_dqdr[fld] += Drni*s_q[es][fld][i];
            r_dqds[fld] += Dsni*s_q[es][fld][i];
          }
        }
        
        #pragma unroll p_Nfields
        for(int fld=0; fld<p_Nfields; ++fld){
          r_dqdx[fld] = drdx*r_dqdr[fld] + dsdx*r_dqds[fld];
          r_dqdy[fld] = drdy*r_dqdr[fld] + dsdy*r_dqds[fld];
        }
  
        // Compute volume flux for q, qx and qy
        // A*dQ/dx
        r_Aqx[0] = -p_sqrtRT*(r_dqdx[1]);
        r_Aqx[1] = -p_sqrtRT*(r_dqdx[0] + p_sqrt2*r_dqdx[4]);  
        r_Aqx[2] = -p_sqrtRT*(r_dqdx[3]);
        r_Aqx[3] = -p_sqrtRT*(r_dqdx[2]);
        r_Aqx[4] = -p_sqrtRT*p_sqrt2*r_dqdx[1];      
        r_Aqx[5] =  0.f;
        // B*dQ/dy
        r_Bqy[0] = -p_sqrtRT*(r_dqdy[2]);
        r_Bqy[1] = -p_sqrtRT*(r_dqdy[3]);  
        r_Bqy[2] = -p_sqrtRT*(r_dqdy[0] + p_sqrt2*r_dqdy[5]);  
        r_Bqy[3] = -p_sqrtRT*(r_dqdy[1]);    
        r_Bqy[4] =  0.f;
        r_Bqy[5] = -p_sqrtRT*p_sqrt2*r_dqdy[2];  

        // mean flow forcing 
        r_N[0] = 0.f;
        r_N[1] = drampdt*p_q2bar;
        r_N[2] = drampdt*p_q3bar;
        r_N[3] = 2.f*ramp*drampdt*p_q4bar;
        r_N[4] = 2.f*ramp*drampdt*p_q5bar;
        r_N[5] = 2.f*ramp*drampdt*p_q6bar;
 
        // Update
        const int id       = p_Nfields*(e*p_Np + n);
        const int rhsId    = nrhs*id + p_Nfields*shift;
        const int pmlrhsId = nrhs*p_Nfields*(pmlId*p_Np + n) + p_Nfields*shift; 
        
        #pragma unroll p_Nfields
        for(int fld=0; fld<p_Nfields; ++fld){
          pmlrhsqx[pmlrhsId + fld] +=  r_Aqx[fld];
          pmlrhsqy[pmlrhsId + fld] +=  r_Bqy[fld];
          rhsq[rhsId +fld]         +=  r_Aqx[fld] + r_Bqy[fld] + r_N[fld];
         
        }

      }
    }
  }
  
}
}




@kernel void boltzmannSAVolume2D(const int Nelements,
            @restrict const  int *  elementIds,
            const dfloat ramp,
            const dfloat drampdt,
            const int nrhs,
            const int shift,
            @restrict const  dfloat *  vgeo,
            @restrict const  dfloat *  DrT,
            @restrict const  dfloat *  DsT,
            @restrict const  dfloat *  q,
                  @restrict dfloat *  rhsq){
  
  for(int eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){  // for all elements

    @shared dfloat s_q[p_NblockV][p_Nfields][p_Np];
    @exclusive int e;

  for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
    for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element

      int et = eo+es; // element in block

      if(et<Nelements){
        e = elementIds[et];
        const int id = p_Nfields*(e*p_Np + n);
        #pragma unroll p_Nfields
        for(int fld=0; fld<p_Nfields;++fld){
          s_q[es][fld][n] = q[id+fld];
        }

      }
    }
  }

    // make sure all node data is loaded into @shared
    @barrier("local");

  for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
    for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element 
      int et = eo+es; // element in block
      if(et<Nelements){   
        // prefetch geometric factors (constant on triangle)
        const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
        const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
        const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
        const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];

        // compute 'r' and 's' derivatives of (q_m) at node n
        dfloat r_dqdr[p_Nfields], r_dqds[p_Nfields]; 
        dfloat r_dqdx[p_Nfields], r_dqdy[p_Nfields];
        dfloat r_rhsq[p_Nfields];
        
        #pragma unroll p_Nfields
        for(int fld=0; fld<p_Nfields;++fld){
          r_dqdr[fld] = 0.f, r_dqds[fld] = 0.f;
          r_dqdx[fld] = 0.f, r_dqdy[fld] = 0.f;
          r_rhsq[fld] = 0.f;
         }

        #pragma unroll p_Np
        for(int i=0;i<p_Np;++i){
          const dfloat Drni = DrT[n+i*p_Np];
          const dfloat Dsni = DsT[n+i*p_Np];    
          #pragma unroll p_Nfields
          for(int fld=0; fld<p_Nfields;++fld){
           r_dqdr[fld] += Drni*s_q[es][fld][i];
           r_dqds[fld] += Dsni*s_q[es][fld][i];
         }
        }
      
        // Compute derivatives in physical coordinates 
        #pragma unroll p_Nfields
        for(int fld=0; fld<p_Nfields;++fld){
          r_dqdx[fld] = drdx*r_dqdr[fld] + dsdx*r_dqds[fld];
          r_dqdy[fld] = drdy*r_dqdr[fld] + dsdy*r_dqds[fld];
        }

         // transport operator
        r_rhsq[0] = -p_sqrtRT*(r_dqdx[1] + r_dqdy[2]);
        r_rhsq[1] = -p_sqrtRT*(r_dqdx[0] + p_sqrt2*r_dqdx[4] + r_dqdy[3]); 
        r_rhsq[2] = -p_sqrtRT*(r_dqdx[3] + r_dqdy[0] + p_sqrt2*r_dqdy[5]); 
        r_rhsq[3] = -p_sqrtRT*(r_dqdx[2] + r_dqdy[1]);   
        r_rhsq[4] = -p_sqrtRT*p_sqrt2*r_dqdx[1];     
        r_rhsq[5] = -p_sqrtRT*p_sqrt2*r_dqdy[2];        

        // BGK relaxation approximation to the Boltzmann collision operator
        r_rhsq[3] += p_tauInv*s_q[es][1][n]*s_q[es][2][n]/s_q[es][0][n];
        r_rhsq[4] += p_tauInv*p_invsqrt2*s_q[es][1][n]*s_q[es][1][n]/s_q[es][0][n];
        r_rhsq[5] += p_tauInv*p_invsqrt2*s_q[es][2][n]*s_q[es][2][n]/s_q[es][0][n];

        // Add mean flow forcing
        r_rhsq[1] += drampdt*p_q2bar;
        r_rhsq[2] += drampdt*p_q3bar;
        r_rhsq[3] += 2.f*ramp*drampdt*p_q4bar;
        r_rhsq[4] += 2.f*ramp*drampdt*p_q5bar;
        r_rhsq[5] += 2.f*ramp*drampdt*p_q6bar;

         //Update 
        const int id = p_Nfields*(e*p_Np + n);
        const int rhsId = nrhs*id + p_Nfields*shift;
        
        #pragma unroll p_Nfields
        for(int fld=0; fld<p_Nfields;++fld){
          rhsq[rhsId + fld] = r_rhsq[fld];
        }
      }
    }
  }
}
}






@kernel void boltzmannSAPmlVolume2D(const int pmlNelements,
              @restrict const  int *  pmlElementIds,
              @restrict const  int *  pmlIds,
              const dfloat ramp,
              const dfloat drampdt,
              const int nrhs, 
              const int shift,
              @restrict const  dfloat *  vgeo,
              @restrict const  dfloat *  pmlSigmaX,
              @restrict const  dfloat *  pmlSigmaY,
              @restrict const  dfloat *  DrT,
              @restrict const  dfloat *  DsT,
              @restrict const  dfloat *  q,
              @restrict const  dfloat *  pmlqx,
              @restrict const  dfloat *  pmlqy,
                    @restrict dfloat *  rhsq,
                    @restrict dfloat *  pmlrhsqx,
                    @restrict dfloat *  pmlrhsqy){
  
  for(int eo=0;eo<pmlNelements;eo+=p_NblockV;@outer(0)){  // for all elements

    @shared dfloat s_q[p_NblockV][p_Nfields][p_Np];
    @exclusive int e, pmlId;

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element

      int et = eo+es; // element in block
      if(et<pmlNelements){
        e     = pmlElementIds[et];
        pmlId = pmlIds[et];

        const int id = p_Nfields*(e*p_Np + n);
        #pragma unroll p_Nfields
        for(int fld=0; fld<p_Nfields;++fld){
          s_q[es][fld][n] = q[id+fld];
        }
      }
     }
    }

    // make sure all node data is loaded into @shared
    @barrier("local");

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element 
       int et = eo+es; // element in block
       if(et<pmlNelements){  

        // prefetch geometric factors 
        const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
        const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
        const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
        const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];
        
        // Prefetch sigma
        const dfloat sigmaxe = pmlSigmaX[pmlId*p_Np+n];
        const dfloat sigmaye = pmlSigmaY[pmlId*p_Np+n];

        // Pack register variables into arrays 
        dfloat r_pmlqx[p_Nfields], r_pmlqy[p_Nfields];
        dfloat r_dqdr[p_Nfields],  r_dqds[p_Nfields];
        dfloat r_dqdx[p_Nfields],  r_dqdy[p_Nfields];
        dfloat r_Aqx[p_Nfields],   r_Bqy[p_Nfields];
        dfloat r_N[p_Nfields];
        
        // Initialize
        #pragma unroll p_Nfields
        for(int fld=0; fld<p_Nfields; ++fld){
          r_pmlqx[fld] = 0.f, r_pmlqy[fld] = 0.f; 
          r_dqdr[fld]  = 0.f, r_dqds[fld]  = 0.f; 
          r_dqdx[fld]  = 0.f, r_dqdy[fld]  = 0.f; 
          r_N[fld]     = 0.f; 
        }
    
       
       // Read from global
        const int pid = p_Nfields*(pmlId*p_Np + n);
        #pragma unroll p_Nfields
        for(int fld=0; fld<p_Nfields; ++fld){
          r_pmlqx[fld] = pmlqx[pid+fld]; 
          r_pmlqy[fld] = pmlqy[pid+fld]; 
        }


        // Compute Derivatives
        #pragma unroll p_Np
        for(int i=0;i<p_Np;++i){
          const dfloat Drni = DrT[n+i*p_Np];
          const dfloat Dsni = DsT[n+i*p_Np];   
          #pragma unroll p_Nfields
          for(int fld=0; fld<p_Nfields; ++fld){
            r_dqdr[fld] += Drni*s_q[es][fld][i];
            r_dqds[fld] += Dsni*s_q[es][fld][i];
          }
        }
        
        #pragma unroll p_Nfields
        for(int fld=0; fld<p_Nfields; ++fld){
          r_dqdx[fld] = drdx*r_dqdr[fld] + dsdx*r_dqds[fld];
          r_dqdy[fld] = drdy*r_dqdr[fld] + dsdy*r_dqds[fld];
        }
  
        // Compute volume flux for q, qx and qy
        // A*dQ/dx
        r_Aqx[0] = -p_sqrtRT*(r_dqdx[1]);
        r_Aqx[1] = -p_sqrtRT*(r_dqdx[0] + p_sqrt2*r_dqdx[4]);  
        r_Aqx[2] = -p_sqrtRT*(r_dqdx[3]);
        r_Aqx[3] = -p_sqrtRT*(r_dqdx[2]);
        r_Aqx[4] = -p_sqrtRT*p_sqrt2*r_dqdx[1];      
        r_Aqx[5] =  0.f;
        // B*dQ/dy
        r_Bqy[0] = -p_sqrtRT*(r_dqdy[2]);
        r_Bqy[1] = -p_sqrtRT*(r_dqdy[3]);  
        r_Bqy[2] = -p_sqrtRT*(r_dqdy[0] + p_sqrt2*r_dqdy[5]);  
        r_Bqy[3] = -p_sqrtRT*(r_dqdy[1]);    
        r_Bqy[4] =  0.f;
        r_Bqy[5] = -p_sqrtRT*p_sqrt2*r_dqdy[2];  

        // N(q) + mean flow forcing 
        r_N[0] = 0.f;
        r_N[1] = drampdt*p_q2bar;
        r_N[2] = drampdt*p_q3bar;
        r_N[3] = 2.f*ramp*drampdt*p_q4bar  + p_tauInv*(s_q[es][1][n]*s_q[es][2][n]/s_q[es][0][n]);
        r_N[4] = 2.f*ramp*drampdt*p_q5bar  + p_tauInv*(p_invsqrt2*s_q[es][1][n]*s_q[es][1][n]/s_q[es][0][n]);
        r_N[5] = 2.f*ramp*drampdt*p_q6bar  + p_tauInv*(p_invsqrt2*s_q[es][2][n]*s_q[es][2][n]/s_q[es][0][n]);

     
     
        const dfloat msigmaxe = sigmaxe + sigmaye*p_pmlAlpha;
        const dfloat msigmaye = sigmaye + sigmaxe*p_pmlAlpha; 

        // Update
        const int id       = p_Nfields*(e*p_Np + n);
        const int rhsId    = nrhs*id + p_Nfields*shift;
        const int pmlrhsId = nrhs*p_Nfields*(pmlId*p_Np + n) + p_Nfields*shift; 
        
        #pragma unroll p_Nfields
        for(int fld=0; fld<p_Nfields; ++fld){
          pmlrhsqx[pmlrhsId + fld] = -msigmaxe*r_pmlqx[fld]  + r_Aqx[fld];
          pmlrhsqy[pmlrhsId + fld] = -msigmaye*r_pmlqy[fld]  + r_Bqy[fld];
          rhsq[rhsId +fld]         = -msigmaxe*r_pmlqx[fld] - msigmaye*r_pmlqy[fld] + r_Aqx[fld] + r_Bqy[fld] + r_N[fld];
         
        }

      }
    }
  }
  
}
}