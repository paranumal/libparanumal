#if 0
// q  \in  Np x Nelements
// Pq \in  NpPx Nelements

//                        |         | 
// form invP, P wrt   o x x x x x x x x o
//                        |         |

// 1D transforms (assume J=const)
//  S = (lambda*W + hScaling*trans(D)*W*D) // stiffness matrix (also needs assembly)
//
//  S~ = W\S = W\trans(D)*W*D
//  S~ = V*Mu*inv(V) [ [V,Mu] = eig(S~) ]
//
//  S = W*V*(lambda*I+hScaling*Mu)*inv(V)
//
// inv(S) = V*(lambda*I + hScaling*Mu)^{-1}*inv(W*V)
//
// invP := inv(W*V)
// P = V
//
// inv(S) = P*(lambda*I + hscaling*Mu)^{-1}*invP

// 1. multiply by invP in each direcction
// 2. divide nodewise by  (lambda + Mu_i/h_r^2 + Mu_j/h_s^2 + Mu_k/h_t^2)*h_r*h_s*h_t/8 for suitable h_r,h_s,h_t
//    use h_r = 1/min r_x ? give or take a factor of 2
// 3. multiply by P in each direction
#endif


@kernel void ellipticOasPreconTri2D_v0(const int Nelements,
				      @restrict const  int   *  vmapPP,
				      @restrict const  dfloat *  forwardT,
				      @restrict const  dfloat *  diagInvOp,
				      @restrict const  dfloat *  backT,
				      @restrict const  dfloat *  q,
				      @restrict dfloat *  Pq){
  
  for(int e=0; e<Nelements; ++e; @outer(0)){

    @shared dfloat s_q1[p_NpP];
    @shared dfloat s_q2[p_NpP];
    
    for(int n=0;n<p_NpP;++n;@inner(0)){
      // load element
      if(n<p_Np)
	s_q1[n] = q[n+e*p_Np];

      // load overlap
      if(n>=p_Np){
	const int id = vmapPP[n-p_Np+e*p_Nfaces*p_Nfp];
	s_q1[n] = q[id];
      }
    }
    
    @barrier("local");

    // forward transform and scaling
    for(int n=0;n<p_NpP;++n;@inner(0)){
      dfloat r_diagInvOp = diagInvOp[e*p_NpP + n];
      
      dfloat res = 0;
      for(int i=0;i<p_NpP;++i){
	res += forwardT[n+i*p_NpP]*s_q1[i];
      }

      s_q2[n] = res*r_diagInvOp;
    }

    @barrier("local");

    // backward transform
    for(int n=0;n<p_NpP;++n;@inner(0)){
      dfloat res = 0;
      for(int i=0;i<p_NpP;++i){
	res += backT[n+i*p_NpP]*s_q2[i];
      }
      Pq[n+e*p_NpP] = res;
    }
  } 
}

@kernel void ellipticOasPreconTri2D_v1(const int Nelements,
				      @restrict const  int   *  vmapPP,
				      @restrict const  dfloat *  forwardT,
				      @restrict const  dfloat *  diagInvOp,
				      @restrict const  dfloat *  backT,
				      @restrict const  dfloat *  q,
				      @restrict dfloat *  Pq){
  
  for(int eo=0; eo<Nelements; eo+=p_NblockV; @outer(0)){

    @shared dfloat s_q1[p_NblockV][p_NpP];
    @shared dfloat s_q2[p_NblockV][p_NpP];

    for(int e=eo;e<eo+p_NblockV;++e;@inner(1)){
      for(int n=0;n<p_NpP;++n;@inner(0)){
	if(e<Nelements){
	  // load element
	  if(n<p_Np)
	    s_q1[e-eo][n] = q[e*p_Np+n];
	  
	  // load overlap
	  if(n>=p_Np){
	    const int id = vmapPP[n-p_Np+e*p_Nfaces*p_Nfp];
	    s_q1[e-eo][n] = q[id];
	  }
	}
      }
    }
    
    @barrier("local");

    // forward transform and scaling
    for(int e=eo;e<eo+p_NblockV;++e;@inner(1)){
      for(int n=0;n<p_NpP;++n;@inner(0)){
	if(e<Nelements){
	  dfloat r_diagInvOp = diagInvOp[e*p_NpP + n];
	  
	  dfloat res = 0;
	  for(int i=0;i<p_NpP;++i){
	    res += forwardT[n+i*p_NpP]*s_q1[e-eo][i];
	  }
	  
	  s_q2[e-eo][n] = res*r_diagInvOp;
	}
      }
    }
    
    @barrier("local");

    // backward transform
    for(int e=eo;e<eo+p_NblockV;++e;@inner(1)){
      for(int n=0;n<p_NpP;++n;@inner(0)){
	if(e<Nelements){
	  dfloat res = 0;
	  for(int i=0;i<p_NpP;++i){
	    res += backT[n+i*p_NpP]*s_q2[e-eo][i];
	  }
	  Pq[n+e*p_NpP] = res;
	}
      }
    }
  } 
}

  
@kernel void ellipticOasPreconTri2D(const int Nelements,
				   @restrict const  int   *  vmapPP,
				   @restrict const  dfloat *  forwardT,
				   @restrict const  dfloat *  diagInvOp,
				   @restrict const  dfloat *  backT,
				   @restrict const  dfloat *  q,
				   @restrict dfloat *  Pq){
  
  for(int eo=0; eo<Nelements; eo+=p_NblockV; @outer(0)){

    @shared dfloat s_q1[p_NblockV][p_Np];
    @shared dfloat s_q1halo[p_NblockV][p_NfacesNfp];
    @shared dfloat s_q2[p_NblockV][p_NpP];

    @shared dfloat s_forwardT[p_NpP][p_NpP];
    @shared dfloat s_backT[p_NpP][p_NpP];
    
    for(int es=0;es<p_NblockV;++es;@inner(1)){
      for(int n=0;n<p_NpP;++n;@inner(0)){
	int e = eo + es;
	int t = es*p_NpP + n;
	
	if(t<p_NblockV*p_Np)
	  if(t+eo*p_Np<p_Np*Nelements){
	    s_q1[0][t] = q[eo*p_Np + t];
	  }
	
	if(t<p_NblockV*p_NfacesNfp)
	  if(t+eo*p_Nfp*p_Nfaces<p_Nfp*p_Nfaces*Nelements){
	    int idP = vmapPP[eo*p_Nfp*p_Nfaces + t];
	    s_q1halo[0][t] = q[idP];
	  }

	while(t<p_NpP*p_NpP){
	  s_forwardT[0][t] = forwardT[t];
	  s_backT[0][t] = backT[t];
	  t+=p_NblockV*p_NpP;
	}
      }
    }
    
    @barrier("local");

    // forward transform and scaling
    for(int es=0;es<p_NblockV;++es;@inner(1)){
      for(int n=0;n<p_NpP;++n;@inner(0)){
	const int e = eo + es;
	if(e<Nelements){
	  dfloat r_diagInvOp = diagInvOp[e*p_NpP + n];
	  
	  dfloat res = 0;
	  #pragma unroll p_Np
	    for(int i=0;i<p_Np;++i){
	      res += s_forwardT[i][n]*s_q1[es][i];
	    }
	  
	  #pragma unroll p_NfacesNfp
	    for(int i=0;i<p_NfacesNfp;++i){
	      res += s_forwardT[i+p_Np][n]*s_q1halo[es][i];
	    }
	  
	  s_q2[es][n] = res*r_diagInvOp;
	}
      }
    }
    
    @barrier("local");
    
    // backward transform
    for(int es=0;es<p_NblockV;++es;@inner(1)){
      for(int n=0;n<p_NpP;++n;@inner(0)){
	const int e = eo + es;
	if(e<Nelements){
	  dfloat res = 0;
	  #pragma unroll p_NpP
	    for(int i=0;i<p_NpP;++i){
	      res += s_backT[i][n]*s_q2[es][i];
	    }
	  
	  Pq[n+e*p_NpP] = res;
	}
      }
    }
  } 
}

  
