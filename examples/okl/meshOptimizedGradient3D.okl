#define RXID 0  
#define RYID 1
#define RZID 2
#define SXID 3  
#define SYID 4
#define SZID 5
#define TXID 6  
#define TYID 7
#define TZID 8

// baseline mesh Gradient
@kernel void meshGradient3D_v0(int Nelements, 
			      int Np, 
			      int Nvgeo,
			      dfloat * vgeo, 
			      dfloat * Dr, 
			      dfloat * Ds,
			      dfloat * Dt,	
			      dfloat * q, 
			      dfloat * dqdx, 
			      dfloat * dqdy,
			      dfloat * dqdz){
  
  for(int e=0;e<Nelements;++e;@outer(0)){
    // load geometric factors
    dfloat drdx = vgeo[e*Nvgeo + RXID];
    dfloat drdy = vgeo[e*Nvgeo + RYID];
    dfloat drdz = vgeo[e*Nvgeo + RZID];
    dfloat dsdx = vgeo[e*Nvgeo + SXID];
    dfloat dsdy = vgeo[e*Nvgeo + SYID];
    dfloat dsdz = vgeo[e*Nvgeo + SZID];
    dfloat dtdx = vgeo[e*Nvgeo + TXID];
    dfloat dtdy = vgeo[e*Nvgeo + TYID];
    dfloat dtdz = vgeo[e*Nvgeo + TZID];

    // compute gradient at each node
    for(int n=0;n<Np;++n;@inner(0)){

      // matrix-vector multiplies
      dfloat dqdr = 0, dqds = 0, dqdt = 0;
      for(int m=0;m<Np;++m){
	dqdr += Dr[n*Np + m]*q[m + e*Np];
	dqds += Ds[n*Np + m]*q[m + e*Np];
	dqdt += Dt[n*Np + m]*q[m + e*Np];
      }

      // chain rule
      dqdx[n+e*Np] = drdx*dqdr + dsdx*dqds + dtdx*dqdt;
      dqdy[n+e*Np] = drdy*dqdr + dsdy*dqds + dtdy*dqdt;
      dqdz[n+e*Np] = drdz*dqdr + dsdz*dqds + dtdz*dqdt;
    }
  }
}

// declare variables @restrict const and po inter 
@kernel void meshGradient3D_v1(const int Nelements, 
			      const int Np, 
			      const int Nvgeo,
			      @restrict const  dfloat *  vgeo,
			      @restrict const  dfloat *  Dr, 
			      @restrict const  dfloat *  Ds,
			      @restrict const  dfloat *  Dt,
			      @restrict const  dfloat *  q,
			      @restrict dfloat *  dqdx,
			      @restrict dfloat *  dqdy,
			      @restrict dfloat *  dqdz){
  
  for(int e=0;e<Nelements;++e;@outer(0)){
    const dfloat drdx = vgeo[e*Nvgeo + RXID];
    const dfloat drdy = vgeo[e*Nvgeo + RYID];
    const dfloat drdz = vgeo[e*Nvgeo + RZID];
    const dfloat dsdx = vgeo[e*Nvgeo + SXID];
    const dfloat dsdy = vgeo[e*Nvgeo + SYID];
    const dfloat dsdz = vgeo[e*Nvgeo + SZID];
    const dfloat dtdx = vgeo[e*Nvgeo + TXID];
    const dfloat dtdy = vgeo[e*Nvgeo + TYID];
    const dfloat dtdz = vgeo[e*Nvgeo + TZID];    
    
    for(int n=0;n<Np;++n;@inner(0)){

      dfloat dqdr = 0, dqds = 0, dqdt = 0;
      
      for(int m=0;m<Np;++m){
	dqdr += Dr[n*Np + m]*q[m + e*Np];
	dqds += Ds[n*Np + m]*q[m + e*Np];
	dqdt += Dt[n*Np + m]*q[m + e*Np];	
      }

      dqdx[n+e*Np] = drdx*dqdr + dsdx*dqds + dtdx*dqdt;
      dqdy[n+e*Np] = drdy*dqdr + dsdy*dqds + dtdy*dqdt;
      dqdz[n+e*Np] = drdz*dqdr + dsdz*dqds + dtdz*dqdt;
    }
  }
}

// use compiler variables for Np and Nvgeo
@kernel void meshGradient3D_v2(const int Nelements, 
			      const int Np, 
			      const int Nvgeo,
			      @restrict const  dfloat *  vgeo,
			      @restrict const  dfloat *  Dr, 
			      @restrict const  dfloat *  Ds,
			      @restrict const  dfloat *  Dt,
			      @restrict const  dfloat *  q,
			      @restrict dfloat *  dqdx, 
			      @restrict dfloat *  dqdy,
			      @restrict dfloat *  dqdz){
  
  for(int e=0;e<Nelements;++e;@outer(0)){
    const dfloat drdx = vgeo[e*p_Nvgeo + RXID];
    const dfloat drdy = vgeo[e*p_Nvgeo + RYID];
    const dfloat drdz = vgeo[e*p_Nvgeo + RZID];
    const dfloat dsdx = vgeo[e*p_Nvgeo + SXID];
    const dfloat dsdy = vgeo[e*p_Nvgeo + SYID];
    const dfloat dsdz = vgeo[e*p_Nvgeo + SZID];
    const dfloat dtdx = vgeo[e*p_Nvgeo + TXID];
    const dfloat dtdy = vgeo[e*p_Nvgeo + TYID];
    const dfloat dtdz = vgeo[e*p_Nvgeo + TZID];    
    
    for(int n=0;n<p_Np;++n;@inner(0)){

      dfloat dqdr = 0, dqds = 0, dqdt = 0;

      for(int m=0;m<p_Np;++m){
	dqdr += Dr[n*p_Np + m]*q[m + e*p_Np];
	dqds += Ds[n*p_Np + m]*q[m + e*p_Np];
	dqdt += Dt[n*p_Np + m]*q[m + e*p_Np];
      }

      dqdx[n+e*p_Np] = drdx*dqdr + dsdx*dqds + dtdx*dqdt;
      dqdy[n+e*p_Np] = drdy*dqdr + dsdy*dqds + dtdy*dqdt;
      dqdz[n+e*p_Np] = drdz*dqdr + dsdz*dqds + dtdz*dqdt;
    }
  }
}


// unroll the Dr and Ds loop
@kernel void meshGradient3D_v3(const int Nelements, 
			      const int Np, 
			      const int Nvgeo,
			      @restrict const  dfloat *  vgeo,
			      @restrict const  dfloat *  Dr, 
			      @restrict const  dfloat *  Ds,
			      @restrict const  dfloat *  Dt,
			      @restrict const  dfloat *  q,
			      @restrict dfloat *  dqdx, 
			      @restrict dfloat *  dqdy,
			      @restrict dfloat *  dqdz){
  
  for(int e=0;e<Nelements;++e;@outer(0)){
    const dfloat drdx = vgeo[e*p_Nvgeo + RXID];
    const dfloat drdy = vgeo[e*p_Nvgeo + RYID];
    const dfloat drdz = vgeo[e*p_Nvgeo + RZID];
    const dfloat dsdx = vgeo[e*p_Nvgeo + SXID];
    const dfloat dsdy = vgeo[e*p_Nvgeo + SYID];
    const dfloat dsdz = vgeo[e*p_Nvgeo + SZID];
    const dfloat dtdx = vgeo[e*p_Nvgeo + TXID];
    const dfloat dtdy = vgeo[e*p_Nvgeo + TYID];
    const dfloat dtdz = vgeo[e*p_Nvgeo + TZID];    
    
    for(int n=0;n<p_Np;++n;@inner(0)){

      dfloat dqdr = 0, dqds = 0, dqdt = 0;

      #pragma unroll p_Np
	for(int m=0;m<p_Np;++m){
	  dqdr += Dr[n*p_Np + m]*q[m + e*p_Np];
	  dqds += Ds[n*p_Np + m]*q[m + e*p_Np];
	  dqdt += Dt[n*p_Np + m]*q[m + e*p_Np];
	}
      
      dqdx[n+e*p_Np] = drdx*dqdr + dsdx*dqds + dtdx*dqdt;
      dqdy[n+e*p_Np] = drdy*dqdr + dsdy*dqds + dtdy*dqdt;
      dqdz[n+e*p_Np] = drdz*dqdr + dsdz*dqds + dtdz*dqdt;
    }
  }
}



// read from Dr and Ds in thread contiguous blocks 
@kernel void meshGradient3D_v4(const int Nelements, 
			      const int Np, 
			      const int Nvgeo,
			      @restrict const  dfloat *  vgeo,
			      @restrict const  dfloat *  DrT, 
			      @restrict const  dfloat *  DsT,
			      @restrict const  dfloat *  DtT,
			      @restrict const  dfloat *  q,
			      @restrict dfloat *  dqdx, 
			      @restrict dfloat *  dqdy,
			      @restrict dfloat *  dqdz){
  
  for(int e=0;e<Nelements;++e;@outer(0)){
    const dfloat drdx = vgeo[e*p_Nvgeo + RXID];
    const dfloat drdy = vgeo[e*p_Nvgeo + RYID];
    const dfloat drdz = vgeo[e*p_Nvgeo + RZID];
    const dfloat dsdx = vgeo[e*p_Nvgeo + SXID];
    const dfloat dsdy = vgeo[e*p_Nvgeo + SYID];
    const dfloat dsdz = vgeo[e*p_Nvgeo + SZID];
    const dfloat dtdx = vgeo[e*p_Nvgeo + TXID];
    const dfloat dtdy = vgeo[e*p_Nvgeo + TYID];
    const dfloat dtdz = vgeo[e*p_Nvgeo + TZID];    
    
    for(int n=0;n<p_Np;++n;@inner(0)){

      dfloat dqdr = 0, dqds = 0, dqdt = 0;

      #pragma unroll p_Np
	for(int m=0;m<p_Np;++m){
	  dqdr += DrT[n + m*p_Np]*q[m + e*p_Np];
	  dqds += DsT[n + m*p_Np]*q[m + e*p_Np];
	  dqdt += DtT[n + m*p_Np]*q[m + e*p_Np];
	}
      
      dqdx[n+e*p_Np] = drdx*dqdr + dsdx*dqds + dtdx*dqdt;
      dqdy[n+e*p_Np] = drdy*dqdr + dsdy*dqds + dtdy*dqdt;
      dqdz[n+e*p_Np] = drdz*dqdr + dsdz*dqds + dtdz*dqdt;
    }
  }
}


// load q node data for element e into @shared memory
@kernel void meshGradient3D_v5(const int Nelements, 
			      const int Np, 
			      const int Nvgeo,
			      @restrict const  dfloat *  vgeo,
			      @restrict const  dfloat *  DrT, 
			      @restrict const  dfloat *  DsT,
			      @restrict const  dfloat *  DtT,
			      @restrict const  dfloat *  q,
			      @restrict dfloat *  dqdx, 
			      @restrict dfloat *  dqdy,
			      @restrict dfloat *  dqdz){
  
  for(int e=0;e<Nelements;++e;@outer(0)){
    const dfloat drdx = vgeo[e*p_Nvgeo + RXID];
    const dfloat drdy = vgeo[e*p_Nvgeo + RYID];
    const dfloat drdz = vgeo[e*p_Nvgeo + RZID];
    const dfloat dsdx = vgeo[e*p_Nvgeo + SXID];
    const dfloat dsdy = vgeo[e*p_Nvgeo + SYID];
    const dfloat dsdz = vgeo[e*p_Nvgeo + SZID];
    const dfloat dtdx = vgeo[e*p_Nvgeo + TXID];
    const dfloat dtdy = vgeo[e*p_Nvgeo + TYID];
    const dfloat dtdz = vgeo[e*p_Nvgeo + TZID];    

    @shared dfloat s_q[p_Np];
    for(int n=0;n<p_Np;++n;@inner(0))
      s_q[n] = q[n+e*p_Np];

    @barrier("local"); // make sure all nodes are loaded
    
    for(int n=0;n<p_Np;++n;@inner(0)){
      
      dfloat dqdr = 0, dqds = 0, dqdt = 0;
      
      #pragma unroll p_Np
	for(int m=0;m<p_Np;++m){
	  dqdr += DrT[n + m*p_Np]*s_q[m];
	  dqds += DsT[n + m*p_Np]*s_q[m];
	  dqdt += DtT[n + m*p_Np]*s_q[m];
	}
      
      dqdx[n+e*p_Np] = drdx*dqdr + dsdx*dqds + dtdx*dqdt;
      dqdy[n+e*p_Np] = drdy*dqdr + dsdy*dqds + dtdy*dqdt;
      dqdz[n+e*p_Np] = drdz*dqdr + dsdz*dqds + dtdz*dqdt;
    }
  }
}




@kernel void meshGradient3D_v6(const int Nelements, 
			      const int Np, 
			      const int Nvgeo,
			      @restrict const  dfloat *  vgeo,
			      @restrict const  dfloat *  DrT,
			      @restrict const  dfloat *  DsT,
			      @restrict const  dfloat *  DtT,
			      @restrict const  dfloat *  q,
			      @restrict dfloat *  dqdx, 
			      @restrict dfloat *  dqdy,
			      @restrict dfloat *  dqdz){
  
  // single loop variant - loop over all interpolation nodes in the mesh
  for(int node=0;node<p_Np*Nelements;++node;tile(p_Nthreads)){

    // make sure this is valid node after tiling
    if(node<p_Np*Nelements){
      
      // extract element and local node number
      const int e = node/p_Np;
      const int n = node%p_Np;
      
      // read geometric factors
      const dfloat drdx = vgeo[e*p_Nvgeo + RXID];
      const dfloat drdy = vgeo[e*p_Nvgeo + RYID];
      const dfloat drdz = vgeo[e*p_Nvgeo + RZID];
      const dfloat dsdx = vgeo[e*p_Nvgeo + SXID];
      const dfloat dsdy = vgeo[e*p_Nvgeo + SYID];
      const dfloat dsdz = vgeo[e*p_Nvgeo + SZID];
      const dfloat dtdx = vgeo[e*p_Nvgeo + TXID];
      const dfloat dtdy = vgeo[e*p_Nvgeo + TYID];
      const dfloat dtdz = vgeo[e*p_Nvgeo + TZID];        
      
      // compute 'r' and 's' derivatives
      dfloat dqdr = 0, dqds = 0, dqdt = 0;

      #pragma unroll p_Np
	for(int m=0;m<p_Np;++m){
	  dqdr += DrT[n + m*p_Np]*q[m+e*p_Np];
	  dqds += DsT[n + m*p_Np]*q[m+e*p_Np];
	  dqdt += DtT[n + m*p_Np]*q[m+e*p_Np];
	}
      
      // apply chain rule
      dqdx[node] = drdx*dqdr + dsdx*dqds + dtdx*dqdt;
      dqdy[node] = drdy*dqdr + dsdy*dqds + dtdy*dqdt;
      dqdz[node] = drdz*dqdr + dsdz*dqds + dtdz*dqdt;
    }
  }
}


// manually introduce tiling and prefetch DrT, DsT to @shared memory
@kernel void meshGradient3D_v7(const int Nelements,
			      const int Np,
			      const int Nvgeo,
			      @restrict const  dfloat *  vgeo,
			      @restrict const  dfloat *  DrT,
			      @restrict const  dfloat *  DsT,
			      @restrict const  dfloat *  DtT,
			      @restrict const  dfloat *  q,
			      @restrict dfloat *  dqdx,
			      @restrict dfloat *  dqdy,
			      @restrict dfloat *  dqdz){

  // single loop variant - loop over all interpolation nodes in the mesh
  for(int block=0;block<(p_Np*Nelements+p_Nthreads-1)/p_Nthreads;++block;@outer(0)){

    @shared dfloat s_DrT[p_Np*p_Np];
    @shared dfloat s_DsT[p_Np*p_Np];
    @shared dfloat s_DtT[p_Np*p_Np];
    
    for(int thread=0;thread<p_Nthreads;++thread;@inner(0)){
      int t=thread;
      while(t<(p_Np*p_Np)){
	s_DrT[t] = DrT[t];
	s_DsT[t] = DsT[t];
	s_DtT[t] = DtT[t];
	t += p_Nthreads;
      }
    }

    @barrier("local");
    
    // make sure this is valid node after tiling
    for(int thread=0;thread<p_Nthreads;++thread;@inner(0)){
      int node = thread + block*p_Nthreads;

      if(node<p_Np*Nelements){
	
	// extract element and local node number
	const int e = node/p_Np;
	const int n = node%p_Np;
	
	// read geometric factors
	const dfloat drdx = vgeo[e*p_Nvgeo + RXID];
	const dfloat drdy = vgeo[e*p_Nvgeo + RYID];
	const dfloat drdz = vgeo[e*p_Nvgeo + RZID];
	const dfloat dsdx = vgeo[e*p_Nvgeo + SXID];
	const dfloat dsdy = vgeo[e*p_Nvgeo + SYID];
	const dfloat dsdz = vgeo[e*p_Nvgeo + SZID];
	const dfloat dtdx = vgeo[e*p_Nvgeo + TXID];
	const dfloat dtdy = vgeo[e*p_Nvgeo + TYID];
	const dfloat dtdz = vgeo[e*p_Nvgeo + TZID];    
	
	// compute 'r' and 's' derivatives
	dfloat dqdr = 0, dqds = 0, dqdt = 0;
	
	#pragma unroll p_Np
	  for(int m=0;m<p_Np;++m){
	    dqdr += s_DrT[n + m*p_Np]*q[m+e*p_Np];
	    dqds += s_DsT[n + m*p_Np]*q[m+e*p_Np];
	    dqdt += s_DtT[n + m*p_Np]*q[m+e*p_Np];
	  }
	
	// apply chain rule
	dqdx[node] = drdx*dqdr + dsdx*dqds + dtdx*dqdt;
	dqdy[node] = drdy*dqdr + dsdy*dqds + dtdy*dqdt;
	dqdz[node] = drdz*dqdr + dsdz*dqds + dtdz*dqdt;
      }
    }
  }
}


// manually introduce tiling and prefetch DrT, DsT to @shared memory
@kernel void meshGradient3D_v8(const int Nelements,
			      const int Np,
			      const int Nvgeo,
			      @restrict const  dfloat *  vgeo,
			      @restrict const  dfloat *  DrT,
			      @restrict const  dfloat *  DsT,
			      @restrict const  dfloat *  DtT,
			      @restrict const  dfloat4 *  q4,
			      @restrict dfloat4 *  dq4dx,
			      @restrict dfloat4 *  dq4dy,
			      @restrict dfloat4 *  dq4dz){

  // single loop variant - loop over all interpolation nodes in the mesh
  for(int block=0;block<(p_Np*Nelements+p_Nthreads-1)/p_Nthreads;++block;@outer(0)){

    @shared dfloat s_DrT[p_Np*p_Np];
    @shared dfloat s_DsT[p_Np*p_Np];
    @shared dfloat s_DtT[p_Np*p_Np];
    
    for(int thread=0;thread<p_Nthreads;++thread;@inner(0)){
      int t=thread;
      while(t<(p_Np*p_Np)){
	s_DrT[t] = DrT[t];
	s_DsT[t] = DsT[t];
	s_DtT[t] = DtT[t];
	t += p_Nthreads;
      }
    }

    @barrier("local");
    
    // make sure this is valid node after tiling
    for(int thread=0;thread<p_Nthreads;++thread;@inner(0)){
      int node = thread + block*p_Nthreads;

      if(node<p_Np*Nelements){
	
	// extract element and local node number
	const int e = node/p_Np;
	const int n = node%p_Np;

	// read geometric factors
	const dfloat drdx = vgeo[e*p_Nvgeo + RXID];
	const dfloat drdy = vgeo[e*p_Nvgeo + RYID];
	const dfloat drdz = vgeo[e*p_Nvgeo + RZID];
	const dfloat dsdx = vgeo[e*p_Nvgeo + SXID];
	const dfloat dsdy = vgeo[e*p_Nvgeo + SYID];
	const dfloat dsdz = vgeo[e*p_Nvgeo + SZID];
	const dfloat dtdx = vgeo[e*p_Nvgeo + TXID];
	const dfloat dtdy = vgeo[e*p_Nvgeo + TYID];
	const dfloat dtdz = vgeo[e*p_Nvgeo + TZID];    
	
	// compute 'r' and 's' derivatives
	dfloat4 dq4dr;
	dfloat4 dq4ds;
	dfloat4 dq4dt;
	dq4dr.x = 0; dq4dr.y = 0; dq4dr.z = 0; dq4dr.w = 0;
	dq4ds.x = 0; dq4ds.y = 0; dq4ds.z = 0; dq4ds.w = 0;
	dq4dt.x = 0; dq4dt.y = 0; dq4dt.z = 0; dq4dt.w = 0;
	#pragma unroll p_Np
	  for(int m=0;m<p_Np;++m){
	    dq4dr += s_DrT[n + m*p_Np]*q4[m+e*p_Np];
	    dq4ds += s_DsT[n + m*p_Np]*q4[m+e*p_Np];
	    dq4dt += s_DtT[n + m*p_Np]*q4[m+e*p_Np];
	  }
	
	// apply chain rule
	dq4dx[node] = drdx*dq4dr + dsdx*dq4ds + dtdx*dq4dt;
	dq4dy[node] = drdy*dq4dr + dsdy*dq4ds + dtdy*dq4dt;
	dq4dz[node] = drdz*dq4dr + dsdz*dq4ds + dtdz*dq4dt;
      }
    }
  }
}


// hybrid version where we optimize number of elements handled in the inner block of v5 @kernel
@kernel void meshGradient3D_v9(const int Nelements, 
			      const int Np, 
			      const int Nvgeo,
			      @restrict const  dfloat *  vgeo,
			      @restrict const  dfloat *  DrT, 
			      @restrict const  dfloat *  DsT,
			      @restrict const  dfloat *  DtT,
			      @restrict const  dfloat4 *  q4,
			      @restrict dfloat4 *  dq4dx, 
			      @restrict dfloat4 *  dq4dy,
			      @restrict dfloat4 *  dq4dz){
  
  for(int bo=0;bo<Nelements;bo+=p_Nblock;@outer(0)){

    // store each of the four q fields in separate @shared memory
    // arrays to avoid bank conflicts
    @shared dfloat s_qx[p_Nblock][p_Np], s_qy[p_Nblock][p_Np];
    @shared dfloat s_qz[p_Nblock][p_Np], s_qw[p_Nblock][p_Np];
    
    // loop over block of elements and nodes
    for(int eo=0;eo<p_Nblock;++eo;@inner(1)){
      for(int n=0;n<p_Np;++n;@inner(0)){
	const int e = bo+eo;

	if(e<Nelements){
	  const dfloat4 q4n = q4[n+e*p_Np];
	  s_qx[eo][n] = q4n.x;
	  s_qy[eo][n] = q4n.y;
	  s_qz[eo][n] = q4n.z;
	  s_qw[eo][n] = q4n.w;
	}
      }
    }
    
    @barrier("local"); // make sure all nodes are loaded

    for(int eo=0;eo<p_Nblock;++eo;@inner(1)){
      for(int n=0;n<p_Np;++n;@inner(0)){
	const int e = bo+eo;
	
	if(e<Nelements){
	  dfloat4 dq4dr, dq4ds, dq4dt;
	  dq4dr.x = 0; dq4dr.y = 0; dq4dr.z = 0; dq4dr.w = 0;
	  dq4ds.x = 0; dq4ds.y = 0; dq4ds.z = 0; dq4ds.w = 0;
	  dq4dt.x = 0; dq4dt.y = 0; dq4dt.z = 0; dq4dt.w = 0;
	  
	  #pragma unroll p_Np
	    for(int m=0;m<p_Np;++m){
	      const dfloat dr = DrT[n+m*p_Np];
	      const dfloat ds = DsT[n+m*p_Np];
	      const dfloat dt = DtT[n+m*p_Np];

	      dq4dr.x += dr*s_qx[eo][m]; dq4ds.x += ds*s_qx[eo][m]; dq4dt.x += dt*s_qx[eo][m];
	      dq4dr.y += dr*s_qy[eo][m]; dq4ds.y += ds*s_qy[eo][m]; dq4dt.y += dt*s_qy[eo][m];
	      dq4dr.z += dr*s_qz[eo][m]; dq4ds.z += ds*s_qz[eo][m]; dq4dt.z += dt*s_qz[eo][m];
	      dq4dr.w += dr*s_qw[eo][m]; dq4ds.w += ds*s_qw[eo][m]; dq4dt.w += dt*s_qw[eo][m];
	    }

	  // read geometric factors
	  const dfloat drdx = vgeo[e*p_Nvgeo + RXID];
	  const dfloat drdy = vgeo[e*p_Nvgeo + RYID];
	  const dfloat drdz = vgeo[e*p_Nvgeo + RZID];
	  const dfloat dsdx = vgeo[e*p_Nvgeo + SXID];
	  const dfloat dsdy = vgeo[e*p_Nvgeo + SYID];
	  const dfloat dsdz = vgeo[e*p_Nvgeo + SZID];
	  const dfloat dtdx = vgeo[e*p_Nvgeo + TXID];
	  const dfloat dtdy = vgeo[e*p_Nvgeo + TYID];
	  const dfloat dtdz = vgeo[e*p_Nvgeo + TZID];    
	  
	  dq4dx[n+e*p_Np] = drdx*dq4dr + dsdx*dq4ds + dtdx*dq4dt;
	  dq4dy[n+e*p_Np] = drdy*dq4dr + dsdy*dq4ds + dtdy*dq4dt;
	  dq4dz[n+e*p_Np] = drdz*dq4dr + dsdz*dq4ds + dtdz*dq4dt;
	}
      }
    }
  }
}

