#define RXID 0  
#define RYID 1  
#define RZID 2
#define SXID 3  
#define SYID 4  
#define SZID 5  
#define TXID 6  
#define TYID 7  
#define TZID 8

// baseline mesh Gradient - cube threads with no optimizations at all
@kernel void meshGradientHex3D_v0(int Nelements, 
				 dfloat * vgeo, 
				 dfloat * D, 
				 dfloat * q, 
				 dfloat * dqdx, 
				 dfloat * dqdy,
				 dfloat * dqdz){
  
  for(int e=0;e<Nelements;++e;@outer(0)){
    
    // compute gradient at each node
    for(int k=0;k<p_Nq;++k;@inner(2)){
      for(int j=0;j<p_Nq;++j;@inner(1)){
	for(int i=0;i<p_Nq;++i;@inner(0)){
	  
	  int n = i + p_Nq*j + p_Nq*p_Nq*k;
	  
	  // load geometric factors
	  int gid = p_Np*p_Nvgeo*e + n;
	  float drdx = vgeo[gid + p_Np*RXID];
	  float drdy = vgeo[gid + p_Np*RYID];
	  float drdz = vgeo[gid + p_Np*RZID];
	  float dsdx = vgeo[gid + p_Np*SXID];
	  float dsdy = vgeo[gid + p_Np*SYID];
	  float dsdz = vgeo[gid + p_Np*SZID];
	  float dtdx = vgeo[gid + p_Np*TXID];
	  float dtdy = vgeo[gid + p_Np*TYID];
	  float dtdz = vgeo[gid + p_Np*TZID];
	  
	  // matrix-vector multiplies
	  dfloat dqdr = 0, dqds = 0, dqdt = 0;
	  for(int m=0;m<p_Nq;++m){
	    dqdr += D[i*p_Nq + m]*q[m + j*p_Nq + k*p_Nq*p_Nq + e*p_Np];
	    dqds += D[j*p_Nq + m]*q[i + m*p_Nq + k*p_Nq*p_Nq + e*p_Np];
	    dqdt += D[k*p_Nq + m]*q[i + j*p_Nq + m*p_Nq*p_Nq + e*p_Np];
	  }
	  
	  // chain rule
	  dqdx[n+e*p_Np] = drdx*dqdr + dsdx*dqds + dtdx*dqdt;
	  dqdy[n+e*p_Np] = drdy*dqdr + dsdy*dqds + dtdy*dqdt;
	  dqdz[n+e*p_Np] = drdz*dqdr + dsdz*dqds + dtdz*dqdt;
	}
      }
    }
  }
}
