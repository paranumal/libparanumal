// This @kernel does not use float 4 format, 
@kernel void boltzmannSRABUpdate2D(const int Nelements,
            @restrict const  int *  elementIds,
            const dfloat dt,  
            const dfloat a1,
            const dfloat a2,
            const dfloat a3,
            const int   shift,
            @restrict const  dfloat *  rhsq,
                  @restrict dfloat *  q){
  
// Low storage Runge Kutta time step update
for(int es=0;es<Nelements;++es;@outer(0)){

  // @shared dfloat s_q[p_Np*p_Nfields];
  @exclusive int e; 

  for(int n=0;n<p_maxNodes;++n;@inner(0)){
    e  = elementIds[es];
    if(n<p_Np){
      const int id = p_Nfields*(n + e*p_Np);
      // hard-coded for 3th order
      const int rhsId1 = 3*id + ((shift+0)%3)*p_Nfields;
      const int rhsId2 = 3*id + ((shift+2)%3)*p_Nfields;
      const int rhsId3 = 3*id + ((shift+1)%3)*p_Nfields;

      #pragma unroll p_Nfields
      for(int fld=0; fld< p_Nfields; ++fld){
        q[id+fld] += (a1*rhsq[rhsId1+fld] + a2*rhsq[rhsId2+fld] + a3*rhsq[rhsId3+fld]);
      }
    }
  }
}
}



@kernel void boltzmannSRABPmlUpdate2D(const int pmlNelements,
               @restrict const  int   *  pmlElementIds,
               @restrict const  int   *  pmlIds,
               const dfloat dt,  
               const dfloat a1,
               const dfloat a2,
               const dfloat a3,
               const int   shift,
               @restrict const  dfloat *  rhsq, 
               @restrict const  dfloat *  pmlrhsqx,
               @restrict const  dfloat *  pmlrhsqy,
                     @restrict dfloat *  q,
                     @restrict dfloat *  pmlqx,
                     @restrict dfloat *  pmlqy){
// Low storage Runge Kutta time step update
for(int es=0;es<pmlNelements;++es;@outer(0)){
  // @shared dfloat s_q[p_Np*p_Nfields];
  @exclusive int e;
  for(int n=0; n < p_maxNodes; ++n; @inner(0)){
    e = pmlElementIds[es];
    if (n < p_Np){

      const int pmlId = pmlIds[es];
      const int id  = p_Nfields*(e*p_Np + n);
      const int pid = p_Nfields*(pmlId*p_Np + n);

      const int rhsId1 = 3*id + ((shift+0)%3)*p_Nfields;
      const int rhsId2 = 3*id + ((shift+2)%3)*p_Nfields;
      const int rhsId3 = 3*id + ((shift+1)%3)*p_Nfields;
      const int pmlrhsId1 = 3*pid + ((shift+0)%3)*p_Nfields;
      const int pmlrhsId2 = 3*pid + ((shift+2)%3)*p_Nfields;
      const int pmlrhsId3 = 3*pid + ((shift+1)%3)*p_Nfields;

      #pragma unroll p_Nfields
      for(int fld=0; fld< p_Nfields; ++fld){

        pmlqx[pid+fld] += (a1*pmlrhsqx[pmlrhsId1+fld] + a2*pmlrhsqx[pmlrhsId2+fld] + a3*pmlrhsqx[pmlrhsId3+fld]);
        pmlqy[pid+fld] += (a1*pmlrhsqy[pmlrhsId1+fld] + a2*pmlrhsqy[pmlrhsId2+fld] + a3*pmlrhsqy[pmlrhsId3+fld]);

        q[id+fld]      += (a1*rhsq[rhsId1+fld] + a2*rhsq[rhsId2+fld] + a3*rhsq[rhsId3+fld]);

      }
    }
  }      
}
}


//  
@kernel void boltzmannSAABUpdate2D(const int Nelements,
            @restrict const  int *  elementIds,
            const dfloat expdt, 
            const dfloat ab1,
            const dfloat ab2,
            const dfloat ab3,
            const dfloat saab1,
            const dfloat saab2,
            const dfloat saab3,
            const int   shift,
            @restrict const  dfloat *  rhsq,
                  @restrict dfloat *  q){
  
// Low storage Runge Kutta time step update
for(int es=0;es<Nelements;++es;@outer(0)){

  @exclusive int e; 

  for(int n=0;n<p_maxNodes;++n;@inner(0)){
    e  = elementIds[es];
    if(n<p_Np){
      const int id = p_Nfields*(n + e*p_Np);
      // hard-coded for 3th order
      const int rhsId1 = 3*id + ((shift+0)%3)*p_Nfields;
      const int rhsId2 = 3*id + ((shift+2)%3)*p_Nfields;
      const int rhsId3 = 3*id + ((shift+1)%3)*p_Nfields;
      //
      q[id+0] = q[id+0] + ab1*rhsq[rhsId1+0] + ab2*rhsq[rhsId2+0] + ab3*rhsq[rhsId3+0];
      q[id+1] = q[id+1] + ab1*rhsq[rhsId1+1] + ab2*rhsq[rhsId2+1] + ab3*rhsq[rhsId3+1];
      q[id+2] = q[id+2] + ab1*rhsq[rhsId1+2] + ab2*rhsq[rhsId2+2] + ab3*rhsq[rhsId3+2];
      //
      q[id+3] = expdt*q[id+3] + saab1*rhsq[rhsId1+3] + saab2*rhsq[rhsId2+3] + saab3*rhsq[rhsId3+3];
      q[id+4] = expdt*q[id+4] + saab1*rhsq[rhsId1+4] + saab2*rhsq[rhsId2+4] + saab3*rhsq[rhsId3+4];
      q[id+5] = expdt*q[id+5] + saab1*rhsq[rhsId1+5] + saab2*rhsq[rhsId2+5] + saab3*rhsq[rhsId3+5];
    }
  }
}
}



@kernel void boltzmannSAABPmlUpdate2D(const int pmlNelements,
               @restrict const  int   *  pmlElementIds,
               @restrict const  int   *  pmlIds,
               const dfloat expdt,  
               const dfloat ab1,
               const dfloat ab2,
               const dfloat ab3,
               const dfloat saab1,
               const dfloat saab2,
               const dfloat saab3,
               const int   shift,
               @restrict const  dfloat *  rhsq, 
               @restrict const  dfloat *  pmlrhsqx,
               @restrict const  dfloat *  pmlrhsqy,
                     @restrict dfloat *  q,
                     @restrict dfloat *  pmlqx,
                     @restrict dfloat *  pmlqy){
  // Low storage Runge Kutta time step update
  for(int es=0;es<pmlNelements;++es;@outer(0)){
    // @shared dfloat s_q[p_Np*p_Nfields];
    @exclusive int e;
    for(int n=0; n < p_maxNodes; ++n; @inner(0)){
     e = pmlElementIds[es];
      if (n < p_Np){

        const int pmlId = pmlIds[es];
        const int id  = p_Nfields*(e*p_Np + n);
        const int pid = p_Nfields*(pmlId*p_Np + n);

        const int rhsId1 = 3*id + ((shift+0)%3)*p_Nfields;
        const int rhsId2 = 3*id + ((shift+2)%3)*p_Nfields;
        const int rhsId3 = 3*id + ((shift+1)%3)*p_Nfields;

        const int pmlrhsId1 = 3*pid + ((shift+0)%3)*p_Nfields;
        const int pmlrhsId2 = 3*pid + ((shift+2)%3)*p_Nfields;
        const int pmlrhsId3 = 3*pid + ((shift+1)%3)*p_Nfields;
         
         #pragma unroll p_Nfields 
         for(int fld=0; fld< p_Nfields; ++fld){

          pmlqx[pid+fld] += (ab1*pmlrhsqx[pmlrhsId1+fld] + ab2*pmlrhsqx[pmlrhsId2+fld] + ab3*pmlrhsqx[pmlrhsId3+fld]);
          pmlqy[pid+fld] += (ab1*pmlrhsqy[pmlrhsId1+fld] + ab2*pmlrhsqy[pmlrhsId2+fld] + ab3*pmlrhsqy[pmlrhsId3+fld]);
          if(fld<3)
            q[id+fld]      += (ab1*rhsq[rhsId1+fld]+ab2*rhsq[rhsId2+fld]+ab3*rhsq[rhsId3+fld]);
          else
            q[id+fld]      = expdt*q[id+fld]+saab1*rhsq[rhsId1+fld] + saab2*rhsq[rhsId2+fld] + saab3*rhsq[rhsId3+fld];

         }
      }
    }      
  }
}



@kernel void boltzmannDOPRIRKStage2D(const int Nelements,
                         @restrict const  int *  elementIds,
                         const int NtotalElements,
                         const int rk,
                         const dfloat dt,  
                         @restrict const  dfloat *  rkA,
                         @restrict const  dfloat *  q,
                         @restrict const  dfloat *  rkrhsq,
                               @restrict dfloat *  rkq){
  
  // Runge Kutta intermediate stage
  for(int es=0;es<Nelements;++es;@outer(0)){
    for(int n=0;n<p_Np;++n;@inner(0)){

      const int e = elementIds[es];
      const int id = p_Nfields*(n + e*p_Np);

      for(int fld=0; fld< p_Nfields; ++fld){

        // const int idn = id + fld;        
        dfloat r_q = q[id +fld];

        for (int i=0;i<rk;i++) {
          const int offset = NtotalElements*p_Nfields*p_Np;
          r_q += dt*rkA[p_NrkStages*rk + i]*rkrhsq[id + fld +i*offset];
        }
        rkq[id + fld] = r_q;
      }
    }
  }
}


@kernel void boltzmannDOPRIRKUpdate2D(const int Nelements,
                                    @restrict const  int *  elementIds,
                                    const int NtotalElements,
                                    const int rk,
                                    const dfloat dt,  
                                    @restrict const  dfloat *  rkA,
                                    @restrict const  dfloat *  rkE,
                                    @restrict const  dfloat *  q,
                                    @restrict const  dfloat *  rhsq,
                                          @restrict dfloat *  rkrhsq,
                                          @restrict dfloat *  rkq,
                                          @restrict dfloat *  rkerr){
  
  // Runge Kutta intermediate stage
  for(int es=0;es<Nelements;++es;@outer(0)){
    for(int n=0;n<p_Np;++n;@inner(0)){

      const int e = elementIds[es];
      const int id = p_Nfields*(n + e*p_Np);

      for(int fld=0; fld< p_Nfields; ++fld){
        // const int idn = id + fld; 
        const int offset = NtotalElements*p_Nfields*p_Np;
  
        dfloat r_rhsq = rhsq[id + fld];

        if (rk==(p_NrkStages-1)) { //last stage

          dfloat r_q = q[id +fld];
          dfloat r_rkerr = 0.f;
          for (int i=0;i<(p_NrkStages-1);i++) {
            r_q     += dt*rkA[p_NrkStages*rk + i]*rkrhsq[id + fld + i*offset];
            r_rkerr += dt*rkE[       i]*rkrhsq[id + fld + i*offset];
          }
          r_q     += dt*rkA[p_NrkStages*rk + p_NrkStages-1]*r_rhsq;
          r_rkerr += dt*rkE[       p_NrkStages-1]*r_rhsq;

          rkq[id   +fld] = r_q;
          rkerr[id +fld] = r_rkerr;
        }

        rkrhsq[id+fld+rk*offset] = r_rhsq;
      }
    }
  }
}


@kernel void boltzmannDOPRIRKPmlStage2D(const int pmlNelements,
                                        @restrict const  int   *  pmlElementIds,
                                        @restrict const  int   *  pmlIds,
                                        const int NtotalElements,
                                        const int rk,
                                        const dfloat dt,  
                                        @restrict const  dfloat *  rkA,
                                        @restrict const  dfloat *  q,
                                        @restrict const  dfloat *  qx,
                                        @restrict const  dfloat *  qy,
                                        @restrict const  dfloat *  rkrhsq,
                                        @restrict const  dfloat *  rkrhsqx,
                                        @restrict const  dfloat *  rkrhsqy,
                                              @restrict dfloat *  rkq,
                                              @restrict dfloat *  rkqx,
                                              @restrict dfloat *  rkqy){
  
  // Runge Kutta intermediate stage
  for(int es=0;es<pmlNelements;++es;@outer(0)){
    @exclusive int e;
    for(int n=0; n < p_Np; ++n; @inner(0)){
      e = pmlElementIds[es];
      if (n < p_Np){
        const int pmlId = pmlIds[es];
        const int id  = p_Nfields*(e*p_Np + n);
        const int pid = p_Nfields*(pmlId*p_Np + n);

        for(int fld=0; fld< p_Nfields; ++fld){
          // const int idn = id + fld;        
          dfloat r_q  = q[id  + fld];
          dfloat r_qx = qx[pid+ fld];
          dfloat r_qy = qy[pid+ fld];

          for (int i=0;i<rk;i++) {
            const int offset    = NtotalElements*p_Nfields*p_Np;
            const int offsetpml = pmlNelements*p_Nfields*p_Np;
            r_q  += dt*rkA[p_NrkStages*rk+i]*rkrhsq[id+fld+i*offset];
            r_qx += dt*rkA[p_NrkStages*rk+i]*rkrhsqx[pid+fld+i*offsetpml];
            r_qy += dt*rkA[p_NrkStages*rk+i]*rkrhsqy[pid+fld+i*offsetpml];
          }
        rkq [id  +fld] = r_q;
        rkqx[pid +fld] = r_qx;
        rkqy[pid +fld] = r_qy;
      }
    }
  }
}

}


@kernel void boltzmannXDOPRIRKStage2D(const int Nelements,
                         @restrict const  int *  elementIds,
                         const int NtotalElements,
                         const int rk,
                         const dfloat dt, 
                         const dfloat expmca, 
                         @restrict const  dfloat *  rkA,
                         @restrict const  dfloat *  q,
                         @restrict const  dfloat *  rkrhsq,
                               @restrict dfloat *  rkq){
  
  // Runge Kutta intermediate stage
  for(int es=0;es<Nelements;++es;@outer(0)){
    for(int n=0;n<p_Np;++n;@inner(0)){

      const int e = elementIds[es];
      const int id = p_Nfields*(n + e*p_Np);

      for(int fld=0; fld< p_Nfields; ++fld){

        // const int idn = id + fld;        
        dfloat r_q = q[id +fld];

        for (int i=0;i<rk;i++) {
          const int offset = NtotalElements*p_Nfields*p_Np;
          r_q += dt*rkA[p_NrkStages*rk + i]*rkrhsq[id + fld +i*offset];
        }

        if(fld>2){
          r_q = expmca * r_q ; 
        }

        rkq[id + fld] = r_q;
      }
    }
  }
}



@kernel void boltzmannSAADRKStage2D(const int Nelements,
                         @restrict const  int *  elementIds,
                         const int NtotalElements,
                         const int rk,
                         const dfloat dt,
                         @restrict const  dfloat *  sarkC, 
                         @restrict const  dfloat *  rkA,
                         @restrict const  dfloat *  sarkA,
                         @restrict const  dfloat *  q,
                         @restrict const  dfloat *  rkrhsq,
                               @restrict dfloat *  rkq){
  
  // Runge Kutta intermediate stage
  for(int es=0;es<Nelements;++es;@outer(0)){
    for(int n=0;n<p_Np;++n;@inner(0)){

      const int e      = elementIds[es];
      const int id     = p_Nfields*(n + e*p_Np);
      const int offset = NtotalElements*p_Nfields*p_Np;

      for(int fld=0; fld< p_Nfields; ++fld){

        dfloat r_q = 0.f; 

        if(fld<3){
          r_q = q[id +fld];
          for (int i=0;i<rk;i++){
            r_q += dt*rkA[p_NrkStages*rk + i]*rkrhsq[id + fld +i*offset];
          }
        }
        else{
          r_q = sarkC[rk]*q[id +fld];
          for (int i=0;i<rk;i++){
            r_q += dt*sarkA[p_NrkStages*rk + i]*rkrhsq[id + fld +i*offset];
          }
        }
        rkq[id + fld] = r_q;
      }
    }
  }
}






@kernel void boltzmannDOPRIRKPmlUpdate2D(const int pmlNelements,
                                        @restrict const  int   *  pmlElementIds,
                                        @restrict const  int   *  pmlIds,
                                        const int NtotalElements,
                                        const int rk,
                                        const dfloat dt,  
                                        @restrict const  dfloat *  rkA,
                                        @restrict const  dfloat *  rkE,
                                        @restrict const  dfloat *  q,
                                        @restrict const  dfloat *  qx,
                                        @restrict const  dfloat *  qy,
                                        @restrict const  dfloat *  rhsq,
                                        @restrict const  dfloat *  rhsqx,
                                        @restrict const  dfloat *  rhsqy,
                                              @restrict dfloat *  rkrhsq,
                                              @restrict dfloat *  rkrhsqx,
                                              @restrict dfloat *  rkrhsqy,
                                              @restrict dfloat *  rkq,
                                              @restrict dfloat *  rkqx,
                                              @restrict dfloat *  rkqy,
                                              @restrict dfloat *  rkerr){
  // Runge Kutta intermediate stage
  for(int es=0;es<pmlNelements;++es;@outer(0)){
    @exclusive int e;
    for(int n=0; n < p_Np; ++n; @inner(0)){
      e = pmlElementIds[es];
      if (n < p_Np){
        const int pmlId = pmlIds[es];
        const int id  = p_Nfields*(e*p_Np + n);
        const int pid = p_Nfields*(pmlId*p_Np + n);

        for(int fld=0; fld< p_Nfields; ++fld){

          const int offset    = NtotalElements*p_Nfields*p_Np;
          const int offsetpml = pmlNelements*p_Nfields*p_Np;

          dfloat r_rhsq  = rhsq [id  + fld];
          dfloat r_rhsqx = rhsqx[pid + fld];
          dfloat r_rhsqy = rhsqy[pid + fld];

         if (rk==(p_NrkStages-1)) { //last stage

            dfloat r_q  = q [id  +fld];
            dfloat r_qx = qx[pid +fld];
            dfloat r_qy = qy[pid +fld];

            dfloat r_rkerr = 0.f;

            for (int i=0;i<(p_NrkStages-1);i++) {
              r_q     += dt*rkA[p_NrkStages*rk + i]*rkrhsq[  id + fld + i*offset];
              r_qx    += dt*rkA[p_NrkStages*rk + i]*rkrhsqx[pid + fld + i*offsetpml];
              r_qy    += dt*rkA[p_NrkStages*rk + i]*rkrhsqy[pid + fld + i*offsetpml];

              r_rkerr += dt*rkE[       i]*rkrhsq[id + fld + i*offset];
            }

            r_q     += dt*rkA[p_NrkStages*rk + p_NrkStages-1]*r_rhsq;
            r_qx    += dt*rkA[p_NrkStages*rk + p_NrkStages-1]*r_rhsqx;
            r_qy    += dt*rkA[p_NrkStages*rk + p_NrkStages-1]*r_rhsqy;

            r_rkerr += dt*rkE[       p_NrkStages-1]*r_rhsq;

            rkq[  id  +fld] = r_q;
            rkqx[pid  +fld] = r_qx;
            rkqy[pid  +fld] = r_qy;

            rkerr[id +fld] = r_rkerr;
          }

        rkrhsq[id+fld+rk*offset]      = r_rhsq;
        rkrhsqx[pid+fld+rk*offsetpml] = r_rhsqx;
        rkrhsqy[pid+fld+rk*offsetpml] = r_rhsqy;
        }
      }
    }
  }
}





@kernel void boltzmannXDOPRIRKPmlStage2D(const int pmlNelements,
                                        @restrict const  int   *  pmlElementIds,
                                        @restrict const  int   *  pmlIds,
                                        const int NtotalElements,
                                        const int rk,
                                        const dfloat dt,
                                        const dfloat expmca,  
                                        @restrict const  dfloat *  rkA,
                                        @restrict const  dfloat *  q,
                                        @restrict const  dfloat *  qx,
                                        @restrict const  dfloat *  qy,
                                        @restrict const  dfloat *  rkrhsq,
                                        @restrict const  dfloat *  rkrhsqx,
                                        @restrict const  dfloat *  rkrhsqy,
                                              @restrict dfloat *  rkq,
                                              @restrict dfloat *  rkqx,
                                              @restrict dfloat *  rkqy){
  
  // Runge Kutta intermediate stage
  for(int es=0;es<pmlNelements;++es;@outer(0)){
    @exclusive int e;
    for(int n=0; n < p_Np; ++n; @inner(0)){
      e = pmlElementIds[es];
      if (n < p_Np){
        const int pmlId = pmlIds[es];
        const int id  = p_Nfields*(e*p_Np + n);
        const int pid = p_Nfields*(pmlId*p_Np + n);

        for(int fld=0; fld< p_Nfields; ++fld){
          // const int idn = id + fld;        
          dfloat r_q  = q[id  + fld];
          dfloat r_qx = qx[pid+ fld];
          dfloat r_qy = qy[pid+ fld];

          for (int i=0;i<rk;i++) {
            const int offset    = NtotalElements*p_Nfields*p_Np;
            const int offsetpml = pmlNelements*p_Nfields*p_Np;
            r_q  += dt*rkA[p_NrkStages*rk+i]*rkrhsq[id+fld+i*offset];
            r_qx += dt*rkA[p_NrkStages*rk+i]*rkrhsqx[pid+fld+i*offsetpml];
            r_qy += dt*rkA[p_NrkStages*rk+i]*rkrhsqy[pid+fld+i*offsetpml];
          }

          if(fld>2){
            r_q = expmca * r_q ; 
          }

          rkq [id  +fld] = r_q;
          rkqx[pid +fld] = r_qx;
          rkqy[pid +fld] = r_qy;
      }
    }
  }
}

}




@kernel void boltzmannSAADRKPmlStage2D(const int pmlNelements,
                                        @restrict const  int   *  pmlElementIds,
                                        @restrict const  int   *  pmlIds,
                                        const int NtotalElements,
                                        const int rk,
                                        const dfloat dt,
                                        @restrict const  dfloat *  sarkC,  
                                        @restrict const  dfloat *  rkA,
                                        @restrict const  dfloat *  sarkA,                                        
                                        @restrict const  dfloat *  q,
                                        @restrict const  dfloat *  qx,
                                        @restrict const  dfloat *  qy,
                                        @restrict const  dfloat *  rkrhsq,
                                        @restrict const  dfloat *  rkrhsqx,
                                        @restrict const  dfloat *  rkrhsqy,
                                              @restrict dfloat *  rkq,
                                              @restrict dfloat *  rkqx,
                                              @restrict dfloat *  rkqy){
  
  // Runge Kutta intermediate stage
  for(int es=0;es<pmlNelements;++es;@outer(0)){
    @exclusive int e;
    for(int n=0; n < p_Np; ++n; @inner(0)){
      e = pmlElementIds[es];
      if (n < p_Np){
        const int pmlId     = pmlIds[es];
        const int id        = p_Nfields*(e*p_Np + n);
        const int pid       = p_Nfields*(pmlId*p_Np + n);
        const int offset    = NtotalElements*p_Nfields*p_Np;
        const int offsetpml = pmlNelements*p_Nfields*p_Np;

        for(int fld=0; fld< p_Nfields; ++fld){
          // const int idn = id + fld;        
          dfloat r_q  = 0.f;
          dfloat r_qx = 0.f;
          dfloat r_qy = 0.f;

          if(fld<3){
            r_q  = q[id  + fld];
            r_qx = qx[pid+ fld];
            r_qy = qy[pid+ fld];

            for (int i=0;i<rk;i++){
              r_q  += dt*rkA[p_NrkStages*rk+i]*rkrhsq[id+fld+i*offset];
              r_qx += dt*rkA[p_NrkStages*rk+i]*rkrhsqx[pid+fld+i*offsetpml];
              r_qy += dt*rkA[p_NrkStages*rk+i]*rkrhsqy[pid+fld+i*offsetpml];
            }
          }
          else{
            r_q  = sarkC[rk]*q[id  + fld];
            r_qx = qx[pid+ fld];
            r_qy = qy[pid+ fld];

            for (int i=0;i<rk;i++){
              r_q  += dt*sarkA[p_NrkStages*rk+i]*rkrhsq[id+fld+i*offset];
              r_qx += dt*rkA[p_NrkStages*rk+i]*rkrhsqx[pid+fld+i*offsetpml];
              r_qy += dt*rkA[p_NrkStages*rk+i]*rkrhsqy[pid+fld+i*offsetpml];
            }
          }

          rkq [id  +fld] = r_q;
          rkqx[pid +fld] = r_qx;
          rkqy[pid +fld] = r_qy;
      }
    }
  }
}

}

@kernel void boltzmannXDOPRIRKUpdate2D(const int Nelements,
                                    @restrict const  int *  elementIds,
                                    const int NtotalElements,
                                    const int rk,
                                    const dfloat dt,
                                    const dfloat expca,
                                    const dfloat expma,  
                                    @restrict const  dfloat *  rkA,
                                    @restrict const  dfloat *  rkE,
                                    @restrict const  dfloat *  q,
                                    @restrict const  dfloat *  rhsq,
                                          @restrict dfloat *  rkrhsq,
                                          @restrict dfloat *  rkq,
                                          @restrict dfloat *  rkerr){
  
  // Runge Kutta intermediate stage
  for(int es=0;es<Nelements;++es;@outer(0)){
    for(int n=0;n<p_Np;++n;@inner(0)){

      const int e = elementIds[es];
      const int id = p_Nfields*(n + e*p_Np);

      for(int fld=0; fld< p_Nfields; ++fld){
        // const int idn = id + fld; 
        const int offset = NtotalElements*p_Nfields*p_Np;
         dfloat r_rhsq = rhsq[id + fld]; 
        
        // multiply rhs with exp(c_i*invtau*dt)
        if(fld>2){
          r_rhsq = expca*r_rhsq;
        }

        if (rk==(p_NrkStages-1)) { //last stage

          dfloat r_q = q[id +fld];
          dfloat r_rkerr = 0.f;
          for (int i=0;i<(p_NrkStages-1);i++) {
            r_q     += dt*rkA[p_NrkStages*rk + i]*rkrhsq[id + fld + i*offset];
            r_rkerr += dt*rkE[       i]*rkrhsq[id + fld + i*offset];
          }
          r_q     += dt*rkA[p_NrkStages*rk + p_NrkStages-1]*r_rhsq;
          r_rkerr += dt*rkE[p_NrkStages-1]*r_rhsq;
          
          // multply with exp(-invtau*dt)
          if(fld>2){
            r_q     = expma * r_q;
            // r_rkerr =  r_rkerr;
            r_rkerr = r_rkerr * expma;
          }
          
          rkq[id   +fld] = r_q;
          rkerr[id +fld] = r_rkerr;
        }

        rkrhsq[id+fld+rk*offset] = r_rhsq;
      }
    }
  }
}



@kernel void boltzmannSAADRKUpdate2D(const int Nelements,
                                    @restrict const  int *  elementIds,
                                    const int NtotalElements,
                                    const int rk,
                                    const dfloat dt,
                                    @restrict const  dfloat * sarkC, 
                                    @restrict const  dfloat *  rkA,
                                    @restrict const  dfloat *  rkE,
                                    @restrict const  dfloat *  sarkA,
                                    @restrict const  dfloat *  sarkE,
                                    @restrict const  dfloat *  q,
                                    @restrict const  dfloat *  rhsq,
                                          @restrict dfloat *  rkrhsq,
                                          @restrict dfloat *  rkq,
                                          @restrict dfloat *  rkerr){
  
  // Runge Kutta intermediate stage
  for(int es=0;es<Nelements;++es;@outer(0)){
    for(int n=0;n<p_Np;++n;@inner(0)){

      const int e = elementIds[es];
      const int id = p_Nfields*(n + e*p_Np);

      for(int fld=0; fld< p_Nfields; ++fld){
        // const int idn = id + fld; 
        const int offset = NtotalElements*p_Nfields*p_Np;

        dfloat r_rhsq  = rhsq[id + fld];
        dfloat r_q     = 0.f;
        dfloat r_rkerr = 0.f;

        if(rk==(p_NrkStages-1)){

          if(fld<3){

            r_q = q[id +fld];

            for (int i=0;i<(p_NrkStages-1);i++) {
              r_q     += dt*rkA[p_NrkStages*rk + i]*rkrhsq[id + fld + i*offset];
              r_rkerr += dt*rkE[       i]*rkrhsq[id + fld + i*offset];
            }
            r_q     += dt*rkA[p_NrkStages*rk + p_NrkStages-1]*r_rhsq;
            r_rkerr += dt*rkE[                 p_NrkStages-1]*r_rhsq;
          }
          else{

            r_q = sarkC[rk]*q[id +fld];

             for (int i=0;i<(p_NrkStages-1);i++) {
              r_q     += dt*sarkA[p_NrkStages*rk + i]*rkrhsq[id + fld + i*offset];
              r_rkerr += dt*sarkE[                 i]*rkrhsq[id + fld + i*offset];
            }
            r_q     += dt*sarkA[p_NrkStages*rk + p_NrkStages-1]*r_rhsq;
            r_rkerr += dt*sarkE[                 p_NrkStages-1]*r_rhsq;
          }

          rkq[id   +fld] = r_q;
          rkerr[id +fld] = r_rkerr;
        }

        rkrhsq[id+fld+rk*offset] = r_rhsq;
      }
    }
  }
}



@kernel void boltzmannXDOPRIRKPmlUpdate2D(const int pmlNelements,
                                        @restrict const  int   *  pmlElementIds,
                                        @restrict const  int   *  pmlIds,
                                        const int NtotalElements,
                                        const int rk,
                                        const dfloat dt,
                                        const dfloat expca,
                                        const dfloat expma,   
                                        @restrict const  dfloat *  rkA,
                                        @restrict const  dfloat *  rkE,
                                        @restrict const  dfloat *  q,
                                        @restrict const  dfloat *  qx,
                                        @restrict const  dfloat *  qy,
                                        @restrict const  dfloat *  rhsq,
                                        @restrict const  dfloat *  rhsqx,
                                        @restrict const  dfloat *  rhsqy,
                                              @restrict dfloat *  rkrhsq,
                                              @restrict dfloat *  rkrhsqx,
                                              @restrict dfloat *  rkrhsqy,
                                              @restrict dfloat *  rkq,
                                              @restrict dfloat *  rkqx,
                                              @restrict dfloat *  rkqy,
                                              @restrict dfloat *  rkerr){
  // Runge Kutta intermediate stage
  for(int es=0;es<pmlNelements;++es;@outer(0)){
    @exclusive int e;
    for(int n=0; n < p_Np; ++n; @inner(0)){
      e = pmlElementIds[es];
      if (n < p_Np){
        const int pmlId = pmlIds[es];
        const int id  = p_Nfields*(e*p_Np + n);
        const int pid = p_Nfields*(pmlId*p_Np + n);

        for(int fld=0; fld< p_Nfields; ++fld){

          const int offset    = NtotalElements*p_Nfields*p_Np;
          const int offsetpml = pmlNelements*p_Nfields*p_Np;

          dfloat r_rhsq  = rhsq [id  + fld];
          dfloat r_rhsqx = rhsqx[pid + fld];
          dfloat r_rhsqy = rhsqy[pid + fld];

          if(fld>2){
            r_rhsq = expca*r_rhsq;
          }



          if (rk==(p_NrkStages-1)) { //last stage

            dfloat r_q  = q [id  +fld];
            dfloat r_qx = qx[pid +fld];
            dfloat r_qy = qy[pid +fld];

            dfloat r_rkerr = 0.f;

            for (int i=0;i<(p_NrkStages-1);i++){
              r_q     += dt*rkA[p_NrkStages*rk + i]*rkrhsq[  id + fld + i*offset];
              r_qx    += dt*rkA[p_NrkStages*rk + i]*rkrhsqx[pid + fld + i*offsetpml];
              r_qy    += dt*rkA[p_NrkStages*rk + i]*rkrhsqy[pid + fld + i*offsetpml];

              r_rkerr += dt*rkE[       i]*rkrhsq[id + fld + i*offset];
            }

            r_q     += dt*rkA[p_NrkStages*rk + p_NrkStages-1]*r_rhsq;
            r_qx    += dt*rkA[p_NrkStages*rk + p_NrkStages-1]*r_rhsqx;
            r_qy    += dt*rkA[p_NrkStages*rk + p_NrkStages-1]*r_rhsqy;

            r_rkerr += dt*rkE[       p_NrkStages-1]*r_rhsq;


            if(fld>2){
              r_q     = expma * r_q;
              // r_rkerr = expma * r_rkerr;
              // r_rkerr = r_rkerr;
              r_rkerr = r_rkerr*expma;
           }

            rkq[  id  +fld] = r_q;
            rkqx[pid  +fld] = r_qx;
            rkqy[pid  +fld] = r_qy;

            rkerr[id +fld] = r_rkerr;
          }

        rkrhsq[id+fld+rk*offset]      = r_rhsq;
        rkrhsqx[pid+fld+rk*offsetpml] = r_rhsqx;
        rkrhsqy[pid+fld+rk*offsetpml] = r_rhsqy;
        }
      }
    }
  }
}



@kernel void boltzmannSAADRKPmlUpdate2D(const int pmlNelements,
                                        @restrict const  int   *  pmlElementIds,
                                        @restrict const  int   *  pmlIds,
                                        const int NtotalElements,
                                        const int rk,
                                        const dfloat dt,
                                        @restrict const  dfloat * sarkC, 
                                        @restrict const  dfloat *  rkA,
                                        @restrict const  dfloat *  rkE,
                                        @restrict const  dfloat *  sarkA,
                                        @restrict const  dfloat *  sarkE,
                                        @restrict const  dfloat *  q,
                                        @restrict const  dfloat *  qx,
                                        @restrict const  dfloat *  qy,
                                        @restrict const  dfloat *  rhsq,
                                        @restrict const  dfloat *  rhsqx,
                                        @restrict const  dfloat *  rhsqy,
                                              @restrict dfloat *  rkrhsq,
                                              @restrict dfloat *  rkrhsqx,
                                              @restrict dfloat *  rkrhsqy,
                                              @restrict dfloat *  rkq,
                                              @restrict dfloat *  rkqx,
                                              @restrict dfloat *  rkqy,
                                              @restrict dfloat *  rkerr){
  // Runge Kutta intermediate stage
  for(int es=0;es<pmlNelements;++es;@outer(0)){
    @exclusive int e;
    for(int n=0; n < p_Np; ++n; @inner(0)){
      e = pmlElementIds[es];
      if (n < p_Np){
        const int pmlId = pmlIds[es];
        const int id  = p_Nfields*(e*p_Np + n);
        const int pid = p_Nfields*(pmlId*p_Np + n);

        for(int fld=0; fld< p_Nfields; ++fld){

          const int offset    = NtotalElements*p_Nfields*p_Np;
          const int offsetpml = pmlNelements*p_Nfields*p_Np;

          dfloat r_rhsq  = rhsq [id  + fld];
          dfloat r_rhsqx = rhsqx[pid + fld];
          dfloat r_rhsqy = rhsqy[pid + fld];

          if(rk==(p_NrkStages-1)){
            //
            dfloat r_q     = 0.f;
            dfloat r_qx    = 0.f;
            dfloat r_qy    = 0.f;
            dfloat r_rkerr = 0.f;

            if(fld<3){
              r_q  = q [id  +fld];
              r_qx = qx[pid +fld];
              r_qy = qy[pid +fld];

              dfloat r_rkerr = 0.f;

              for (int i=0;i<(p_NrkStages-1);i++) {
                r_q     += dt*rkA[p_NrkStages*rk + i]*rkrhsq[  id + fld + i*offset];
                r_qx    += dt*rkA[p_NrkStages*rk + i]*rkrhsqx[pid + fld + i*offsetpml];
                r_qy    += dt*rkA[p_NrkStages*rk + i]*rkrhsqy[pid + fld + i*offsetpml];
                r_rkerr += dt*rkE[       i]*rkrhsq[id + fld + i*offset];
              }

              r_q     += dt*rkA[p_NrkStages*rk + p_NrkStages-1]*r_rhsq;
              r_qx    += dt*rkA[p_NrkStages*rk + p_NrkStages-1]*r_rhsqx;
              r_qy    += dt*rkA[p_NrkStages*rk + p_NrkStages-1]*r_rhsqy;

              r_rkerr += dt*rkE[p_NrkStages-1]*r_rhsq;
            }
            else{

              r_q  = sarkC[rk]*q [id  +fld];
              r_qx = qx[pid +fld];
              r_qy = qy[pid +fld];

              dfloat r_rkerr = 0.f;

              for (int i=0;i<(p_NrkStages-1);i++) {
                r_q     += dt*sarkA[p_NrkStages*rk + i]*rkrhsq[  id + fld + i*offset];
                r_qx    += dt*rkA[p_NrkStages*rk + i]*rkrhsqx[pid + fld + i*offsetpml];
                r_qy    += dt*rkA[p_NrkStages*rk + i]*rkrhsqy[pid + fld + i*offsetpml];

                r_rkerr += dt*sarkE[       i]*rkrhsq[id + fld + i*offset];
              }

              r_q     += dt*sarkA[p_NrkStages*rk + p_NrkStages-1]*r_rhsq;
              r_qx    += dt*rkA[p_NrkStages*rk + p_NrkStages-1]*r_rhsqx;
              r_qy    += dt*rkA[p_NrkStages*rk + p_NrkStages-1]*r_rhsqy;

              r_rkerr += dt*sarkE[p_NrkStages-1]*r_rhsq;
            }
          }

        rkrhsq[id+fld+rk*offset]      = r_rhsq;
        rkrhsqx[pid+fld+rk*offsetpml] = r_rhsqx;
        rkrhsqy[pid+fld+rk*offsetpml] = r_rhsqy;
        }     
      }
    }
  }
}








@kernel void boltzmannErrorEstimate2D(const int N,
                               const dfloat ATOL,
                               const dfloat RTOL,
                               @restrict const  dfloat *  q,
                               @restrict const  dfloat *  rkq,
                               @restrict const  dfloat *  rkerr,
                                     @restrict dfloat *  errtmp){
  
  for(int b=0;b<(N+p_blockSize-1)/p_blockSize;++b;@outer(0)){
    
    @shared volatile dfloat s_err[p_blockSize];

    for(int t=0;t<p_blockSize;++t;@inner(0)){
      const int id = t + p_blockSize*b;
      if (id<N) {
        const dfloat   qn =   q[id];
        const dfloat rkqn = rkq[id];
        const dfloat qmax = (qn>rkqn) ? qn : rkqn;
        // const dfloat qmax = rkqn;
        dfloat sk = ATOL + RTOL*qmax;

        s_err[t] = (rkerr[id]/sk)*(rkerr[id]/sk);
      } else {
        s_err[t] = 0.f;  
      }
    }

    @barrier("local");
#if p_blockSize>512
    for(int t=0;t<p_blockSize;++t;@inner(0)) if(t<512) s_err[t] += s_err[t+512];
    @barrier("local");
#endif
#if p_blockSize>256
    for(int t=0;t<p_blockSize;++t;@inner(0)) if(t<256) s_err[t] += s_err[t+256];
    @barrier("local");
#endif

    for(int t=0;t<p_blockSize;++t;@inner(0)) if(t<128) s_err[t] += s_err[t+128];
    @barrier("local");

    for(int t=0;t<p_blockSize;++t;@inner(0)) if(t< 64) s_err[t] += s_err[t+64];
    @barrier("local");

    for(int t=0;t<p_blockSize;++t;@inner(0)) if(t< 32) s_err[t] += s_err[t+32];
    for(int t=0;t<p_blockSize;++t;@inner(0)) if(t< 16) s_err[t] += s_err[t+16];
    for(int t=0;t<p_blockSize;++t;@inner(0)) if(t<  8) s_err[t] += s_err[t+8];
    for(int t=0;t<p_blockSize;++t;@inner(0)) if(t<  4) s_err[t] += s_err[t+4];
    for(int t=0;t<p_blockSize;++t;@inner(0)) if(t<  2) s_err[t] += s_err[t+2];

    for(int t=0;t<p_blockSize;++t;@inner(0)) if(t<  1) errtmp[b] = s_err[0] + s_err[1];
  }
}








@kernel void boltzmannLSERKUpdate2D(const int Nelements,
            @restrict const  int *  elementIds,
            const dfloat dt,  
            const dfloat rka,
            const dfloat rkb,
            @restrict const  dfloat *  rhsq,
                  @restrict dfloat *  resq,
                  @restrict dfloat *  q){
  
  // Low storage Runge Kutta time step update
  for(int es=0;es<Nelements;++es;@outer(0)){

    for(int n=0;n<p_Np;++n;@inner(0)){
      const int e = elementIds[es];
      const int id = p_Nfields*(n + e*p_Np);
                  
        for(int fld=0; fld< p_Nfields; ++fld){

         const int idn = id + fld;
         dfloat r_resq = resq[idn];
         dfloat r_rhsq = rhsq[idn]; 


         dfloat r_q    = q[idn];
         //
         r_resq = rka*r_resq + dt*r_rhsq;
         r_q   += rkb*r_resq;
         //
         resq[idn] = r_resq;
         q[idn]    = r_q;
       
      }
    }
  }
}



@kernel void boltzmannLSERKPmlUpdate2D(const int pmlNelements,
              @restrict const  int   *  pmlElementIds,
              @restrict const  int   *  pmlIds,
              const dfloat dt,  
              const dfloat rka,
              const dfloat rkb,
              const dfloat ramp, 
              @restrict const  dfloat *  rhsq, 
              @restrict const  dfloat *  rhsqx,
              @restrict const  dfloat *  rhsqy, 
                    @restrict dfloat *  resq,
                    @restrict dfloat *  resqx,
                    @restrict dfloat *  resqy,
                    @restrict dfloat *  qx,
                    @restrict dfloat *  qy,
                    @restrict dfloat *  q){
  
// Low storage Runge Kutta time step update
for(int es=0;es<pmlNelements;++es;@outer(0)){
  @exclusive int e;
  for(int n=0; n < p_Np; ++n; @inner(0)){
    e = pmlElementIds[es];

    if (n < p_Np){
      const int pmlId = pmlIds[es];
      const int id  = p_Nfields*(e*p_Np + n);
      const int pid = p_Nfields*(pmlId*p_Np + n);
      //
      #pragma unroll p_Nfields
      for (int fld =0; fld<p_Nfields; ++fld){
        const dfloat r_q  = q [id  + fld];
        const dfloat r_qx = qx[pid + fld];
        const dfloat r_qy = qy[pid + fld];

        dfloat r_resq  = resq [id + fld];      
        dfloat r_resqx = resqx[pid+ fld];
        dfloat r_resqy = resqy[pid+ fld];

        const dfloat r_rhsq  = rhsq [id  + fld];
        const dfloat r_rhsqx = rhsqx[pid + fld];
        const dfloat r_rhsqy = rhsqy[pid + fld];

        r_resq  = rka*r_resq  + dt*r_rhsq ;
        r_resqx = rka*r_resqx + dt*r_rhsqx;
        r_resqy = rka*r_resqy + dt*r_rhsqy;

        q [id + fld] = r_q  + rkb*r_resq ;
        qx[pid+ fld] = r_qx + rkb*r_resqx;
        qy[pid+ fld] = r_qy + rkb*r_resqy;

        resq [id + fld]  = r_resq ;      
        resqx[pid+ fld]  = r_resqx;
        resqy[pid+ fld]  = r_resqy;
      } 
    }
  }
}
}



// Check indexing for SARK KERNELS !!!!!!!!!!!!!
@kernel void boltzmannSARKStageUpdate2D(const int Nelements,
            @restrict const  int *  elementIds,
            const dfloat dt, 
            const dfloat expdt, 
            const dfloat rka,
            const dfloat erka,
            const dfloat rkb,
            const dfloat erkb,
            const int shift,
            @restrict const  dfloat *  rhsq,
            @restrict const  dfloat *  qs,
                  @restrict dfloat *  q){
  
  // Low storage Runge Kutta time step update
  for(int es=0;es<Nelements;++es;@outer(0)){
    for(int n=0;n<p_Np;++n;@inner(0)){
      const int e = elementIds[es];
      
      const int id = p_Nfields*(n + e*p_Np);
        // hard-coded for 3th order
        const int rhsId1 = 3*id + ((shift+0)%3)*p_Nfields;
        const int rhsId2 = 3*id + ((shift+1)%3)*p_Nfields;
      
        q[id+0] = qs[id+0] + dt*(rka*rhsq[rhsId1+0] + rkb*rhsq[rhsId2+0]);
        q[id+1] = qs[id+1] + dt*(rka*rhsq[rhsId1+1] + rkb*rhsq[rhsId2+1]);
        q[id+2] = qs[id+2] + dt*(rka*rhsq[rhsId1+2] + rkb*rhsq[rhsId2+2]);
        //
        q[id+3] = expdt*qs[id+3] + dt*(erka*rhsq[rhsId1+3] + erkb*rhsq[rhsId2+3]);
        q[id+4] = expdt*qs[id+4] + dt*(erka*rhsq[rhsId1+4] + erkb*rhsq[rhsId2+4]);
        q[id+5] = expdt*qs[id+5] + dt*(erka*rhsq[rhsId1+5] + erkb*rhsq[rhsId2+5]);
    }
  }
}



@kernel void boltzmannSARKUpdate2D(const int Nelements,
            @restrict const  int *  elementIds,
            const dfloat dt, 
            const dfloat expdt, 
            const dfloat rka,
            const dfloat erka,
            const dfloat rkb,
            const dfloat erkb,
            const dfloat rkc,
            const dfloat erkc,
            const int shift,
            @restrict const  dfloat *  rhsq,
                  @restrict dfloat *  qs,
                  @restrict dfloat *  q){
  
  // Low storage Runge Kutta time step update
  for(int es=0;es<Nelements;++es;@outer(0)){
    for(int n=0;n<p_Np;++n;@inner(0)){
      const int e = elementIds[es];
      
      const int id = p_Nfields*(n + e*p_Np);
        // hard-coded for 3th order
        const int rhsId1 = 3*id + ((shift+0)%3)*p_Nfields;
        const int rhsId2 = 3*id + ((shift+1)%3)*p_Nfields;
        const int rhsId3 = 3*id + ((shift+2)%3)*p_Nfields;
        
        #pragma unroll p_Nfields
        for(int fld=0; fld<p_Nfields; ++fld ){
         dfloat r_q = 0.f; 
         if(fld<3)
           r_q = qs[id+fld] + dt*(rka*rhsq[rhsId1+fld] + rkb*rhsq[rhsId2+fld] + rkc*rhsq[rhsId3+fld]);
         else
           r_q = expdt*qs[id+fld] + dt*(erka*rhsq[rhsId1+fld] + erkb*rhsq[rhsId2+fld] + erkc*rhsq[rhsId3+fld]);

          q [id+fld] = r_q;
          qs[id+fld] = r_q;
        }
    }
  }
}



@kernel void boltzmannSARKPmlStageUpdate2D(const int pmlNelements,
              @restrict const  int *  pmlElementIds, 
              @restrict const  int * pmlIds,
              const dfloat dt,  
              const dfloat expdt, 
              const dfloat rka,
              const dfloat erka,
              const dfloat rkb,
              const dfloat erkb,
              const dfloat ramp, 
              const int shift,
              @restrict const  dfloat *  rhsq,
              @restrict const  dfloat *  rhsqx,
              @restrict const  dfloat *  rhsqy,
              @restrict const  dfloat *  qs,
              @restrict const  dfloat *  qsx,
              @restrict const  dfloat *  qsy,
                    @restrict dfloat *  qx,
                    @restrict dfloat *  qy,
                    @restrict dfloat *  q){
  // Low storage Runge Kutta time step update
  for(int es=0;es<pmlNelements;++es;@outer(0)){
  @exclusive int e;
    for(int n=0; n < p_Np; ++n; @inner(0)){
    e = pmlElementIds[es];

    if (n < p_Np){
      const int pmlId = pmlIds[es];
      const int id  = p_Nfields*(e*p_Np + n);
      const int pid = p_Nfields*(pmlId*p_Np + n);

      const int rhsId1 = 3*id + ((shift+0)%3)*p_Nfields;
      const int rhsId2 = 3*id + ((shift+1)%3)*p_Nfields;
      
      const int pmlrhsId1 = 3*pid + ((shift+0)%3)*p_Nfields;
      const int pmlrhsId2 = 3*pid + ((shift+1)%3)*p_Nfields;
      //
      #pragma unroll p_Nfields
      for(int fld=0; fld< p_Nfields; ++fld){

      qx[pid+fld] = qsx[pid+fld] + dt*( rka*rhsqx[pmlrhsId1+fld] + rkb*rhsqx[pmlrhsId2+fld]);
      qy[pid+fld] = qsy[pid+fld] + dt*( rka*rhsqy[pmlrhsId1+fld] + rkb*rhsqy[pmlrhsId2+fld]);

      if(fld<3)
        q[id+fld] = qs[id+fld] + dt*(rka*rhsq[rhsId1+fld] + rkb*rhsq[rhsId2+fld]);
      else
        q[id+fld] = expdt*qs[id+fld] + dt*(erka*rhsq[rhsId1+fld] + erkb*rhsq[rhsId2+fld]);
      }
    }
  }
}
}


@kernel void boltzmannSARKPmlUpdate2D(const int pmlNelements,
              @restrict const  int *  pmlElementIds, 
              @restrict const  int * pmlIds,
              const dfloat dt,  
              const dfloat expdt, 
              const dfloat rka,
              const dfloat erka,
              const dfloat rkb,
              const dfloat erkb,
              const dfloat rkc,
              const dfloat erkc,
              const dfloat ramp, 
              const int shift,
              @restrict const  dfloat *  rhsq,
              @restrict const  dfloat *  rhsqx,
              @restrict const  dfloat *  rhsqy,
                    @restrict dfloat *  qs,
                    @restrict dfloat *  qsx,
                    @restrict dfloat *  qsy,
                    @restrict dfloat *  qx,
                    @restrict dfloat *  qy,
                    @restrict dfloat *  q){
  // Low storage Runge Kutta time step update
  for(int es=0;es<pmlNelements;++es;@outer(0)){
  @exclusive int e;
    for(int n=0; n < p_Np; ++n; @inner(0)){
    e = pmlElementIds[es];

    if (n < p_Np){
      const int pmlId = pmlIds[es];
      const int id  = p_Nfields*(e*p_Np + n);
      const int pid = p_Nfields*(pmlId*p_Np + n);

      const int rhsId1 = 3*id + ((shift+0)%3)*p_Nfields;
      const int rhsId2 = 3*id + ((shift+1)%3)*p_Nfields;
      const int rhsId3 = 3*id + ((shift+2)%3)*p_Nfields;

      const int pmlrhsId1 = 3*pid + ((shift+0)%3)*p_Nfields;
      const int pmlrhsId2 = 3*pid + ((shift+1)%3)*p_Nfields;
      const int pmlrhsId3 = 3*pid + ((shift+2)%3)*p_Nfields;
      //
      #pragma unroll p_Nfields
      for(int fld=0; fld< p_Nfields; ++fld){

        dfloat r_qx =0.f, r_qy =0.f, r_q = 0.f; 
        
        r_qx = qsx[pid+fld] + dt*( rka*rhsqx[pmlrhsId1+fld] + rkb*rhsqx[pmlrhsId2+fld] +rkc*rhsqx[pmlrhsId3+fld]);
        r_qy = qsy[pid+fld] + dt*( rka*rhsqy[pmlrhsId1+fld] + rkb*rhsqy[pmlrhsId2+fld] +rkc*rhsqy[pmlrhsId3+fld]);

        qx[pid+fld]  = r_qx;
        qy[pid+fld]  = r_qy;
        qsx[pid+fld] = r_qx;
        qsy[pid+fld] = r_qy;

        if(fld<3)
          r_q = qs[id+fld] + dt*(rka*rhsq[rhsId1+fld] + rkb*rhsq[rhsId2+fld] + rkc*rhsq[rhsId3+fld]);
        else
          r_q = expdt*qs[id+fld] + dt*(erka*rhsq[rhsId1+fld] + erkb*rhsq[rhsId2+fld] +erkc*rhsq[rhsId3+fld]);

        q[id+fld]  = r_q;
        qs[id+fld] = r_q;

      }
    }
  }
}
}




// Perform an update like Y = Q + c_im*Res_IM + c_ex*Res_EX;
@kernel void boltzmannLSIMEXResidualUpdate2D(const int Nelements,
            @restrict const  int *  elementIds,
            const dfloat dt, 
            const dfloat aki,
            const dfloat ake, 
            @restrict const  dfloat *  q,
            @restrict const  dfloat *  qZ,
            @restrict const  dfloat *  rhsq,
                  @restrict dfloat *  qY){
  // Low storage Runge Kutta time step update
  for(int es=0;es<Nelements;++es;@outer(0)){
    for(int n=0;n<p_Np;++n;@inner(0)){
      const int e = elementIds[es];
      
      const int id = p_Nfields*(n + e*p_Np);
      
      #pragma unroll p_Nfields
      for(int fld=0; fld<p_Nfields; ++fld){
        qY[id +fld] = q[id+fld] + dt*( ake*rhsq[id +fld] + aki*qZ[id +fld]);
      }
    }
  }
}



// Perform an update like Y = Q + c_im*Res_IM + c_ex*Res_EX;
@kernel void boltzmannLSIMEXPmlResidualUpdate2D(const int pmlNelements,
            @restrict const  int *  pmlElementIds, 
            @restrict const  int * pmlIds,
            const dfloat dt,
            const dfloat ramp, 
            const dfloat c_im,
            const dfloat c_ex, 
            @restrict const  dfloat *  q,
            @restrict const  dfloat  *  pmlqx,
            @restrict const  dfloat  *  pmlqy,
            @restrict const  dfloat  *  qZ,      
            @restrict const  dfloat  *  rhsq,
            @restrict const  dfloat  *  rhsqx,
            @restrict const  dfloat  *  rhsqy,
                  @restrict dfloat  *  qY,  
                  @restrict dfloat  *  pmlYx,
                  @restrict dfloat  *  pmlYy){

  for(int es=0;es<pmlNelements;++es;@outer(0)){
  @exclusive int e;
    for(int n=0; n < p_Np; ++n; @inner(0)){
    e = pmlElementIds[es];

    if (n < p_Np){
      const int pmlId = pmlIds[es];
      const int id  = p_Nfields*(e*p_Np + n);
      const int pid = p_Nfields*(pmlId*p_Np + n);
      
      #pragma unroll p_Nfields
      for(int fld=0; fld<p_Nfields; ++fld){
        pmlYx[pid+fld] = pmlqx[pid+fld] + c_ex*dt*rhsqx[pid+fld]; // fully explicit
        pmlYy[pid+fld] = pmlqy[pid+fld] + c_ex*dt*rhsqy[pid+fld]; // fully explicit
        qY[id+fld]     = q[id+fld]      + dt*(c_ex*rhsq[id+fld] + c_im*qZ[id+fld]); // imlicit-explicit
      }
    }
  }
}
}
      


// Perform an update like Y = Q + c_im*Res_IM + c_ex*Res_EX;
@kernel void boltzmannLSIMEXImplicitUpdate2D(const int Nelements,
            @restrict const  int *  elementIds,
            const dfloat dt, 
            const dfloat akk,
            @restrict const  dfloat *  qZ,
                  @restrict dfloat *  qY){
  // Low storage Runge Kutta time step update
  for(int es=0;es<Nelements;++es;@outer(0)){
    for(int n=0;n<p_Np;++n;@inner(0)){
      const int e = elementIds[es];
      
      const int id = p_Nfields*(n + e*p_Np);
      
      #pragma unroll p_Nfields
      for(int fld=0; fld<p_Nfields; ++fld){
       qY[id + fld] += akk*dt*qZ[id+fld];
      }
    }
  }
}




// Perform an update like Y = Q + c_im*Res_IM + c_ex*Res_EX;
@kernel void boltzmannLSIMEXUpdate2D(const int Nelements,
            @restrict const  int *  elementIds,
            const dfloat dt, 
            const dfloat akk,
            @restrict const  dfloat *  qZ,
                  @restrict dfloat *  qY,
            @restrict const  dfloat *  rhsq,
                  @restrict dfloat *  q){
  // Low storage Runge Kutta time step update
  for(int es=0;es<Nelements;++es;@outer(0)){
    for(int n=0;n<p_Np;++n;@inner(0)){
      const int e = elementIds[es];

      const int id = p_Nfields*(n + e*p_Np);
      #pragma unroll p_Nfields
       for(int fld=0; fld<p_Nfields; ++fld){
        q[id  +fld] += akk*dt*(rhsq[id+fld] + qZ[id+fld]);
       }
    }
  }
}



// Perform an update like Y = Q + c_im*Res_IM + c_ex*Res_EX;
@kernel void boltzmannLSIMEXPmlImplicitUpdate2D(const int pmlNelements,
            @restrict const  int *  pmlElementIds, 
            @restrict const  int * pmlIds,
            const dfloat dt, 
            const dfloat ramp,
            const dfloat akk,
            @restrict const  dfloat  *  qZ,
                  @restrict dfloat  *  qY){
 for(int es=0;es<pmlNelements;++es;@outer(0)){
  @exclusive int e;
    for(int n=0; n < p_Np; ++n; @inner(0)){
    e = pmlElementIds[es];

    if (n < p_Np){
      const int pmlId = pmlIds[es];
      const int id  = p_Nfields*(e*p_Np + n);
      // const int pid = p_Nfields*(pmlId*p_Np + n);
      
      #pragma unroll p_Nfields
      for(int fld=0; fld<p_Nfields; ++fld){
        qY[id + fld] +=  akk*dt*qZ[id+fld];
      }
    }
  }
}
}



// Perform an update like Y = Q + c_im*Res_IM + c_ex*Res_EX;
@kernel void boltzmannLSIMEXPmlUpdate2D(const int pmlNelements,
            @restrict const  int *  pmlElementIds, 
            @restrict const  int * pmlIds,
            const dfloat dt, 
            const dfloat akk,
            const dfloat ramp,
            @restrict const  dfloat  *  qZ,
            @restrict const  dfloat  *  qY,
            @restrict const  dfloat  *  qYx,
            @restrict const  dfloat  *  qYy,
            @restrict const  dfloat  *  rhsq,
            @restrict const  dfloat  *  rhsqx,
            @restrict const  dfloat  *  rhsqy,    
                  @restrict dfloat  *  pmlqx,
                  @restrict dfloat  *  pmlqy,
                  @restrict dfloat  *  q ){
  for(int es=0;es<pmlNelements;++es;@outer(0)){
  @exclusive int e;
    for(int n=0; n < p_Np; ++n; @inner(0)){
    e = pmlElementIds[es];

    if (n < p_Np){
      const int pmlId = pmlIds[es];
      const int id  = p_Nfields*(e*p_Np + n);
      const int pid = p_Nfields*(pmlId*p_Np + n);
      
      #pragma unroll p_Nfields
      for(int fld=0; fld<p_Nfields; ++fld){
        
        //update qx
        pmlqx[pid+fld] +=  akk*dt*rhsqx[pid+fld];
        pmlqy[pid+fld] +=  akk*dt*rhsqy[pid+fld];
        q[id  +fld]    +=  akk*dt*(rhsq[id+fld] + qZ[id+fld]);
      }
    }
  }
}
}
    






// This @kernel does not use float 4 format, 
@kernel void boltzmannMRABUpdate2D(const int Nelements,
            @restrict const  int *  elementIds,
            const dfloat dt,  
            const dfloat a1,
            const dfloat a2,
            const dfloat a3,
            const int   shift,
            @restrict const  int   *  vmapM,
            @restrict const  dfloat *  rhsq,
                  @restrict dfloat *  fQM,
                  @restrict dfloat *  q){
  
  // Low storage Runge Kutta time step update
  for(int es=0;es<Nelements;++es;@outer(0)){

    @shared dfloat s_q[p_Np*p_Nfields];
    @exclusive int e; 

    for(int n=0;n<p_maxNodes;++n;@inner(0)){
      e  = elementIds[es];
      if(n<p_Np){
        const int id = p_Nfields*(n + e*p_Np);

        // hard-coded for 3th order
        const int rhsId1 = 3*id + ((shift+0)%3)*p_Nfields;
        const int rhsId2 = 3*id + ((shift+2)%3)*p_Nfields;
        const int rhsId3 = 3*id + ((shift+1)%3)*p_Nfields;
        
        #pragma unroll p_Nfields
        for(int fld=0; fld< p_Nfields; ++fld){
          s_q[p_Nfields*n+fld] = q[id+fld] + dt*(a1*rhsq[rhsId1+fld] + a2*rhsq[rhsId2+fld] + a3*rhsq[rhsId3+fld]);
        }
      }
    }

    // make sure all node data is loaded into @shared
    @barrier("local");

    for(int n=0;n<p_maxNodes;++n;@inner(0)){

      // Update q
      if(n<p_Np){

        const int id = p_Nfields*(e*p_Np + n);
        #pragma unroll p_Nfields
        for (int fld = 0; fld < p_Nfields; ++fld){
          q[id+fld]   = s_q[p_Nfields*n+fld];
        } 

      }

      if(n<p_Nfaces*p_Nfp){

        const int iid  = e*p_Nfp*p_Nfaces + n;
        const int qidM = p_Nfields*(vmapM[iid]-e*p_Np);
        const int qid  = p_Nfields*iid; 
         
         #pragma unroll p_Nfields
         for (int fld = 0; fld < p_Nfields; ++fld){
          fQM[qid+fld] = s_q[qidM+fld];  
        }   
      }

    }

  }
}



// This @kernel does not use float 4 format, 
@kernel void boltzmannMRSAABUpdate2D(const int Nelements,
            @restrict const  int *  elementIds,
            const dfloat expdt, 
            const dfloat ab1,
            const dfloat ab2,
            const dfloat ab3,
            const dfloat saab1,
            const dfloat saab2,
            const dfloat saab3,
            const int   shift,
            @restrict const  int   *  vmapM,
            @restrict const  dfloat *  rhsq,
                  @restrict dfloat *  fQM,
                  @restrict dfloat *  q){
  
  // Low storage Runge Kutta time step update
  for(int es=0;es<Nelements;++es;@outer(0)){

    @shared dfloat s_q[p_Np*p_Nfields];
    @exclusive int e; 

    for(int n=0;n<p_maxNodes;++n;@inner(0)){
      e  = elementIds[es];
      if(n<p_Np){
        const int id = p_Nfields*(n + e*p_Np);

        // hard-coded for 3th order
        const int rhsId1 = 3*id + ((shift+0)%3)*p_Nfields;
        const int rhsId2 = 3*id + ((shift+2)%3)*p_Nfields;
        const int rhsId3 = 3*id + ((shift+1)%3)*p_Nfields;

        //
        s_q[p_Nfields*n+0] = q[id+0] + ab1*rhsq[rhsId1+0] + ab2*rhsq[rhsId2+0] + ab3*rhsq[rhsId3+0];
        s_q[p_Nfields*n+1] = q[id+1] + ab1*rhsq[rhsId1+1] + ab2*rhsq[rhsId2+1] + ab3*rhsq[rhsId3+1];
        s_q[p_Nfields*n+2] = q[id+2] + ab1*rhsq[rhsId1+2] + ab2*rhsq[rhsId2+2] + ab3*rhsq[rhsId3+2];
        //
        s_q[p_Nfields*n+3] = expdt*q[id+3] + saab1*rhsq[rhsId1+3] + saab2*rhsq[rhsId2+3] + saab3*rhsq[rhsId3+3];
        s_q[p_Nfields*n+4] = expdt*q[id+4] + saab1*rhsq[rhsId1+4] + saab2*rhsq[rhsId2+4] + saab3*rhsq[rhsId3+4];
        s_q[p_Nfields*n+5] = expdt*q[id+5] + saab1*rhsq[rhsId1+5] + saab2*rhsq[rhsId2+5] + saab3*rhsq[rhsId3+5];
      }
    }

    // make sure all node data is loaded into @shared
    @barrier("local");

    for(int n=0;n<p_maxNodes;++n;@inner(0)){

      // Update q
      if(n<p_Np){

        const int id = p_Nfields*(e*p_Np + n);
        #pragma unroll p_Nfields
        for (int fld = 0; fld < p_Nfields; ++fld){
          q[id+fld]   = s_q[p_Nfields*n+fld];
        } 

      }

      if(n<p_Nfaces*p_Nfp){

        const int iid  = e*p_Nfp*p_Nfaces + n;
        const int qidM = p_Nfields*(vmapM[iid]-e*p_Np);
        const int qid  = p_Nfields*iid; 
         #pragma unroll p_Nfields
         for (int fld = 0; fld < p_Nfields; ++fld){
          fQM[qid+fld] = s_q[qidM+fld];  
        }   
      }

    }

  }
}





@kernel void boltzmannMRABPmlUpdate2D(const int pmlNelements,
               @restrict const  int   *  pmlElementIds,
               @restrict const  int   *  pmlIds,
               const dfloat dt,  
               const dfloat a1,
               const dfloat a2,
               const dfloat a3,
               const int   shift,
               @restrict const  int   *  vmapM,
               @restrict const  dfloat *  rhsq, 
               @restrict const  dfloat *  pmlrhsqx,
               @restrict const  dfloat *  pmlrhsqy,
                     @restrict dfloat *  q,
                     @restrict dfloat *  pmlqx,
                     @restrict dfloat *  pmlqy,
                     @restrict dfloat *  fQM){
  // Low storage Runge Kutta time step update
  for(int es=0;es<pmlNelements;++es;@outer(0)){
    @shared dfloat s_q[p_Np*p_Nfields];
    @exclusive int e;
    for(int n=0; n < p_maxNodes; ++n; @inner(0)){
     e = pmlElementIds[es];
      if (n < p_Np){

        const int pmlId = pmlIds[es];
        const int id  = p_Nfields*(e*p_Np + n);
        const int pid = p_Nfields*(pmlId*p_Np + n);

        const int rhsId1 = 3*id + ((shift+0)%3)*p_Nfields;
        const int rhsId2 = 3*id + ((shift+2)%3)*p_Nfields;
        const int rhsId3 = 3*id + ((shift+1)%3)*p_Nfields;

        const int pmlrhsId1 = 3*pid + ((shift+0)%3)*p_Nfields;
        const int pmlrhsId2 = 3*pid + ((shift+2)%3)*p_Nfields;
        const int pmlrhsId3 = 3*pid + ((shift+1)%3)*p_Nfields;
        //
        #pragma unroll p_Nfields
        for(int fld=0; fld< p_Nfields; ++fld){

          pmlqx[pid+fld] += dt*(a1*pmlrhsqx[pmlrhsId1+fld] + a2*pmlrhsqx[pmlrhsId2+fld] + a3*pmlrhsqx[pmlrhsId3+fld]);
          pmlqy[pid+fld] += dt*(a1*pmlrhsqy[pmlrhsId1+fld] + a2*pmlrhsqy[pmlrhsId2+fld] + a3*pmlrhsqy[pmlrhsId3+fld]);
          
          dfloat n_q      = q[id+fld] + dt*(a1*rhsq[rhsId1+fld] + a2*rhsq[rhsId2+fld] + a3*rhsq[rhsId3+fld]);
          
          s_q[p_Nfields*n+fld] = n_q;
          q[id+fld]            = n_q;
         }
      }
    }


    @barrier("local");

    for(int n=0;n<p_maxNodes;++n;@inner(0)){
      if(n<p_Nfaces*p_Nfp){

        const int iid  = e*p_Nfp*p_Nfaces + n;
        const int qidM = p_Nfields*(vmapM[iid]-e*p_Np);
        const int qid  = p_Nfields*iid; 
        
        #pragma unroll p_Nfields
        for (int fld = 0; fld < p_Nfields; ++fld){
          fQM[qid+fld] = s_q[qidM+fld];
        }   
      }

    }
      
  }
}


@kernel void boltzmannMRSAABPmlUpdate2D(const int pmlNelements,
               @restrict const  int   *  pmlElementIds,
               @restrict const  int   *  pmlIds,
               const dfloat expdt,  
               const dfloat ab1,
               const dfloat ab2,
               const dfloat ab3,
               const dfloat saab1,
               const dfloat saab2,
               const dfloat saab3,
               const int   shift,
               @restrict const  int   *  vmapM,
               @restrict const  dfloat *  rhsq, 
               @restrict const  dfloat *  pmlrhsqx,
               @restrict const  dfloat *  pmlrhsqy,
                     @restrict dfloat *  q,
                     @restrict dfloat *  pmlqx,
                     @restrict dfloat *  pmlqy,
                     @restrict dfloat *  fQM){
  // Low storage Runge Kutta time step update
  for(int es=0;es<pmlNelements;++es;@outer(0)){
    @shared dfloat s_q[p_Np*p_Nfields];
    @exclusive int e;
    for(int n=0; n < p_maxNodes; ++n; @inner(0)){
     e = pmlElementIds[es];
      if (n < p_Np){

        const int pmlId = pmlIds[es];
        const int id  = p_Nfields*(e*p_Np + n);
        const int pid = p_Nfields*(pmlId*p_Np + n);

        const int rhsId1 = 3*id + ((shift+0)%3)*p_Nfields;
        const int rhsId2 = 3*id + ((shift+2)%3)*p_Nfields;
        const int rhsId3 = 3*id + ((shift+1)%3)*p_Nfields;

        const int pmlrhsId1 = 3*pid + ((shift+0)%3)*p_Nfields;
        const int pmlrhsId2 = 3*pid + ((shift+2)%3)*p_Nfields;
        const int pmlrhsId3 = 3*pid + ((shift+1)%3)*p_Nfields;
        //
        #pragma unroll p_Nfields
         for(int fld=0; fld<p_Nfields; ++fld){

          pmlqx[pid+fld] += ab1*pmlrhsqx[pmlrhsId1+fld] + ab2*pmlrhsqx[pmlrhsId2+fld] + ab3*pmlrhsqx[pmlrhsId3+fld];
          pmlqy[pid+fld] += ab1*pmlrhsqy[pmlrhsId1+fld] + ab2*pmlrhsqy[pmlrhsId2+fld] + ab3*pmlrhsqy[pmlrhsId3+fld];

          dfloat n_q = 0.f; 

          if(fld<3)
            n_q      = q[id+fld]+ab1*rhsq[rhsId1+fld]+ab2*rhsq[rhsId2+fld]+ab3*rhsq[rhsId3+fld];
          else
            n_q      = expdt*q[id+fld]+saab1*rhsq[rhsId1+fld] + saab2*rhsq[rhsId2+fld] + saab3*rhsq[rhsId3+fld];
          //          
          s_q[p_Nfields*n+fld] = n_q;
          q[id+fld]            = n_q;
         }
      }
    }


    @barrier("local");

    for(int n=0;n<p_maxNodes;++n;@inner(0)){
      if(n<p_Nfaces*p_Nfp){

        const int iid  = e*p_Nfp*p_Nfaces + n;
        const int qidM = p_Nfields*(vmapM[iid]-e*p_Np);
        const int qid  = p_Nfields*iid; 
        #pragma unroll p_Nfields
         for (int fld = 0; fld < p_Nfields; ++fld){
          fQM[qid+fld] = s_q[qidM+fld];
        }   
      }

    }
      
  }
}

// This @kernel does not use float4 format, 
@kernel void boltzmannMRABTraceUpdate2D(const int Nelements,
            @restrict const  int *  elementIds,
            const dfloat dt,  
            const dfloat a1,
            const dfloat a2,
            const dfloat a3,
            const int   shift,
            @restrict const  int   *  vmapM,
            @restrict const  dfloat *  rhsq,
                  @restrict dfloat *  fQM,
            @restrict const  dfloat *  q){
  
  // Low storage Runge Kutta time step update
  for(int es=0;es<Nelements;++es;@outer(0)){

    @shared dfloat s_q[p_Np*p_Nfields];
    @exclusive int e; 

    for(int n=0;n<p_maxNodes;++n;@inner(0)){
      e  = elementIds[es];
      if(n<p_Np){
        const int id = p_Nfields*(n + e*p_Np);

        // hard-coded for 3th order
        const int rhsId1 = 3*id + ((shift+0)%3)*p_Nfields;
        const int rhsId2 = 3*id + ((shift+2)%3)*p_Nfields;
        const int rhsId3 = 3*id + ((shift+1)%3)*p_Nfields;
        
        #pragma unroll p_Nfields
          for(int fld=0; fld< p_Nfields; ++fld){
          s_q[p_Nfields*n+fld] = q[id+fld] + dt*(a1*rhsq[rhsId1+fld] + a2*rhsq[rhsId2+fld] + a3*rhsq[rhsId3+fld]);
          }
      }
    }

    // make sure all node data is loaded into @shared
    @barrier("local");

    for(int n=0;n<p_maxNodes;++n;@inner(0)){
      if(n<p_Nfaces*p_Nfp){

        const int iid  = e*p_Nfp*p_Nfaces + n;
        const int qidM = p_Nfields*(vmapM[iid]-e*p_Np);
        const int qid  = p_Nfields*iid; 
        
         #pragma unroll p_Nfields
         for (int fld = 0; fld < p_Nfields; ++fld){
          fQM[qid+fld] = s_q[qidM+fld];  
        }   
      }

    }

  }
}


// This @kernel does not use float4 format, 
@kernel void boltzmannMRSAABTraceUpdate2D(const int Nelements,
            @restrict const  int *  elementIds,
            const dfloat expdt, 
            const dfloat ab1,
            const dfloat ab2,
            const dfloat ab3,
            const dfloat saab1,
            const dfloat saab2,
            const dfloat saab3,
            const int   shift,
            @restrict const  int   *  vmapM,
            @restrict const  dfloat *  rhsq,
                  @restrict dfloat *  fQM,
            @restrict const  dfloat *  q){
  
  // Low storage Runge Kutta time step update
  for(int es=0;es<Nelements;++es;@outer(0)){

    @shared dfloat s_q[p_Np*p_Nfields];
    @exclusive int e; 

    for(int n=0;n<p_maxNodes;++n;@inner(0)){
      e  = elementIds[es];
      if(n<p_Np){
        const int id = p_Nfields*(n + e*p_Np);

        // hard-coded for 3th order
        const int rhsId1 = 3*id + ((shift+0)%3)*p_Nfields;
        const int rhsId2 = 3*id + ((shift+2)%3)*p_Nfields;
        const int rhsId3 = 3*id + ((shift+1)%3)*p_Nfields;
       
        #pragma unroll p_Nfields
          for(int fld=0; fld< p_Nfields; ++fld){
            if(fld<3)
              s_q[p_Nfields*n+fld] = q[id+fld]+ab1*rhsq[rhsId1+fld]+ab2*rhsq[rhsId2+fld]+ab3*rhsq[rhsId3+fld];
            else
              s_q[p_Nfields*n+fld] = expdt*q[id+fld] + saab1*rhsq[rhsId1+fld] + saab2*rhsq[rhsId2+fld] + saab3*rhsq[rhsId3+fld];
          }
      }
    }

    // make sure all node data is loaded into @shared
    @barrier("local");

    for(int n=0;n<p_maxNodes;++n;@inner(0)){
      if(n<p_Nfaces*p_Nfp){

        const int iid  = e*p_Nfp*p_Nfaces + n;
        const int qidM = p_Nfields*(vmapM[iid]-e*p_Np);
        const int qid  = p_Nfields*iid; 
        
        #pragma unroll p_Nfields
         for (int fld = 0; fld < p_Nfields; ++fld){
          fQM[qid+fld] = s_q[qidM+fld];  
        }   
      }

    }

  }
}

@kernel void boltzmannMRABPmlTraceUpdate2D(const int pmlNelements,
               @restrict const  int   *  pmlElementIds,
               @restrict const  int   *  pmlIds,
               const dfloat dt,  
               const dfloat a1,
               const dfloat a2,
               const dfloat a3,
               const int   shift,
               @restrict const  int   *  vmapM,
               @restrict const  dfloat *  rhsq, 
               @restrict const  dfloat *  pmlrhsqx,
               @restrict const  dfloat *  pmlrhsqy,
               @restrict const  dfloat *  q,
               @restrict const  dfloat *  pmlqx,
               @restrict const  dfloat *  pmlqy,
                     @restrict dfloat *  fQM){
  // Low storage Runge Kutta time step update
  for(int es=0;es<pmlNelements;++es;@outer(0)){
    @shared dfloat s_q[p_Np*p_Nfields];
    @exclusive int e;
    for(int n=0; n < p_maxNodes; ++n; @inner(0)){
     e = pmlElementIds[es];
      if (n < p_Np){
        // const int pmlId = pmlIds[es];
        const int id  = p_Nfields*(e*p_Np + n);
        // const int pid = p_Nfields*(pmlId*p_Np + n);

        const int rhsId1 = 3*id + ((shift+0)%3)*p_Nfields;
        const int rhsId2 = 3*id + ((shift+2)%3)*p_Nfields;
        const int rhsId3 = 3*id + ((shift+1)%3)*p_Nfields;
        //
        #pragma unroll p_Nfields
         for(int fld=0; fld< p_Nfields; ++fld){      
          s_q[p_Nfields*n+fld] = q[id+fld] + dt*(a1*rhsq[rhsId1+fld] + a2*rhsq[rhsId2+fld] + a3*rhsq[rhsId3+fld]);
         }
      }
    }

    @barrier("local");

    for(int n=0;n<p_maxNodes;++n;@inner(0)){
      if(n<p_Nfaces*p_Nfp){

        const int iid  = e*p_Nfp*p_Nfaces + n;
        const int qidM = p_Nfields*(vmapM[iid]-e*p_Np);
        const int qid  = p_Nfields*iid; 
        
        #pragma unroll p_Nfields
         for (int fld = 0; fld < p_Nfields; ++fld){
          fQM[qid+fld] = s_q[qidM+fld];
        }   
      }

    }
      
  }
}





@kernel void boltzmannMRSAABPmlTraceUpdate2D(const int pmlNelements,
                      @restrict const  int   *  pmlElementIds,
                      @restrict const  int   *  pmlIds,
                      const dfloat expdt, 
                      const dfloat ab1,
                      const dfloat ab2,
                      const dfloat ab3,
                      const dfloat saab1,
                      const dfloat saab2,
                      const dfloat saab3,
                      const int   shift,
                      @restrict const  int   *  vmapM,
                      @restrict const  dfloat *  rhsq, 
                      @restrict const  dfloat *  pmlrhsqx,
                      @restrict const  dfloat *  pmlrhsqy,
                      @restrict const  dfloat *  q,
                      @restrict const  dfloat *  pmlqx,
                      @restrict const  dfloat *  pmlqy,
                            @restrict dfloat *  fQM){
  // Low storage Runge Kutta time step update
  for(int es=0;es<pmlNelements;++es;@outer(0)){
    @shared dfloat s_q[p_Np*p_Nfields];
    @exclusive int e;
    for(int n=0; n < p_maxNodes; ++n; @inner(0)){
     e = pmlElementIds[es];
      if (n < p_Np){
        // const int pmlId = pmlIds[es];
        const int id  = p_Nfields*(e*p_Np + n);
        // const int pid = p_Nfields*(pmlId*p_Np + n);

        const int rhsId1 = 3*id + ((shift+0)%3)*p_Nfields;
        const int rhsId2 = 3*id + ((shift+2)%3)*p_Nfields;
        const int rhsId3 = 3*id + ((shift+1)%3)*p_Nfields;
       
        #pragma unroll p_Nfields
          for(int fld=0; fld< p_Nfields; ++fld){
            if(fld<3)
              s_q[p_Nfields*n+fld] = q[id+fld]+ab1*rhsq[rhsId1+fld]+ab2*rhsq[rhsId2+fld]+ab3*rhsq[rhsId3+fld];
            else
              s_q[p_Nfields*n+fld] = expdt*q[id+fld]+saab1*rhsq[rhsId1+fld] + saab2*rhsq[rhsId2+fld] + saab3*rhsq[rhsId3+fld];
          }
      }
    }

    @barrier("local");

    for(int n=0;n<p_maxNodes;++n;@inner(0)){
      if(n<p_Nfaces*p_Nfp){

        const int iid  = e*p_Nfp*p_Nfaces + n;
        const int qidM = p_Nfields*(vmapM[iid]-e*p_Np);
        const int qid  = p_Nfields*iid; 

        #pragma unroll p_Nfields
         for (int fld = 0; fld < p_Nfields; ++fld){
          fQM[qid+fld] = s_q[qidM+fld];
        }   
      }

    }
      
  }
}



// @kernel void boltzmannSARK3StageUpdate2D(const int Nelements,
//             @restrict const  int *  elementIds,
//             const dfloat dt, 
//             const dfloat expdt, 
//             const dfloat rka,
//             const dfloat erka,
//             const dfloat rkb,
//             const dfloat erkb,
//             @restrict const  dfloat4 *  rhsq1,
//             @restrict const  dfloat4 *  rhsq2,
//             @restrict const  dfloat4 *  qold,
//                   @restrict dfloat4 *  q){
  
//   // Low storage Runge Kutta time step update
//   for(int e=0;e<Nelements;++e;@outer(0)){
//     for(int n=0;n<p_Np;++n;@inner(0)){
//       const int element = elementIds[e];
//       const int base = 2*(n + element*p_Np);

//       dfloat4 rhsq1a = rhsq1[base+0];
//       dfloat4 rhsq1b = rhsq1[base+1];

//       dfloat4 rhsq2a = rhsq2[base+0];
//       dfloat4 rhsq2b = rhsq2[base+1];


//       dfloat4 qoa = qold[base+0];
//       dfloat4 qob = qold[base+1];
      
//       //
//       dfloat4 qa, qb;
//       qa.x   = qoa.x + dt*( rka* rhsq1a.x + rkb* rhsq2a.x ); // + rkc* rhsq3a.x );
//       qa.y   = qoa.y + dt*( rka* rhsq1a.y + rkb* rhsq2a.y ); // + rkc* rhsq3a.y );
//       qa.z   = qoa.z + dt*( rka* rhsq1a.z + rkb* rhsq2a.z ); //+ rkc* rhsq3a.z );
      
//       //
//       qa.w  = expdt*qoa.w  + dt*( erka*rhsq1a.w + erkb*rhsq2a.w); // +erkc*rhsq3a.w );
//       qb.x  = expdt*qob.x  + dt*( erka*rhsq1b.x + erkb*rhsq2b.x); //+erkc*rhsq3b.x );
//       qb.y  = expdt*qob.y  + dt*( erka*rhsq1b.y + erkb*rhsq2b.y);//+erkc*rhsq3b.y );
      
//       q[base+0] = qa;
//       q[base+1] = qb;

//     }
//   }
// }


// @kernel void boltzmannSARK3PmlStageUpdate2D(const int Nelements,
//               @restrict const  int *  elementIds, 
//               const dfloat dt,  
//               const dfloat expdt, 
//               const dfloat rka,
//               const dfloat erka,
//               const dfloat rkb,
//               const dfloat erkb,
//               const dfloat ramp, 
//               @restrict const  dfloat4 *  rhsq1,
//               @restrict const  dfloat *  rhsqx1,
//               @restrict const  dfloat *  rhsqy1,
//               @restrict const  dfloat4 *  rhsq2, 
//               @restrict const  dfloat *  rhsqx2,
//               @restrict const  dfloat *  rhsqy2,
//               @restrict const  dfloat4 *  qold,
//               @restrict const  dfloat *  qxold,
//               @restrict const  dfloat *  qyold,
//                     @restrict dfloat *  qx,
//                     @restrict dfloat *  qy,
//                     @restrict dfloat4 *  q){
//   for(int e=0;e<Nelements;++e;@outer(0)){
//     for(int n=0;n<p_Np;++n;@inner(0)){

//       const int element = elementIds[e];
//       const int base = n + element*p_Nfields*p_Np;


//       dfloat rhsqx11 = rhsqx1[base+0*p_Np];
//       dfloat rhsqx12 = rhsqx1[base+1*p_Np];
//       dfloat rhsqx13 = rhsqx1[base+2*p_Np];
//       dfloat rhsqx14 = rhsqx1[base+3*p_Np];
//       dfloat rhsqx15 = rhsqx1[base+4*p_Np];
//       dfloat rhsqx16 = rhsqx1[base+5*p_Np];

//       dfloat rhsqy11 = rhsqy1[base+0*p_Np];
//       dfloat rhsqy12 = rhsqy1[base+1*p_Np];
//       dfloat rhsqy13 = rhsqy1[base+2*p_Np];
//       dfloat rhsqy14 = rhsqy1[base+3*p_Np];
//       dfloat rhsqy15 = rhsqy1[base+4*p_Np];
//       dfloat rhsqy16 = rhsqy1[base+5*p_Np];
      
//       //
//       dfloat rhsqx21 = rhsqx2[base+0*p_Np];
//       dfloat rhsqx22 = rhsqx2[base+1*p_Np];
//       dfloat rhsqx23 = rhsqx2[base+2*p_Np];
//       dfloat rhsqx24 = rhsqx2[base+3*p_Np];
//       dfloat rhsqx25 = rhsqx2[base+4*p_Np];
//       dfloat rhsqx26 = rhsqx2[base+5*p_Np];

//       dfloat rhsqy21 = rhsqy2[base+0*p_Np];
//       dfloat rhsqy22 = rhsqy2[base+1*p_Np];
//       dfloat rhsqy23 = rhsqy2[base+2*p_Np];
//       dfloat rhsqy24 = rhsqy2[base+3*p_Np];
//       dfloat rhsqy25 = rhsqy2[base+4*p_Np];
//       dfloat rhsqy26 = rhsqy2[base+5*p_Np];
//       //
//       dfloat qxold1 = qxold[base+0*p_Np];
//       dfloat qxold2 = qxold[base+1*p_Np];
//       dfloat qxold3 = qxold[base+2*p_Np];
//       dfloat qxold4 = qxold[base+3*p_Np];
//       dfloat qxold5 = qxold[base+4*p_Np];
//       dfloat qxold6 = qxold[base+5*p_Np];

//       dfloat qyold1 = qyold[base+0*p_Np];
//       dfloat qyold2 = qyold[base+1*p_Np];
//       dfloat qyold3 = qyold[base+2*p_Np];
//       dfloat qyold4 = qyold[base+3*p_Np];
//       dfloat qyold5 = qyold[base+4*p_Np];
//       dfloat qyold6 = qyold[base+5*p_Np];


//       //
//       dfloat qx1 = qxold1 + dt*( rka*rhsqx11 + rkb*rhsqx21);
//       dfloat qx2 = qxold2 + dt*( rka*rhsqx12 + rkb*rhsqx22);
//       dfloat qx3 = qxold3 + dt*( rka*rhsqx13 + rkb*rhsqx23);
//       dfloat qx4 = qxold4 + dt*( rka*rhsqx14 + rkb*rhsqx24);
//       dfloat qx5 = qxold5 + dt*( rka*rhsqx15 + rkb*rhsqx25);
//       dfloat qx6 = qxold6 + dt*( rka*rhsqx16 + rkb*rhsqx26);
          
//       // 
//       dfloat qy1 = qyold1 + dt*(  rka*rhsqy11 +  rkb*rhsqy21);
//       dfloat qy2 = qyold2 + dt*(  rka*rhsqy12 +  rkb*rhsqy22);
//       dfloat qy3 = qyold3 + dt*(  rka*rhsqy13 +  rkb*rhsqy23);
//       dfloat qy4 = qyold4 + dt*(  rka*rhsqy14 +  rkb*rhsqy24);
//       dfloat qy5 = qyold5 + dt*(  rka*rhsqy15 +  rkb*rhsqy25);
//       dfloat qy6 = qyold6 + dt*(  rka*rhsqy16 +  rkb*rhsqy26);
      
//       //
//       qx[base+0*p_Np] = qx1;
//       qx[base+1*p_Np] = qx2;
//       qx[base+2*p_Np] = qx3;
//       qx[base+3*p_Np] = qx4;
//       qx[base+4*p_Np] = qx5;
//       qx[base+5*p_Np] = qx6;

//       qy[base+0*p_Np] = qy1;
//       qy[base+1*p_Np] = qy2;
//       qy[base+2*p_Np] = qy3;
//       qy[base+3*p_Np] = qy4;
//       qy[base+4*p_Np] = qy5;
//       qy[base+5*p_Np] = qy6;

//       //
//       const int id = 2*(n + element*p_Np);

//       dfloat4 rhsq1a = rhsq1[id+0];
//       dfloat4 rhsq1b = rhsq1[id+1];

//       dfloat4 rhsq2a = rhsq2[id+0];
//       dfloat4 rhsq2b = rhsq2[id+1];
//       //
//       dfloat4 qoa    = qold[id+0];
//       dfloat4 qob    = qold[id+1];

//  //
//       dfloat4 qa, qb;
//       qa.x   = qoa.x + dt*( rka* rhsq1a.x + rkb* rhsq2a.x ); 
//       qa.y   = qoa.y + dt*( rka* rhsq1a.y + rkb* rhsq2a.y ); 
//       qa.z   = qoa.z + dt*( rka* rhsq1a.z + rkb* rhsq2a.z ); 
      
//       //
//       qa.w  = expdt*qoa.w  + dt*( erka*rhsq1a.w + erkb*rhsq2a.w); 
//       qb.x  = expdt*qob.x  + dt*( erka*rhsq1b.x + erkb*rhsq2b.x); 
//       qb.y  = expdt*qob.y  + dt*( erka*rhsq1b.y + erkb*rhsq2b.y);
      
//       q[id+0] = qa;
//       q[id+1] = qb;
      
     
//     }
//   }
// }




// @kernel void boltzmannSARK3Update2D(const int Nelements,
//             @restrict const  int *  elementIds,
//             const dfloat dt, 
//             const dfloat expdt, 
//             const dfloat rka,
//             const dfloat erka,
//             const dfloat rkb,
//             const dfloat erkb,
//             const dfloat rkc,
//             const dfloat erkc,
//             @restrict const  dfloat4 *  rhsq1,
//             @restrict const  dfloat4 *  rhsq2,
//             @restrict const  dfloat4 *  rhsq3,
//                   @restrict dfloat4 *  qold,
//                   @restrict dfloat4 *  q){
  
//   // Low storage Runge Kutta time step update
//   for(int e=0;e<Nelements;++e;@outer(0)){
//     for(int n=0;n<p_Np;++n;@inner(0)){
//       const int element = elementIds[e];
//       const int base = 2*(n + element*p_Np);
//       //
//       dfloat4 rhsq1a = rhsq1[base+0];
//       dfloat4 rhsq1b = rhsq1[base+1];
//       //
//       dfloat4 rhsq2a = rhsq2[base+0];
//       dfloat4 rhsq2b = rhsq2[base+1];
//       //
//       dfloat4 rhsq3a = rhsq3[base+0];
//       dfloat4 rhsq3b = rhsq3[base+1];
//       //    
//       dfloat4 qoa = qold[base+0];
//       dfloat4 qob = qold[base+1];
      
//       dfloat4 qa, qb; 
//       qa.x   = qoa.x + dt*( rka* rhsq1a.x + rkb* rhsq2a.x + rkc* rhsq3a.x );
//       qa.y   = qoa.y + dt*( rka* rhsq1a.y + rkb* rhsq2a.y + rkc* rhsq3a.y );
//       qa.z   = qoa.z + dt*( rka* rhsq1a.z + rkb* rhsq2a.z + rkc* rhsq3a.z );
//       //
//       qa.w  = expdt*qoa.w  + dt*( erka*rhsq1a.w + erkb*rhsq2a.w +erkc*rhsq3a.w );
//       qb.x  = expdt*qob.x  + dt*( erka*rhsq1b.x + erkb*rhsq2b.x +erkc*rhsq3b.x );
//       qb.y  = expdt*qob.y  + dt*( erka*rhsq1b.y + erkb*rhsq2b.y +erkc*rhsq3b.y );
      
//       q[base+0] = qa;
//       q[base+1] = qb;
//       //
//       qold[base+0] = qa;
//       qold[base+1] = qb;


//     }
//   }
// }



// @kernel void boltzmannSARK3PmlUpdate2D(const int Nelements,
//               @restrict const  int *  elementIds, 
//               const dfloat dt,  
//               const dfloat expdt, 
//               const dfloat rka,
//               const dfloat erka,
//               const dfloat rkb,
//               const dfloat erkb,
//               const dfloat rkc,
//               const dfloat erkc,
//               const dfloat ramp, 
//               @restrict const  dfloat4 *  rhsq1,
//               @restrict const  dfloat *  rhsqx1,
//               @restrict const  dfloat *  rhsqy1, 
//               @restrict const  dfloat4 *  rhsq2,
//               @restrict const  dfloat *  rhsqx2,
//               @restrict const  dfloat *  rhsqy2,
//               @restrict const  dfloat4 *  rhsq3,
//               @restrict const  dfloat *  rhsqx3,
//               @restrict const  dfloat *  rhsqy3,
//                     @restrict dfloat4 *  qold, 
//                     @restrict dfloat *  qxold,
//                     @restrict dfloat *  qyold,
//                     @restrict dfloat *  qx,
//                     @restrict dfloat *  qy,
//                     @restrict dfloat4 *  q){
  
//   // Low storage Runge Kutta time step update
//   for(int e=0;e<Nelements;++e;@outer(0)){
//     for(int n=0;n<p_Np;++n;@inner(0)){

//       const int element = elementIds[e];
//       const int base = n + element*p_Nfields*p_Np;


//       dfloat rhsqx11 = rhsqx1[base+0*p_Np];
//       dfloat rhsqx12 = rhsqx1[base+1*p_Np];
//       dfloat rhsqx13 = rhsqx1[base+2*p_Np];
//       dfloat rhsqx14 = rhsqx1[base+3*p_Np];
//       dfloat rhsqx15 = rhsqx1[base+4*p_Np];
//       dfloat rhsqx16 = rhsqx1[base+5*p_Np];

//       dfloat rhsqy11 = rhsqy1[base+0*p_Np];
//       dfloat rhsqy12 = rhsqy1[base+1*p_Np];
//       dfloat rhsqy13 = rhsqy1[base+2*p_Np];
//       dfloat rhsqy14 = rhsqy1[base+3*p_Np];
//       dfloat rhsqy15 = rhsqy1[base+4*p_Np];
//       dfloat rhsqy16 = rhsqy1[base+5*p_Np];

//       //
//       dfloat rhsqx21 = rhsqx2[base+0*p_Np];
//       dfloat rhsqx22 = rhsqx2[base+1*p_Np];
//       dfloat rhsqx23 = rhsqx2[base+2*p_Np];
//       dfloat rhsqx24 = rhsqx2[base+3*p_Np];
//       dfloat rhsqx25 = rhsqx2[base+4*p_Np];
//       dfloat rhsqx26 = rhsqx2[base+5*p_Np];

//       dfloat rhsqy21 = rhsqy2[base+0*p_Np];
//       dfloat rhsqy22 = rhsqy2[base+1*p_Np];
//       dfloat rhsqy23 = rhsqy2[base+2*p_Np];
//       dfloat rhsqy24 = rhsqy2[base+3*p_Np];
//       dfloat rhsqy25 = rhsqy2[base+4*p_Np];
//       dfloat rhsqy26 = rhsqy2[base+5*p_Np];

//       //
//       dfloat rhsqx31 = rhsqx3[base+0*p_Np];
//       dfloat rhsqx32 = rhsqx3[base+1*p_Np];
//       dfloat rhsqx33 = rhsqx3[base+2*p_Np];
//       dfloat rhsqx34 = rhsqx3[base+3*p_Np];
//       dfloat rhsqx35 = rhsqx3[base+4*p_Np];
//       dfloat rhsqx36 = rhsqx3[base+5*p_Np];

//       dfloat rhsqy31 = rhsqy3[base+0*p_Np];
//       dfloat rhsqy32 = rhsqy3[base+1*p_Np];
//       dfloat rhsqy33 = rhsqy3[base+2*p_Np];
//       dfloat rhsqy34 = rhsqy3[base+3*p_Np];
//       dfloat rhsqy35 = rhsqy3[base+4*p_Np];
//       dfloat rhsqy36 = rhsqy3[base+5*p_Np];

      
//       //
//       dfloat qxold1 = qxold[base+0*p_Np];
//       dfloat qxold2 = qxold[base+1*p_Np];
//       dfloat qxold3 = qxold[base+2*p_Np];
//       dfloat qxold4 = qxold[base+3*p_Np];
//       dfloat qxold5 = qxold[base+4*p_Np];
//       dfloat qxold6 = qxold[base+5*p_Np];

//       dfloat qyold1 = qyold[base+0*p_Np];
//       dfloat qyold2 = qyold[base+1*p_Np];
//       dfloat qyold3 = qyold[base+2*p_Np];
//       dfloat qyold4 = qyold[base+3*p_Np];
//       dfloat qyold5 = qyold[base+4*p_Np];
//       dfloat qyold6 = qyold[base+5*p_Np];

//       //
//       dfloat qx1 = qxold1 + dt*( rka*rhsqx11 + rkb*rhsqx21 + rkc*rhsqx31);
//       dfloat qx2 = qxold2 + dt*( rka*rhsqx12 + rkb*rhsqx22 + rkc*rhsqx32);
//       dfloat qx3 = qxold3 + dt*( rka*rhsqx13 + rkb*rhsqx23 + rkc*rhsqx33);
//       dfloat qx4 = qxold4 + dt*( rka*rhsqx14 + rkb*rhsqx24 + rkc*rhsqx34);
//       dfloat qx5 = qxold5 + dt*( rka*rhsqx15 + rkb*rhsqx25 + rkc*rhsqx35);
//       dfloat qx6 = qxold6 + dt*( rka*rhsqx16 + rkb*rhsqx26 + rkc*rhsqx36);
      
//       // //
//       dfloat qy1 = qyold1 + dt*( rka*rhsqy11 + rkb*rhsqy21 + rkc*rhsqy31);
//       dfloat qy2 = qyold2 + dt*( rka*rhsqy12 + rkb*rhsqy22 + rkc*rhsqy32);
//       dfloat qy3 = qyold3 + dt*( rka*rhsqy13 + rkb*rhsqy23 + rkc*rhsqy33);
//       dfloat qy4 = qyold4 + dt*( rka*rhsqy14 + rkb*rhsqy24 + rkc*rhsqy34);
//       dfloat qy5 = qyold5 + dt*( rka*rhsqy15 + rkb*rhsqy25 + rkc*rhsqy35);
//       dfloat qy6 = qyold6 + dt*( rka*rhsqy16 + rkb*rhsqy26 + rkc*rhsqy36);
//       //
//       qx[base+0*p_Np] = qx1;
//       qx[base+1*p_Np] = qx2;
//       qx[base+2*p_Np] = qx3;
//       qx[base+3*p_Np] = qx4;
//       qx[base+4*p_Np] = qx5;
//       qx[base+5*p_Np] = qx6;

//       qy[base+0*p_Np] = qy1;
//       qy[base+1*p_Np] = qy2;
//       qy[base+2*p_Np] = qy3;
//       qy[base+3*p_Np] = qy4;
//       qy[base+4*p_Np] = qy5;
//       qy[base+5*p_Np] = qy6;
//       //
//       qxold[base+0*p_Np] = qx1;
//       qxold[base+1*p_Np] = qx2;
//       qxold[base+2*p_Np] = qx3;
//       qxold[base+3*p_Np] = qx4;
//       qxold[base+4*p_Np] = qx5;
//       qxold[base+5*p_Np] = qx6;

//       qyold[base+0*p_Np] = qy1;
//       qyold[base+1*p_Np] = qy2;
//       qyold[base+2*p_Np] = qy3;
//       qyold[base+3*p_Np] = qy4;
//       qyold[base+4*p_Np] = qy5;
//       qyold[base+5*p_Np] = qy6;
//       //

//       const int id = 2*(n + element*p_Np);
//       //
//       dfloat4 rhsq1a = rhsq1[id+0];
//       dfloat4 rhsq1b = rhsq1[id+1];
//       //
//       dfloat4 rhsq2a = rhsq2[id+0];
//       dfloat4 rhsq2b = rhsq2[id+1];
//       //
//       dfloat4 rhsq3a = rhsq3[id+0];
//       dfloat4 rhsq3b = rhsq3[id+1];
//       //    
//       dfloat4 qoa = qold[id+0];
//       dfloat4 qob = qold[id+1];
      
//       dfloat4 qa, qb; 
//       qa.x   = qoa.x + dt*( rka* rhsq1a.x + rkb* rhsq2a.x + rkc* rhsq3a.x );
//       qa.y   = qoa.y + dt*( rka* rhsq1a.y + rkb* rhsq2a.y + rkc* rhsq3a.y );
//       qa.z   = qoa.z + dt*( rka* rhsq1a.z + rkb* rhsq2a.z + rkc* rhsq3a.z );
//       //
//       qa.w  = expdt*qoa.w  + dt*( erka*rhsq1a.w + erkb*rhsq2a.w +erkc*rhsq3a.w );
//       qb.x  = expdt*qob.x  + dt*( erka*rhsq1b.x + erkb*rhsq2b.x +erkc*rhsq3b.x );
//       qb.y  = expdt*qob.y  + dt*( erka*rhsq1b.y + erkb*rhsq2b.y +erkc*rhsq3b.y );
      
//       q[id+0] = qa;
//       q[id+1] = qb;
//       //
//       qold[id+0] = qa;
//       qold[id+1] = qb;


      

//       //

//     }
//   }
// }








// @kernel void boltzmannSAAB3Update2D(const int Nelements,
//             @restrict const  int *  elementIds,
//             const dfloat dt, 
//             const dfloat expdt, 
//             const dfloat ab1,
//             const dfloat ab2,
//             const dfloat ab3,
//             const dfloat saab1,
//             const dfloat saab2,
//             const dfloat saab3,
//                   @restrict dfloat4 *  rhsq3,
//                   @restrict dfloat4 *  rhsq2,
//                   @restrict dfloat4 *  rhsq1,
//                   @restrict dfloat4 *  q){
  
//   // Low storage Runge Kutta time step update
//   for(int e=0;e<Nelements;++e;@outer(0)){
//     for(int n=0;n<p_Np;++n;@inner(0)){
//       const int element = elementIds[e];

//       const int base = 2*(n + element*p_Np);

//       dfloat4 rhsq1a = rhsq1[base+0];
//       dfloat4 rhsq1b = rhsq1[base+1];

//       dfloat4 rhsq2a = rhsq2[base+0];
//       dfloat4 rhsq2b = rhsq2[base+1];

//       dfloat4 rhsq3a = rhsq3[base+0];
//       dfloat4 rhsq3b = rhsq3[base+1];
//       //
//       dfloat4 qa = q[base+0];
//       dfloat4 qb = q[base+1];
//       //
//        //
//       qa.x += ab1*rhsq1a.x +  ab2*rhsq2a.x + ab3*rhsq3a.x;
//       qa.y += ab1*rhsq1a.y +  ab2*rhsq2a.y + ab3*rhsq3a.y;
//       qa.z += ab1*rhsq1a.z +  ab2*rhsq2a.z + ab3*rhsq3a.z;
//       //
//       qa.w  = expdt*qa.w  + saab1*rhsq1a.w +  saab2*rhsq2a.w + saab3*rhsq3a.w;
//       qb.x  = expdt*qb.x  + saab1*rhsq1b.x +  saab2*rhsq2b.x + saab3*rhsq3b.x;
//       qb.y  = expdt*qb.y  + saab1*rhsq1b.y +  saab2*rhsq2b.y + saab3*rhsq3b.y;
//       //           
//       rhsq3[base+0] = rhsq2a;
//       rhsq3[base+1] = rhsq2b;
//       //
//       rhsq2[base+0] = rhsq1a;
//       rhsq2[base+1] = rhsq1b;
//       //
//       q[base+0] = qa;
//       q[base+1] = qb;
//     }
//   }
// }



// @kernel void boltzmannSAAB3PmlUpdate2D(const int Nelements,
//               @restrict const  int *  elementIds, 
//               const dfloat dt,  
//               const dfloat expdt, 
//               const dfloat ramp, 
//               const dfloat ab1,
//               const dfloat ab2,
//               const dfloat ab3,
//               const dfloat saab1,
//               const dfloat saab2,
//               const dfloat saab3,
//               @restrict const  dfloat4 *  rhsq1,
//               @restrict const  dfloat *  rhsqx1,
//               @restrict const  dfloat *  rhsqy1,
//                     @restrict dfloat4 *  rhsq2,  
//                     @restrict dfloat *  rhsqx2,
//                     @restrict dfloat *  rhsqy2,
//                     @restrict dfloat4 *  rhsq3,
//                     @restrict dfloat *  rhsqx3,
//                     @restrict dfloat *  rhsqy3,
//                     @restrict dfloat *  qx,
//                     @restrict dfloat *  qy,
//                     @restrict dfloat4 *  q){
  
//   // Low storage Runge Kutta time step update
//   for(int e=0;e<Nelements;++e;@outer(0)){
//     for(int n=0;n<p_Np;++n;@inner(0)){

//       const int element = elementIds[e];
//       const int base = n + element*p_Nfields*p_Np;
//       const int id1 = base + 0*p_Np;
//       const int id2 = base + 1*p_Np;
//       const int id3 = base + 2*p_Np;
//       const int id4 = base + 3*p_Np;
//       const int id5 = base + 4*p_Np;
//       const int id6 = base + 5*p_Np;


//       dfloat rhsqx11 = rhsqx1[id1];
//       dfloat rhsqx12 = rhsqx1[id2];
//       dfloat rhsqx13 = rhsqx1[id3];
//       dfloat rhsqx14 = rhsqx1[id4];
//       dfloat rhsqx15 = rhsqx1[id5];
//       dfloat rhsqx16 = rhsqx1[id6];

//       dfloat rhsqy11 = rhsqy1[id1];
//       dfloat rhsqy12 = rhsqy1[id2];
//       dfloat rhsqy13 = rhsqy1[id3];
//       dfloat rhsqy14 = rhsqy1[id4];
//       dfloat rhsqy15 = rhsqy1[id5];
//       dfloat rhsqy16 = rhsqy1[id6];

//       //
//       dfloat rhsqx21 = rhsqx2[id1];
//       dfloat rhsqx22 = rhsqx2[id2];
//       dfloat rhsqx23 = rhsqx2[id3];
//       dfloat rhsqx24 = rhsqx2[id4];
//       dfloat rhsqx25 = rhsqx2[id5];
//       dfloat rhsqx26 = rhsqx2[id6];

//       dfloat rhsqy21 = rhsqy2[id1];
//       dfloat rhsqy22 = rhsqy2[id2];
//       dfloat rhsqy23 = rhsqy2[id3];
//       dfloat rhsqy24 = rhsqy2[id4];
//       dfloat rhsqy25 = rhsqy2[id5];
//       dfloat rhsqy26 = rhsqy2[id6];

//       //
//       dfloat rhsqx31 = rhsqx3[id1];
//       dfloat rhsqx32 = rhsqx3[id2];
//       dfloat rhsqx33 = rhsqx3[id3];
//       dfloat rhsqx34 = rhsqx3[id4];
//       dfloat rhsqx35 = rhsqx3[id5];
//       dfloat rhsqx36 = rhsqx3[id6];

//       dfloat rhsqy31 = rhsqy3[id1];
//       dfloat rhsqy32 = rhsqy3[id2];
//       dfloat rhsqy33 = rhsqy3[id3];
//       dfloat rhsqy34 = rhsqy3[id4];
//       dfloat rhsqy35 = rhsqy3[id5];
//       dfloat rhsqy36 = rhsqy3[id6];

//       //
//       qx[id1] += ab1*rhsqx11 + ab2*rhsqx21 + ab3*rhsqx31;
//       qx[id2] += ab1*rhsqx12 + ab2*rhsqx22 + ab3*rhsqx32;
//       qx[id3] += ab1*rhsqx13 + ab2*rhsqx23 + ab3*rhsqx33;
//       qx[id4] += ab1*rhsqx14 + ab2*rhsqx24 + ab3*rhsqx34;
//       qx[id5] += ab1*rhsqx15 + ab2*rhsqx25 + ab3*rhsqx35;
//       qx[id6] += ab1*rhsqx16 + ab2*rhsqx26 + ab3*rhsqx36;

//       qy[id1] += ab1*rhsqy11 + ab2*rhsqy21 + ab3*rhsqy31;
//       qy[id2] += ab1*rhsqy12 + ab2*rhsqy22 + ab3*rhsqy32;
//       qy[id3] += ab1*rhsqy13 + ab2*rhsqy23 + ab3*rhsqy33;
//       qy[id4] += ab1*rhsqy14 + ab2*rhsqy24 + ab3*rhsqy34;
//       qy[id5] += ab1*rhsqy15 + ab2*rhsqy25 + ab3*rhsqy35;
//       qy[id6] += ab1*rhsqy16 + ab2*rhsqy26 + ab3*rhsqy36;
//       //
//       rhsqx2[id1] = rhsqx11;
//       rhsqx2[id2] = rhsqx12;
//       rhsqx2[id3] = rhsqx13;
//       rhsqx2[id4] = rhsqx14;
//       rhsqx2[id5] = rhsqx15;
//       rhsqx2[id6] = rhsqx16;
//       //
//       rhsqx3[id1] = rhsqx21;
//       rhsqx3[id2] = rhsqx22;
//       rhsqx3[id3] = rhsqx23;
//       rhsqx3[id4] = rhsqx24;
//       rhsqx3[id5] = rhsqx25;
//       rhsqx3[id6] = rhsqx26;
//       //
//       //
//       rhsqy2[id1] = rhsqy11;
//       rhsqy2[id2] = rhsqy12;
//       rhsqy2[id3] = rhsqy13;
//       rhsqy2[id4] = rhsqy14;
//       rhsqy2[id5] = rhsqy15;
//       rhsqy2[id6] = rhsqy16;
//       //
//       rhsqy3[id1] = rhsqy21;
//       rhsqy3[id2] = rhsqy22;
//       rhsqy3[id3] = rhsqy23;
//       rhsqy3[id4] = rhsqy24;
//       rhsqy3[id5] = rhsqy25;
//       rhsqy3[id6] = rhsqy26;
//       //
//       const int id = 2*(n + element*p_Np);

//       dfloat4 rhsq1a = rhsq1[id+0];
//       dfloat4 rhsq1b = rhsq1[id+1];

//       dfloat4 rhsq2a = rhsq2[id+0];
//       dfloat4 rhsq2b = rhsq2[id+1];

//       dfloat4 rhsq3a = rhsq3[id+0];
//       dfloat4 rhsq3b = rhsq3[id+1];
//       //
//       dfloat4 qa = q[id+0];
//       dfloat4 qb = q[id+1];
//       //
//       qa.x += ab1*rhsq1a.x +  ab2*rhsq2a.x + ab3*rhsq3a.x;
//       qa.y += ab1*rhsq1a.y +  ab2*rhsq2a.y + ab3*rhsq3a.y;
//       qa.z += ab1*rhsq1a.z +  ab2*rhsq2a.z + ab3*rhsq3a.z;
//       //
//       qa.w  = expdt*qa.w  + saab1*rhsq1a.w +  saab2*rhsq2a.w + saab3*rhsq3a.w;
//       qb.x  = expdt*qb.x  + saab1*rhsq1b.x +  saab2*rhsq2b.x + saab3*rhsq3b.x;
//       qb.y  = expdt*qb.y  + saab1*rhsq1b.y +  saab2*rhsq2b.y + saab3*rhsq3b.y;
//       //           
//       rhsq3[id+0] = rhsq2a;
//       rhsq3[id+1] = rhsq2b;
//       //
//       rhsq2[id+0] = rhsq1a;
//       rhsq2[id+1] = rhsq1b;
//       //
//       q[id+0] = qa;
//       q[id+1] = qb;

//     }
//   }
// }











// @kernel void boltzmannLSERKPmlUpdate2D_0(const int Nelements,
//               @restrict const  int *  elementIds, 
//               const dfloat dt,  
//               const dfloat rka,
//               const dfloat rkb,
//               const dfloat ramp, 
//               @restrict const  dfloat4 *  rhsq, 
//               @restrict const  dfloat *  rhsqx,
//               @restrict const  dfloat *  rhsqy, 
//                     @restrict dfloat4 *  resq,
//                     @restrict dfloat *  resqx,
//                     @restrict dfloat *  resqy,
//                     @restrict dfloat *  qx,
//                     @restrict dfloat *  qy,
//                     @restrict dfloat4 *  q){
  
//   // Low storage Runge Kutta time step update
//   for(int es=0;es<Nelements;++es;@outer(0)){
//     for(int n=0;n<p_Np;++n;@inner(0)){

//       const int e  = elementIds[es];
      
//       const int base = n + e*p_Nfields*p_Np;
//       const int id   = 2*(n + e*p_Np); 

//       dfloat resqx1 = resqx[base+0*p_Np];
//       dfloat resqx2 = resqx[base+1*p_Np];
//       dfloat resqx3 = resqx[base+2*p_Np];
//       dfloat resqx4 = resqx[base+3*p_Np];
//       dfloat resqx5 = resqx[base+4*p_Np];
//       dfloat resqx6 = resqx[base+5*p_Np];

//       dfloat resqy1 = resqy[base+0*p_Np];
//       dfloat resqy2 = resqy[base+1*p_Np];
//       dfloat resqy3 = resqy[base+2*p_Np];
//       dfloat resqy4 = resqy[base+3*p_Np];
//       dfloat resqy5 = resqy[base+4*p_Np];
//       dfloat resqy6 = resqy[base+5*p_Np];
//       //
//       dfloat rhsqx1 = rhsqx[base+0*p_Np];
//       dfloat rhsqx2 = rhsqx[base+1*p_Np];
//       dfloat rhsqx3 = rhsqx[base+2*p_Np];
//       dfloat rhsqx4 = rhsqx[base+3*p_Np];
//       dfloat rhsqx5 = rhsqx[base+4*p_Np];
//       dfloat rhsqx6 = rhsqx[base+5*p_Np];

//       dfloat rhsqy1 = rhsqy[base+0*p_Np];
//       dfloat rhsqy2 = rhsqy[base+1*p_Np];
//       dfloat rhsqy3 = rhsqy[base+2*p_Np];
//       dfloat rhsqy4 = rhsqy[base+3*p_Np];
//       dfloat rhsqy5 = rhsqy[base+4*p_Np];
//       dfloat rhsqy6 = rhsqy[base+5*p_Np];
      
//       //Compute  Residual
//       resqx1 = rka*resqx1 + dt*rhsqx1;
//       resqx2 = rka*resqx2 + dt*rhsqx2;
//       resqx3 = rka*resqx3 + dt*rhsqx3;
//       resqx4 = rka*resqx4 + dt*rhsqx4;
//       resqx5 = rka*resqx5 + dt*rhsqx5;
//       resqx6 = rka*resqx6 + dt*rhsqx6;

//       resqy1 = rka*resqy1 + dt*rhsqy1;
//       resqy2 = rka*resqy2 + dt*rhsqy2;
//       resqy3 = rka*resqy3 + dt*rhsqy3;
//       resqy4 = rka*resqy4 + dt*rhsqy4;
//       resqy5 = rka*resqy5 + dt*rhsqy5;
//       resqy6 = rka*resqy6 + dt*rhsqy6;
      

//       // Update Q
//       qx[base+0*p_Np] += rkb*resqx1;
//       qx[base+1*p_Np] += rkb*resqx2;
//       qx[base+2*p_Np] += rkb*resqx3;
//       qx[base+3*p_Np] += rkb*resqx4;
//       qx[base+4*p_Np] += rkb*resqx5;
//       qx[base+5*p_Np] += rkb*resqx6;

//       qy[base+0*p_Np] += rkb*resqy1;
//       qy[base+1*p_Np] += rkb*resqy2;
//       qy[base+2*p_Np] += rkb*resqy3;
//       qy[base+3*p_Np] += rkb*resqy4;
//       qy[base+4*p_Np] += rkb*resqy5;
//       qy[base+5*p_Np] += rkb*resqy6;
      
//       //Update Res
//       resqx[base+0*p_Np] = resqx1;
//       resqx[base+1*p_Np] = resqx2;
//       resqx[base+2*p_Np] = resqx3;
//       resqx[base+3*p_Np] = resqx4;
//       resqx[base+4*p_Np] = resqx5;
//       resqx[base+5*p_Np] = resqx6;

//       resqy[base+0*p_Np] = resqy1;
//       resqy[base+1*p_Np] = resqy2;
//       resqy[base+2*p_Np] = resqy3;
//       resqy[base+3*p_Np] = resqy4;
//       resqy[base+4*p_Np] = resqy5;
//       resqy[base+5*p_Np] = resqy6;
      
//       // Update Q
//       dfloat4 resqa = resq[id + 0];
//       dfloat4 resqb = resq[id + 1];

//       dfloat4 rhsqa = rhsq[id+0];
//       dfloat4 rhsqb = rhsq[id+1];

//       dfloat4 qa = q[id+0];
//       dfloat4 qb = q[id+1];

//       resqa = rka*resqa + dt*rhsqa;
//       resqb = rka*resqb + dt*rhsqb;

//       resq[id+0] = resqa;
//       resq[id+1] = resqb;
       
//       qa += rkb*resqa;
//       qb += rkb*resqb;
//       //
//       q[id+0] = qa;
//       q[id+1] = qb;

      
//     }
//   }
// }











// // Perform an update like Y = Q + c_im*Res_IM + c_ex*Res_EX;
// @kernel void boltzmannLSIMEXResidualUpdate2D(const int Nelements,
//             @restrict const  int *  elementIds,
//             const dfloat dt, 
//             const dfloat aki,
//             const dfloat ake, 
//             @restrict const  dfloat4 *  q,
//             @restrict const  dfloat4 *  qZ,
//                   @restrict dfloat4 *  qY){
//   // Low storage Runge Kutta time step update
//   for(int e=0;e<Nelements;++e;@outer(0)){
//     for(int n=0;n<p_Np;++n;@inner(0)){
//       const int element = elementIds[e];

//       const int id0 = 2*(n + element*p_Np);
//       const int id1 = id0 + 1; 

//       dfloat4 qima = qZ[id0];
//       dfloat4 qimb = qZ[id1];

//       dfloat4 qexa = qY[id0];
//       dfloat4 qexb = qY[id1];
//       //
//       dfloat4 qa   = q[id0];
//       dfloat4 qb   = q[id1];

//       qY[id0] = qa + ake*dt*qexa + aki*dt*qima;
//       qY[id1] = qb + ake*dt*qexb + aki*dt*qimb;
      

//     }
//   }
// }


// // Perform an update like Y = Q + c_im*Res_IM + c_ex*Res_EX;
// @kernel void boltzmannLSIMEXImplicitUpdate2D(const int Nelements,
//             @restrict const  int *  elementIds,
//             const dfloat dt, 
//             const dfloat akk,
//             @restrict const  dfloat4 *  qZ,
//             @restrict const  dfloat4 *  qY,
//                   @restrict dfloat4 *  q,
//                   @restrict dfloat4 *  qS){
//   // Low storage Runge Kutta time step update
//   for(int e=0;e<Nelements;++e;@outer(0)){
//     for(int n=0;n<p_Np;++n;@inner(0)){
//       //
//       const int element = elementIds[e];
//       const int id0 = 2*(n + element*p_Np);
//       const int id1 = id0 + 1; 

//       dfloat4 qima = qZ[id0];
//       dfloat4 qimb = qZ[id1];

//       dfloat4 qexa = qY[id0];
//       dfloat4 qexb = qY[id1];
//       //
//       dfloat4 qa  = q[id0];
//       dfloat4 qb  = q[id1];

//       qS[id0] = qa; 
//       qS[id1] = qb; 

//       q[id0] = qexa + akk*dt*qima;
//       q[id1] = qexb + akk*dt*qimb;      

//     }
//   }
// }


// // Perform an update like Y = Q + c_im*Res_IM + c_ex*Res_EX;
// @kernel void boltzmannLSIMEXUpdate2D(const int Nelements,
//             @restrict const  int *  elementIds,
//             const dfloat dt, 
//             const dfloat akk,
//             @restrict const  dfloat4 *  qZ,
//             @restrict const  dfloat4 *  qY,
//             @restrict const  dfloat4 *  qS,
//                   @restrict dfloat4 *  q){
//   // Low storage Runge Kutta time step update
//   for(int e=0;e<Nelements;++e;@outer(0)){
//     for(int n=0;n<p_Np;++n;@inner(0)){
//       const int element = elementIds[e];

//       const int id0 = 2*(n + element*p_Np);
//       const int id1 = id0 + 1; 

//       dfloat4 qia = qZ[id0];
//       dfloat4 qib = qZ[id1];

//       dfloat4 qea = qY[id0];
//       dfloat4 qeb = qY[id1];
//       //
//       dfloat4 qa  = qS[id0];
//       dfloat4 qb  = qS[id1];
//       //
//       q[id0] = qa+ akk*dt*(qia + qea);
//       q[id1] = qb+ akk*dt*(qib + qeb);     

//     }
//   }
// }






// // Perform an update like Y = Q + c_im*Res_IM + c_ex*Res_EX;
// @kernel void boltzmannLSIMEXPmlResidualUpdate2D(const int Nelements,
//             @restrict const  int *  elementIds,
//             const dfloat dt,
//             const dfloat ramp, 
//             const dfloat c_im,
//             const dfloat c_ex, 
//             @restrict const  dfloat4 *  q,
//             @restrict const  dfloat  *  pmlqx,
//             @restrict const  dfloat  *  pmlqy,
//                   @restrict dfloat4 *  qZ,
//                   @restrict dfloat4 *  qY,  
//                   @restrict dfloat  *  pmlYx,
//                   @restrict dfloat  *  pmlYy){
//   // Low storage Runge Kutta time step update
//   for(int e=0;e<Nelements;++e;@outer(0)){
//     for(int n=0;n<p_Np;++n;@inner(0)){
//       const int element = elementIds[e];
//       //
//       const int base = n + element*p_Nfields*p_Np;
//       const int id1 = base + 0*p_Np;
//       const int id2 = base + 1*p_Np;
//       const int id3 = base + 2*p_Np;
//       const int id4 = base + 3*p_Np;
//       const int id5 = base + 4*p_Np;
//       const int id6 = base + 5*p_Np;
//       // PML UPDATES
//       dfloat qx1 = pmlqx[id1];
//       dfloat qx2 = pmlqx[id2];
//       dfloat qx3 = pmlqx[id3];
//       dfloat qx4 = pmlqx[id4];
//       dfloat qx5 = pmlqx[id5];
//       dfloat qx6 = pmlqx[id6]; 
//       //
//       dfloat qy1 = pmlqy[id1];
//       dfloat qy2 = pmlqy[id2];
//       dfloat qy3 = pmlqy[id3];
//       dfloat qy4 = pmlqy[id4];
//       dfloat qy5 = pmlqy[id5];
//       dfloat qy6 = pmlqy[id6]; 

//       // PML UPDATES
//       dfloat qxe1 = pmlYx[id1];
//       dfloat qxe2 = pmlYx[id2];
//       dfloat qxe3 = pmlYx[id3];
//       dfloat qxe4 = pmlYx[id4];
//       dfloat qxe5 = pmlYx[id5];
//       dfloat qxe6 = pmlYx[id6]; 
//       //
//       dfloat qye1 = pmlYy[id1];
//       dfloat qye2 = pmlYy[id2];
//       dfloat qye3 = pmlYy[id3];
//       dfloat qye4 = pmlYy[id4];
//       dfloat qye5 = pmlYy[id5];
//       dfloat qye6 = pmlYy[id6]; 
     
//       // PML UPDATES
//       pmlYx[id1] = qx1 + c_ex*dt*qxe1;
//       pmlYx[id2] = qx2 + c_ex*dt*qxe2;
//       pmlYx[id3] = qx3 + c_ex*dt*qxe3;
//       pmlYx[id4] = qx4 + c_ex*dt*qxe4;
//       pmlYx[id5] = qx5 + c_ex*dt*qxe5;
//       pmlYx[id6] = qx6 + c_ex*dt*qxe6; 
//       //
//       pmlYy[id1] = qy1 + c_ex*dt*qye1;
//       pmlYy[id2] = qy2 + c_ex*dt*qye2;
//       pmlYy[id3] = qy3 + c_ex*dt*qye3;
//       pmlYy[id4] = qy4 + c_ex*dt*qye4;
//       pmlYy[id5] = qy5 + c_ex*dt*qye5;
//       pmlYy[id6] = qy6 + c_ex*dt*qye6; 
      
//       //
//       const int id = 2*(n + element*p_Np);

//       dfloat4 qima = qZ[id];
//       dfloat4 qimb = qZ[id+1];

//       dfloat4 qexa = qY[id];
//       dfloat4 qexb = qY[id+1];
//       //
//       dfloat4 qa   = q[id];
//       dfloat4 qb   = q[id+1];

//       qY[id]   = qa + c_ex*dt*qexa + c_im*dt*qima;
//       qY[id+1] = qb + c_ex*dt*qexb + c_im*dt*qimb;
     
//     }
//   }
// }







// // Perform an update like Y = Q + c_im*Res_IM + c_ex*Res_EX;
// @kernel void boltzmannLSIMEXPmlImplicitUpdate2D(const int Nelements,
//             @restrict const  int *  elementIds,
//             const dfloat dt, 
//             const dfloat ramp,
//             const dfloat akk,
//             @restrict const  dfloat4 *  qY,
//             @restrict const  dfloat  *  qYx,
//             @restrict const  dfloat  *  qYy,
//             @restrict const  dfloat4 *  qZ,
//                   @restrict dfloat  *  pmlqx,
//                   @restrict dfloat  *  pmlqy,
//                   @restrict dfloat  *  qSx,
//                   @restrict dfloat  *  qSy,   
//                   @restrict dfloat4 *  qS,
//                   @restrict dfloat4 *  q ){
//   // Low storage Runge Kutta time step update
//   for(int e=0;e<Nelements;++e;@outer(0)){
//     for(int n=0;n<p_Np;++n;@inner(0)){
//       const int element = elementIds[e];
//       //
//       const int base = n + element*p_Nfields*p_Np;
//       const int id1 = base + 0*p_Np;
//       const int id2 = base + 1*p_Np;
//       const int id3 = base + 2*p_Np;
//       const int id4 = base + 3*p_Np;
//       const int id5 = base + 4*p_Np;
//       const int id6 = base + 5*p_Np;
//       // There are many dummy operation to keep the readable update later
//       dfloat qx1 = pmlqx[id1];
//       dfloat qx2 = pmlqx[id2];
//       dfloat qx3 = pmlqx[id3];
//       dfloat qx4 = pmlqx[id4];
//       dfloat qx5 = pmlqx[id5];
//       dfloat qx6 = pmlqx[id6]; 
//       //
//       dfloat qy1 = pmlqy[id1];
//       dfloat qy2 = pmlqy[id2];
//       dfloat qy3 = pmlqy[id3];
//       dfloat qy4 = pmlqy[id4];
//       dfloat qy5 = pmlqy[id5];
//       dfloat qy6 = pmlqy[id6];         
      
//       // PML UPDATES
//       dfloat qxe1 = qYx[id1];
//       dfloat qxe2 = qYx[id2];
//       dfloat qxe3 = qYx[id3];
//       dfloat qxe4 = qYx[id4];
//       dfloat qxe5 = qYx[id5];
//       dfloat qxe6 = qYx[id6]; 
//       //
//       dfloat qye1 = qYy[id1];
//       dfloat qye2 = qYy[id2];
//       dfloat qye3 = qYy[id3];
//       dfloat qye4 = qYy[id4];
//       dfloat qye5 = qYy[id5];
//       dfloat qye6 = qYy[id6]; 
      
//       // PML UPDATES
//       qSx[id1] = qx1;
//       qSx[id2] = qx2;
//       qSx[id3] = qx3;
//       qSx[id4] = qx4;
//       qSx[id5] = qx5;
//       qSx[id6] = qx6; 
//       //
//       qSy[id1] = qy1;
//       qSy[id2] = qy2;
//       qSy[id3] = qy3;
//       qSy[id4] = qy4;
//       qSy[id5] = qy5;
//       qSy[id6] = qy6;   

//       // PML UPDATES
//       pmlqx[id1] = qxe1;
//       pmlqx[id2] = qxe2;
//       pmlqx[id3] = qxe3;
//       pmlqx[id4] = qxe4;
//       pmlqx[id5] = qxe5;
//       pmlqx[id6] = qxe6; 
//        // PML UPDATES
//       pmlqy[id1] = qye1;
//       pmlqy[id2] = qye2;
//       pmlqy[id3] = qye3;
//       pmlqy[id4] = qye4;
//       pmlqy[id5] = qye5;
//       pmlqy[id6] = qye6; 
//       //
      
//       const int id = 2*(n + element*p_Np);
      
//       dfloat4 qima = qZ[id];
//       dfloat4 qimb = qZ[id+1];

//       dfloat4 qexa = qY[id];
//       dfloat4 qexb = qY[id+1];
//       //
//       dfloat4 qa  = q[id];
//       dfloat4 qb  = q[id+1];

//       qS[id] = qa; 
//       qS[id+1] = qb; 

//       q[id]   = qexa + akk*dt*qima;
//       q[id+1] = qexb + akk*dt*qimb;  

//     }
//   }
// }



// // Perform an update like Y = Q + c_im*Res_IM + c_ex*Res_EX;
// @kernel void boltzmannLSIMEXPmlUpdate2D(const int Nelements,
//             @restrict const  int *  elementIds,
//             const dfloat dt, 
//             const dfloat akk,
//             const dfloat ramp,
//             @restrict const  dfloat4  *  qZ,
//             @restrict const  dfloat4  *  qY,
//             @restrict const  dfloat  *  qYx,
//             @restrict const  dfloat  *  qYy,
//             @restrict const  dfloat4  *  qS,
//             @restrict const  dfloat  *  qSx,
//             @restrict const  dfloat  *  qSy,    
//                   @restrict dfloat  *  pmlqx,
//                   @restrict dfloat  *  pmlqy,
//                   @restrict dfloat4 *  q ){
//   // Low storage Runge Kutta time step update
//   for(int e=0;e<Nelements;++e;@outer(0)){
//     for(int n=0;n<p_Np;++n;@inner(0)){
//       const int element = elementIds[e];

//       //
//       const int base = n + element*p_Nfields*p_Np;
//       const int id1 = base + 0*p_Np;
//       const int id2 = base + 1*p_Np;
//       const int id3 = base + 2*p_Np;
//       const int id4 = base + 3*p_Np;
//       const int id5 = base + 4*p_Np;
//       const int id6 = base + 5*p_Np; 
//       // 
//       dfloat qxe1 = qYx[id1];
//       dfloat qxe2 = qYx[id2];
//       dfloat qxe3 = qYx[id3];
//       dfloat qxe4 = qYx[id4];
//       dfloat qxe5 = qYx[id5];
//       dfloat qxe6 = qYx[id6]; 
//       //
//       dfloat qye1 = qYy[id1];
//       dfloat qye2 = qYy[id2];
//       dfloat qye3 = qYy[id3];
//       dfloat qye4 = qYy[id4];
//       dfloat qye5 = qYy[id5];
//       dfloat qye6 = qYy[id6];      
//       // 
//       dfloat qsx1 = qSx[id1];
//       dfloat qsx2 = qSx[id2];
//       dfloat qsx3 = qSx[id3];
//       dfloat qsx4 = qSx[id4];
//       dfloat qsx5 = qSx[id5];
//       dfloat qsx6 = qSx[id6]; 
//       // 
//       dfloat qsy1 = qSy[id1];
//       dfloat qsy2 = qSy[id2];
//       dfloat qsy3 = qSy[id3];
//       dfloat qsy4 = qSy[id4];
//       dfloat qsy5 = qSy[id5];
//       dfloat qsy6 = qSy[id6];  
//       // 
//       pmlqx[id1] =qsx1 + akk*dt*qxe1;
//       pmlqx[id2] =qsx2 + akk*dt*qxe2;
//       pmlqx[id3] =qsx3 + akk*dt*qxe3;
//       pmlqx[id4] =qsx4 + akk*dt*qxe4;
//       pmlqx[id5] =qsx5 + akk*dt*qxe5;
//       pmlqx[id6] =qsx6 + akk*dt*qxe6; 
//       // 
//       pmlqy[id1] =qsy1 + akk*dt*qye1;
//       pmlqy[id2] =qsy2 + akk*dt*qye2;
//       pmlqy[id3] =qsy3 + akk*dt*qye3;
//       pmlqy[id4] =qsy4 + akk*dt*qye4;
//       pmlqy[id5] =qsy5 + akk*dt*qye5;
//       pmlqy[id6] =qsy6 + akk*dt*qye6; 
//       //
//       const int id = 2*(n + element*p_Np);
      
//       dfloat4 qia = qZ[id];
//       dfloat4 qib = qZ[id+1];

//       dfloat4 qea = qY[id];
//       dfloat4 qeb = qY[id+1];
//       //
//       dfloat4 qa  = qS[id];
//       dfloat4 qb  = qS[id+1];
//       //
//       q[id]   = qa+ akk*dt*(qia + qea);
//       q[id+1] = qb+ akk*dt*(qib + qeb);    

//     }
//   }
// }

