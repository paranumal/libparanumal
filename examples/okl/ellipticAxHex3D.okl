
#if 0
__constant__ dfloat c_D[10][9] = {
                                   {.1, .2, .3, .4, .5, .6, .7, .8, .9},
                                   {.1, .2, .3, .4, .5, .6, .7, .8, .9},
                                   {.1, .2, .3, .4, .5, .6, .7, .8, .9},
                                   {.1, .2, .3, .4, .5, .6, .7, .8, .9},
                                   {.1, .2, .3, .4, .5, .6, .7, .8, .9},
                                   {.1, .2, .3, .4, .5, .6, .7, .8, .9},
                                   {.1, .2, .3, .4, .5, .6, .7, .8, .9},
                                   {.1, .2, .3, .4, .5, .6, .7, .8, .9},
                                   {.1, .2, .3, .4, .5, .6, .7, .8, .9},
                                   {.1, .2, .3, .4, .5, .6, .7, .8, .9}
                                 };

__constant__ dfloat c_I[10][9] = {
                                   {.1, .2, .3, .4, .5, .6, .7, .8, .9},
                                   {.1, .2, .3, .4, .5, .6, .7, .8, .9},
                                   {.1, .2, .3, .4, .5, .6, .7, .8, .9},
                                   {.1, .2, .3, .4, .5, .6, .7, .8, .9},
                                   {.1, .2, .3, .4, .5, .6, .7, .8, .9},
                                   {.1, .2, .3, .4, .5, .6, .7, .8, .9},
                                   {.1, .2, .3, .4, .5, .6, .7, .8, .9},
                                   {.1, .2, .3, .4, .5, .6, .7, .8, .9},
                                   {.1, .2, .3, .4, .5, .6, .7, .8, .9},
                                   {.1, .2, .3, .4, .5, .6, .7, .8, .9}
                                 };
#endif

// hex @kernel for screened coulomb potential mat-vec
#define cubeThreads                             \
	for(int k=0; k<p_Nq; ++k; @inner(2))            \
		for(int j=0; j<p_Nq; ++j; @inner(1))          \
			for(int i=0; i<p_Nq; ++i; @inner(0))


// cube thread version
@kernel void ellipticAxHex3D_e0(const dlong Nelements,
                               @restrict const  dfloat *  ggeo,
                               @restrict const  dfloat *  D,
                               const dfloat lambda,
                               @restrict const  dfloat *  q,
                               @restrict dfloat *  Aq){

	for(dlong e=0; e<Nelements; ++e; @outer(0)) {

		@shared dfloat s_q[p_Nq][p_Nq][p_Nq];
		@shared dfloat s_D[p_Nq][p_Nq];

		@exclusive dfloat r_qr, r_qs, r_qt, r_Aq;
		@exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;

		// prefetch q(:,:,:,e) to @shared
		cubeThreads {
		  const dlong base = i + j*p_Nq + k*p_Nq*p_Nq + e*p_Np;

		  s_q[k][j][i] = q[base];

		  if(k==0) // fetch D to @shared
		  s_D[j][i] = D[j*p_Nq+i];
		}

		@barrier("local");

		cubeThreads {

		  const dlong base = e*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

		  // assumes w*J built into G entries
		  r_GwJ = ggeo[base+p_GWJID*p_Np];

		  r_G00 = ggeo[base+p_G00ID*p_Np];
		  r_G01 = ggeo[base+p_G01ID*p_Np];
		  r_G02 = ggeo[base+p_G02ID*p_Np];

		  r_G11 = ggeo[base+p_G11ID*p_Np];
		  r_G12 = ggeo[base+p_G12ID*p_Np];
		  r_G22 = ggeo[base+p_G22ID*p_Np];

		  dfloat qr = 0.f, qs = 0.f, qt = 0.f;

		  for(int n=0; n<p_Nq; ++n) {
		  qr += s_D[i][n]*s_q[k][j][n];
			  qs += s_D[j][n]*s_q[k][n][i];
			  qt += s_D[k][n]*s_q[n][j][i];
		  }

		  r_qr = qr; r_qs = qs; r_qt = qt;

		  r_Aq = r_GwJ*lambda*s_q[k][j][i];
		}

		// r term ----->
		@barrier("local");

		cubeThreads {
		  s_q[k][j][i] = r_G00*r_qr + r_G01*r_qs + r_G02*r_qt;
		}

		@barrier("local");

		cubeThreads {
		  dfloat tmp = 0.f;
		  for(int n=0; n<p_Nq; ++n)
		  tmp += s_D[n][i]*s_q[k][j][n];

		  r_Aq += tmp;
		}

		// s term ---->
		@barrier("local");

		cubeThreads {
		  s_q[k][j][i] = r_G01*r_qr + r_G11*r_qs + r_G12*r_qt;
		}

		@barrier("local");

		cubeThreads {
		  dfloat tmp = 0.f;
		  for(int n=0; n<p_Nq; ++n)
		  tmp += s_D[n][j]*s_q[k][n][i];

		  r_Aq += tmp;
		}

		// t term ---->
		@barrier("local");

		cubeThreads {
		  s_q[k][j][i] = r_G02*r_qr + r_G12*r_qs + r_G22*r_qt;
		}

		@barrier("local");

		cubeThreads {
		  dfloat tmp = 0.f;
		  for(int n=0; n<p_Nq; ++n)
		  tmp += s_D[n][k]*s_q[n][j][i];

		  r_Aq += tmp;

		  dlong base = e*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
		  Aq[base] = r_Aq;
		}
	}
}

//e0a - element list
@kernel void ellipticAxHex3D_e0a(const dlong Nelements,
                                @restrict const  dlong *  elementList,
                                @restrict const  dfloat *  ggeo,
                                @restrict const  dfloat *  D,
                                const dfloat lambda,
                                @restrict const  dfloat *  q,
                                @restrict dfloat *  Aq){

	for(dlong e=0; e<Nelements; ++e; @outer(0)) {

		@shared dfloat s_q[p_Nq][p_Nq][p_Nq];
		@shared dfloat s_D[p_Nq][p_Nq];

		@exclusive dfloat r_qr, r_qs, r_qt, r_Aq;
		@exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;

		// prefetch q(:,:,:,e) to @shared
		cubeThreads {
		  const dlong base = i + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np;

		  s_q[k][j][i] = q[base];

		  if(k==0) // fetch D to @shared
		  s_D[j][i] = D[j*p_Nq+i];
		}

		@barrier("local");

		cubeThreads {

		  const dlong base = elementList[e]*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

		  // assumes w*J built into G entries
		  r_GwJ = ggeo[base+p_GWJID*p_Np];

		  r_G00 = ggeo[base+p_G00ID*p_Np];
		  r_G01 = ggeo[base+p_G01ID*p_Np];
		  r_G02 = ggeo[base+p_G02ID*p_Np];

		  r_G11 = ggeo[base+p_G11ID*p_Np];
		  r_G12 = ggeo[base+p_G12ID*p_Np];
		  r_G22 = ggeo[base+p_G22ID*p_Np];

		  dfloat qr = 0.f, qs = 0.f, qt = 0.f;

		  for(int n=0; n<p_Nq; ++n) {
		  qr += s_D[i][n]*s_q[k][j][n];
			  qs += s_D[j][n]*s_q[k][n][i];
			  qt += s_D[k][n]*s_q[n][j][i];
		  }

		  r_qr = qr; r_qs = qs; r_qt = qt;

		  r_Aq = r_GwJ*lambda*s_q[k][j][i];
		}

		// r term ----->
		@barrier("local");

		cubeThreads {
		  s_q[k][j][i] = r_G00*r_qr + r_G01*r_qs + r_G02*r_qt;
		}

		@barrier("local");

		cubeThreads {
		  dfloat tmp = 0.f;
		  for(int n=0; n<p_Nq; ++n)
		  tmp += s_D[n][i]*s_q[k][j][n];

		  r_Aq += tmp;
		}

		// s term ---->
		@barrier("local");

		cubeThreads {
		  s_q[k][j][i] = r_G01*r_qr + r_G11*r_qs + r_G12*r_qt;
		}

		@barrier("local");

		cubeThreads {
		  dfloat tmp = 0.f;
		  for(int n=0; n<p_Nq; ++n)
		  tmp += s_D[n][j]*s_q[k][n][i];

		  r_Aq += tmp;
		}

		// t term ---->
		@barrier("local");

		cubeThreads {
		  s_q[k][j][i] = r_G02*r_qr + r_G12*r_qs + r_G22*r_qt;
		}

		@barrier("local");

		cubeThreads {
		  dfloat tmp = 0.f;
		  for(int n=0; n<p_Nq; ++n)
		  tmp += s_D[n][k]*s_q[n][j][i];

		  r_Aq += tmp;

		  dlong base =  elementList[e]*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
		  Aq[base] = r_Aq;
		}
	}
}//e0a end

//e0b - optimized e0a

#if 0

//e0c - less registers
@kernel void ellipticAxHex3D_e0b(const int Nelements,
                                @restrict const  int *  elementList,
                                @restrict const  dfloat *  ggeo,
                                @restrict const  dfloat *  D,
                                const dfloat lambda,
                                @restrict const  dfloat *  q,
                                @restrict dfloat *  Aq){

	for(int e=0; e<Nelements; ++e; @outer(0)) {

		@shared dfloat s_q[p_Nq][p_Nq][p_Nq];
		@shared dfloat s_qr[p_Nq][p_Nq][p_Nq];
		@shared dfloat s_qs[p_Nq][p_Nq][p_Nq];
		@shared dfloat s_qt[p_Nq][p_Nq][p_Nq];

		@shared dfloat s_D[p_Nq][p_Nq];
		//	@shared dfloat s_Aq[p_Nq][p_Nq][p_Nq];

		@exclusive dfloat emap;
		//r_Aq;
		@exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;
		@exclusive dfloat r_Aq;
		// prefetch q(:,:,:,e) to @shared
		cubeThreads {
		  emap = elementList[e];
		  const int base = i + j*p_Nq + k*p_Nq*p_Nq + emap*p_Np;

		  s_q[k][j][i] = q[base];

		  if(k==0) // fetch D to @shared
		  s_D[j][i] = D[j*p_Nq+i];
		}

		@barrier("local");



		cubeThreads {

		  //  const int base = elementList[e]*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

		  // assumes w*J built into G entries


		  const int base = emap*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

		  r_GwJ = ggeo[base+p_GWJID*p_Np];

		  r_G00 = ggeo[base+p_G00ID*p_Np];
		  r_G01 = ggeo[base+p_G01ID*p_Np];
		  r_G02 = ggeo[base+p_G02ID*p_Np];

		  r_G11 = ggeo[base+p_G11ID*p_Np];
		  r_G12 = ggeo[base+p_G12ID*p_Np];
		  r_G22 = ggeo[base+p_G22ID*p_Np];


		  dfloat qr = 0.f;
		  dfloat qs = 0.f, qt = 0.f;

		  #pragma unroll p_Nq
		  for(int n=0; n<p_Nq; ++n) {
		  qr += s_D[i][n]*s_q[k][j][n];
			  qs += s_D[j][n]*s_q[k][n][i];
			  qt += s_D[k][n]*s_q[n][j][i];
		  }
		  
 
		  s_qr[k][j][i] = r_G00*qr + r_G01*qs + r_G02*qt;
		  s_qs[k][j][i] = r_G01*qr + r_G11*qs + r_G12*qt;
		  s_qt[k][j][i] = r_G02*qr + r_G12*qs + r_G22*qt;
		  
		  
		  r_Aq = r_GwJ*lambda*s_q[k][j][i];
		}


		// r term ----->


		@barrier("local");

		cubeThreads {
		  dfloat tmp = 0.0f;

		  #pragma unroll p_Nq
		  for(int n=0; n<p_Nq; ++n){
		    tmp += s_D[n][i]*s_qr[k][j][n];
			  tmp += s_D[n][j]*s_qs[k][n][i];
			  tmp += s_D[n][k]*s_qt[n][j][i];
		  }

		  //  r_Aq += tmp;
		  //  s_Aq[k][j][i] +=tmp;
		  r_Aq += tmp;
		  int base =  emap*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

		  Aq[base] = r_Aq;
		  //r_Aq;
		  //s_Aq[k][j][i];

		}
	}
}//e0b end

//e03 - more registers (?)



// i-j sliced version
@kernel void ellipticAxHex3D_e1(const int Nelements,
                               @restrict const  dfloat *  ggeo,
                               @restrict const  dfloat *  D,
                               const dfloat lambda,
                               @restrict const  dfloat *  q,
                               @restrict dfloat *  Aq){

	for(int eo=0; eo<Nelements; eo+=p_NblockV; @outer(0)) {

		@shared dfloat s_tmpr[p_NblockV][p_Nq][p_Nq];
		@shared dfloat s_tmps[p_NblockV][p_Nq][p_Nq];
		@shared dfloat s_q[p_NblockV][p_Nq][p_Nq];
		@shared dfloat s_D[p_Nq][p_Nq];

		@exclusive dfloat r_q[p_Nq], r_Aq[p_Nq], r_qt, r_tmpt;

		// prefetch q(i,j,:,e) to register array
		for(int es=0; es<p_NblockV; ++es; @inner(2)) {
			for(int j=0; j<p_Nq; ++j; @inner(1)) {
				for(int i=0; i<p_Nq; ++i; @inner(0)) {
					const int e = eo + es;

					if(e<Nelements) {
						const int base = i + j*p_Nq + e*p_Np;

						for(int k=0; k<p_Nq; ++k) {
							r_q[k] = q[base + k*p_Nq*p_Nq];
							r_Aq[k] = 0.f;
						}
					}

					if(es==0) // fetch D to @shared
						s_D[j][i] = D[j*p_Nq+i];

				}
			}
		}

		@barrier("local");

		for(int k=0; k<p_Nq; ++k) {

			for(int es=0; es<p_NblockV; ++es; @inner(2)) {
				for(int j=0; j<p_Nq; ++j; @inner(1)) {
					for(int i=0; i<p_Nq; ++i; @inner(0)) {
						const int e = eo + es;
						if(e<Nelements) {

							// share k-slice of q
							s_q[es][j][i] = r_q[k];

							// hide @shared latency behind t-derivative
							dfloat qtk = 0.f;
							for(int n=0; n<p_Nq; ++n) {
								qtk += s_D[k][n]*r_q[n];
							}
							r_qt = qtk;

						}
					}
				}
			}

			@barrier("local");

			// process k-slice (first r- and s-derivatives)
			for(int es=0; es<p_NblockV; ++es; @inner(2)) {
				for(int j=0; j<p_Nq; ++j; @inner(1)) {
					for(int i=0; i<p_Nq; ++i; @inner(0)) {
						const int e = eo + es;
						if(e<Nelements) {
							const int base = e*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

							const dfloat G00 = ggeo[base+p_G00ID*p_Np];
							const dfloat G01 = ggeo[base+p_G01ID*p_Np];
							const dfloat G02 = ggeo[base+p_G02ID*p_Np];
							const dfloat G11 = ggeo[base+p_G11ID*p_Np];
							const dfloat G12 = ggeo[base+p_G12ID*p_Np];
							const dfloat G22 = ggeo[base+p_G22ID*p_Np];
							const dfloat GwJ = ggeo[base+p_GWJID*p_Np];

							dfloat qr = 0.f, qs = 0.f;
							for(int n=0; n<p_Nq; ++n) {
								qr += s_D[i][n]*s_q[es][j][n];
								qs += s_D[j][n]*s_q[es][n][i];
							}

							// assumes w*J built into G entries
							s_tmpr[es][j][i] = G00*qr + G01*qs + G02*r_qt;
							s_tmps[es][j][i] = G01*qr + G11*qs + G12*r_qt;
							r_tmpt           = G02*qr + G12*qs + G22*r_qt;

							r_Aq[k] += GwJ*lambda*r_q[k];

#if 1
							for(int n=0; n<p_Nq; ++n) {
								r_Aq[n] += s_D[k][n]*r_tmpt;
							}
#endif
						}
					}
				}
			}

			@barrier("local");

			// second derivatives
			for(int es=0; es<p_NblockV; ++es; @inner(2)) {
				for(int j=0; j<p_Nq; ++j; @inner(1)) {
					for(int i=0; i<p_Nq; ++i; @inner(0)) {
						const int e = eo + es;
						if(e<Nelements) {

							dfloat Aq1 = 0.0f, Aq2 = 0.0f;

							for(int n=0; n<p_Nq; ++n) {
								Aq1 += s_D[n][i]*s_tmpr[es][j][n];
								Aq2 += s_D[n][j]*s_tmps[es][n][i];
							}
#if 1
							r_Aq[k] +=  Aq1 + Aq2;
#endif
						}
					}
				}
			}
		}

		// write result out (local node storage)
		for(int es=0; es<p_NblockV; ++es; @inner(2)) {
			for(int j=0; j<p_Nq; ++j; @inner(1)) {
				for(int i=0; i<p_Nq; ++i; @inner(0)) {
					const int e = eo + es;
					if(e<Nelements) {
						int base = e*p_Np + j*p_Nq + i;
						for(int k=0; k<p_Nq; ++k) {
							Aq[base] = r_Aq[k];
							base+=p_Nq*p_Nq;
						}
					}
				}
			}
		}
	}
}

//e1a (with elementList)
@kernel void ellipticAxHex3D_e1a(const int Nelements,
                                @restrict const  int *  elementList,
                                @restrict const  dfloat *  ggeo,
                                @restrict const  dfloat *  D,
                                const dfloat lambda,
                                @restrict const  dfloat *  q,
                                @restrict dfloat *  Aq){

	for(int eo=0; eo<Nelements; eo+=p_NblockV; @outer(0)) {

		@shared dfloat s_tmpr[p_NblockV][p_Nq][p_Nq];
		@shared dfloat s_tmps[p_NblockV][p_Nq][p_Nq];
		@shared dfloat s_q[p_NblockV][p_Nq][p_Nq];
		@shared dfloat s_D[p_Nq][p_Nq];

		@exclusive dfloat r_q[p_Nq], r_Aq[p_Nq], r_qt, r_tmpt;

		// prefetch q(i,j,:,e) to register array
		for(int es=0; es<p_NblockV; ++es; @inner(2)) {
			for(int j=0; j<p_Nq; ++j; @inner(1)) {
				for(int i=0; i<p_Nq; ++i; @inner(0)) {
					const int e = eo + es;

					if(e<Nelements) {
						const int base = i + j*p_Nq + elementList[e]*p_Np;

						for(int k=0; k<p_Nq; ++k) {
							r_q[k] = q[base + k*p_Nq*p_Nq];
							r_Aq[k] = 0.f;
						}
					}

					if(es==0) // fetch D to @shared
						s_D[j][i] = D[j*p_Nq+i];

				}
			}
		}

		@barrier("local");

		for(int k=0; k<p_Nq; ++k) {

			for(int es=0; es<p_NblockV; ++es; @inner(2)) {
				for(int j=0; j<p_Nq; ++j; @inner(1)) {
					for(int i=0; i<p_Nq; ++i; @inner(0)) {
						const int e = eo + es;
						if(e<Nelements) {

							// share k-slice of q
							s_q[es][j][i] = r_q[k];

							// hide @shared latency behind t-derivative
							dfloat qtk = 0.f;
							for(int n=0; n<p_Nq; ++n) {
								qtk += s_D[k][n]*r_q[n];
							}
							r_qt = qtk;

						}
					}
				}
			}

			@barrier("local");

			// process k-slice (first r- and s-derivatives)
			for(int es=0; es<p_NblockV; ++es; @inner(2)) {
				for(int j=0; j<p_Nq; ++j; @inner(1)) {
					for(int i=0; i<p_Nq; ++i; @inner(0)) {
						const int e = eo + es;
						if(e<Nelements) {
							const int base = elementList[e]*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

							const dfloat G00 = ggeo[base+p_G00ID*p_Np];
							const dfloat G01 = ggeo[base+p_G01ID*p_Np];
							const dfloat G02 = ggeo[base+p_G02ID*p_Np];
							const dfloat G11 = ggeo[base+p_G11ID*p_Np];
							const dfloat G12 = ggeo[base+p_G12ID*p_Np];
							const dfloat G22 = ggeo[base+p_G22ID*p_Np];
							const dfloat GwJ = ggeo[base+p_GWJID*p_Np];

							dfloat qr = 0.f, qs = 0.f;
							for(int n=0; n<p_Nq; ++n) {
								qr += s_D[i][n]*s_q[es][j][n];
								qs += s_D[j][n]*s_q[es][n][i];
							}

							// assumes w*J built into G entries
							s_tmpr[es][j][i] = G00*qr + G01*qs + G02*r_qt;
							s_tmps[es][j][i] = G01*qr + G11*qs + G12*r_qt;
							r_tmpt           = G02*qr + G12*qs + G22*r_qt;

							r_Aq[k] += GwJ*lambda*r_q[k];

#if 1
							for(int n=0; n<p_Nq; ++n) {
								r_Aq[n] += s_D[k][n]*r_tmpt;
							}
#endif
						}
					}
				}
			}

			@barrier("local");

			// second derivatives
			for(int es=0; es<p_NblockV; ++es; @inner(2)) {
				for(int j=0; j<p_Nq; ++j; @inner(1)) {
					for(int i=0; i<p_Nq; ++i; @inner(0)) {
						const int e = eo + es;
						if(e<Nelements) {

							dfloat Aq1 = 0.0f, Aq2 = 0.0f;

							for(int n=0; n<p_Nq; ++n) {
								Aq1 += s_D[n][i]*s_tmpr[es][j][n];
								Aq2 += s_D[n][j]*s_tmps[es][n][i];
							}
#if 1
							r_Aq[k] +=  Aq1 + Aq2;
#endif
						}
					}
				}
			}
		}

		// write result out (local node storage)
		for(int es=0; es<p_NblockV; ++es; @inner(2)) {
			for(int j=0; j<p_Nq; ++j; @inner(1)) {
				for(int i=0; i<p_Nq; ++i; @inner(0)) {
					const int e = eo + es;
					if(e<Nelements) {
						int base = elementList[e]*p_Np + j*p_Nq + i;
						for(int k=0; k<p_Nq; ++k) {
							Aq[base] = r_Aq[k];
							base+=p_Nq*p_Nq;
						}
					}
				}
			}
		}
	}
} //e1a


//e1b (4d @shared)
@kernel void ellipticAxHex3D_e1b(const int Nelements,
                                @restrict const  int *  elementList,
                                @restrict const  dfloat *  ggeo,
                                @restrict const  dfloat *  D,
                                const dfloat lambda,
                                @restrict const  dfloat *  q,
                                @restrict dfloat *  Aq){

	for(int eo=0; eo<Nelements; eo+=p_NblockV; @outer(0)) {

		@shared dfloat s_tmpr[p_NblockV][p_Nq][p_Nq];
		@shared dfloat s_tmps[p_NblockV][p_Nq][p_Nq];
		@shared dfloat s_q[p_NblockV][p_Nq][p_Nq][p_Nq];
		@shared dfloat s_Aq[p_NblockV][p_Nq][p_Nq][p_Nq];
		// in the original @kernel, each point (i,j) in element es (in block eo) 
		// loads elements (i,j, 0),..,. (i,j, p_Nq)
		// we differentiate slice after slice.
	 //	@shared dfloat s_q[p_NblockV][p_Nq][p_Nq];
		@shared dfloat s_D[p_Nq][p_Nq];

		@exclusive dfloat  r_qt, r_tmpt, emap;
//r_q[p_Nq], r_Aq[p_Nq],
		// prefetch q(i,j,:,e) to register array
		
		for(int es=0; es<p_NblockV; ++es; @inner(2)) {
			for(int j=0; j<p_Nq; ++j; @inner(1)) {
				for(int i=0; i<p_Nq; ++i; @inner(0)) {
					const int e = eo + es;
					emap = elementList[e];

					if(emap<Nelements) {
						const int base = i + j*p_Nq + emap*p_Np;
						for (int k=0; k<p_Nq; k++){
							
	            s_q[es][k][j][i] = q[base + k*p_Nq*p_Nq];
							s_Aq[es][k][j][i] = 0.f;
						}
				
					

					if(es==0) // fetch D to @shared
						s_D[j][i] = D[j*p_Nq+i];
				}

				}
			}
		}

		@barrier("local");

		for(int k=0; k<p_Nq; ++k) {

			for(int es=0; es<p_NblockV; ++es; @inner(2)) {
				for(int j=0; j<p_Nq; ++j; @inner(1)) {
					for(int i=0; i<p_Nq; ++i; @inner(0)) {
						const int e = eo + es;
						emap = elementList[e];
						if(emap<Nelements) {

							// share k-slice of q
					//		s_q[es][j][i] = r_q[k];

							// hide @shared latency behind t-derivative
							dfloat qtk = 0.f;
							for(int n=0; n<p_Nq; ++n) {
								qtk += s_D[k][n]*s_q[es][n][j][i];
							}
							r_qt = qtk;

						}
					}
				}
			}

			@barrier("local");

			// process k-slice (first r- and s-derivatives)
			for(int es=0; es<p_NblockV; ++es; @inner(2)) {
				for(int j=0; j<p_Nq; ++j; @inner(1)) {
					for(int i=0; i<p_Nq; ++i; @inner(0)) {
						const int e = eo + es;
						emap = elementList[e];
						if(emap<Nelements) {
							const int base = emap*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

							const dfloat G00 = ggeo[base+p_G00ID*p_Np];
							const dfloat G01 = ggeo[base+p_G01ID*p_Np];
							const dfloat G02 = ggeo[base+p_G02ID*p_Np];
							const dfloat G11 = ggeo[base+p_G11ID*p_Np];
							const dfloat G12 = ggeo[base+p_G12ID*p_Np];
							const dfloat G22 = ggeo[base+p_G22ID*p_Np];
							const dfloat GwJ = ggeo[base+p_GWJID*p_Np];

							dfloat qr = 0.f, qs = 0.f;
							for(int n=0; n<p_Nq; ++n) {
								qr += s_D[i][n]*s_q[es][k][j][n];
								qs += s_D[j][n]*s_q[es][k][n][i];
							}

							// assumes w*J built into G entries
							s_tmpr[es][j][i] = G00*qr + G01*qs + G02*r_qt;
							s_tmps[es][j][i] = G01*qr + G11*qs + G12*r_qt;
							r_tmpt           = G02*qr + G12*qs + G22*r_qt;

							s_Aq[es][k][j][i] += GwJ*lambda*s_q[es][k][j][i];

#if 1
							for(int n=0; n<p_Nq; ++n) {
								s_Aq[es][n][j][i] += s_D[k][n]*r_tmpt;
							}
#endif
						}
					}
				}
			}

			@barrier("local");

			// second derivatives
			for(int es=0; es<p_NblockV; ++es; @inner(2)) {
				for(int j=0; j<p_Nq; ++j; @inner(1)) {
					for(int i=0; i<p_Nq; ++i; @inner(0)) {
						const int e = eo + es;
						emap = elementList[e];
						if(emap<Nelements) {

							dfloat Aq1 = 0.0f, Aq2 = 0.0f;

							for(int n=0; n<p_Nq; ++n) {
								Aq1 += s_D[n][i]*s_tmpr[es][j][n];
								Aq2 += s_D[n][j]*s_tmps[es][n][i];
							}
#if 1
							s_Aq[es][k][j][i] +=  Aq1 + Aq2;
#endif

						}
					}
				}
			}
		}//for k ()
@barrier("local");
		// write result out (local node storage)
	
		for(int es=0; es<p_NblockV; ++es; @inner(2)) {
			for(int j=0; j<p_Nq; ++j; @inner(1)) {
				for(int i=0; i<p_Nq; ++i; @inner(0)) {
					const int e = eo + es;
					emap = elementList[e];
					if(emap<Nelements) {
						int base;
							for (int k=0; k<p_Nq; k++){
							base = emap*p_Np +k*p_Nq*p_Nq+ j*p_Nq + i;
							Aq[base] = s_Aq[es][k][j][i];
						//	base+=p_Nq*p_Nq;
						}
						
					}
				}
			}
		}
	}
} //e1b


// e1c - like e6, just no interpolation. 2d i-j "slabs". 
/*
@kernel void ellipticAxHex3D_e1c(const int Nelements,
                                @restrict const  int *  elementList,
                                @restrict const  dfloat *  ggeo,
                                @restrict const  dfloat *  D,
                                const dfloat lambda,
                               @restrict const  dfloat *  q,
                               @restrict dfloat *  Aq){

for(int e=0; e<Nelements; ++e; @outer(0)){

		@shared dfloat s_tmpr[p_Nq][p_Nq];
		@shared dfloat s_tmps[p_Nq][p_Nq];
		@shared dfloat s_q[p_Nq][p_Nq][p_Nq];
		@shared dfloat s_Aq[p_Nq][p_Nq][p_Nq];

		@shared dfloat s_D[p_Nq][p_Nq];

		@exclusive dfloat  r_qt, r_tmpt, emap;
//r_q[p_Nq], r_Aq[p_Nq],
		// prefetch q(i,j,:,e) to register array
		
			for(int j=0; j<p_Nq; ++j; @inner(1)) {
				for(int i=0; i<p_Nq; ++i; @inner(0)) {
			emap = elementList[e];

					if(emap<Nelements) {
						const int base = i + j*p_Nq + emap*p_Np;
						for (int k=0; k<p_Nq; k++){
							
	            s_q[k][j][i] = q[base + k*p_Nq*p_Nq];
							s_Aq[k][j][i] = 0.f;
						}
				
					

			//		if(es==0) // fetch D to @shared
						s_D[j][i] = D[j*p_Nq+i];
				}

				}
			}
		

		@barrier("local");

		for(int k=0; k<p_Nq; ++k) {

				for(int j=0; j<p_Nq; ++j; @inner(1)) {
					for(int i=0; i<p_Nq; ++i; @inner(0)) {
					
						emap = elementList[e];
						if(emap<Nelements) {

							dfloat qtk = 0.f;
							for(int n=0; n<p_Nq; ++n) {
								qtk += s_D[k][n]*s_q[n][j][i];
							}
							r_qt = qtk;

						}
					}
				
			}

			@barrier("local");

			// process k-slice (first r- and s-derivatives)
				for(int j=0; j<p_Nq; ++j; @inner(1)) {
					for(int i=0; i<p_Nq; ++i; @inner(0)) {
						
						emap = elementList[e];
						if(emap<Nelements) {
							const int base = emap*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

							const dfloat G00 = ggeo[base+p_G00ID*p_Np];
							const dfloat G01 = ggeo[base+p_G01ID*p_Np];
							const dfloat G02 = ggeo[base+p_G02ID*p_Np];
							const dfloat G11 = ggeo[base+p_G11ID*p_Np];
							const dfloat G12 = ggeo[base+p_G12ID*p_Np];
							const dfloat G22 = ggeo[base+p_G22ID*p_Np];
							const dfloat GwJ = ggeo[base+p_GWJID*p_Np];

							dfloat qr = 0.f, qs = 0.f;
							for(int n=0; n<p_Nq; ++n) {
								
								qr += s_D[i][n]*s_q[k][j][n];
								qs += s_D[j][n]*s_q[k][n][i];
							}

							// assumes w*J built into G entries
							s_tmpr[j][i] = G00*qr + G01*qs + G02*r_qt;
							s_tmps[j][i] = G01*qr + G11*qs + G12*r_qt;
							r_tmpt           = G02*qr + G12*qs + G22*r_qt;

							s_Aq[k][j][i] += GwJ*lambda*s_q[k][j][i];

#if 1
							for(int n=0; n<p_Nq; ++n) {
								s_Aq[n][j][i] += s_D[k][n]*r_tmpt;
							}
#endif
						}
					}
				}
			

			@barrier("local");

			// second derivatives
		
				for(int j=0; j<p_Nq; ++j; @inner(1)) {
					for(int i=0; i<p_Nq; ++i; @inner(0)) {
				
						emap = elementList[e];
						if(emap<Nelements) {

							dfloat Aq1 = 0.0f, Aq2 = 0.0f;

							for(int n=0; n<p_Nq; ++n) {
								Aq1 += s_D[n][i]*s_tmpr[j][n];
								Aq2 += s_D[n][j]*s_tmps[n][i];
							}
#if 1
							s_Aq[k][j][i] +=  Aq1 + Aq2;
#endif

						}
					
				}
			}
		}//for k ()
@barrier("local");
		// write result out (local node storage)
	
	
			for(int j=0; j<p_Nq; ++j; @inner(1)) {
				for(int i=0; i<p_Nq; ++i; @inner(0)) {
				
					emap = elementList[e];
					if(emap<Nelements) {
						int base;
							for (int k=0; k<p_Nq; k++){
							base = emap*p_Np +k*p_Nq*p_Nq+ j*p_Nq + i;
							Aq[base] = s_Aq[k][j][i];
						//	base+=p_Nq*p_Nq;
						}
						
					}
				}
			
		}
	}
} //e1c
*/


// e1c - like e6, just no interpolation. 2d i-j "slabs". 

@kernel void ellipticAxHex3D_e1c(const int Nelements,
                                @restrict const  int *  elementList,
                                @restrict const  dfloat *  ggeo,
                                @restrict const  dfloat *  D,
                                const dfloat lambda,
				@restrict const  dfloat *  q,
				@restrict dfloat *  Aq){

  for(int e=0; e<Nelements; ++e; @outer(0)){

    @shared dfloat s_tmpr[p_Nq][p_Nq];
    @shared dfloat s_tmps[p_Nq][p_Nq];
    @shared dfloat s_q[p_Nq][p_Nq][p_Nq];
    @shared dfloat s_Aq[p_Nq][p_Nq][p_Nq];
    
    @shared dfloat s_D[p_Nq][p_Nq];
    
    @exclusive dfloat  r_qt, r_tmpt;
    @exclusive int emap;
    
    // prefetch q(i,j,:,e) to register array
    for(int j=0; j<p_Nq; ++j; @inner(1)) {
      for(int i=0; i<p_Nq; ++i; @inner(0)) {
	emap = elementList[e];

	const int base = i + j*p_Nq + emap*p_Np;
	for (int k=0; k<p_Nq; k++){
	  
	  s_q[k][j][i] = q[base + k*p_Nq*p_Nq];
	  s_Aq[k][j][i] = 0.f;
	} 

	s_D[j][i] = D[j*p_Nq+i];
      }
    }
    
    @barrier("local");
    
    for(int k=0; k<p_Nq; ++k) {
      
      for(int j=0; j<p_Nq; ++j; @inner(1)) {
	for(int i=0; i<p_Nq; ++i; @inner(0)) {
	  
	  dfloat qtk = 0.f;
	  for(int n=0; n<p_Nq; ++n) {
	    qtk += s_D[k][n]*s_q[n][j][i];
	  }
	  r_qt = qtk;
	}
      }
      
      @barrier("local");

      // process k-slice (first r- and s-derivatives)
      for(int j=0; j<p_Nq; ++j; @inner(1)) {
	for(int i=0; i<p_Nq; ++i; @inner(0)) {
						
	  const int base = emap*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
	  
	  const dfloat G00 = ggeo[base+p_G00ID*p_Np];
	  const dfloat G01 = ggeo[base+p_G01ID*p_Np];
	  const dfloat G02 = ggeo[base+p_G02ID*p_Np];
	  const dfloat G11 = ggeo[base+p_G11ID*p_Np];
	  const dfloat G12 = ggeo[base+p_G12ID*p_Np];
	  const dfloat G22 = ggeo[base+p_G22ID*p_Np];
	  const dfloat GwJ = ggeo[base+p_GWJID*p_Np];
	  
	  dfloat qr = 0.f, qs = 0.f;
	  for(int n=0; n<p_Nq; ++n) {
	    
	    qr += s_D[i][n]*s_q[k][j][n];
	    qs += s_D[j][n]*s_q[k][n][i];
	  }
	  
	  // assumes w*J built into G entries
	  s_tmpr[j][i] = G00*qr + G01*qs + G02*r_qt;
	  s_tmps[j][i] = G01*qr + G11*qs + G12*r_qt;
	  r_tmpt           = G02*qr + G12*qs + G22*r_qt;
	  
	  s_Aq[k][j][i] += GwJ*lambda*s_q[k][j][i];
	  
	  for(int n=0; n<p_Nq; ++n) {
	    s_Aq[n][j][i] += s_D[k][n]*r_tmpt;
	  }
	}
      }
      
      
      @barrier("local");
      
      // second derivatives
		
      for(int j=0; j<p_Nq; ++j; @inner(1)) {
	for(int i=0; i<p_Nq; ++i; @inner(0)) {

	  dfloat Aq1 = 0.0f, Aq2 = 0.0f;
	  
	  for(int n=0; n<p_Nq; ++n) {
	    Aq1 += s_D[n][i]*s_tmpr[j][n];
	    Aq2 += s_D[n][j]*s_tmps[n][i];
	  }
	  
	  s_Aq[k][j][i] +=  Aq1 + Aq2;
	}
      }
    }//for k ()

    @barrier("local");

    // write result out (local node storage)
    for(int j=0; j<p_Nq; ++j; @inner(1)) {
      for(int i=0; i<p_Nq; ++i; @inner(0)) {
				
	for (int k=0; k<p_Nq; k++){
	  int base = emap*p_Np +k*p_Nq*p_Nq+ j*p_Nq + i;
	  Aq[base] = s_Aq[k][j][i];
	}
      }
    }
  }

} //e1c


//e1c0 - loop with k internal not external

@kernel void ellipticAxHex3D_e1c0(const int Nelements,
                                @restrict const  int *  elementList,
                                @restrict const  dfloat *  ggeo,
                                @restrict const  dfloat *  D,
                                const dfloat lambda,
                               @restrict const  dfloat *  q,
                               @restrict dfloat *  Aq){

for(int e=0; e<Nelements; ++e; @outer(0)){

		@shared dfloat s_tmpr[p_Nq][p_Nq];
		@shared dfloat s_tmps[p_Nq][p_Nq];
		@shared dfloat s_q[p_Nq][p_Nq][p_Nq];
		@shared dfloat s_Aq[p_Nq][p_Nq][p_Nq];

		@shared dfloat s_D[p_Nq][p_Nq];

		@exclusive dfloat  r_qt, r_tmpt, emap;
//r_q[p_Nq], r_Aq[p_Nq],
		// prefetch q(i,j,:,e) to register array
		
			for(int j=0; j<p_Nq; ++j; @inner(1)) {
				for(int i=0; i<p_Nq; ++i; @inner(0)) {
			emap = elementList[e];

					if(emap<Nelements) {
						const int base = i + j*p_Nq + emap*p_Np;
						for (int k=0; k<p_Nq; k++){
							
	            s_q[k][j][i] = q[base + k*p_Nq*p_Nq];
						//	s_Aq[k][j][i] = 0.f;
						}
				
					

			//		if(es==0) // fetch D to @shared
						s_D[j][i] = D[j*p_Nq+i];
				}

				}
			}
		

		@barrier("local");

		

				for(int j=0; j<p_Nq; ++j; @inner(1)) {
					for(int i=0; i<p_Nq; ++i; @inner(0)) {
					for(int k=0; k<p_Nq; ++k) {
						emap = elementList[e];
						if(emap<Nelements) {

							dfloat qtk = 0.f;
							for(int n=0; n<p_Nq; ++n) {
								qtk += s_D[k][n]*s_q[n][j][i];
							}
							r_qt = qtk;

						}
					}}
				
			}

			@barrier("local");

			// process k-slice (first r- and s-derivatives)
				for(int j=0; j<p_Nq; ++j; @inner(1)) {
					for(int i=0; i<p_Nq; ++i; @inner(0)) {
						for(int k=0; k<p_Nq; ++k) {
						emap = elementList[e];
						if(emap<Nelements) {
							const int base = emap*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

							const dfloat G00 = ggeo[base+p_G00ID*p_Np];
							const dfloat G01 = ggeo[base+p_G01ID*p_Np];
							const dfloat G02 = ggeo[base+p_G02ID*p_Np];
							const dfloat G11 = ggeo[base+p_G11ID*p_Np];
							const dfloat G12 = ggeo[base+p_G12ID*p_Np];
							const dfloat G22 = ggeo[base+p_G22ID*p_Np];
							const dfloat GwJ = ggeo[base+p_GWJID*p_Np];

							dfloat qr = 0.f, qs = 0.f;
							for(int n=0; n<p_Nq; ++n) {
								
								qr += s_D[i][n]*s_q[k][j][n];
								qs += s_D[j][n]*s_q[k][n][i];
							}

							// assumes w*J built into G entries
							s_tmpr[j][i] = G00*qr + G01*qs + G02*r_qt;
							s_tmps[j][i] = G01*qr + G11*qs + G12*r_qt;
							r_tmpt           = G02*qr + G12*qs + G22*r_qt;

							s_Aq[k][j][i] += GwJ*lambda*s_q[k][j][i];

#if 1
							for(int n=0; n<p_Nq; ++n) {
								s_Aq[n][j][i] += s_D[k][n]*r_tmpt;
							}
#endif
						}
					}
				}
				}
			

			@barrier("local");

			// second derivatives
		
				for(int j=0; j<p_Nq; ++j; @inner(1)) {
					for(int i=0; i<p_Nq; ++i; @inner(0)) {
				for(int k=0; k<p_Nq; ++k) {
						emap = elementList[e];
						if(emap<Nelements) {

							dfloat Aq1 = 0.0f, Aq2 = 0.0f;

							for(int n=0; n<p_Nq; ++n) {
								Aq1 += s_D[n][i]*s_tmpr[j][n];
								Aq2 += s_D[n][j]*s_tmps[n][i];
							}
							
							
#if 1
							s_Aq[k][j][i] +=  Aq1 + Aq2;
#endif

						}
					
				}
			}
		}//for k ()
@barrier("local");
		// write result out (local node storage)
	
	
			for(int j=0; j<p_Nq; ++j; @inner(1)) {
				for(int i=0; i<p_Nq; ++i; @inner(0)) {
				
					emap = elementList[e];
					if(emap<Nelements) {
						int base;
							for (int k=0; k<p_Nq; k++){
							base = emap*p_Np +k*p_Nq*p_Nq+ j*p_Nq + i;
							Aq[base] = s_Aq[k][j][i];
						//	base+=p_Nq*p_Nq;
						}
						
					}
				}
			
		}
	}
} //e1c0 end



// e1d - thicker slices -> this works for N=9, in theory of course

#define p_sliceThickness 4
@kernel void ellipticAxHex3D_e1d(const int Nelements,
                                @restrict const  int *  elementList,
                                @restrict const  dfloat *  ggeo,
                                @restrict const  dfloat *  D,
                                const dfloat lambda,
                                @restrict const  dfloat *  q,
                                @restrict dfloat *  Aq){

for(int e=0; e<Nelements; ++e; @outer(0)){

		@shared dfloat s_tmpr[p_Nq][p_Nq];
		@shared dfloat s_tmps[p_Nq][p_Nq];
		@shared dfloat s_q[p_Nq][p_Nq][p_Nq];
		@shared dfloat s_Aq[p_Nq][p_Nq][p_Nq];

		@shared dfloat s_D[p_Nq][p_Nq];

		@exclusive dfloat  r_qt, r_tmpt, emap;
//r_q[p_Nq], r_Aq[p_Nq],
		// prefetch q(i,j,:,e) to register array
		
			for(int j=0; j<p_Nq; ++j; @inner(1)) {
				for(int i=0; i<p_Nq; ++i; @inner(0)) {
					emap = elementList[e];

					if(emap<Nelements) {
						const int base = i + j*p_Nq + emap*p_Np;
						for (int k=0; k<p_Nq; k+=p_sliceThickness){
							if (k<p_Nq)
							{
	            s_q[k][j][i] = q[base + k*p_Nq*p_Nq];
							s_Aq[k][j][i] = 0.f;
							}
						}
				
					

			//		if(es==0) // fetch D to @shared
						s_D[j][i] = D[j*p_Nq+i];
				}

				}
			}
		

		@barrier("local");

		for(int k=0; k<p_Nq; k+=p_sliceThickness) {

				for(int j=0; j<p_Nq; ++j; @inner(1)) {
					for(int i=0; i<p_Nq; ++i; @inner(0)) {
					if (k<p_Nq){
						emap = elementList[e];
						if(emap<Nelements) {

							dfloat qtk = 0.f;
							for(int n=0; n<p_Nq; ++n) {
								qtk += s_D[k][n]*s_q[n][j][i];
							}
							r_qt = qtk;

					}
					}
					}
				
			}

			@barrier("local");

			// process k-slice (first r- and s-derivatives)
				for(int j=0; j<p_Nq; ++j; @inner(1)) {
					for(int i=0; i<p_Nq; ++i; @inner(0)) {
						
						emap = elementList[e];
						if(emap<Nelements) {
							const int base = emap*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

							const dfloat G00 = ggeo[base+p_G00ID*p_Np];
							const dfloat G01 = ggeo[base+p_G01ID*p_Np];
							const dfloat G02 = ggeo[base+p_G02ID*p_Np];
							const dfloat G11 = ggeo[base+p_G11ID*p_Np];
							const dfloat G12 = ggeo[base+p_G12ID*p_Np];
							const dfloat G22 = ggeo[base+p_G22ID*p_Np];
							const dfloat GwJ = ggeo[base+p_GWJID*p_Np];

							dfloat qr = 0.f, qs = 0.f;
							for(int n=0; n<p_Nq; ++n) {
								
								qr += s_D[i][n]*s_q[k][j][n];
								qs += s_D[j][n]*s_q[k][n][i];
							}

							// assumes w*J built into G entries
							s_tmpr[j][i] = G00*qr + G01*qs + G02*r_qt;
							s_tmps[j][i] = G01*qr + G11*qs + G12*r_qt;
							r_tmpt           = G02*qr + G12*qs + G22*r_qt;

							s_Aq[k][j][i] += GwJ*lambda*s_q[k][j][i];

#if 1
							for(int n=0; n<p_Nq; ++n) {
								s_Aq[n][j][i] += s_D[k][n]*r_tmpt;
							}
#endif
						}
					}
				}
			

			@barrier("local");

			// second derivatives
		
				for(int j=0; j<p_Nq; ++j; @inner(1)) {
					for(int i=0; i<p_Nq; ++i; @inner(0)) {
				
						emap = elementList[e];
						if(emap<Nelements) {

							dfloat Aq1 = 0.0f, Aq2 = 0.0f;

							for(int n=0; n<p_Nq; ++n) {
								Aq1 += s_D[n][i]*s_tmpr[j][n];
								Aq2 += s_D[n][j]*s_tmps[n][i];
							}
#if 1
							s_Aq[k][j][i] +=  Aq1 + Aq2;
#endif

						}
					
				}
			}
		}//for k ()
@barrier("local");
		// write result out (local node storage)
	
	
			for(int j=0; j<p_Nq; ++j; @inner(1)) {
				for(int i=0; i<p_Nq; ++i; @inner(0)) {
				
					emap = elementList[e];
					if(emap<Nelements) {
						int base;
							for (int k=0; k<p_Nq; k++){
							base = emap*p_Np +k*p_Nq*p_Nq+ j*p_Nq + i;
							Aq[base] = s_Aq[k][j][i];
						//	base+=p_Nq*p_Nq;
						}
						
					}
				}
			
		}
	}
} //e1d








/*
   I = interp;
   D = diff and interp;

   qr_{kji} =  I_{jb} D_{ia} I_{kc} q_{cba};
   qs_{kji} =  D_{jb} I_{ia} I_{kc} q_{cba};
   qt_{kji} =  I_{jb} I_{ia} D_{kc} q_{cba};

   w*J*G*grad q = WJG*[qr;qs;qt];

   lap_{cba} =
   I_{ck} I_{bj} D_{ai} qr_{kji} +
   I_{ck} D_{bj} I_{ai} qs_{kji} +
   D_{ck} I_{bj} I_{ai} qt_{kji} ;
 */

#define p_gjNp (p_gjNq*p_gjNq*p_gjNq)
#define p_gjNq2 (p_gjNq*p_gjNq)
#define p_Nq2 (p_Nq*p_Nq)

#if ((p_NblockG*p_gjNq*p_gjNq)<=32)
#define optBarrier(op)
#else
#define optBarrier(op) barrier(op)
#endif


/* note that the gjGeo must be the geometric factors at the p_gjNp integration nodes */
@kernel void ellipticAxHex3D_e2(const int Nelements,
                               @restrict const  dfloat *  gjGeo,
                               @restrict const  dfloat *  gjD,
                               @restrict const  dfloat *  gjI,
                               const dfloat lambda,
                               @restrict const  dfloat *  q,
                               @restrict dfloat *  Aq){

	for(int e=0; e<Nelements; ++e; @outer(0)) {

		@shared dfloat s_D[p_gjNq][p_Nq];
		@shared dfloat s_I[p_gjNq][p_Nq];

		@exclusive dfloat r_Iq[p_gjNq], r_Dq[p_gjNq], r_lapq[p_Nq];

		@shared dfloat s_Ixxq[p_Nq][p_Nq],  s_Dxxq[p_Nq][p_Nq];
		@shared dfloat s_IxDq[p_Nq][p_gjNq], s_IxIq[p_Nq][p_gjNq], s_DxIq[p_Nq][p_gjNq];
		@shared dfloat s_qr[p_gjNq][p_gjNq], s_qs[p_gjNq][p_gjNq], s_qt[p_gjNq][p_gjNq];
		@shared dfloat s_Dqr[p_gjNq][p_Nq], s_Iqs[p_gjNq][p_Nq], s_Iqt[p_gjNq][p_Nq];

		// prefetch D and I matrices and zero register storage
		for(int b=0; b<p_gjNq; ++b; @inner(1)) {
			for(int a=0; a<p_gjNq; ++a; @inner(0)) {
				int t = a + b*p_gjNq;
				if(t<p_gjNq*p_Nq) {
					s_D[0][t] = gjD[t];
					s_I[0][t] = gjI[t];
				}

				for(int k=0; k<p_gjNq; ++k) {
					r_Iq[k] = 0;
					r_Dq[k] = 0;
				}

				for(int c=0; c<p_Nq; ++c) {
					r_lapq[c] = 0;
				}
			}
		}

		@barrier("local");

		//  interpolate and differentiate in 't'
		for(int c=0; c<p_Nq; ++c) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int a=0; a<p_gjNq; ++a; @inner(0)) {
					if(a<p_Nq && b<p_Nq) {
						const dfloat qcba = q[e*p_Np+c*p_Nq2+b*p_Nq+a];
						for(int k=0; k<p_gjNq; ++k) {
							// I_{kc} q_{cba}
							r_Iq[k] += s_I[k][c]*qcba;
							r_Dq[k] += s_D[k][c]*qcba;
						}
					}
				}
			}
		}

		// scan through k slices
		for(int k=0; k<p_gjNq; ++k) {

			@barrier("local");

			// prefetch slice
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int a=0; a<p_gjNq; ++a; @inner(0)) {

					if(a<p_Nq && b<p_Nq) {
						s_Ixxq[b][a] = r_Iq[k];
						s_Dxxq[b][a] = r_Dq[k];
					}
				}
			}

			@barrier("local");

			// interpolate and differentiate in 'r' direction
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {

					if(b<p_Nq) {
						dfloat IxDq= 0, IxIq = 0, DxIq = 0;

						for(int a=0; a<p_Nq; ++a) {
							IxDq += s_D[i][a]*s_Ixxq[b][a];
							IxIq += s_I[i][a]*s_Ixxq[b][a];
							DxIq += s_I[i][a]*s_Dxxq[b][a];
						}

						s_IxDq[b][i] = IxDq;
						s_IxIq[b][i] = IxIq;
						s_DxIq[b][i] = DxIq;
					}
				}
			}

			@barrier("local");

			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {

					const int base = e*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;

					// assumes w*J built into G entries
					//	  const dfloat r_GwJ = gjGeo[base+p_GWJID*p_gjNp];

					const dfloat r_G00 = gjGeo[base+p_G00ID*p_gjNp];
					const dfloat r_G01 = gjGeo[base+p_G01ID*p_gjNp];
					const dfloat r_G02 = gjGeo[base+p_G02ID*p_gjNp];

					const dfloat r_G11 = gjGeo[base+p_G11ID*p_gjNp];
					const dfloat r_G12 = gjGeo[base+p_G12ID*p_gjNp];
					const dfloat r_G22 = gjGeo[base+p_G22ID*p_gjNp];

					dfloat qr = 0, qs = 0, qt = 0;

					// interpolate and differentiate in 's' direction
					for(int n=0; n<p_Nq; ++n) {
						qr += s_I[j][n]*s_IxDq[n][i];
						qs += s_D[j][n]*s_IxIq[n][i];
						qt += s_I[j][n]*s_DxIq[n][i];
					}

					// apply chain rule
					s_qr[j][i] = r_G00*qr + r_G01*qs + r_G02*qt;
					s_qs[j][i] = r_G01*qr + r_G11*qs + r_G12*qt;
					s_qt[j][i] = r_G02*qr + r_G12*qs + r_G22*qt;
				}
			}

			@barrier("local");

			// transpose differentiate and interpolate in 'r'
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int a=0; a<p_gjNq; ++a; @inner(0)) {

					if(a<p_Nq) {
						dfloat tmpr = 0, tmps = 0, tmpt = 0;
						for(int i=0; i<p_gjNq; ++i) {
							tmpr += s_D[i][a]*s_qr[j][i];
							tmps += s_I[i][a]*s_qs[j][i];
							tmpt += s_I[i][a]*s_qt[j][i];
						}

						s_Dqr[j][a] = tmpr;
						s_Iqs[j][a] = tmps;
						s_Iqt[j][a] = tmpt;
					}
				}
			}

			@barrier("local");

			// transpose differentiate and interpolate in 's'
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int a=0; a<p_gjNq; ++a; @inner(0)) {

					if(b<p_Nq && a<p_Nq) {
						dfloat tmpr = 0, tmps = 0, tmpt = 0;
						for(int j=0; j<p_gjNq; ++j) {
							tmpr += s_I[j][b]*s_Dqr[j][a];
							tmps += s_D[j][b]*s_Iqs[j][a];
							tmpt += s_I[j][b]*s_Iqt[j][a];
						}

						// transpose differentiate and interpolate in 't'
						for(int c=0; c<p_Nq; ++c) {
							r_lapq[c] += s_I[k][c]*(tmpr+tmps);
							r_lapq[c] += s_D[k][c]*tmpt;
						}
					}
				}
			}
		}

		for(int b=0; b<p_gjNq; ++b; @inner(1)) {
			for(int a=0; a<p_gjNq; ++a; @inner(0)) {

				if(a<p_Nq && b<p_Nq) { // bad
					for(int c=0; c<p_Nq; ++c) {
						Aq[e*p_Np + c*p_Nq2 + b*p_Nq + a] = r_lapq[c];
					}
				}
			}
		}
	}
}

/* note that the gjGeo must be the geometric factors at the p_gjNp integration nodes */
@kernel void ellipticAxHex3D_e3(const int Nelements,
                               @restrict const  dfloat *  gjGeo,
                               @restrict const  dfloat *  gjD,
                               @restrict const  dfloat *  gjI,
                               const dfloat lambda,
                               @restrict const  dfloat *  q,
                               @restrict dfloat *  Aq){

	for(int eo=0; eo<Nelements; eo+=p_NblockG; @outer(0)) {

		@shared dfloat s_D[p_gjNq][p_Nq];
		@shared dfloat s_I[p_gjNq][p_Nq];

		@exclusive dfloat r_Iq[p_gjNq], r_Dq[p_gjNq], r_lapq[p_Nq];
		//    @exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22;

		@shared dfloat s_Ixxq[p_NblockG][p_Nq][p_Nq],  s_Dxxq[p_NblockG][p_Nq][p_Nq];
		@shared dfloat s_IxDq[p_NblockG][p_Nq][p_gjNq], s_IxIq[p_NblockG][p_Nq][p_gjNq], s_DxIq[p_NblockG][p_Nq][p_gjNq];
		@shared dfloat s_qr[p_NblockG][p_gjNq][p_gjNq], s_qs[p_NblockG][p_gjNq][p_gjNq], s_qt[p_NblockG][p_gjNq][p_gjNq];
		@shared dfloat s_Dqr[p_NblockG][p_gjNq][p_Nq], s_Iqs[p_NblockG][p_gjNq][p_Nq], s_Iqt[p_NblockG][p_gjNq][p_Nq];

		// prefetch D and I matrices and zero register storage
		for(int es=0; es<p_NblockG; ++es; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int a=0; a<p_gjNq; ++a; @inner(0)) {
					int t = a + b*p_gjNq + es*p_gjNq*p_gjNq;
					if(t<p_gjNq*p_Nq) {
						s_D[0][t] = gjD[t];
						s_I[0][t] = gjI[t];
					}

					for(int k=0; k<p_gjNq; ++k) {
						r_Iq[k] = 0;
						r_Dq[k] = 0;
					}

					for(int c=0; c<p_Nq; ++c) {
						r_lapq[c] = 0;
					}
				}
			}
		}

		@barrier("local");

		//  interpolate and differentiate in 't'

		for(int c=0; c<p_Nq; ++c) {
			for(int es=0; es<p_NblockG; ++es; @inner(2)) {
				for(int b=0; b<p_gjNq; ++b; @inner(1)) {
					for(int a=0; a<p_gjNq; ++a; @inner(0)) {
						int t = a + b*p_gjNq;
						if(t<p_Nq*p_Nq) { // a<p_Nq && b<p_Nq){
							int e = eo+es;
							if(e<Nelements) {
								const dfloat qcba = q[e*p_Np+c*p_Nq2+t];

								#pragma unroll p_gjNq
								for(int k=0; k<p_gjNq; ++k) {
									// I_{kc} q_{cba}
									r_Iq[k] += s_I[k][c]*qcba;
									r_Dq[k] += s_D[k][c]*qcba;
								}
							}
						}
					}
				}
			}
		}


		// scan through k slices
		for(int k=0; k<p_gjNq; ++k) {

			@barrier("local");

			// prefetch slice
			for(int es=0; es<p_NblockG; ++es; @inner(2)) {
				for(int b=0; b<p_gjNq; ++b; @inner(1)) {
					for(int a=0; a<p_gjNq; ++a; @inner(0)) {

						int t = a+b*p_gjNq;
						if(t<p_Nq*p_Nq) {
							s_Ixxq[es][0][t] = r_Iq[k];
							s_Dxxq[es][0][t] = r_Dq[k];
						}
					}
				}
			}

			@barrier("local");

			// interpolate and differentiate in 'r' direction
			for(int es=0; es<p_NblockG; ++es; @inner(2)) {
				for(int b=0; b<p_gjNq; ++b; @inner(1)) {
					for(int i=0; i<p_gjNq; ++i; @inner(0)) {

						if(b<p_Nq) {
							dfloat IxDq= 0, IxIq = 0, DxIq = 0;

							#pragma unroll p_Nq
							for(int a=0; a<p_Nq; ++a) {
								IxDq += s_D[i][a]*s_Ixxq[es][b][a];
								IxIq += s_I[i][a]*s_Ixxq[es][b][a];
								DxIq += s_I[i][a]*s_Dxxq[es][b][a];
							}

							s_IxDq[es][b][i] = IxDq;
							s_IxIq[es][b][i] = IxIq;
							s_DxIq[es][b][i] = DxIq;
						}
					}
				}
			}

			@barrier("local");

			for(int es=0; es<p_NblockG; ++es; @inner(2)) {
				for(int j=0; j<p_gjNq; ++j; @inner(1)) {
					for(int i=0; i<p_gjNq; ++i; @inner(0)) {

						int e = eo+es;
						if(e<Nelements) {

							dfloat qr = 0, qs = 0, qt = 0;

							// interpolate and differentiate in 's' direction
							#pragma unroll p_Nq
							for(int n=0; n<p_Nq; ++n) {
								qr += s_I[j][n]*s_IxDq[es][n][i];
								qs += s_D[j][n]*s_IxIq[es][n][i];
								qt += s_I[j][n]*s_DxIq[es][n][i];
							}

							const int base = e*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;

							// assumes w*J built into G entries
							//	      dfloat r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
							dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22;
							r_G00 = gjGeo[base+p_G00ID*p_gjNp];
							r_G01 = gjGeo[base+p_G01ID*p_gjNp];
							r_G02 = gjGeo[base+p_G02ID*p_gjNp];

							r_G11 = gjGeo[base+p_G11ID*p_gjNp];
							r_G12 = gjGeo[base+p_G12ID*p_gjNp];
							r_G22 = gjGeo[base+p_G22ID*p_gjNp];

							// apply chain rule
							s_qr[es][j][i] = r_G00*qr + r_G01*qs + r_G02*qt;
							s_qs[es][j][i] = r_G01*qr + r_G11*qs + r_G12*qt;
							s_qt[es][j][i] = r_G02*qr + r_G12*qs + r_G22*qt;
						}
					}
				}
			}

			@barrier("local");

			// transpose differentiate and interpolate in 'r'
			for(int es=0; es<p_NblockG; ++es; @inner(2)) {
				for(int j=0; j<p_gjNq; ++j; @inner(1)) {
					for(int a=0; a<p_gjNq; ++a; @inner(0)) {

						if(a<p_Nq) {
							dfloat tmpr = 0, tmps = 0, tmpt = 0;
							#pragma unroll p_gjNq
							for(int i=0; i<p_gjNq; ++i) {
								tmpr += s_D[i][a]*s_qr[es][j][i];
								tmps += s_I[i][a]*s_qs[es][j][i];
								tmpt += s_I[i][a]*s_qt[es][j][i];
							}

							s_Dqr[es][j][a] = tmpr;
							s_Iqs[es][j][a] = tmps;
							s_Iqt[es][j][a] = tmpt;
						}
					}
				}
			}

			@barrier("local");

			// transpose differentiate and interpolate in 's'
			for(int es=0; es<p_NblockG; ++es; @inner(2)) {
				for(int b=0; b<p_gjNq; ++b; @inner(1)) {
					for(int a=0; a<p_gjNq; ++a; @inner(0)) {
						int t = a+p_gjNq*b;
						int ta = t%p_Nq; // need to know a,b for contiguous threads
						int tb = t/p_Nq;
						if(t<p_Nq*p_Nq) {
							dfloat tmpr = 0, tmps = 0, tmpt = 0;

							#pragma unroll p_gjNq
							for(int j=0; j<p_gjNq; ++j) {
								tmpr += s_I[j][tb]*s_Dqr[es][j][ta];
								tmps += s_D[j][tb]*s_Iqs[es][j][ta];
								tmpt += s_I[j][tb]*s_Iqt[es][j][ta];
							}

							// transpose differentiate and interpolate in 't'
							#pragma unroll p_Nq
							for(int c=0; c<p_Nq; ++c) {
								r_lapq[c] += s_I[k][c]*(tmpr+tmps);
								r_lapq[c] += s_D[k][c]*tmpt;
							}
						}
					}
				}
			}
		}

		for(int es=0; es<p_NblockG; ++es; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int a=0; a<p_gjNq; ++a; @inner(0)) {
					int t = a+b*p_gjNq;
					if(t<p_Nq*p_Nq) {
						int e = eo+es;
						if(e<Nelements) {
							for(int c=0; c<p_Nq; ++c) {
								Aq[e*p_Np + c*p_Nq2 + t] = r_lapq[c];
							}
						}
					}
				}
			}
		}
	}
}

#define p_Nthreads  (p_NblockG*p_gjNq*p_gjNq)

#define allThreads                              \
	for(int es=0; es<p_NblockG; ++es; @inner(2))        \
		for(int b=0; b<p_gjNq; ++b; @inner(1))            \
			for(int a=0; a<p_gjNq; ++a; @inner(0))


#if p_gNq==8 || p_gNq==16
#define p_gjPad 1
#else
#define p_gjPad 0
#endif

#if p_Nq==8 || p_Nq==16
#define p_gllPad 1
#else
#define p_gllPad 0
#endif

#define p_gllPad 0
#define p_gjPad 0

/* note that the gjGeo must be the geometric factors at the p_gjNp integration nodes */
@kernel void ellipticPartialAxHex3D_e3(const int Nelements,
                                      @restrict const  int *  elementList,
                                      @restrict const  dfloat *  gjGeo,
                                      @restrict const  dfloat *  gjD,
                                      @restrict const  dfloat *  gjI,
                                      const dfloat lambda,
                                      @restrict const  dfloat *  q,
                                      @restrict dfloat *  Aq,
                                      @restrict dfloat *  qAq){


	for(int eo=0; eo<Nelements; eo+=p_NblockG; @outer(0)) {

		@shared dfloat s_D[p_gjNq][p_Nq+p_gllPad];
		@shared dfloat s_I[p_gjNq][p_Nq+p_gllPad];

		@shared dfloat s_DT[p_Nq][p_gjNq+p_gjPad];
		@shared dfloat s_IT[p_Nq][p_gjNq+p_gllPad];

		@exclusive dfloat r_q[p_Nq];
		@exclusive dfloat r_lapq[p_Nq];

		@shared dfloat s_Ixxq[p_NblockG][p_Nq][p_Nq+p_gllPad];
		@shared dfloat s_Dxxq[p_NblockG][p_Nq][p_Nq+p_gllPad];
		@shared dfloat s_IxDq[p_NblockG][p_Nq][p_gjNq+p_gjPad];
		@shared dfloat s_IxIq[p_NblockG][p_Nq][p_gjNq+p_gjPad];
		@shared dfloat s_DxIq[p_NblockG][p_Nq][p_gjNq+p_gjPad];
		@shared dfloat s_qr[p_NblockG][p_gjNq][p_gjNq+p_gjPad];
		@shared dfloat s_qs[p_NblockG][p_gjNq][p_gjNq+p_gjPad];
		@shared dfloat s_qt[p_NblockG][p_gjNq][p_gjNq+p_gjPad];

#if 1
		@shared dfloat s_Dqr[p_NblockG][p_gjNq][p_Nq+p_gllPad];
		@shared dfloat s_Iqs[p_NblockG][p_gjNq][p_Nq+p_gllPad];
		@shared dfloat s_Iqt[p_NblockG][p_gjNq][p_Nq+p_gllPad];
#else
#define s_Dqr s_IxDq
#define s_Iqs s_IxIq
#define s_Iqt s_DxIq
#endif

		@shared dfloat s_qI[p_NblockG][p_gjNq][p_gjNq+p_gjPad];

		@exclusive int emap;
		@exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;

		// prefetch D and I matrices and zero register storage
		for(int es=0; es<p_NblockG; ++es; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int a=0; a<p_gjNq; ++a; @inner(0)) {
					int t = a + b*p_gjNq + es*p_gjNq*p_gjNq;

					if(t<p_gjNq*p_Nq) {
						const int tb = t/p_Nq;
						const int ta = t%p_Nq;
#if 1
						s_D[tb][ta] = gjD[t];
						s_I[tb][ta] = gjI[t];
						s_DT[ta][tb] = gjD[t];
						s_IT[ta][tb] = gjI[t];
#endif

					}

					for(int c=0; c<p_Nq; ++c) {
						r_q[c] = 0;
						r_lapq[c] = 0;
					}

					int e = eo+es;
					if(e<Nelements) {
						emap = elementList[e];

						if(a<p_Nq && b<p_Nq) {

							#pragma unroll p_Nq
							for(int c=0; c<p_Nq; ++c) {
								r_q[c] = q[emap*p_Np+c*p_Nq2+b*p_Nq+a];
							}
						}

					}
					else
						emap = -999999;

				}
			}
		}

		// scan through k slices

		for(int k=0; k<p_gjNq; ++k) {

			optBarrier(localMemFence);

			// prefetch slice
			for(int es=0; es<p_NblockG; ++es; @inner(2)) {
				for(int b=0; b<p_gjNq; ++b; @inner(1)) {
					for(int a=0; a<p_gjNq; ++a; @inner(0)) {

						if(eo+es<Nelements) {

							const int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + b*p_gjNq + a;

							r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
							r_G00 = gjGeo[base+p_G00ID*p_gjNp];
							r_G01 = gjGeo[base+p_G01ID*p_gjNp];
							r_G02 = gjGeo[base+p_G02ID*p_gjNp];

							// assumes w*J built into G entries
							//dfloat	 r_G00, r_G01, r_G02, r_G11, r_G12, r_G22;

							if(a<p_Nq && b<p_Nq) {

								dfloat Iqk = 0, Dqk = 0;

								// puts more data in flight
								for(int c=0; c<p_Nq; ++c) {
									const dfloat qcba = r_q[c];
									//		  const dfloat qcba = q[emap*p_Np+c*p_Nq2+b*p_Nq+a];
									// I_{kc} q_{cba}
#if 1
									Iqk += s_I[k][c]*qcba;
									Dqk += s_D[k][c]*qcba;
#else
									Iqk += c_I[k][c]*qcba;
									Dqk += c_D[k][c]*qcba;
#endif
								}
								s_Ixxq[es][b][a] = Iqk;
								s_Dxxq[es][b][a] = Dqk;
							}
						}
					}
				}
			}

			optBarrier(localMemFence);

			// interpolate and differentiate in 'r' direction
			for(int es=0; es<p_NblockG; ++es; @inner(2)) {
				for(int b=0; b<p_gjNq; ++b; @inner(1)) {
					for(int i=0; i<p_gjNq; ++i; @inner(0)) {

						if(es+eo<Nelements) {

							if(b<p_Nq) {
								dfloat IxDq= 0, IxIq = 0, DxIq = 0;

								//		#pragma unroll p_Nq
								for(int a=0; a<p_Nq; ++a) {
#if 1
									const dfloat Iia = s_I[i][a];
									const dfloat Dia = s_D[i][a];
									const dfloat Ixxqba = s_Ixxq[es][b][a];
									IxDq += Dia*Ixxqba;
									IxIq += Iia*Ixxqba;
									DxIq += Iia*s_Dxxq[es][b][a];
#else
									IxDq += s_DT[a][i]*s_Ixxq[es][b][a];
									IxIq += s_IT[a][i]*s_Ixxq[es][b][a];
									DxIq += s_IT[a][i]*s_Dxxq[es][b][a];
#endif
								}

								s_IxDq[es][b][i] = IxDq;
								s_IxIq[es][b][i] = IxIq;
								s_DxIq[es][b][i] = DxIq;
							}
						}
					}
				}
			}

			optBarrier(localMemFence);

			for(int es=0; es<p_NblockG; ++es; @inner(2)) {
				for(int j=0; j<p_gjNq; ++j; @inner(1)) {
					for(int i=0; i<p_gjNq; ++i; @inner(0)) {

						if(eo+es<Nelements) {


							dfloat qr = 0, qs = 0, qt = 0, qI = 0;

							// interpolate and differentiate in 's' direction
							//	      #pragma unroll p_Nq
							for(int n=0; n<p_Nq; ++n) {
#if 0
								const dfloat Ijn = s_I[j][n];
								const dfloat Djn = s_D[j][n];
								qr += Ijn*s_IxDq[es][n][i];
								qt += Ijn*s_DxIq[es][n][i];
								qI += Ijn*s_IxIq[es][n][i];
								qs += Djn*s_IxIq[es][n][i];

#else
								const dfloat Ijn = s_IT[n][j];
								const dfloat Djn = s_DT[n][j];
								const dfloat IxIqni = s_IxIq[es][n][i];
								qr += Ijn*s_IxDq[es][n][i];
								qt += Ijn*s_DxIq[es][n][i];
								qI += Ijn*IxIqni;
								qs += Djn*IxIqni;

#endif
							}

							const int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;

							r_G11 = gjGeo[base+p_G11ID*p_gjNp];
							r_G12 = gjGeo[base+p_G12ID*p_gjNp];
							r_G22 = gjGeo[base+p_G22ID*p_gjNp];

							// apply chain rule (notice the swtich of indices in i,j)
							s_qr[es][i][j] = r_G00*qr + r_G01*qs + r_G02*qt;
							s_qs[es][i][j] = r_G01*qr + r_G11*qs + r_G12*qt;
							s_qt[es][i][j] = r_G02*qr + r_G12*qs + r_G22*qt;
							s_qI[es][i][j] = r_GwJ*qI*lambda;
						}
					}
				}
			}

			optBarrier(localMemFence);

			// transpose differentiate and interpolate in 'r'
			for(int es=0; es<p_NblockG; ++es; @inner(2)) {
				for(int j=0; j<p_gjNq; ++j; @inner(1)) {
					for(int a=0; a<p_gjNq; ++a; @inner(0)) {

						if(eo+es<Nelements) {
							if(a<p_Nq) {
								dfloat tmpr = 0, tmps = 0, tmpt = 0, tmpI = 0;
								//		#pragma unroll p_gjNq
								for(int i=0; i<p_gjNq; ++i) {
#if 1
									const dfloat Iia = s_I[i][a];
									const dfloat Dia = s_D[i][a];
									tmpr += Dia*s_qr[es][i][j];
									tmps += Iia*s_qs[es][i][j];
									tmpt += Iia*s_qt[es][i][j];
									tmpI += Iia*s_qI[es][i][j];
#else
									tmpr += s_DT[a][i]*s_qr[es][i][j];
									tmps += s_IT[a][i]*s_qs[es][i][j];
									tmpt += s_IT[a][i]*s_qt[es][i][j];
									tmpI += s_IT[a][i]*s_qI[es][i][j];
#endif
								}


								s_Dqr[es][j][a] = tmpr+tmpI; // blend lambda term in here
								s_Iqs[es][j][a] = tmps;
								s_Iqt[es][j][a] = tmpt;
							}
						}
					}
				}
			}

			optBarrier(localMemFence);

			// transpose differentiate and interpolate in 's'
			for(int es=0; es<p_NblockG; ++es; @inner(2)) {
				for(int b=0; b<p_gjNq; ++b; @inner(1)) {
					for(int a=0; a<p_gjNq; ++a; @inner(0)) {
						if(eo+es<Nelements) {
							if(a<p_Nq && b<p_Nq) {
								dfloat tmpr = 0, tmps = 0, tmpt = 0;

								//		#pragma unroll p_gjNq
								for(int j=0; j<p_gjNq; ++j) {
#if 1
									const dfloat Ijb = s_I[j][b];
									const dfloat Djb = s_D[j][b];

									tmpr += Ijb*s_Dqr[es][j][a];
									tmps += Djb*s_Iqs[es][j][a];
									tmpt += Ijb*s_Iqt[es][j][a];

#else
									tmpr += s_IT[b][j]*s_Dqr[es][j][a];
									tmps += s_DT[b][j]*s_Iqs[es][j][a];
									tmpt += s_IT[b][j]*s_Iqt[es][j][a];
#endif
								}

								// transpose differentiate and interpolate in 't'
								tmpr += tmps; // blend r and s
								//		  #pragma unroll p_Nq
								for(int c=0; c<p_Nq; ++c) {
#if 1
									r_lapq[c] += s_I[k][c]*tmpr;
									r_lapq[c] += s_D[k][c]*tmpt;
#else
									r_lapq[c] += c_I[k][c]*tmpr;
									r_lapq[c] += c_D[k][c]*tmpt;
#endif
								}
							}
						}
					}
				}
			}
		}

		optBarrier(localMemFence);

		for(int es=0; es<p_NblockG; ++es; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int a=0; a<p_gjNq; ++a; @inner(0)) {

					dfloat r_qAq = 0;

					if(a<p_Nq && b<p_Nq) {
						if(eo+es<Nelements) {
							#pragma unroll p_Nq
							for(int c=0; c<p_Nq; ++c) {
								const int id = emap*p_Np + c*p_Nq2 + b*p_Nq + a;
								Aq[id] = r_lapq[c];
							}
						}
					}
				}
			}
		}
	}
}


/* note that the gjGeo must be the geometric factors at the p_gjNp integration nodes */
@kernel void ellipticPartialAxReductionHex3D_e3(const int Nelements,
    @restrict const  int *  elementList,
    @restrict const  dfloat *  gjGeo,
    @restrict const  dfloat *  gjD,
    @restrict const  dfloat *  gjI,
    const dfloat lambda,
    @restrict const  dfloat *  q,
    @restrict dfloat *  Aq,
    @restrict dfloat *  qAq){


	for(int eo=0; eo<Nelements; eo+=p_NblockG; @outer(0)) {

		@shared volatile dfloat s_D[p_gjNq][p_Nq+p_gllPad];
		@shared volatile dfloat s_I[p_gjNq][p_Nq+p_gllPad];
#if 0
		@shared volatile dfloat s_DT[p_Nq][p_gjNq];
		@shared volatile dfloat s_IT[p_Nq][p_gjNq];
#endif

		@exclusive dfloat r_q[p_Nq];
		@exclusive dfloat r_lapq[p_Nq];

		@shared volatile dfloat s_Ixxq[p_NblockG][p_Nq][p_Nq+p_gllPad];
		@shared volatile dfloat s_Dxxq[p_NblockG][p_Nq][p_Nq+p_gllPad];
		@shared volatile dfloat s_IxDq[p_NblockG][p_Nq][p_gjNq+p_gjPad];
		@shared volatile dfloat s_IxIq[p_NblockG][p_Nq][p_gjNq+p_gjPad];
		@shared volatile dfloat s_DxIq[p_NblockG][p_Nq][p_gjNq+p_gjPad];
		@shared volatile dfloat s_qr[p_NblockG][p_gjNq][p_gjNq+p_gjPad];
		@shared volatile dfloat s_qs[p_NblockG][p_gjNq][p_gjNq+p_gjPad];
		@shared volatile dfloat s_qt[p_NblockG][p_gjNq][p_gjNq+p_gjPad];
		//    @shared volatile dfloat s_Dqr[p_NblockG][p_Nq][p_gjNq], s_Iqs[p_NblockG][p_Nq][p_gjNq], s_Iqt[p_NblockG][p_Nq][p_gjNq];
#if 1
		@shared volatile dfloat s_red[p_NblockG*p_gjNq*p_gjNq];
#endif
		@shared volatile dfloat s_qI[p_NblockG][p_gjNq][p_gjNq+p_gjPad];

#if 1
#define s_Dqr s_IxDq
#define s_Iqs s_IxIq
#define s_Iqt s_DxIq
		//#define s_red s_qr[0][0]

#endif

		@exclusive int emap, thread;
		@exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;

		// prefetch D and I matrices and zero register storage
		for(int es=0; es<p_NblockG; ++es; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int a=0; a<p_gjNq; ++a; @inner(0)) {
					int t = a + b*p_gjNq + es*p_gjNq*p_gjNq;

					if(t<p_gjNq*p_Nq) {
						const int tb = t/p_Nq;
						const int ta = t%p_Nq;
						s_D[tb][ta] = gjD[t];
						s_I[tb][ta] = gjI[t];
#if 0
						s_DT[0][t] = gjD[t];
						s_IT[0][t] = gjI[t];
#endif
					}

					for(int c=0; c<p_Nq; ++c) {
						r_q[c] = 0;
						r_lapq[c] = 0;
					}

					int e = eo+es;
					if(e<Nelements) {
						emap = elementList[e];
#if 1
						if(a<p_Nq && b<p_Nq) {
							for(int c=0; c<p_Nq; ++c) {
								r_q[c] = q[emap*p_Np+c*p_Nq2+b*p_Nq+a];
							}
						}
#endif
					}
					else
						emap = -999999;

				}
			}
		}

		// scan through k slices

		//    #pragma unroll p_gjNq
		for(int k=0; k<p_gjNq; ++k) {

			optBarrier(localMemFence);

			// prefetch slice
			for(int es=0; es<p_NblockG; ++es; @inner(2)) {
				for(int b=0; b<p_gjNq; ++b; @inner(1)) {
					for(int a=0; a<p_gjNq; ++a; @inner(0)) {
						if(eo+es<Nelements) {

							// assumes w*J built into G entries
							//dfloat	 r_G00, r_G01, r_G02, r_G11, r_G12, r_G22;
							const int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + b*p_gjNq + a;

							r_GwJ = gjGeo[base+p_GWJID*p_gjNp];

							r_G00 = gjGeo[base+p_G00ID*p_gjNp];
							r_G01 = gjGeo[base+p_G01ID*p_gjNp];
							r_G02 = gjGeo[base+p_G02ID*p_gjNp];

							r_G11 = gjGeo[base+p_G11ID*p_gjNp];
							r_G12 = gjGeo[base+p_G12ID*p_gjNp];
							r_G22 = gjGeo[base+p_G22ID*p_gjNp];

							if(a<p_Nq && b<p_Nq) {

								dfloat Iqk = 0, Dqk = 0;

								// puts more data in flight
								for(int c=0; c<p_Nq; ++c) {
									const dfloat qcba = r_q[c];
									//		  const dfloat qcba = q[emap*p_Np+c*p_Nq2+b*p_Nq+a];
									// I_{kc} q_{cba}
#if 1
									Iqk += s_I[k][c]*qcba;
									Dqk += s_D[k][c]*qcba;
#else
									Iqk += c_I[k][c]*qcba;
									Dqk += c_D[k][c]*qcba;
#endif
								}
								s_Ixxq[es][b][a] = Iqk;
								s_Dxxq[es][b][a] = Dqk;
							}
						}
					}
				}
			}

			optBarrier(localMemFence);

			// interpolate and differentiate in 'r' direction
			for(int es=0; es<p_NblockG; ++es; @inner(2)) {
				for(int b=0; b<p_gjNq; ++b; @inner(1)) {
					for(int i=0; i<p_gjNq; ++i; @inner(0)) {

						if(es+eo<Nelements) {

							if(b<p_Nq) {
								dfloat IxDq= 0, IxIq = 0, DxIq = 0;

								#pragma unroll p_Nq
								for(int a=0; a<p_Nq; ++a) {
#if 1
									IxDq += s_D[i][a]*s_Ixxq[es][b][a];
									IxIq += s_I[i][a]*s_Ixxq[es][b][a];
									DxIq += s_I[i][a]*s_Dxxq[es][b][a];
#else
									IxDq += s_DT[a][i]*s_Ixxq[es][b][a];
									IxIq += s_IT[a][i]*s_Ixxq[es][b][a];
									DxIq += s_IT[a][i]*s_Dxxq[es][b][a];
#endif
								}

								s_IxDq[es][b][i] = IxDq;
								s_IxIq[es][b][i] = IxIq;
								s_DxIq[es][b][i] = DxIq;
							}
						}
					}
				}
			}

			optBarrier(localMemFence);

			for(int es=0; es<p_NblockG; ++es; @inner(2)) {
				for(int j=0; j<p_gjNq; ++j; @inner(1)) {
					for(int i=0; i<p_gjNq; ++i; @inner(0)) {

						if(eo+es<Nelements) {

							dfloat qr = 0, qs = 0, qt = 0, qI = 0;

							// interpolate and differentiate in 's' direction
							#pragma unroll p_Nq
							for(int n=0; n<p_Nq; ++n) {
#if 1
								qr += s_I[j][n]*s_IxDq[es][n][i];
								qt += s_I[j][n]*s_DxIq[es][n][i];
								qI += s_I[j][n]*s_IxIq[es][n][i];
								qs += s_D[j][n]*s_IxIq[es][n][i];

#else
								qr += s_IT[n][j]*s_IxDq[es][n][i];
								qt += s_IT[n][j]*s_DxIq[es][n][i];
								qI += s_IT[n][j]*s_IxIq[es][n][i];
								qs += s_DT[n][j]*s_IxIq[es][n][i];

#endif
							}


							// apply chain rule (notice the swtich of indices in i,j)
							s_qr[es][i][j] = r_G00*qr + r_G01*qs + r_G02*qt;
							s_qs[es][i][j] = r_G01*qr + r_G11*qs + r_G12*qt;
							s_qt[es][i][j] = r_G02*qr + r_G12*qs + r_G22*qt;
							s_qI[es][i][j] = r_GwJ*qI*lambda;
						}
					}
				}
			}

			optBarrier(localMemFence);

			// transpose differentiate and interpolate in 'r'
			for(int es=0; es<p_NblockG; ++es; @inner(2)) {
				for(int j=0; j<p_gjNq; ++j; @inner(1)) {
					for(int a=0; a<p_gjNq; ++a; @inner(0)) {

						if(eo+es<Nelements) {
							if(a<p_Nq) {
								dfloat tmpr = 0, tmps = 0, tmpt = 0, tmpI = 0;
								#pragma unroll p_gjNq
								for(int i=0; i<p_gjNq; ++i) {
#if 1
									tmpr += s_D[i][a]*s_qr[es][i][j];
									tmps += s_I[i][a]*s_qs[es][i][j];
									tmpt += s_I[i][a]*s_qt[es][i][j];
									tmpI += s_I[i][a]*s_qI[es][i][j];
#else
									tmpr += s_DT[a][i]*s_qr[es][i][j];
									tmps += s_IT[a][i]*s_qs[es][i][j];
									tmpt += s_IT[a][i]*s_qt[es][i][j];
									tmpI += s_IT[a][i]*s_qI[es][i][j];
#endif
								}

								s_Dqr[es][a][j] = tmpr+tmpI; // blend lambda term in here
								s_Iqs[es][a][j] = tmps;
								s_Iqt[es][a][j] = tmpt;
							}
						}
					}
				}
			}

			optBarrier(localMemFence);

			// transpose differentiate and interpolate in 's'
			for(int es=0; es<p_NblockG; ++es; @inner(2)) {
				for(int b=0; b<p_gjNq; ++b; @inner(1)) {
					for(int a=0; a<p_gjNq; ++a; @inner(0)) {
						if(eo+es<Nelements) {
							if(a<p_Nq && b<p_Nq) {
								dfloat tmpr = 0, tmps = 0, tmpt = 0;

								#pragma unroll p_gjNq
								for(int j=0; j<p_gjNq; ++j) {
#if 1
									tmpr += s_I[j][b]*s_Dqr[es][a][j];
									tmps += s_D[j][b]*s_Iqs[es][a][j];
									tmpt += s_I[j][b]*s_Iqt[es][a][j];
#else
									tmpr += s_IT[b][j]*s_Dqr[es][a][j];
									tmps += s_DT[b][j]*s_Iqs[es][a][j];
									tmpt += s_IT[b][j]*s_Iqt[es][a][j];
#endif
								}

								// transpose differentiate and interpolate in 't'
								tmpr += tmps; // blend r and s
								#pragma unroll p_Nq
								for(int c=0; c<p_Nq; ++c) {
#if 1
									r_lapq[c] += s_I[k][c]*tmpr;
									r_lapq[c] += s_D[k][c]*tmpt;
#else
									r_lapq[c] += c_I[k][c]*tmpr;
									r_lapq[c] += c_D[k][c]*tmpt;
#endif
								}
							}
						}
					}
				}
			}
		}

		optBarrier(localMemFence);

		for(int es=0; es<p_NblockG; ++es; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int a=0; a<p_gjNq; ++a; @inner(0)) {

					dfloat r_qAq = 0;

					if(a<p_Nq && b<p_Nq) {
						if(eo+es<Nelements) {
							for(int c=0; c<p_Nq; ++c) {
								const int id = emap*p_Np + c*p_Nq2 + b*p_Nq + a;
								Aq[id] = r_lapq[c];
		#if 0
								r_qAq += r_q[c]*r_lapq[c]; // should buffer q ?
		#endif
								//r_qAq += q[id]*r_lapq[c]; // should buffer q ?
							}
						}
					}
#if 0
					thread =  a + b*p_gjNq + es*p_gjNq*p_gjNq;
					s_red[thread] = r_qAq;
#endif
				}
			}
		}

#if 0
		optBarrier(localMemFence);

#if (p_Nthreads>512)
		allThreads
		if(thread+512<p_Nthreads && thread<512)
			s_red[thread] += s_red[thread+512];
#endif

#if (p_Nthreads>256)
		optBarrier(localMemFence);
		allThreads
		if(thread+256<p_Nthreads && thread<256)
			s_red[thread] += s_red[thread+256];
#endif

#if (p_Nthreads>128)
		optBarrier(localMemFence);
		allThreads
		if(thread+128<p_Nthreads && thread<128)
			s_red[thread] += s_red[thread+128];
#endif

#if (p_Nthreads>64)
		optBarrier(localMemFence);
		allThreads
		if(thread+64<p_Nthreads && thread<64)
			s_red[thread] += s_red[thread+64];
#endif

#if (p_Nthreads>32)
		optBarrier(localMemFence);
		allThreads
		if(thread+32<p_Nthreads && thread<32)
			s_red[thread] += s_red[thread+32];
#endif

#if (p_Nthreads>16)
		allThreads
		if(thread+16<p_Nthreads && thread<16)
			s_red[thread] += s_red[thread+16];
#endif

#if (p_Nthreads>8)
		allThreads
		if(thread+8<p_Nthreads && thread<8)
			s_red[thread] += s_red[thread+8];
#endif

#if (p_Nthreads>4)
		allThreads
		if(thread+4<p_Nthreads && thread<4)
			s_red[thread] += s_red[thread+4];
#endif

#if (p_Nthreads>2)
		allThreads
		if(thread+2<p_Nthreads && thread<2)
			s_red[thread] += s_red[thread+2];
#endif

#if (p_Nthreads>1)
		allThreads
		if(thread+1<p_Nthreads && thread==0)
			s_red[thread] += s_red[thread+1];
#endif
		allThreads
		if(thread==0) {
			const dfloat r_qAq = s_red[0];
			atomicAdd(qAq, r_qAq);
		}
#endif
	}
#undef s_Dqr
#undef s_Iqs
#undef s_Iqt
}


/* note that the gjGeo must be the geometric factors at the p_gjNp integration nodes */
@kernel void ellipticPartialAxHex3D_e5(const int Nelements,
                                      @restrict const  int *  elementList,
                                      @restrict const  dfloat *  gjGeo,
                                      @restrict const  dfloat *  gjD,
                                      @restrict const  dfloat *  gjI,
                                      const dfloat lambda,
                                      @restrict const  dfloat *  q,
                                      @restrict dfloat *  Aq,
                                      @restrict dfloat *  qAq){


	for(int eo=0; eo<Nelements; eo+=p_NblockG; @outer(0)) {

		@shared volatile dfloat s_D[p_gjNq][p_Nq+p_gllPad];
		@shared volatile dfloat s_I[p_gjNq][p_Nq+p_gllPad];

		@shared volatile dfloat s_DT[p_Nq][p_gjNq+p_gjPad];
		@shared volatile dfloat s_IT[p_Nq][p_gjNq+p_gllPad];

		@exclusive dfloat r_q[p_Nq];
		@exclusive dfloat r_lapq[p_Nq];

		@shared volatile dfloat s_Ixxq[p_NblockG][p_Nq][p_Nq+p_gllPad];
		@shared volatile dfloat s_Dxxq[p_NblockG][p_Nq][p_Nq+p_gllPad];
		@shared volatile dfloat s_IxDq[p_NblockG][p_Nq][p_gjNq+p_gjPad];
		@shared volatile dfloat s_IxIq[p_NblockG][p_Nq][p_gjNq+p_gjPad];
		@shared volatile dfloat s_DxIq[p_NblockG][p_Nq][p_gjNq+p_gjPad];
		@shared volatile dfloat s_qr[p_NblockG][p_gjNq][p_gjNq+p_gjPad];
		@shared volatile dfloat s_qs[p_NblockG][p_gjNq][p_gjNq+p_gjPad];
		@shared volatile dfloat s_qt[p_NblockG][p_gjNq][p_gjNq+p_gjPad];

		@shared volatile dfloat s_Dqr[p_NblockG][p_gjNq][p_Nq+p_gllPad];
		@shared volatile dfloat s_Iqs[p_NblockG][p_gjNq][p_Nq+p_gllPad];
		@shared volatile dfloat s_Iqt[p_NblockG][p_gjNq][p_Nq+p_gllPad];

		@shared volatile dfloat s_qI[p_NblockG][p_gjNq][p_gjNq+p_gjPad];

		@exclusive int emap;
		@exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;

		// prefetch D and I matrices and zero register storage
		for(int es=0; es<p_NblockG; ++es; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int a=0; a<p_gjNq; ++a; @inner(0)) {
					int t = a + b*p_gjNq + es*p_gjNq*p_gjNq;

					if(t<p_gjNq*p_Nq) {
						const int tb = t/p_Nq;
						const int ta = t%p_Nq;
#if 1
						s_D[tb][ta] = gjD[t];
						s_I[tb][ta] = gjI[t];
						s_DT[ta][tb] = gjD[t];
						s_IT[ta][tb] = gjI[t];
#endif

					}

					for(int c=0; c<p_Nq; ++c) {
						r_q[c] = 0;
						r_lapq[c] = 0;
					}

					int e = eo+es;
					if(e<Nelements) {
						emap = elementList[e];

						if(a<p_Nq && b<p_Nq) {

							#pragma unroll p_Nq
							for(int c=0; c<p_Nq; ++c) {
								r_q[c] = q[emap*p_Np+c*p_Nq2+b*p_Nq+a];
							}
						}

					}
					else
						emap = -999999;

				}
			}
		}

		// scan through k slices
		for(int k=0; k<p_gjNq; ++k) {

			optBarrier(localMemFence);

			// prefetch slice
			for(int es=0; es<p_NblockG; ++es; @inner(2)) {
				for(int b=0; b<p_gjNq; ++b; @inner(1)) {
					for(int a=0; a<p_gjNq; ++a; @inner(0)) {
						if(eo+es<Nelements) {

							// assumes w*J built into G entries
							//dfloat	 r_G00, r_G01, r_G02, r_G11, r_G12, r_G22;
							const int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + b*p_gjNq + a;

							r_GwJ = gjGeo[base+p_GWJID*p_gjNp];

							r_G00 = gjGeo[base+p_G00ID*p_gjNp];
							r_G01 = gjGeo[base+p_G01ID*p_gjNp];
							r_G02 = gjGeo[base+p_G02ID*p_gjNp];

							r_G11 = gjGeo[base+p_G11ID*p_gjNp];
							r_G12 = gjGeo[base+p_G12ID*p_gjNp];
							r_G22 = gjGeo[base+p_G22ID*p_gjNp];

							if(a<p_Nq && b<p_Nq) {

								dfloat Iqk = 0, Dqk = 0;

								// puts more data in flight
								for(int c=0; c<p_Nq; ++c) {
									const dfloat qcba = r_q[c];
									//		  const dfloat qcba = q[emap*p_Np+c*p_Nq2+b*p_Nq+a];
									// I_{kc} q_{cba}
#if 1
									Iqk += s_I[k][c]*qcba;
									Dqk += s_D[k][c]*qcba;
#else
									Iqk += c_I[k][c]*qcba;
									Dqk += c_D[k][c]*qcba;
#endif
								}
								s_Ixxq[es][b][a] = Iqk;
								s_Dxxq[es][b][a] = Dqk;
							}
						}
					}
				}
			}

			optBarrier(localMemFence);

			// interpolate and differentiate in 'r' direction
			for(int es=0; es<p_NblockG; ++es; @inner(2)) {
				for(int j=0; j<p_gjNq; ++j; @inner(1)) {
					for(int i=0; i<p_gjNq; ++i; @inner(0)) {

						if(es+eo<Nelements) {

							dfloat IIIq = 0, IIDq= 0, IDIq = 0, DIIq = 0;

							for(int b=0; b<p_Nq; ++b) {
								const dfloat Ijb = s_I[j][b];
								const dfloat Djb = s_D[j][b];
								for(int a=0; a<p_Nq; ++a) {
									const dfloat qba = s_Ixxq[es][b][a];
									const dfloat Iia = s_I[i][a];
									const dfloat Dia = s_D[i][a];
									IIIq += Iia*Ijb*qba;
									IIDq += Dia*Ijb*qba;
									IDIq += Iia*Djb*qba;
									DIIq += Iia*Ijb*s_Dxxq[es][b][a];
								}
							}

							// apply chain rule (notice the swtich of indices in i,j)
							s_qr[es][i][j] = r_G00*IIDq + r_G01*IDIq + r_G02*DIIq;
							s_qs[es][i][j] = r_G01*IIDq + r_G11*IDIq + r_G12*DIIq;
							s_qt[es][i][j] = r_G02*IIDq + r_G12*IDIq + r_G22*DIIq;
							s_qI[es][i][j] = r_GwJ*IIIq*lambda;
						}
					}
				}
			}

			optBarrier(localMemFence);

			// transpose differentiate and interpolate in 'r'
			for(int es=0; es<p_NblockG; ++es; @inner(2)) {
				for(int j=0; j<p_gjNq; ++j; @inner(1)) {
					for(int a=0; a<p_gjNq; ++a; @inner(0)) {

						if(eo+es<Nelements) {
							if(a<p_Nq) {
								dfloat tmpr = 0, tmps = 0, tmpt = 0, tmpI = 0;
								//		#pragma unroll p_gjNq
								for(int i=0; i<p_gjNq; ++i) {
#if 1
									tmpr += s_D[i][a]*s_qr[es][i][j];
									tmps += s_I[i][a]*s_qs[es][i][j];
									tmpt += s_I[i][a]*s_qt[es][i][j];
									tmpI += s_I[i][a]*s_qI[es][i][j];
#else
									tmpr += s_DT[a][i]*s_qr[es][i][j];
									tmps += s_IT[a][i]*s_qs[es][i][j];
									tmpt += s_IT[a][i]*s_qt[es][i][j];
									tmpI += s_IT[a][i]*s_qI[es][i][j];
#endif
								}

								s_Dqr[es][j][a] = tmpr+tmpI; // blend lambda term in here
								s_Iqs[es][j][a] = tmps;
								s_Iqt[es][j][a] = tmpt;
							}
						}
					}
				}
			}

			optBarrier(localMemFence);

			// transpose differentiate and interpolate in 's'
			for(int es=0; es<p_NblockG; ++es; @inner(2)) {
				for(int b=0; b<p_gjNq; ++b; @inner(1)) {
					for(int a=0; a<p_gjNq; ++a; @inner(0)) {
						if(eo+es<Nelements) {
							if(a<p_Nq && b<p_Nq) {
								dfloat tmpr = 0, tmps = 0, tmpt = 0;

								//		#pragma unroll p_gjNq
								for(int j=0; j<p_gjNq; ++j) {
#if 1
									tmpr += s_I[j][b]*s_Dqr[es][j][a];
									tmps += s_D[j][b]*s_Iqs[es][j][a];
									tmpt += s_I[j][b]*s_Iqt[es][j][a];
#else
									tmpr += s_IT[b][j]*s_Dqr[es][j][a];
									tmps += s_DT[b][j]*s_Iqs[es][j][a];
									tmpt += s_IT[b][j]*s_Iqt[es][j][a];
#endif
								}

								// transpose differentiate and interpolate in 't'
								tmpr += tmps; // blend r and s
								#pragma unroll p_Nq
								for(int c=0; c<p_Nq; ++c) {
#if 1
									r_lapq[c] += s_I[k][c]*tmpr;
									r_lapq[c] += s_D[k][c]*tmpt;
#else
									r_lapq[c] += c_I[k][c]*tmpr;
									r_lapq[c] += c_D[k][c]*tmpt;
#endif
								}
							}
						}
					}
				}
			}
		}

		optBarrier(localMemFence);

		for(int es=0; es<p_NblockG; ++es; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int a=0; a<p_gjNq; ++a; @inner(0)) {

					dfloat r_qAq = 0;

					if(a<p_Nq && b<p_Nq) {
						if(eo+es<Nelements) {
							#pragma unroll p_Nq
							for(int c=0; c<p_Nq; ++c) {
								const int id = emap*p_Np + c*p_Nq2 + b*p_Nq + a;
								Aq[id] = r_lapq[c];
							}
						}
					}
				}
			}
		}
	}
}


@kernel void ellipticPartialAxHex3D_e6(const int Nelements,
                                      @restrict const  int *  elementList,
                                      @restrict const  dfloat *  gjGeo,
                                      @restrict const  dfloat *  gjD,
                                      @restrict const  dfloat *  gjI,
                                      const dfloat lambda,
                                      @restrict dfloat *  q,
                                      @restrict dfloat *  Aq,
                                      @restrict dfloat *  qAq){
	//KS Nall = 64000, mesh->Np = 125 mesh->Nelements = 512
	for(int e=0; e<Nelements; ++e; @outer(0)) {

		//KS: every thread processes one element
		// p_Nq number of points in the element
		//KS: Nggeo = 7, gjNq = 6, gjNp = 216 Nq = 5


		@shared dfloat s_D[p_gjNq][p_Nq+p_gllPad];
		@shared dfloat s_I[p_gjNq][p_Nq+p_gllPad];

		@exclusive dfloat r_q[p_Nq];
		@exclusive dfloat r_lapq[p_Nq];

		@shared dfloat s_Ixxq[p_Nq][p_Nq+p_gllPad];
		@shared dfloat s_Dxxq[p_Nq][p_Nq+p_gllPad];

		@shared dfloat s_IxDq[p_Nq][p_gjNq+p_gjPad];
		@shared dfloat s_IxIq[p_Nq][p_gjNq+p_gjPad];
		@shared dfloat s_DxIq[p_Nq][p_gjNq+p_gjPad];

		@shared dfloat s_qr[p_gjNq][p_gjNq+p_gjPad];
		@shared dfloat s_qs[p_gjNq][p_gjNq+p_gjPad];
		@shared dfloat s_qt[p_gjNq][p_gjNq+p_gjPad];

		@shared dfloat s_Dqr[p_gjNq][p_Nq+p_gllPad];
		@shared dfloat s_Iqs[p_gjNq][p_Nq+p_gllPad];
		@shared dfloat s_Iqt[p_gjNq][p_Nq+p_gllPad];

		@shared dfloat s_qI[p_gjNq][p_gjNq+p_gjPad];

		@exclusive int emap, ta, tb;
		@exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;
		// less registers (by half) or less @shared (ny half)
		// get rid of one of the register arrryas
		// use a cube of @shared
		// rewrite

		// put q in @shared
		// interpolation matrix in 3 directions
		// change which D we using (larger D) gjN

		// prefetch D and I matrices and zero register storage
		for(int b=0; b<p_gjNq; ++b; @inner(1)) {
			for(int a=0; a<p_gjNq; ++a; @inner(0)) {
				const int t = a + p_gjNq*b;

				if(a<p_Nq && b<p_gjNq) {
					s_D[b][a] = gjD[b*p_Nq+a];
					s_I[b][a] = gjI[b*p_Nq+a];
				}

				for(int c=0; c<p_Nq; ++c) {
					//	  r_q[c] = 0;
					r_lapq[c] = 0;
				}

				emap = elementList[e];
				//Nq2 = Nq*Nq
				if(a<p_Nq && b<p_Nq) {

					#pragma unroll p_Nq
					for(int c=0; c<p_Nq; ++c) {
						r_q[c] = q[emap*p_Np+c*p_Nq2+b*p_Nq+a];
					}                                                                                                                                                        //for c
				}                                                                                                                                                        //if
			}                                                                                                                                                        //for a
		}                                                                                                                                                        //for b

		// *************** scan through k slices
		// ==================================== prefetch first, diff in 't'
		for(int k=0; k<p_gjNq; ++k) {

			optBarrier(localMemFence);

			// prefetch slice
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int a=0; a<p_gjNq; ++a; @inner(0)) {

					const int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + b*p_gjNq + a;
					r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
					r_G00 = gjGeo[base+p_G00ID*p_gjNp];
					r_G01 = gjGeo[base+p_G01ID*p_gjNp];
					r_G02 = gjGeo[base+p_G02ID*p_gjNp];

					r_G11 = gjGeo[base+p_G11ID*p_gjNp];
					r_G12 = gjGeo[base+p_G12ID*p_gjNp];
					r_G22 = gjGeo[base+p_G22ID*p_gjNp];
					// assumes w*J built into G entries

					if (a<p_Nq && b<p_Nq) {

						dfloat Iqk = 0, Dqk = 0;

						// puts more data in flight
						for(int c=0; c<p_Nq; ++c) {
							const dfloat qcba = r_q[c];
							Iqk += s_I[k][c]*qcba;
							Dqk += s_D[k][c]*qcba;
						}
						s_Ixxq[b][a] = Iqk;
						s_Dxxq[b][a] = Dqk;
					}
				}
			}

			optBarrier(localMemFence);
			//=========================== r direction =========================================
			// interpolate and differentiate in 'r' direction
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {

					if(b<p_Nq) {

						dfloat IxDq= 0, IxIq = 0, DxIq = 0;

						#pragma unroll p_Nq
						for(int a=0; a<p_Nq; ++a) {
							const dfloat Iia = s_I[i][a];
							const dfloat Ixxqba = s_Ixxq[b][a];
							IxIq += Iia*Ixxqba;
							DxIq += Iia*s_Dxxq[b][a];
						}

						#pragma unroll p_Nq
						for(int a=0; a<p_Nq; ++a) {
							const dfloat Dia = s_D[i][a];
							const dfloat Ixxqba = s_Ixxq[b][a];
							IxDq += Dia*Ixxqba;
						}

						s_IxDq[b][i] = IxDq;
						// this is what we want
						s_IxIq[b][i] = IxIq;
						s_DxIq[b][i] = DxIq;
					}
				}
			}

			optBarrier(localMemFence);
			//=============================== derivatives =========================================
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {

					dfloat qr = 0, qs = 0, qt = 0, qI = 0;

					// interpolate and differentiate in 's' direction
					#pragma unroll p_Nq
					for(int b=0; b<p_Nq; ++b) {
						const dfloat Ijn = s_I[j][b];
						// qr = dq/dr, qt = dq/dt and qI = dq/dI
						qr += Ijn*s_IxDq[b][i];
						qt += Ijn*s_DxIq[b][i];
						qI += Ijn*s_IxIq[b][i];
					}

					#pragma unroll p_Nq
					//qs = dq/ds
					for(int b=0; b<p_Nq; ++b) {
						const dfloat Djn = s_D[j][b];
						qs += Djn*s_IxIq[b][i];
					}

					// apply chain rule (notice the swtich of indices in i,j)
					s_qr[i][j] = r_G00*qr + r_G01*qs + r_G02*qt;
					s_qs[i][j] = r_G01*qr + r_G11*qs + r_G12*qt;
					s_qt[i][j] = r_G02*qr + r_G12*qs + r_G22*qt;
					// qI needed because of interpolation (?)
					s_qI[i][j] = r_GwJ*qI*lambda;
				}                                                                                                                                                        // for i
			}                                                                                                                                                        // for j
			// =============================== transpose differentiate ==============================
			optBarrier(localMemFence);

			// transpose differentiate and interpolate in 'r'
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int a=0; a<p_gjNq; ++a; @inner(0)) {

					if(a<p_Nq) {
						dfloat tmpr = 0, tmps = 0, tmpt = 0, tmpI = 0;
						#pragma unroll p_gjNq
						for(int i=0; i<p_gjNq; ++i) {
							const dfloat Iia = s_I[i][a];
							tmps += Iia*s_qs[i][j];
							tmpt += Iia*s_qt[i][j];
							tmpI += Iia*s_qI[i][j];
						}

						#pragma unroll p_gjNq
						for(int i=0; i<p_gjNq; ++i) {
							const dfloat Dia = s_D[i][a];
							tmpr += Dia*s_qr[i][j];
						}

						s_Dqr[j][a] = tmpr+tmpI;                                                                                                                                                         // blend lambda term in here
						s_Iqs[j][a] = tmps;
						s_Iqt[j][a] = tmpt;
					}
				}
			}

			optBarrier(localMemFence);

			// transpose differentiate and interpolate in 's'
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int a=0; a<p_gjNq; ++a; @inner(0)) {
					if(a<p_Nq && b<p_Nq) {
						dfloat tmpr = 0, tmps = 0, tmpt = 0;

						#pragma unroll p_gjNq
						for(int j=0; j<p_gjNq; ++j) {
							const dfloat Ijb = s_I[j][b];

							tmpr += Ijb*s_Dqr[j][a];
							tmpt += Ijb*s_Iqt[j][a];
						}


						#pragma unroll p_gjNq
						for(int j=0; j<p_gjNq; ++j) {
							const dfloat Djb = s_D[j][b];

							tmps += Djb*s_Iqs[j][a];
						}

						// transpose differentiate and interpolate in 't'
						tmpr += tmps;                                                                                                                                                         // blend r and s
						#pragma unroll p_Nq
						for(int c=0; c<p_Nq; ++c) {
							r_lapq[c] += s_I[k][c]*tmpr + s_D[k][c]*tmpt;
						}
					}
				}
			}
		}                                                                                                                                                        // this is FOR k

		//    optBarrier(localMemFence);

		for(int b=0; b<p_gjNq; ++b; @inner(1)) {
			for(int a=0; a<p_gjNq; ++a; @inner(0)) {

				dfloat r_qAq = 0;

				if(a<p_Nq && b<p_Nq) {
					#pragma unroll p_Nq
					for(int c=0; c<p_Nq; ++c) {
						const int id = emap*p_Np + c*p_Nq2 + b*p_Nq + a;
						Aq[id] = r_lapq[c];
					}
				}
			}
		}
	}
}



@kernel void ellipticPartialAxHex3D_e6a(const int Nelements,
                                       @restrict const  int *  elementList,
                                       @restrict const  dfloat *  gjGeo,
                                       @restrict const  dfloat *  gjD,
                                       @restrict const  dfloat *  gjI,
                                       const dfloat   lambda,
                                       @restrict const  dfloat *  q,
                                       @restrict dfloat *  Aq,
                                       @restrict const  dfloat *  qAq){


	for(int e=0;e<Nelements;++e;@outer(0)){

		@shared dfloat s_D[p_gjNq][p_gjNq];
		@shared dfloat s_I[p_gjNq][p_Nq+p_gllPad];

		@exclusive dfloat r_lapq[p_gjNq];

		@shared dfloat s_qr[p_gjNq][p_gjNq+p_gjPad];
		@shared dfloat s_qs[p_gjNq][p_gjNq+p_gjPad];

		@shared dfloat s_tmpq[p_gjNq][p_gjNq][p_gjNq];

		@exclusive int emap;
		@exclusive dfloat r_qt;

		// prefetch D and I matrices and zero register storage
		for(int b=0;b<p_gjNq;++b;@inner(1)){
			for(int a=0;a<p_gjNq;++a;@inner(0)){

				emap = elementList[e];

				const int t = a + p_gjNq*b;

				s_D[b][a] = gjD[b*p_gjNq+a];

				if(a<p_Nq && b<p_gjNq)
					s_I[b][a] = gjI[b*p_Nq+a];

				if(a<p_Nq && b<p_Nq){
					// prefetch q(a,b,:) to registers
					#pragma unroll p_Nq
					for(int c=0;c<p_Nq;++c){
						r_lapq[c] = q[emap*p_Np+c*p_Nq2+b*p_Nq+a];
					}
				}
			}
		}

		@barrier("local");

		for(int b=0;b<p_gjNq;++b;@inner(1)){
			for(int a=0;a<p_gjNq;++a;@inner(0)){

				if(a<p_Nq && b<p_Nq){

					#pragma unroll p_Nq
					for(int k=0;k<p_gjNq;++k){
						dfloat tmp = 0;

						#pragma unroll p_Nq
						for(int c=0;c<p_Nq;++c){
							tmp += s_I[k][c]*r_lapq[c];
						}

						s_tmpq[k][b][a] = tmp;
					}
				}
				#pragma unroll p_gjNq
				for(int k=0;k<p_gjNq;++k){
					r_lapq[k] = 0;
				}
			}
		}

		// scan through k slices
		// interpolate to GJ in each 'r' and 's' direction
		#pragma unroll p_gjNq
		for(int k=0;k<p_gjNq;++k){

			@barrier("local");

			for(int b=0;b<p_gjNq;++b;@inner(1)){
				for(int i=0;i<p_gjNq;++i;@inner(0)){
					dfloat tmp = 0;

					if(b<p_Nq){
						#pragma unroll p_Nq
						for(int a=0;a<p_Nq;++a){
							tmp += s_I[i][a]*s_tmpq[k][b][a];
						}
					}
					s_qr[b][i] = tmp;
				}
			}

			@barrier("local");

			for(int j=0;j<p_gjNq;++j;@inner(1)){
				for(int i=0;i<p_gjNq;++i;@inner(0)){

					dfloat tmp = 0;

					#pragma unroll p_Nq
					for(int b=0;b<p_Nq;++b){
						tmp += s_I[j][b]*s_qr[b][i];
					}

					s_tmpq[k][j][i] = tmp;
				}
			}
		}

		#pragma unroll p_gjNq
		for(int k=0;k<p_gjNq;++k){

			@barrier("local");

			for(int j=0;j<p_gjNq;++j;@inner(1)){
				for(int i=0;i<p_gjNq;++i;@inner(0)){

					const int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					const dfloat r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
					const dfloat r_G00 = gjGeo[base+p_G00ID*p_gjNp];
					const dfloat r_G01 = gjGeo[base+p_G01ID*p_gjNp];
					const dfloat r_G02 = gjGeo[base+p_G02ID*p_gjNp];

					const dfloat r_G11 = gjGeo[base+p_G11ID*p_gjNp];
					const dfloat r_G12 = gjGeo[base+p_G12ID*p_gjNp];
					const dfloat r_G22 = gjGeo[base+p_G22ID*p_gjNp];

					// differentiate
					dfloat qr = 0, qs = 0, qt = 0;
					#pragma unroll p_gjNq
					for(int n=0;n<p_gjNq;++n){
						qr += s_D[i][n]*s_tmpq[k][j][n];
						qs += s_D[j][n]*s_tmpq[k][n][i];
						qt += s_D[k][n]*s_tmpq[n][j][i];
					}

					// apply chain rule (notice the swtich of indices in i,j)
				
#if 0
					#pragma unroll p_gjNq
					for(int n=0;n<p_gjNq;++n){
						r_lapq[n] += s_D[k][n]*r_qt;
					}
#endif
				}
			}

			@barrier("local");

			// weak diff
			for(int j=0;j<p_gjNq;++j;@inner(1)){
				for(int i=0;i<p_gjNq;++i;@inner(0)){
					dfloat lapqr = 0, lapqs = 0;

					#pragma unroll p_gjNq
					for(int n=0;n<p_gjNq;++n){
						lapqr += s_D[n][i]*s_qr[j][n];
						lapqs += s_D[n][j]*s_qs[n][i];
						r_lapq[n] += s_D[k][n]*r_qt;
					}

					r_lapq[k] += lapqr + lapqs;
				}
			}
		}

		// now interpolate back in 't'
		#pragma unroll p_Nq
		for(int c=0;c<p_Nq;++c){

			@barrier("local");

			for(int j=0;j<p_gjNq;++j;@inner(1)){
				for(int i=0;i<p_gjNq;++i;@inner(0)){
					dfloat tmp = 0;

					#pragma unroll p_gjNq
					for(int k=0;k<p_gjNq;++k){
						tmp += s_I[k][c]*r_lapq[k];
					}

					s_tmpq[c][j][i] = tmp;
				}
			}

			@barrier("local");

			for(int b=0;b<p_gjNq;++b;@inner(1)){
				for(int i=0;i<p_gjNq;++i;@inner(0)){
					if(b<p_Nq){
						dfloat tmp = 0;

						#pragma unroll p_gjNq
						for(int j=0;j<p_gjNq;++j){
							tmp += s_I[j][b]*s_tmpq[c][j][i];
						}

						s_qr[b][i] = tmp;
					}
				}
			}

			@barrier("local");

			for(int b=0;b<p_gjNq;++b;@inner(1)){
				for(int a=0;a<p_gjNq;++a;@inner(0)){
					const int t = a + b*p_gjNq;
					if(t<p_Nq*p_Nq){
						const int ta = t%p_Nq;
						const int tb = t/p_Nq;

						dfloat tmp = 0;

						#pragma unroll p_gjNq
						for(int i=0;i<p_gjNq;++i){
							tmp += s_I[i][ta]*s_qr[tb][i];
						}

						const int id = emap*p_Np + c*p_Nq2 + tb*p_Nq + ta;
						Aq[id] = tmp;
					}
				}
			}
		}
	}
}



@kernel void ellipticPartialAxHex3D_e6b(const int Nelements,
                                       @restrict const  int *  elementList,
                                       @restrict const  dfloat *  gjGeo,
                                       @restrict const  dfloat *  gjD,
                                       @restrict const  dfloat *  gjI,
                                       const dfloat   lambda,
                                       @restrict const  dfloat *  q,
                                       @restrict dfloat *  Aq,
                                       @restrict const  dfloat *  qAq){


	for(int e=0;e<Nelements;++e;@outer(0)){

		@shared dfloat s_D[p_gjNq][p_gjNq];
		@shared dfloat s_I[p_gjNq][p_Nq+p_gllPad];

		@exclusive dfloat r_lapq[p_gjNq];
		@exclusive dfloat r_tmpq[p_gjNq];

		@shared dfloat s_tmpq[p_gjNq][p_gjNq];

		@shared dfloat s_qr[p_gjNq][p_gjNq+p_gjPad];
		@shared dfloat s_qs[p_gjNq][p_gjNq+p_gjPad];

		@exclusive int emap;
		@exclusive dfloat r_qt;

		// prefetch D and I matrices and zero register storage
		for(int b=0;b<p_gjNq;++b;@inner(1)){
			for(int a=0;a<p_gjNq;++a;@inner(0)){

				emap = elementList[e];

				const int t = a + p_gjNq*b;

				s_D[b][a] = gjD[b*p_gjNq+a];

				if(a<p_Nq && b<p_gjNq)
					s_I[b][a] = gjI[b*p_Nq+a];

#if 0
				if(a<p_Nq && b<p_Nq){
					// prefetch q(a,b,:) to registers
					#pragma unroll p_Nq
					for(int c=0;c<p_Nq;++c){
						r_lapq[c] = q[emap*p_Np+c*p_Nq2+b*p_Nq+a];
					}
				}
#endif
			}
		}

		#pragma unroll p_Nq
		for(int k=0;k<p_gjNq;++k){

			@barrier("local");

			for(int b=0;b<p_gjNq;++b;@inner(1)){
				for(int a=0;a<p_gjNq;++a;@inner(0)){

					dfloat tmp = 0;

					if(a<p_Nq && b<p_Nq){
						#pragma unroll p_Nq
						for(int c=0;c<p_Nq;++c){

							tmp += s_I[k][c]*q[emap*p_Np+c*p_Nq2+b*p_Nq+a]; // r_lapq[c];
						}
					}

					s_tmpq[b][a] = tmp;
				}
			}

			@barrier("local");

			for(int b=0;b<p_gjNq;++b;@inner(1)){
				for(int i=0;i<p_gjNq;++i;@inner(0)){
					dfloat tmp = 0;

					if(b<p_Nq){
						#pragma unroll p_Nq
						for(int a=0;a<p_Nq;++a){
							tmp += s_I[i][a]*s_tmpq[b][a];
						}
					}

					s_qr[b][i] = tmp;
				}
			}

			@barrier("local");

			for(int j=0;j<p_gjNq;++j;@inner(1)){
				for(int i=0;i<p_gjNq;++i;@inner(0)){

					dfloat tmp = 0;

					#pragma unroll p_Nq
					for(int b=0;b<p_Nq;++b){
						tmp += s_I[j][b]*s_qr[b][i];
					}

					r_tmpq[k] = tmp;
				}
			}
		}

		for(int j=0;j<p_gjNq;++j;@inner(1))
			for(int i=0;i<p_gjNq;++i;@inner(0))
				for(int k=0;k<p_gjNq;++k)
					r_lapq[k] = 0;

		#pragma unroll p_gjNq
		for(int k=0;k<p_gjNq;++k){

			@barrier("local");

			for(int j=0;j<p_gjNq;++j;@inner(1))
				for(int i=0;i<p_gjNq;++i;@inner(0))
					s_tmpq[j][i] = r_tmpq[k];

			@barrier("local");

			for(int j=0;j<p_gjNq;++j;@inner(1)){
				for(int i=0;i<p_gjNq;++i;@inner(0)){

					const int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					const dfloat r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
					const dfloat r_G00 = gjGeo[base+p_G00ID*p_gjNp];
					const dfloat r_G01 = gjGeo[base+p_G01ID*p_gjNp];
					const dfloat r_G02 = gjGeo[base+p_G02ID*p_gjNp];

					const dfloat r_G11 = gjGeo[base+p_G11ID*p_gjNp];
					const dfloat r_G12 = gjGeo[base+p_G12ID*p_gjNp];
					const dfloat r_G22 = gjGeo[base+p_G22ID*p_gjNp];

					// differentiate
					dfloat qr = 0, qs = 0, qt = 0;
					#pragma unroll p_gjNq
					for(int n=0;n<p_gjNq;++n){
						qr += s_D[i][n]*s_tmpq[j][n];
						qs += s_D[j][n]*s_tmpq[n][i];
						qt += s_D[k][n]*r_tmpq[n];
					}

					// apply chain rule (notice the swtich of indices in i,j)
					s_qr[j][i] = r_G00*qr + r_G01*qs + r_G02*qt;
					s_qs[j][i] = r_G01*qr + r_G11*qs + r_G12*qt;
					r_qt = r_G02*qr + r_G12*qs + r_G22*qt;

					r_lapq[k] += lambda*r_GwJ*r_tmpq[k];
				}
			}

			@barrier("local");

			// weak diff
			for(int j=0;j<p_gjNq;++j;@inner(1)){
				for(int i=0;i<p_gjNq;++i;@inner(0)){
					dfloat lapqr = 0, lapqs = 0;

					#pragma unroll p_gjNq
					for(int n=0;n<p_gjNq;++n){
						lapqr += s_D[n][i]*s_qr[j][n];
						lapqs += s_D[n][j]*s_qs[n][i];
					}
					#pragma unroll p_gjNq
					for(int n=0;n<p_gjNq;++n){
						r_lapq[n] += s_D[k][n]*r_qt;
					}

					r_lapq[k] += lapqr + lapqs;
				}
			}
		}

		// now interpolate back in 't'
		#pragma unroll p_Nq
		for(int c=0;c<p_Nq;++c){

			@barrier("local");

			for(int j=0;j<p_gjNq;++j;@inner(1)){
				for(int i=0;i<p_gjNq;++i;@inner(0)){
					dfloat tmp = 0;

					#pragma unroll p_gjNq
					for(int k=0;k<p_gjNq;++k){
						tmp += s_I[k][c]*r_lapq[k];
					}

					s_tmpq[j][i] = tmp;
				}
			}

			@barrier("local");

			for(int b=0;b<p_gjNq;++b;@inner(1)){
				for(int i=0;i<p_gjNq;++i;@inner(0)){
					if(b<p_Nq){
						dfloat tmp = 0;

						#pragma unroll p_gjNq
						for(int j=0;j<p_gjNq;++j){
							tmp += s_I[j][b]*s_tmpq[j][i];
						}

						s_qr[b][i] = tmp;
					}
				}
			}

			@barrier("local");

			for(int b=0;b<p_gjNq;++b;@inner(1)){
				for(int a=0;a<p_gjNq;++a;@inner(0)){
					const int t = a + b*p_gjNq;
					if(t<p_Nq2){
						const int ta = t%p_Nq;
						const int tb = t/p_Nq;
						dfloat tmp = 0;

						#pragma unroll p_gjNq
						for(int i=0;i<p_gjNq;++i){
							tmp += s_I[i][ta]*s_qr[tb][i];
						}

						const int id = emap*p_Np + c*p_Nq2 + tb*p_Nq + ta;
						Aq[id] = tmp;
					}
				}
			}
		}
	}
}



@kernel void ellipticPartialAxHex3D_e7(const int Nelements,
                                      @restrict const  int *  elementList,
                                      @restrict const  dfloat *  gjGeo,
                                      @restrict const  dfloat *  gjD,
                                      @restrict const  dfloat *  gjI,
                                      const dfloat lambda,
                                      @restrict const  dfloat *  q,
                                      @restrict dfloat *  gradq,
                                      @restrict dfloat *  Aq){

	// split into gradient then divergence to reduce register and @shared memory pressure

	// gradient
	for(int e=0; e<Nelements; ++e; @outer(0)) {

		@shared dfloat s_D[p_gjNq][p_Nq+p_gllPad];
		@shared dfloat s_I[p_gjNq][p_Nq+p_gllPad];

		@exclusive dfloat r_q[p_Nq];

		@shared dfloat s_Ixxq[p_Nq][p_Nq+p_gllPad];
		@shared dfloat s_Dxxq[p_Nq][p_Nq+p_gllPad];

		@shared dfloat s_IxDq[p_Nq][p_gjNq+p_gjPad];
		@shared dfloat s_IxIq[p_Nq][p_gjNq+p_gjPad];
		@shared dfloat s_DxIq[p_Nq][p_gjNq+p_gjPad];

		@exclusive int emap;
		@exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;

		// prefetch D and I matrices and zero register storage
		for(int b=0; b<p_gjNq; ++b; @inner(1)) {
			for(int a=0; a<p_gjNq; ++a; @inner(0)) {
				const int t = a + p_gjNq*b;

				if(a<p_Nq && b<p_gjNq) {
					s_D[b][a] = gjD[b*p_Nq+a];
					s_I[b][a] = gjI[b*p_Nq+a];
				}

				emap = elementList[e];

				if(a<p_Nq && b<p_Nq) {

					#pragma unroll p_Nq
					for(int c=0; c<p_Nq; ++c) {
						r_q[c] = q[emap*p_Np+c*p_Nq2+b*p_Nq+a];
					}
				}
			}
		}

		// scan through k slices

		for(int k=0; k<p_gjNq; ++k) {

			optBarrier(localMemFence);

			// prefetch slice
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int a=0; a<p_gjNq; ++a; @inner(0)) {

					const int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + b*p_gjNq + a;
					r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
					r_G00 = gjGeo[base+p_G00ID*p_gjNp];
					r_G01 = gjGeo[base+p_G01ID*p_gjNp];
					r_G02 = gjGeo[base+p_G02ID*p_gjNp];

					r_G11 = gjGeo[base+p_G11ID*p_gjNp];
					r_G12 = gjGeo[base+p_G12ID*p_gjNp];
					r_G22 = gjGeo[base+p_G22ID*p_gjNp];
					// assumes w*J built into G entries

					if(a<p_Nq && b<p_Nq) {

						dfloat Iqk = 0, Dqk = 0;

						#pragma unroll p_Nq
						for(int c=0; c<p_Nq; ++c) {
							const dfloat qcba = r_q[c];
							Iqk += s_I[k][c]*qcba;
							Dqk += s_D[k][c]*qcba;
						}
						s_Ixxq[b][a] = Iqk;
						s_Dxxq[b][a] = Dqk;
					}
				}
			}

			optBarrier(localMemFence);

			// interpolate and differentiate in 'r' direction
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {

					if(b<p_Nq) {

						dfloat IxDq= 0, IxIq = 0, DxIq = 0;

						#pragma unroll p_Nq
						for(int a=0; a<p_Nq; ++a) {
							const dfloat Iia = s_I[i][a];
							const dfloat Dia = s_D[i][a];
							const dfloat Ixxqba = s_Ixxq[b][a];
							IxDq += Dia*Ixxqba;
							IxIq += Iia*Ixxqba;
							DxIq += Iia*s_Dxxq[b][a];
						}

						s_IxDq[b][i] = IxDq;
						s_IxIq[b][i] = IxIq;
						s_DxIq[b][i] = DxIq;
					}
				}
			}

			optBarrier(localMemFence);

			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {

					dfloat qr = 0, qs = 0, qt = 0, qI = 0;

					// interpolate and differentiate in 's' direction
					#pragma unroll p_Nq
					for(int n=0; n<p_Nq; ++n) {
						const dfloat Ijn = s_I[j][n];
						const dfloat Djn = s_D[j][n];
						qr += Ijn*s_IxDq[n][i];
						qt += Ijn*s_DxIq[n][i];
						qI += Ijn*s_IxIq[n][i];
						qs += Djn*s_IxIq[n][i];
					}

					// apply chain rule (notice the swtich of indices in i,j)
					// should bundle these
					const int base = e*p_gjNp*4 + 4*k*p_gjNq*p_gjNq + j*p_gjNq + i;
					gradq[base+0*p_gjNq2] = r_G00*qr + r_G01*qs + r_G02*qt;
					gradq[base+1*p_gjNq2] = r_G01*qr + r_G11*qs + r_G12*qt;
					gradq[base+2*p_gjNq2] = r_G02*qr + r_G12*qs + r_G22*qt;
					gradq[base+3*p_gjNq2] = r_GwJ*qI*lambda;
				}
			}
		}
	}

	// divergence
	for(int e=0; e<Nelements; ++e; @outer(0)) {

		@shared dfloat s_D[p_gjNq][p_Nq+p_gllPad];
		@shared dfloat s_I[p_gjNq][p_Nq+p_gllPad];

		@exclusive dfloat r_lapq[p_Nq];

		@shared dfloat s_qtmp[p_gjNq][p_gjNq+p_gjPad];

		@shared dfloat s_Dqr[p_gjNq][p_Nq+p_gllPad];
		@shared dfloat s_Iqs[p_gjNq][p_Nq+p_gllPad];
		@shared dfloat s_Iqt[p_gjNq][p_Nq+p_gllPad];

		@exclusive int emap;

		for(int b=0; b<p_gjNq; ++b; @inner(1)) {
			for(int a=0; a<p_gjNq; ++a; @inner(0)) {
				if(a<p_Nq && b<p_gjNq) {
					s_D[b][a] = gjD[b*p_Nq+a];
					s_I[b][a] = gjI[b*p_Nq+a];
				}
			}

			for(int c=0; c<p_Nq; ++c) {
				r_lapq[c] = 0.f;
			}

			emap = elementList[e];
		}

		for(int k=0; k<p_gjNq; ++k) {

			// 1.
			optBarrier(localMemFence);

			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					// should bundle these
					const int base = e*p_gjNp*4 + 4*k*p_gjNq*p_gjNq + j*p_gjNq + i;
					s_qtmp[i][j] = gradq[base+0*p_gjNq2];
				}
			}

			optBarrier(localMemFence);

			// transpose differentiate and interpolate in 'r'
			for(int a=0; a<p_gjNq; ++a; @inner(1)) {
				for(int j=0; j<p_gjNq; ++j; @inner(0)) {

					if(a<p_Nq) {
						dfloat tmpr = 0;
						#pragma unroll p_gjNq
						for(int i=0; i<p_gjNq; ++i) {
							const dfloat Dia = s_D[i][a];
							tmpr += Dia*s_qtmp[i][j];
						}

						s_Dqr[j][a] = tmpr;
					}
				}
			}

			// 2.
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					// should bundle these
					const int base = e*p_gjNp*4 + 4*k*p_gjNq*p_gjNq + j*p_gjNq + i;
					s_qtmp[i][j] = gradq[base+1*p_gjNq2];
				}
			}

			optBarrier(localMemFence);

			// transpose differentiate and interpolate in 'r'
			for(int a=0; a<p_gjNq; ++a; @inner(1)) {
				for(int j=0; j<p_gjNq; ++j; @inner(0)) {

					if(a<p_Nq) {
						dfloat tmps = 0;
						#pragma unroll p_gjNq
						for(int i=0; i<p_gjNq; ++i) {
							const dfloat Iia = s_I[i][a];
							tmps += Iia*s_qtmp[i][j];
						}

						s_Iqs[j][a] = tmps;
					}
				}
			}

			optBarrier(localMemFence);

			// 3.
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					// should bundle these
					const int base = e*p_gjNp*4 + 4*k*p_gjNq*p_gjNq + j*p_gjNq + i;
					s_qtmp[i][j] = gradq[base+2*p_gjNq2];
				}
			}

			optBarrier(localMemFence);

			// transpose differentiate and interpolate in 'r'
			for(int a=0; a<p_gjNq; ++a; @inner(1)) {
				for(int j=0; j<p_gjNq; ++j; @inner(0)) {

					if(a<p_Nq) {
						dfloat tmpt = 0;
						#pragma unroll p_gjNq
						for(int i=0; i<p_gjNq; ++i) {
							const dfloat Iia = s_I[i][a];
							tmpt += Iia*s_qtmp[i][j];
						}

						s_Iqt[j][a] = tmpt;
					}
				}
			}


			optBarrier(localMemFence);

			// 4.
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					// should bundle these
					const int base = e*p_gjNp*4 + 4*k*p_gjNq*p_gjNq + j*p_gjNq + i;
					s_qtmp[i][j] = gradq[base+3*p_gjNq2];
				}
			}

			optBarrier(localMemFence);

			// transpose differentiate and interpolate in 'r'
			for(int a=0; a<p_gjNq; ++a; @inner(1)) {
				for(int j=0; j<p_gjNq; ++j; @inner(0)) {

					if(a<p_Nq) {
						dfloat tmpI = 0;
						#pragma unroll p_gjNq
						for(int i=0; i<p_gjNq; ++i) {
							const dfloat Iia = s_I[i][a];
							tmpI += Iia*s_qtmp[i][j];
						}

						s_Dqr[j][a] += tmpI;                                                                                                                                                         // blend lambda term in here
					}
				}
			}


			optBarrier(localMemFence);

			// transpose differentiate and interpolate in 's'
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int a=0; a<p_gjNq; ++a; @inner(0)) {
					if(a<p_Nq && b<p_Nq) {
						dfloat tmpr = 0, tmps = 0, tmpt = 0;

						#pragma unroll p_gjNq
						for(int j=0; j<p_gjNq; ++j) {
							const dfloat Ijb = s_I[j][b];
							const dfloat Djb = s_D[j][b];

							tmpr += Ijb*s_Dqr[j][a];
							tmps += Djb*s_Iqs[j][a];
							tmpt += Ijb*s_Iqt[j][a];
						}

						// transpose differentiate and interpolate in 't'
						tmpr += tmps;                                                                                                                                                         // blend r and s
						#pragma unroll p_Nq
						for(int c=0; c<p_Nq; ++c) {
							r_lapq[c] += s_I[k][c]*tmpr;
							r_lapq[c] += s_D[k][c]*tmpt;
						}
					}
				}
			}
		}

		//    optBarrier(localMemFence);

		for(int b=0; b<p_gjNq; ++b; @inner(1)) {
			for(int a=0; a<p_gjNq; ++a; @inner(0)) {

				if(a<p_Nq && b<p_Nq) {
					#pragma unroll p_Nq
					for(int c=0; c<p_Nq; ++c) {
						const int id = emap*p_Np + c*p_Nq2 + b*p_Nq + a;
						Aq[id] = r_lapq[c];
					}
				}
			}
		}
	}
}

// ONLY CPU

@kernel void ellipticPartialAxHex3D_e8(const int Nelements,
                                      @restrict const  int *  elementList,
                                      @restrict const  dfloat *  gjGeo,
                                      @restrict const  dfloat *  gjD,
                                      @restrict const  dfloat *  gjI,
                                      const dfloat lambda,
                                      @restrict dfloat *  q,
                                      @restrict dfloat *  Aq,
                                      @restrict dfloat *  qAq){

	dfloat s_D[p_gjNq][p_Nq+p_gllPad];
	dfloat s_I[p_gjNq][p_Nq+p_gllPad];

	for(int b=0; b<p_gjNq; ++b) {
		for(int a=0; a<p_Nq; ++a) {
			s_D[b][a] = gjD[b*p_Nq+a];
			s_I[b][a] = gjI[b*p_Nq+a];
		}
	}

	dfloat r_q[p_Nq][p_Nq][p_Nq];
	dfloat r_lapq[p_Nq][p_Nq][p_Nq];

	dfloat s_Ixxq[p_Nq][p_Nq+p_gllPad];
	dfloat s_Dxxq[p_Nq][p_Nq+p_gllPad];

	dfloat s_IxDq[p_Nq][p_gjNq+p_gjPad];
	dfloat s_IxIq[p_Nq][p_gjNq+p_gjPad];
	dfloat s_DxIq[p_Nq][p_gjNq+p_gjPad];

	dfloat s_qr[p_gjNq][p_gjNq+p_gjPad];
	dfloat s_qs[p_gjNq][p_gjNq+p_gjPad];
	dfloat s_qt[p_gjNq][p_gjNq+p_gjPad];

	dfloat s_Dqr[p_gjNq][p_Nq+p_gllPad];
	dfloat s_Iqs[p_gjNq][p_Nq+p_gllPad];
	dfloat s_Iqt[p_gjNq][p_Nq+p_gllPad];

	dfloat s_qI[p_gjNq][p_gjNq+p_gjPad];

	for(int e=0; e<Nelements; ++e) {

		const int emap = elementList[e];

		// prefetch D and I matrices and zero register storage
		for(int c=0; c<p_Nq; ++c) {
			for(int b=0; b<p_Nq; ++b) {
				for(int a=0; a<p_Nq; ++a) {
					r_lapq[c][b][a] = 0;
					r_q[c][b][a] = q[emap*p_Np+c*p_Nq2+b*p_Nq+a];
				}
			}
		}

		// scan through k slices

		for(int k=0; k<p_gjNq; ++k) {

			// prefetch slice
			for(int b=0; b<p_Nq; ++b) {
				for(int a=0; a<p_Nq; ++a) {

					// assumes w*J built into G entries

					dfloat Iqk = 0, Dqk = 0;

					// puts more data in flight
					for(int c=0; c<p_Nq; ++c) {
						const dfloat qcba =  r_q[c][b][a];
						Iqk += s_I[k][c]*qcba;
						Dqk += s_D[k][c]*qcba;
					}
					s_Ixxq[b][a] = Iqk;
					s_Dxxq[b][a] = Dqk;
				}
			}

			// interpolate and differentiate in 'r' direction
			for(int b=0; b<p_Nq; ++b) {
				for(int i=0; i<p_gjNq; ++i) {

					dfloat IxDq= 0, IxIq = 0, DxIq = 0;

					for(int a=0; a<p_Nq; ++a) {
						const dfloat Iia = s_I[i][a];
						const dfloat Ixxqba = s_Ixxq[b][a];
						IxIq += Iia*Ixxqba;
						DxIq += Iia*s_Dxxq[b][a];
					}

					for(int a=0; a<p_Nq; ++a) {
						const dfloat Dia = s_D[i][a];
						const dfloat Ixxqba = s_Ixxq[b][a];
						IxDq += Dia*Ixxqba;
					}

					s_IxDq[b][i] = IxDq;
					s_IxIq[b][i] = IxIq;
					s_DxIq[b][i] = DxIq;
				}
			}

			for(int j=0; j<p_gjNq; ++j) {
				for(int i=0; i<p_gjNq; ++i) {

					dfloat qr = 0, qs = 0, qt = 0, qI = 0;

					// interpolate and differentiate in 's' direction
					for(int b=0; b<p_Nq; ++b) {
						const dfloat Ijn = s_I[j][b];
						qr += Ijn*s_IxDq[b][i];
						qt += Ijn*s_DxIq[b][i];
						qI += Ijn*s_IxIq[b][i];
					}

					for(int b=0; b<p_Nq; ++b) {
						const dfloat Djn = s_D[j][b];
						qs += Djn*s_IxIq[b][i];
					}

					const int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					const dfloat r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
					const dfloat r_G00 = gjGeo[base+p_G00ID*p_gjNp];
					const dfloat r_G01 = gjGeo[base+p_G01ID*p_gjNp];
					const dfloat r_G02 = gjGeo[base+p_G02ID*p_gjNp];

					const dfloat r_G11 = gjGeo[base+p_G11ID*p_gjNp];
					const dfloat r_G12 = gjGeo[base+p_G12ID*p_gjNp];
					const dfloat r_G22 = gjGeo[base+p_G22ID*p_gjNp];

					// apply chain rule (notice the swtich of indices in i,j)
					s_qr[i][j] = r_G00*qr + r_G01*qs + r_G02*qt;
					s_qs[i][j] = r_G01*qr + r_G11*qs + r_G12*qt;
					s_qt[i][j] = r_G02*qr + r_G12*qs + r_G22*qt;
					s_qI[i][j] = r_GwJ*qI*lambda;
				}
			}

			// transpose differentiate and interpolate in 'r'
			for(int j=0; j<p_gjNq; ++j) {
				for(int a=0; a<p_Nq; ++a) {

					dfloat tmpr = 0, tmps = 0, tmpt = 0, tmpI = 0;

					for(int i=0; i<p_gjNq; ++i) {
						const dfloat Iia = s_I[i][a];
						tmps += Iia*s_qs[i][j];
						tmpt += Iia*s_qt[i][j];
						tmpI += Iia*s_qI[i][j];
					}

					for(int i=0; i<p_gjNq; ++i) {
						const dfloat Dia = s_D[i][a];
						tmpr += Dia*s_qr[i][j];
					}

					s_Dqr[j][a] = tmpr+tmpI; // blend lambda term in here
					s_Iqs[j][a] = tmps;
					s_Iqt[j][a] = tmpt;
				}
			}

			// transpose differentiate and interpolate in 's'
			for(int b=0; b<p_Nq; ++b) {
				for(int a=0; a<p_Nq; ++a) {

					dfloat tmpr = 0, tmps = 0, tmpt = 0;

					for(int j=0; j<p_gjNq; ++j) {
						const dfloat Ijb = s_I[j][b];

						tmpr += Ijb*s_Dqr[j][a];
						tmpt += Ijb*s_Iqt[j][a];
					}

					for(int j=0; j<p_gjNq; ++j) {
						const dfloat Djb = s_D[j][b];

						tmps += Djb*s_Iqs[j][a];
					}

					// transpose differentiate and interpolate in 't'
					tmpr += tmps; // blend r and s

					for(int c=0; c<p_Nq; ++c) {
						r_lapq[c][b][a] += s_I[k][c]*tmpr + s_D[k][c]*tmpt;
					}
				}
			}
		}

		for(int c=0; c<p_Nq; ++c) {
			for(int b=0; b<p_Nq; ++b) {
				for(int a=0; a<p_Nq; ++a) {
					const int id = emap*p_Np + c*p_Nq2 + b*p_Nq + a;
					Aq[id] = r_lapq[c][b][a];
				}
			}
		}
	}
}


// THIS KERNEL only works on elements with size x*y*z <=1024

// Note: gjD is gjNq x gjNq


@kernel void ellipticPartialAxHex3D_e9(const int Nelements,
                                      @restrict const  int *  elementList,
                                      @restrict const  dfloat *  gjGeo,
                                      @restrict const  dfloat *  gllD,
                                      @restrict const  dfloat *  gjI,
                                      const dfloat lambda,
                                      @restrict dfloat *  q,
                                      @restrict dfloat *  Ixq,
                                      @restrict dfloat *  Aq
                                     ){


	// load q into @shared first
	//@kernel 1 - interpolate to gj hex
	for(int e=0; e<Nelements; ++e; @outer(0)) {
		@exclusive int emap;
		@exclusive dfloat r_res;
		@shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		@shared dfloat s_gsI[p_gjNq][p_Nq];

		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int a=0; a<p_gjNq; ++a; @inner(0)) {
					r_res =0.0f;
					if (c == 0 && a<p_Nq && b<p_gjNq) {
						s_gsI[b][a] = gjI[b*p_Nq+a];
					}
					emap = elementList[e];
					int t = a + b*p_gjNq + c*p_gjNq2;
					if (t<p_Np) {
						int ta = t%p_Nq;
						int tb = (t/p_Nq)%p_Nq;
						int tc = t/p_Nq2;
						s_q[tc][tb][ta] = q[emap*p_Np+t];
					}//if
				}//for a
			}// for b
		}//for c
		//synch threads
		@barrier("local");
		//============== interpolate in 3 dir ========================
		// r --> s --> t
		// rrrrrrr
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Iq = 0.0f;
					if (c<p_Nq && b<p_Nq){
						#pragma unroll p_Nq
						for(int n=0; n<p_Nq; ++n) {
							Iq += s_gsI[i][n]*s_q[c][b][n];
						}
					}
					r_res = Iq;			a
				}
			}
		}

		@barrier("local");

		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					s_q[c][b][i] = r_res;
				}
			}
		}
		@barrier("local");

		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Iq = 0.0f;
					if(c<p_Nq) {
						#pragma unroll p_Nq
						for(int n=0; n<p_Nq; ++n) {
							Iq += s_gsI[j][n]*s_q[c][n][i];
						}
					}
					r_res = Iq;
				}
			}
		}
		@barrier("local");



		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					s_q[c][j][i] = r_res;
				}
			}
		}
		@barrier("local");

		// t direction

		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Iq = 0.0f;
					#pragma unroll p_Nq
					for(int n=0; n<p_Nq; ++n) {
						Iq += s_gsI[k][n]*s_q[n][j][i];
					}
					//	r_res = Iq;
					//		s_q[k][j][i] = Iq;
					emap = elementList[e];
					const int id = emap*p_gjNp + k*p_gjNq*p_gjNq+ j*p_gjNq + i;
					Ixq[id] = Iq;
					//s_q[k][j][i];
				}
			}
		}
	}// for e

	// at this point q is interpolated in all 3 dim.
	// ------------KERNEL 2 -------------->

	// @kernel 2 differentiate on gj hex
	for(int e=0; e<Nelements; ++e; @outer(0)) {
		@shared dfloat s_gjD[p_gjNq][p_gjNq];
		//	@shared dfloat s_gllD[p_gjNq][p_Nq];
		@shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		@exclusive dfloat r_qr, r_qs, r_qt, r_tmp;
		@exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;
		@exclusive int emap;

		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					// D to @shared, q to @shared,
					if (k==0 ) {
						s_gjD[j][i] = gllD[j*p_gjNq+i];
					}
					emap = elementList[e];
					int t = i + j*p_gjNq + k*p_gjNq2;
					s_q[k][j][i] = Ixq[emap*p_gjNp+t];
				}//for i
			}//for j
		}//for k
		@barrier("local");

		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					//load geofactors for my (k,j,i)
					//		emap = elementList[e];
					const int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					//geofactors for k j i thread
					r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
					r_G00 = gjGeo[base+p_G00ID*p_gjNp];
					r_G01 = gjGeo[base+p_G01ID*p_gjNp];
					r_G02 = gjGeo[base+p_G02ID*p_gjNp];

					r_G11 = gjGeo[base+p_G11ID*p_gjNp];
					r_G12 = gjGeo[base+p_G12ID*p_gjNp];
					r_G22 = gjGeo[base+p_G22ID*p_gjNp];
					// now, put together dq/dr, qq/ds, dq/dt and dq/dI

					dfloat dr = 0.0f;
					dfloat ds = 0.0f;
					dfloat dt = 0.0f;
					#pragma unroll p_gjNq
					for (int n = 0; n<p_gjNq; ++n) {
						dr += s_gjD[i][n] * s_q[k][j][n];
						ds += s_gjD[j][n]*s_q[k][n][i];
						dt += s_gjD[k][n]*s_q[n][j][i];
					}
					r_qr = r_G00*dr + r_G01*ds + r_G02*dt;
					r_qs = r_G01*dr + r_G11*ds + r_G12*dt;
					r_qt = r_G02*dr + r_G12*ds + r_G22*dt;

					r_tmp = r_GwJ*s_q[k][j][i]*lambda;
				}
			}
		}
		@barrier("local");
		// Multiply by D^T, size p_Nq x p_gjNq
		// D size p_gjNq x p_Nq

		// r direction
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					s_q[k][j][i] = r_qr;
				}
			}
		}
		@barrier("local");

		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat tmp = 0.f;
					#pragma unroll p_gjNq
					for(int m=0; m<p_gjNq; ++m) {
						tmp += s_gjD[m][i]*s_q[k][j][m];
					}
					r_tmp +=tmp;
				}
			}
		}
		@barrier("local");

		//s direction

		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					s_q[k][j][i] = r_qs;
				}
			}
		}
		@barrier("local");
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat tmp = 0.f;
					#pragma unroll p_gjNq
					for(int m=0; m<p_gjNq; ++m) {
						tmp += s_gjD[m][j]*s_q[k][m][i];
					}
					r_tmp +=tmp;
				}
			}
		}
		@barrier("local");
		//t direction

		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					s_q[k][j][i] = r_qt;
				}
			}
		}
		@barrier("local");
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat tmp = 0.f;
					#pragma unroll p_gjNq
					for(int m=0; m<p_gjNq; ++m) {
						tmp += s_gjD[m][k]*s_q[m][j][i];
					}
					r_tmp +=tmp;
					int base = emap*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					Ixq[base] = r_tmp;
				}
			}
		}
	}//for e

	//-------------------- @kernel 3 interpolate back to gll hex ------------------->

	for(int e=0; e<Nelements; ++e; @outer(0)) {
		// read q

		@shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		@shared dfloat s_I[p_gjNq][p_Nq];
		@exclusive dfloat r_res = 0.0f, r_Aq=0.0f;
		int emap;
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {

					int base = k*p_gjNq*p_gjNq + j*p_gjNq + i;
					emap =elementList[e];
					s_q[k][j][i] = Ixq[emap*p_gjNp+base];
					if(i<p_Nq &&  k == 0 && j<p_gjNq) {
						s_I[j][i] = gjI[j*p_Nq+i];
					}
				}
			}
		}
		@barrier("local");


		// t first
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Iq = 0.0f;
					if(c<p_Nq){
						#pragma unroll p_gjNq
						for(int m=0; m<p_gjNq; ++m) {
							// k--> c
							Iq += s_I[m][c]*s_q[m][j][i];
						}
					}
					r_res = Iq;
				}
			}
		}

		@barrier("local");

		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					s_q[c][j][i] = r_res;
				}
			}
		}




		// r direction
		@barrier("local");

		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					if(c<p_Nq && b<p_Nq){
						dfloat Iq = 0.0f;
						#pragma unroll p_gjNq
						for(int m=0; m<p_gjNq; ++m) {
							Iq += s_I[m][b]*s_q[c][m][i];
						}
						r_res = Iq;
					}
				}
			}
		}
		@barrier("local");

		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					s_q[c][b][i]= r_res;
				}
			}
		}
		@barrier("local");

		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int a=0; a<p_gjNq; ++a; @inner(0)) {
					if (c<p_Nq && b<p_Nq && a< p_Nq){
						dfloat Iq = 0.0f;
						#pragma unroll p_gjNq
						for(int m=0; m<p_gjNq; ++m) {
							Iq += s_I[m][a]*s_q[c][b][m];
						}
						emap = elementList[e];
						int base = emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a;
						Aq[base] = Iq;
					}
				}
			}
		}
	}//e
} //@kernel e9


#define gjCubeThreads(c,b,a)			\
  @barrier("local");			\
  for(int c=0;c<p_gjNq;++c;@inner(2))		\
    for(int b=0;b<p_gjNq;++b;@inner(1))		\
      for(int a=0;a<p_gjNq;++a;@inner(0))


// e10 is the same as e9, just less barriers
@kernel void ellipticPartialAxHex3D_e10(const int Nelements,
                                       @restrict const  int *  elementList,
                                       @restrict const  dfloat *  gjGeo,
                                       @restrict const  dfloat *  gllD,
                                       @restrict const  dfloat *  gjI,
                                       const dfloat lambda,
                                       @restrict dfloat *  q,
                                       @restrict dfloat *  Ixq,
                                       @restrict dfloat *  Aq
                                      ){


	// load q into @shared first
	//@kernel 1 - interpolate to gj hex
	for(int e=0; e<Nelements; ++e; @outer(0)) {
		@exclusive int emap;
		//	@exclusive dfloat r_res;
		@shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		@shared dfloat s_q2[p_gjNq][p_gjNq][p_gjNq];
		@shared dfloat s_gsI[p_gjNq][p_Nq];

		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int a=0; a<p_gjNq; ++a; @inner(0)) {
					//		r_res =0.0f;
					if (c == 0 && a<p_Nq && b<p_gjNq) {
						s_gsI[b][a] = gjI[b*p_Nq+a];
					}
					emap = elementList[e];
					int t = a + b*p_gjNq + c*p_gjNq2;
					if (t<p_Np) {
						int ta = t%p_Nq;
						int tb = (t/p_Nq)%p_Nq;
						int tc = t/p_Nq2;
						s_q[tc][tb][ta] = q[emap*p_Np+t];
					}//if
				}//for a
			}// for b
		}//for c
		//synch threads
		@barrier("local");
		//============== interpolate in 3 dir ========================
		// r --> s --> t
		// rrrrrrr
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					//		dfloat Iq = 0.0f;
					s_q2[c][b][i] = 0.0f;
					if (c<p_Nq && b<p_Nq){
						#pragma unroll p_Nq
						for(int n=0; n<p_Nq; ++n) {
							s_q2[c][b][i] += s_gsI[i][n]*s_q[c][b][n];
						}
					}
					//			r_res = Iq;
					//		s_q2[c][b][i] = Iq;
				}
			}
		}

		@barrier("local");


		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					//	dfloat Iq = 0.0f;
					s_q[c][j][i] = 0.0f;
					if(c<p_Nq) {
						#pragma unroll p_Nq
						for(int n=0; n<p_Nq; ++n) {
							s_q[c][j][i] += s_gsI[j][n]*s_q2[c][n][i];
						}
					}
					//		r_res = Iq;
					//		s_q[c][j][i] = Iq;
				}
			}
		}
		@barrier("local");



		// t direction

		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					//	dfloat Iq = 0.0f;
					s_q2[k][j][i] =0.0f;
					#pragma unroll p_Nq
					for(int n=0; n<p_Nq; ++n) {
						s_q2[k][j][i] += s_gsI[k][n]*s_q[n][j][i];
					}
					//	r_res = Iq;
					//		s_q[k][j][i] = Iq;
					emap = elementList[e];
					const int id = emap*p_gjNp + k*p_gjNq*p_gjNq+ j*p_gjNq + i;
					Ixq[id] = s_q2[k][j][i];
					//s_q[k][j][i];
				}
			}
		}
	}// for e

	// at this point q is interpolated in all 3 dim.
	// ------------KERNEL 2 -------------->

	// @kernel 2 differentiate on gj hex
	for(int e=0; e<Nelements; ++e; @outer(0)) {
		@shared dfloat s_gjD[p_gjNq][p_gjNq];
		//	@shared dfloat s_gllD[p_gjNq][p_Nq];
		@shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		@shared dfloat s_q2[p_gjNq][p_gjNq][p_gjNq];
		@shared dfloat s_q3[p_gjNq][p_gjNq][p_gjNq];
		@exclusive dfloat r_qr, r_qs, r_qt, r_tmp;
		@exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;
		@exclusive int emap;

		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					// D to @shared, q to @shared,
					if (k==0 ) {
						s_gjD[j][i] = gllD[j*p_gjNq+i];
					}
					emap = elementList[e];
					int t = i + j*p_gjNq + k*p_gjNq2;
					s_q[k][j][i] = Ixq[emap*p_gjNp+t];

				}//for i
			}//for j
		}//for k
		@barrier("local");

		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					//load geofactors for my (k,j,i)
					//		emap = elementList[e];
					const int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					//geofactors for k j i thread
					r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
					r_G00 = gjGeo[base+p_G00ID*p_gjNp];
					r_G01 = gjGeo[base+p_G01ID*p_gjNp];
					r_G02 = gjGeo[base+p_G02ID*p_gjNp];

					r_G11 = gjGeo[base+p_G11ID*p_gjNp];
					r_G12 = gjGeo[base+p_G12ID*p_gjNp];
					r_G22 = gjGeo[base+p_G22ID*p_gjNp];
					// now, put together dq/dr, qq/ds, dq/dt and dq/dI

					dfloat dr = 0.0f;
					dfloat ds = 0.0f;
					dfloat dt = 0.0f;
					#pragma unroll p_gjNq
					for (int n = 0; n<p_gjNq; ++n) {
						dr += s_gjD[i][n] * s_q[k][j][n];
						ds += s_gjD[j][n] *s_q[k][n][i];
						dt += s_gjD[k][n] *s_q[n][j][i];
					}
					r_qr = r_G00*dr + r_G01*ds + r_G02*dt;
					r_qs = r_G01*dr + r_G11*ds + r_G12*dt;
					r_qt = r_G02*dr + r_G12*ds + r_G22*dt;

					r_tmp = r_GwJ*s_q[k][j][i]*lambda;

					//int base = emap*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					//		Ixq[base] = s_q[i][j][k];
					//		s_q2[k][j][i] = ds;
				}
			}
		}
		@barrier("local");
		// Multiply by D^T, size p_Nq x p_gjNq
		// D size p_gjNq x p_Nq

		// r direction
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					s_q[k][j][i] = r_qr;
					s_q2[k][j][i] = r_qs;
					s_q3[k][j][i] = r_qt;


				}
			}
		}
		@barrier("local");

		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat tmp = 0.f;
					#pragma unroll p_gjNq
					for(int m=0; m<p_gjNq; ++m) {
						tmp += s_gjD[m][i]*s_q[k][j][m];
						tmp += s_gjD[m][j]*s_q2[k][m][i];
						tmp += s_gjD[m][k]*s_q3[m][j][i];
					}
					r_tmp +=tmp;
					int base = emap*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					Ixq[base] = r_tmp;
				}
			}
		}
	}//for e

	//-------------------- @kernel 3 interpolate back to gll hex ------------------->

	for(int e=0; e<Nelements; ++e; @outer(0)) {
		// read q

		@shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		@shared dfloat s_I[p_gjNq][p_Nq];
		@exclusive dfloat r_res = 0.0f, r_Aq=0.0f;
		int emap;
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {

					int base = k*p_gjNq*p_gjNq + j*p_gjNq + i;
					emap =elementList[e];
					s_q[k][j][i] = Ixq[emap*p_gjNp+base];
					if(i<p_Nq &&  k == 0 && j<p_gjNq) {
						s_I[j][i] = gjI[j*p_Nq+i];
					}
				}
			}
		}
		@barrier("local");


		// t first
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Iq = 0.0f;
					if(c<p_Nq){
						#pragma unroll p_gjNq
						for(int m=0; m<p_gjNq; ++m) {
							// k--> c
							Iq += s_I[m][c]*s_q[m][j][i];
						}
					}
					r_res = Iq;
				}
			}
		}

		@barrier("local");

		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					s_q[c][j][i] = r_res;
				}
			}
		}




		// r direction
		@barrier("local");

		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					if(c<p_Nq && b<p_Nq){
						dfloat Iq = 0.0f;
						#pragma unroll p_gjNq
						for(int m=0; m<p_gjNq; ++m) {
							Iq += s_I[m][b]*s_q[c][m][i];
						}
						r_res = Iq;
					}
				}
			}
		}
		@barrier("local");

		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					s_q[c][b][i]= r_res;
				}
			}
		}
		@barrier("local");

		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int a=0; a<p_gjNq; ++a; @inner(0)) {
					if (c<p_Nq && b<p_Nq && a< p_Nq){
						dfloat Iq = 0.0f;
						#pragma unroll p_gjNq
						for(int m=0; m<p_gjNq; ++m) {
							Iq += s_I[m][a]*s_q[c][b][m];
						}
						emap = elementList[e];
						int base = emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a;
						Aq[base] = Iq;
					}
				}
			}
		}
	}//e
} //@kernel e10

//@kernel e11 --> NO REGISTERS2SHARED and no REGISTERS2GLOBAL transfers


// e10 is the same as e9, just less barriers
@kernel void ellipticPartialAxHex3D_e11(const int Nelements,
                                       @restrict const  int *  elementList,
                                       @restrict const  dfloat *  gjGeo,
                                       @restrict const  dfloat *  gllD,
                                       @restrict const  dfloat *  gjI,
                                       const dfloat lambda,
                                       @restrict dfloat *  q,
                                       @restrict dfloat *  Ixq,
                                       @restrict dfloat *  Aq
                                      ){


	// load q into @shared first
	//@kernel 1 - interpolate to gj hex
	for(int e=0; e<Nelements; ++e; @outer(0)) {
		//	@exclusive int emap;
		//	@exclusive dfloat r_res;
		@shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		@shared dfloat s_q2[p_gjNq][p_gjNq][p_gjNq];
		@shared dfloat s_gsI[p_gjNq][p_Nq];

		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int a=0; a<p_gjNq; ++a; @inner(0)) {
					//		r_res =0.0f;
					if (c == 0 && a<p_Nq && b<p_gjNq) {
						s_gsI[b][a] = gjI[b*p_Nq+a];
					}
					int emap = elementList[e];
					int t = a + b*p_gjNq + c*p_gjNq2;
					if (t<p_Np) {
						int ta = t%p_Nq;
						int tb = (t/p_Nq)%p_Nq;
						int tc = t/p_Nq2;
						s_q[tc][tb][ta] = q[emap*p_Np+t];
					}//if
				}//for a
			}// for b
		}//for c
		//synch threads
		@barrier("local");
		//============== interpolate in 3 dir ========================
		// r --> s --> t
		// rrrrrrr
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					//		dfloat Iq = 0.0f;
					s_q2[c][b][i] = 0.0f;
					if (c<p_Nq && b<p_Nq){
						#pragma unroll p_Nq
						for(int n=0; n<p_Nq; ++n) {
							s_q2[c][b][i] += s_gsI[i][n]*s_q[c][b][n];
						}
					}

				}
			}
		}

		@barrier("local");


		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					//	dfloat Iq = 0.0f;
					s_q[c][j][i] = 0.0f;
					if(c<p_Nq) {
						#pragma unroll p_Nq
						for(int n=0; n<p_Nq; ++n) {
							s_q[c][j][i] += s_gsI[j][n]*s_q2[c][n][i];
						}
					}

				}
			}
		}
		@barrier("local");



		// t direction

		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					//	dfloat Iq = 0.0f;
					s_q2[k][j][i] =0.0f;
					#pragma unroll p_Nq
					for(int n=0; n<p_Nq; ++n) {
						s_q2[k][j][i] += s_gsI[k][n]*s_q[n][j][i];
					}
					//	r_res = Iq;
					//		s_q[k][j][i] = Iq;
					int emap = elementList[e];
					const int id = emap*p_gjNp + k*p_gjNq*p_gjNq+ j*p_gjNq + i;
					Ixq[id] = s_q2[k][j][i];
					//s_q[k][j][i];
				}
			}
		}
	}// for e

	// at this point q is interpolated in all 3 dim.
	// ------------KERNEL 2 -------------->

	// @kernel 2 differentiate on gj hex
	for(int e=0; e<Nelements; ++e; @outer(0)) {
		@shared dfloat s_gjD[p_gjNq][p_gjNq];
		//	@shared dfloat s_gllD[p_gjNq][p_Nq];
		@shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		@shared dfloat s_q1[p_gjNq][p_gjNq][p_gjNq];
		@shared dfloat s_q2[p_gjNq][p_gjNq][p_gjNq];
		@shared dfloat s_q3[p_gjNq][p_gjNq][p_gjNq];
		@shared dfloat s_i4[p_gjNq][p_gjNq][p_gjNq];
		//	@exclusive dfloat r_qr, r_qs, r_qt, r_tmp;
		//		@exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;
		//		@exclusive int emap;

		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					// D to @shared, q to @shared,
					if (k==0 ) {
						s_gjD[j][i] = gllD[j*p_gjNq+i];
					}
					int emap = elementList[e];
					int t = i + j*p_gjNq + k*p_gjNq2;
					s_q[k][j][i] = Ixq[emap*p_gjNp+t];

				}//for i
			}//for j
		}//for k
		@barrier("local");

		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					//load geofactors for my (k,j,i)
					dfloat qr, qs, qt, tmp;
					dfloat G00, G01, G02, G11, G12, G22, GwJ;
					int emap;

					const int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					//geofactors for k j i thread
					GwJ = gjGeo[base+p_GWJID*p_gjNp];
					G00 = gjGeo[base+p_G00ID*p_gjNp];
					G01 = gjGeo[base+p_G01ID*p_gjNp];
					G02 = gjGeo[base+p_G02ID*p_gjNp];

					G11 = gjGeo[base+p_G11ID*p_gjNp];
					G12 = gjGeo[base+p_G12ID*p_gjNp];
					G22 = gjGeo[base+p_G22ID*p_gjNp];
					// now, put together dq/dr, qq/ds, dq/dt and dq/dI

					dfloat dr = 0.0f;
					dfloat ds = 0.0f;
					dfloat dt = 0.0f;
					#pragma unroll p_gjNq
					for (int n = 0; n<p_gjNq; ++n) {
						dr += s_gjD[i][n] * s_q[k][j][n];
						ds += s_gjD[j][n] *s_q[k][n][i];
						dt += s_gjD[k][n] *s_q[n][j][i];
					}
					qr = G00*dr + G01*ds + G02*dt;
					qs = G01*dr + G11*ds + G12*dt;
					qt = G02*dr + G12*ds + G22*dt;

					tmp = GwJ*s_q[k][j][i]*lambda;

					s_q1[k][j][i] = qr;
					s_q2[k][j][i] = qs;
					s_q3[k][j][i] = qt;
					s_i4[k][j][i] = tmp;



				}
			}
		}
		@barrier("local");
		// Multiply by D^T, size p_Nq x p_gjNq
		// D size p_gjNq x p_Nq



		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat tmp = 0.f;
					#pragma unroll p_gjNq
					for(int m=0; m<p_gjNq; ++m) {
						tmp += s_gjD[m][i]*s_q1[k][j][m];
						tmp += s_gjD[m][j]*s_q2[k][m][i];
						tmp += s_gjD[m][k]*s_q3[m][j][i];
					}
					s_i4[k][j][i]+=tmp;
					int emap = elementList[e];
					int base = emap*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					Ixq[base] =	s_i4[k][j][i];
				}
			}
		}
	}//for e

	//-------------------- @kernel 3 interpolate back to gll hex ------------------->

	for(int e=0; e<Nelements; ++e; @outer(0)) {
		// read q

		@shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		@shared dfloat s_q2[p_gjNq][p_gjNq][p_gjNq];
		@shared dfloat s_I[p_gjNq][p_Nq];
		//	@exclusive dfloat r_res = 0.0f, r_Aq=0.0f;
		//	int emap;
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {

					int base = k*p_gjNq*p_gjNq + j*p_gjNq + i;
					int emap =elementList[e];
					s_q[k][j][i] = Ixq[emap*p_gjNp+base];
					if(i<p_Nq &&  k == 0 && j<p_gjNq) {
						s_I[j][i] = gjI[j*p_Nq+i];
					}
				}
			}
		}
		@barrier("local");


		// t first
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Iq = 0.0f;
					if(c<p_Nq){
						#pragma unroll p_gjNq
						for(int m=0; m<p_gjNq; ++m) {
							// k--> c
							Iq += s_I[m][c]*s_q[m][j][i];
						}
					}
					//r_res = Iq;
					s_q2[c][j][i] = Iq;

				}
			}
		}






		// r direction
		@barrier("local");

		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					if(c<p_Nq && b<p_Nq){
						dfloat Iq = 0.0f;
						#pragma unroll p_gjNq
						for(int m=0; m<p_gjNq; ++m) {
							Iq += s_I[m][b]*s_q2[c][m][i];
						}

						s_q[c][b][i] = Iq;
					}
				}
			}
		}
		@barrier("local");




		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int a=0; a<p_gjNq; ++a; @inner(0)) {
					if (c<p_Nq && b<p_Nq && a< p_Nq){
						dfloat Iq = 0.0f;
						#pragma unroll p_gjNq
						for(int m=0; m<p_gjNq; ++m) {
							Iq += s_I[m][a]*s_q[c][b][m];
						}
						int emap = elementList[e];
						int base = emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a;
						Aq[base] = Iq;
					}
				}
			}
		}
	}//e
} //@kernel e11

// @kernel e12 is a ONE KERNEL version of e11

@kernel void ellipticPartialAxHex3D_e12(const int Nelements,
                                       @restrict const  int *  elementList,
                                       @restrict const  dfloat *  gjGeo,
                                       @restrict const  dfloat *  gllD,
                                       @restrict const  dfloat *  gjI,
                                       const dfloat lambda,
                                       @restrict dfloat *  q,
                                       @restrict dfloat *  Ixq,
                                       @restrict dfloat *  Aq
                                      ){


	// load q into @shared first
	//@kernel 1 - interpolate to gj hex
	for(int e=0; e<Nelements; ++e; @outer(0)) {
		//	@exclusive int emap;
		//	@exclusive dfloat r_res;
		@shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];

		@shared dfloat s_q1[p_gjNq][p_gjNq][p_gjNq];
		@shared dfloat s_q2[p_gjNq][p_gjNq][p_gjNq];
		@shared dfloat s_q3[p_gjNq][p_gjNq][p_gjNq];
		@shared dfloat s_i4[p_gjNq][p_gjNq][p_gjNq];

		@shared dfloat s_gjD[p_gjNq][p_gjNq];
		@shared dfloat s_gsI[p_gjNq][p_Nq];

		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int a=0; a<p_gjNq; ++a; @inner(0)) {
					//		r_res =0.0f;
					if (c == 0 && a<p_Nq && b<p_gjNq) {
						s_gsI[b][a] = gjI[b*p_Nq+a];
					}
					if (c==0 ) {
						s_gjD[b][a] = gllD[b*p_gjNq+a];
					}

					int emap = elementList[e];
					int t = a + b*p_gjNq + c*p_gjNq2;
					if (t<p_Np) {
						int ta = t%p_Nq;
						int tb = (t/p_Nq)%p_Nq;
						int tc = t/p_Nq2;
						s_q2[tc][tb][ta] = q[emap*p_Np+t];
					}//if
				}//for a
			}// for b
		}//for c
		//synch threads
		@barrier("local");
		//============== interpolate in 3 dir ========================
		// r --> s --> t
		// rrrrrrr
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					//		dfloat Iq = 0.0f;
					s_q[c][b][i] = 0.0f;
					if (c<p_Nq && b<p_Nq){
						#pragma unroll p_Nq
						for(int n=0; n<p_Nq; ++n) {
							s_q[c][b][i] += s_gsI[i][n]*s_q2[c][b][n];
						}
					}

				}
			}
		}

		@barrier("local");


		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					//	dfloat Iq = 0.0f;
					s_q2[c][j][i] = 0.0f;
					if(c<p_Nq) {
						#pragma unroll p_Nq
						for(int n=0; n<p_Nq; ++n) {
							s_q2[c][j][i] += s_gsI[j][n]*s_q[c][n][i];
						}
					}

				}
			}
		}
		@barrier("local");



		// t direction

		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					//	dfloat Iq = 0.0f;
					s_q[k][j][i] =0.0f;
					#pragma unroll p_Nq
					for(int n=0; n<p_Nq; ++n) {
						s_q[k][j][i] += s_gsI[k][n]*s_q2[n][j][i];
					}
				}
			}
		}


		// at this point q is interpolated in all 3 dim.
		// ------------KERNEL 2 -------------->

		@barrier("local");

		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					//load geofactors for my (k,j,i)
					dfloat qr, qs, qt, tmp;
					dfloat G00, G01, G02, G11, G12, G22, GwJ;
					int emap;

					const int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					//geofactors for k j i thread
					GwJ = gjGeo[base+p_GWJID*p_gjNp];
					G00 = gjGeo[base+p_G00ID*p_gjNp];
					G01 = gjGeo[base+p_G01ID*p_gjNp];
					G02 = gjGeo[base+p_G02ID*p_gjNp];

					G11 = gjGeo[base+p_G11ID*p_gjNp];
					G12 = gjGeo[base+p_G12ID*p_gjNp];
					G22 = gjGeo[base+p_G22ID*p_gjNp];
					// now, put together dq/dr, qq/ds, dq/dt and dq/dI

					dfloat dr = 0.0f;
					dfloat ds = 0.0f;
					dfloat dt = 0.0f;
					#pragma unroll p_gjNq
					for (int n = 0; n<p_gjNq; ++n) {
						dr += s_gjD[i][n] * s_q[k][j][n];
						ds += s_gjD[j][n] * s_q[k][n][i];
						dt += s_gjD[k][n] * s_q[n][j][i];
					}
					qr = G00*dr + G01*ds + G02*dt;
					qs = G01*dr + G11*ds + G12*dt;
					qt = G02*dr + G12*ds + G22*dt;

					tmp = GwJ*s_q[k][j][i]*lambda;

					s_q1[k][j][i] = qr;
					s_q2[k][j][i] = qs;
					s_q3[k][j][i] = qt;
					s_i4[k][j][i] = tmp;



				}
			}
		}
		@barrier("local");
		// Multiply by D^T, size p_Nq x p_gjNq
		// D size p_gjNq x p_Nq



		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat tmp = 0.f;
					#pragma unroll p_gjNq
					for(int m=0; m<p_gjNq; ++m) {
						tmp += s_gjD[m][i]*s_q1[k][j][m];
						tmp += s_gjD[m][j]*s_q2[k][m][i];
						tmp += s_gjD[m][k]*s_q3[m][j][i];
					}
					s_i4[k][j][i]+=tmp;

					s_q[k][j][i] =	s_i4[k][j][i];
				}
			}
		}

		@barrier("local");


		// t first
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Iq = 0.0f;
					if(c<p_Nq){
						#pragma unroll p_gjNq
						for(int m=0; m<p_gjNq; ++m) {
							// k--> c
							Iq += s_gsI[m][c]*s_q[m][j][i];
						}
					}
					//r_res = Iq;
					s_q2[c][j][i] = Iq;

				}
			}
		}






		// r direction
		@barrier("local");

		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					if(c<p_Nq && b<p_Nq){
						dfloat Iq = 0.0f;
						#pragma unroll p_gjNq
						for(int m=0; m<p_gjNq; ++m) {
							Iq += s_gsI[m][b]*s_q2[c][m][i];
						}

						s_q[c][b][i] = Iq;
					}
				}
			}
		}
		@barrier("local");




		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int a=0; a<p_gjNq; ++a; @inner(0)) {
					if (c<p_Nq && b<p_Nq && a< p_Nq){
						dfloat Iq = 0.0f;
						#pragma unroll p_gjNq
						for(int m=0; m<p_gjNq; ++m) {
							Iq += s_gsI[m][a]*s_q[c][b][m];
						}
						int emap = elementList[e];
						int base = emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a;
						Aq[base] = Iq;
					}
				}
			}
		}
	}//e
} //@kernel e12



//e6c is a version of e6 just no @exclusive variables

@kernel void ellipticPartialAxHex3D_e6c(const int Nelements,
                                       @restrict const  int *  elementList,
                                       @restrict const  dfloat *  gjGeo,
                                       @restrict const  dfloat *  gjD,
                                       @restrict const  dfloat *  gjI,
                                       const dfloat lambda,
                                       @restrict dfloat *  q,
                                       @restrict dfloat *  Aq,
                                       @restrict dfloat *  qAq){
	//KS Nall = 64000, mesh->Np = 125 mesh->Nelements = 512
	for(int e=0; e<Nelements; ++e; @outer(0)) {

		//KS: every thread processes one element
		// p_Nq number of points in the element
		//KS: Nggeo = 7, gjNq = 6, gjNp = 216 Nq = 5


		@shared dfloat s_D[p_gjNq][p_Nq+p_gllPad];
		@shared dfloat s_I[p_gjNq][p_Nq+p_gllPad];

		@shared dfloat s_q[p_gjNq][p_gjNq][p_Nq];
		@shared dfloat s_lapq[p_gjNq][p_gjNq][p_Nq];

		@shared dfloat s_Ixxq[p_Nq][p_Nq+p_gllPad];
		@shared dfloat s_Dxxq[p_Nq][p_Nq+p_gllPad];

		@shared dfloat s_IxDq[p_Nq][p_gjNq+p_gjPad];
		@shared dfloat s_IxIq[p_Nq][p_gjNq+p_gjPad];
		@shared dfloat s_DxIq[p_Nq][p_gjNq+p_gjPad];

		@shared dfloat s_qr[p_gjNq][p_gjNq+p_gjPad];
		@shared dfloat s_qs[p_gjNq][p_gjNq+p_gjPad];
		@shared dfloat s_qt[p_gjNq][p_gjNq+p_gjPad];

		@shared dfloat s_Dqr[p_gjNq][p_Nq+p_gllPad];
		@shared dfloat s_Iqs[p_gjNq][p_Nq+p_gllPad];
		@shared dfloat s_Iqt[p_gjNq][p_Nq+p_gllPad];

		@shared dfloat s_qI[p_gjNq][p_gjNq+p_gjPad];

		//	@exclusive int emap, ta, tb;
		@exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;
		// less registers (by half) or less @shared (ny half)
		// get rid of one of the register arrryas
		// use a cube of @shared
		// rewrite

		// put q in @shared
		// interpolation matrix in 3 directions
		// change which D we using (larger D) gjN

		// prefetch D and I matrices and zero register storage
		for(int b=0; b<p_gjNq; ++b; @inner(1)) {
			for(int a=0; a<p_gjNq; ++a; @inner(0)) {
				const int t = a + p_gjNq*b;

				if(a<p_Nq && b<p_gjNq) {
					s_D[b][a] = gjD[b*p_Nq+a];
					s_I[b][a] = gjI[b*p_Nq+a];
				}

				for(int c=0; c<p_Nq; ++c) {
					//	  r_q[c] = 0;
					s_lapq[b][a][c] = 0;
				}

				int emap = elementList[e];
				//Nq2 = Nq*Nq
				if(a<p_Nq && b<p_Nq) {

					#pragma unroll p_Nq
					for(int c=0; c<p_Nq; ++c) {
						s_q[b][a][c] = q[emap*p_Np+c*p_Nq2+b*p_Nq+a];
					}                                                                                                                                                        //for c
				}                                                                                                                                                        //if
			}                                                                                                                                                        //for a
		}                                                                                                                                                        //for b

		// *************** scan through k slices
		// ==================================== prefetch first, diff in 't'
		for(int k=0; k<p_gjNq; ++k) {

			optBarrier(localMemFence);

			// prefetch slice
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int a=0; a<p_gjNq; ++a; @inner(0)) {
					int emap = elementList[e];
					int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + b*p_gjNq + a;
					r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
					r_G00 = gjGeo[base+p_G00ID*p_gjNp];
					r_G01 = gjGeo[base+p_G01ID*p_gjNp];
					r_G02 = gjGeo[base+p_G02ID*p_gjNp];

					r_G11 = gjGeo[base+p_G11ID*p_gjNp];
					r_G12 = gjGeo[base+p_G12ID*p_gjNp];
					r_G22 = gjGeo[base+p_G22ID*p_gjNp];

					// assumes w*J built into G entries

					if (a<p_Nq && b<p_Nq) {

						dfloat Iqk = 0, Dqk = 0;

						// puts more data in flight
						for(int c=0; c<p_Nq; ++c) {
							const dfloat qcba = s_q[b][a][c];
							Iqk += s_I[k][c]*qcba;
							Dqk += s_D[k][c]*qcba;
						}
						s_Ixxq[b][a] = Iqk;
						s_Dxxq[b][a] = Dqk;
					}
				}
			}

			optBarrier(localMemFence);
			//=========================== r direction =========================================
			// interpolate and differentiate in 'r' direction
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {

					if(b<p_Nq) {

						dfloat IxDq= 0, IxIq = 0, DxIq = 0;

						#pragma unroll p_Nq
						for(int a=0; a<p_Nq; ++a) {
							const dfloat Iia = s_I[i][a];
							const dfloat Ixxqba = s_Ixxq[b][a];
							IxIq += Iia*Ixxqba;
							DxIq += Iia*s_Dxxq[b][a];
						}

						#pragma unroll p_Nq
						for(int a=0; a<p_Nq; ++a) {
							const dfloat Dia = s_D[i][a];
							const dfloat Ixxqba = s_Ixxq[b][a];
							IxDq += Dia*Ixxqba;
						}

						s_IxDq[b][i] = IxDq;
						// this is what we want
						s_IxIq[b][i] = IxIq;
						s_DxIq[b][i] = DxIq;
					}
				}
			}

			optBarrier(localMemFence);
			//=============================== derivatives =========================================
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {

					dfloat qr = 0, qs = 0, qt = 0, qI = 0;

					// interpolate and differentiate in 's' direction
					#pragma unroll p_Nq
					for(int b=0; b<p_Nq; ++b) {
						const dfloat Ijn = s_I[j][b];
						// qr = dq/dr, qt = dq/dt and qI = dq/dI
						qr += Ijn*s_IxDq[b][i];
						qt += Ijn*s_DxIq[b][i];
						qI += Ijn*s_IxIq[b][i];
					}

					#pragma unroll p_Nq
					//qs = dq/ds
					for(int b=0; b<p_Nq; ++b) {
						const dfloat Djn = s_D[j][b];
						qs += Djn*s_IxIq[b][i];
					}

					// apply chain rule (notice the swtich of indices in i,j)

					//	dfloat G00, G01, G02, G11, G12, G22, GwJ;


					s_qr[i][j] = r_G00*qr + r_G01*qs + r_G02*qt;
					s_qs[i][j] = r_G01*qr + r_G11*qs + r_G12*qt;
					s_qt[i][j] = r_G02*qr + r_G12*qs + r_G22*qt;
					// qI needed because of interpolation (?)
					s_qI[i][j] = r_GwJ*qI*lambda;
				}                                                                                                                                                        // for i
			}                                                                                                                                                        // for j
			// =============================== transpose differentiate ==============================
			optBarrier(localMemFence);

			// transpose differentiate and interpolate in 'r'
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int a=0; a<p_gjNq; ++a; @inner(0)) {

					if(a<p_Nq) {
						dfloat tmpr = 0, tmps = 0, tmpt = 0, tmpI = 0;
						#pragma unroll p_gjNq
						for(int i=0; i<p_gjNq; ++i) {
							const dfloat Iia = s_I[i][a];
							tmps += Iia*s_qs[i][j];
							tmpt += Iia*s_qt[i][j];
							tmpI += Iia*s_qI[i][j];
						}

						#pragma unroll p_gjNq
						for(int i=0; i<p_gjNq; ++i) {
							const dfloat Dia = s_D[i][a];
							tmpr += Dia*s_qr[i][j];
						}

						s_Dqr[j][a] = tmpr+tmpI;                                                                                                                                                         // blend lambda term in here
						s_Iqs[j][a] = tmps;
						s_Iqt[j][a] = tmpt;
					}
				}
			}

			optBarrier(localMemFence);

			// transpose differentiate and interpolate in 's'
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int a=0; a<p_gjNq; ++a; @inner(0)) {
					if(a<p_Nq && b<p_Nq) {
						dfloat tmpr = 0, tmps = 0, tmpt = 0;

						#pragma unroll p_gjNq
						for(int j=0; j<p_gjNq; ++j) {
							const dfloat Ijb = s_I[j][b];

							tmpr += Ijb*s_Dqr[j][a];
							tmpt += Ijb*s_Iqt[j][a];
						}


						#pragma unroll p_gjNq
						for(int j=0; j<p_gjNq; ++j) {
							const dfloat Djb = s_D[j][b];

							tmps += Djb*s_Iqs[j][a];
						}

						// transpose differentiate and interpolate in 't'
						tmpr += tmps;                                                                                                                                                         // blend r and s
						#pragma unroll p_Nq
						for(int c=0; c<p_Nq; ++c) {
							s_lapq[b][a][c] += s_I[k][c]*tmpr + s_D[k][c]*tmpt;
						}
					}
				}
			}
		}  // k                                                                                                                                                      // this is FOR k

		optBarrier(localMemFence);

		for(int b=0; b<p_gjNq; ++b; @inner(1)) {
			for(int a=0; a<p_gjNq; ++a; @inner(0)) {

				dfloat r_qAq = 0;

				if(a<p_Nq && b<p_Nq) {
					#pragma unroll p_Nq
					for(int c=0; c<p_Nq; ++c) {
						int emap = elementList[e];
						const int id = emap*p_Np + c*p_Nq2 + b*p_Nq + a;
						Aq[id] = s_lapq[b][a][c];
					}
				}
			}
		}
	}
}//e6c






// e10 is an optimized version of e9 - WITH as little memFences as possible.
// written by Kasia, Aug 10 2017
/*
@kernel void ellipticPartialAxHex3D_10( const int Nelements,
                                      @restrict const  int *  elementList,
                                      @restrict const  dfloat *  gjGeo,
                                      @restrict const  dfloat *  gjD,
                                      @restrict const  dfloat *  gjI,
                                      @restrict const  dfloat *  gllD,
                                      const dfloat lambda,
                                      @restrict dfloat *  q,
                                      @restrict dfloat *  Ixq,
                                      @restrict dfloat *  Aq,
                                      float * @restrict qAq

)
{

// ---- KERNEL 1 ---- INTERPOLATE

//load to @shared first
for(int e=0; e<Nelements; ++e; @outer(0)) {
	@exclusive int emap;
	@exclusive dfloat r_res;
	@shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
	@shared dfloat s_I[p_gjNq][p_Nq];
		for(int c=0; c<p_Nq; ++c; @inner(2)) {
			for(int b=0; b<p_Nq; ++b; @inner(1)) {
				for(int i=0; i<p_Nq; ++i; @inner(0)) {
		}}}
	
// prefetch to @shared

}
}



@kernel void ellipticPartialAxHex3D_cube1(const int Nelements,
					 @restrict const  int *  elementList,
					 @restrict const  dfloat *  gjGeo,
					 @restrict const  dfloat *  gjD,
					 @restrict const  dfloat *  gjI,
					 const dfloat   lambda,
					 @restrict const  dfloat *  q,
					 @restrict dfloat *  Aq,
					 @restrict dfloat *  qtmp){


  for(int e=0;e<Nelements;++e;@outer(0)){

    @shared dfloat s_gjD[p_gjNq][p_gjNq];
    @shared dfloat s_I[p_gjNq][p_Nq];

    @shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];

    @exclusive int emap;
    @exclusive dfloat r_resr, r_ress, r_rest, r_resI;

    // prefetch D and I matrices and zero register storage
    gjCubeThreads(c,b,a){
      const int t = a + p_gjNq*b + p_gjNq2*c;

      if(t<p_gjNq*p_gjNq)
	s_gjD[0][t] = gjD[t];
      if(t<p_Nq*p_gjNq)
	s_I[0][t] = gjI[t];

      emap = elementList[e];

      if(t<p_Np){
	const int ta = t%p_Nq;
	const int tb = (t/p_Nq)%p_Nq;
	const int tc = t/(p_Nq*p_Nq);
	s_q[tc][tb][ta] = q[emap*p_Np+t];
      }
    }

    gjCubeThreads(c,b,i){
      if(b<p_Nq && c<p_Nq){
	dfloat tmp = 0;
	#pragma unroll p_Nq
	  for(int a=0;a<p_Nq;++a) // transform in 'a'
	    tmp += s_I[i][a]*s_q[c][b][a];
	r_resr = tmp;
      }
    }

    gjCubeThreads(c,b,i)
      s_q[c][b][i] = r_resr;

    gjCubeThreads(c,j,i){
      if(c<p_Nq){
	dfloat tmp = 0;
	#pragma unroll p_Nq
	  for(int b=0;b<p_Nq;++b) // transform in 'b'
	    tmp += s_I[j][b]*s_q[c][b][i];
	r_ress = tmp;
      }
    }

    gjCubeThreads(c,j,i)
      s_q[c][j][i] = r_ress;

    gjCubeThreads(k,j,i){
      dfloat tmp = 0;
      #pragma unroll p_Nq
	for(int c=0;c<p_Nq;++c) // transform in 'c'
	  tmp += s_I[k][c]*s_q[c][j][i];
      r_rest = tmp;
    }

    gjCubeThreads(k,j,i)
      s_q[k][j][i] = r_rest;

    gjCubeThreads(k,j,i){
      const int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
      const dfloat r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
      const dfloat r_G00 = gjGeo[base+p_G00ID*p_gjNp];
      const dfloat r_G01 = gjGeo[base+p_G01ID*p_gjNp];
      const dfloat r_G02 = gjGeo[base+p_G02ID*p_gjNp];

      const dfloat r_G11 = gjGeo[base+p_G11ID*p_gjNp];
      const dfloat r_G12 = gjGeo[base+p_G12ID*p_gjNp];
      const dfloat r_G22 = gjGeo[base+p_G22ID*p_gjNp];

      dfloat qr = 0, qs = 0, qt = 0;

      #pragma unroll p_gjNq
	for(int n=0;n<p_gjNq;++n){
	  qr += s_gjD[i][n]*s_q[k][j][n];
	  qs += s_gjD[j][n]*s_q[k][n][i];
	  qt += s_gjD[k][n]*s_q[n][j][i];
	}

      // apply chain rule (notice the swtich of indices in i,j)
      r_resr = r_G00*qr + r_G01*qs + r_G02*qt;
      r_ress = r_G01*qr + r_G11*qs + r_G12*qt;
      r_rest = r_G02*qr + r_G12*qs + r_G22*qt;
      r_resI = r_GwJ*s_q[k][j][i]*lambda;
    }

    // compute 'r' weak derivative of resr
    gjCubeThreads(k,j,i)
      s_q[k][j][i] = r_resr;

    gjCubeThreads(k,j,i){
      dfloat tmp = 0;
      #pragma unroll p_gjNq
	for(int n=0;n<p_gjNq;++n)
	  tmp += s_gjD[n][i]*s_q[k][j][n]; // transpose(D)
      r_resI += tmp;
    }

    // compute 's' weak derivative of resr
    gjCubeThreads(k,j,i)
      s_q[k][j][i] = r_ress;

    gjCubeThreads(k,j,i){
      dfloat tmp = 0;
      #pragma unroll p_gjNq
	for(int n=0;n<p_gjNq;++n)
	  tmp += s_gjD[n][j]*s_q[k][n][i]; // transpose(D)
      r_resI += tmp;
    }

    // compute 't' weak derivative of resr
    gjCubeThreads(k,j,i)
      s_q[k][j][i] = r_rest;

    gjCubeThreads(k,j,i){ // notice swapped
      dfloat tmp = 0;
      #pragma unroll p_gjNq
	for(int n=0;n<p_gjNq;++n)
	  tmp += s_gjD[n][k]*s_q[n][j][i]; // transpose(D)
      r_resI += tmp;
    }

    // NOW REVERSE: transform back in 't'
    gjCubeThreads(k,j,i)
      s_q[k][j][i] = r_resI;

    gjCubeThreads(c,j,i){
      dfloat tmp = 0;
      if(c<p_Nq){
	#pragma unroll p_gjNq
	  for(int n=0;n<p_gjNq;++n)
	    tmp += s_I[n][c]*s_q[n][j][i];
      }
      r_rest = tmp;
    }

    // transform back in 's'
    gjCubeThreads(c,j,i)
      s_q[c][j][i] = r_rest;

    gjCubeThreads(c,b,i){
      dfloat tmp = 0;
      if(c<p_Nq && b<p_Nq){
	#pragma unroll p_gjNq
	  for(int n=0;n<p_gjNq;++n)
	    tmp += s_I[n][b]*s_q[c][n][i];
      }
      r_ress = tmp;
    }

    // transform back in 'r'
    gjCubeThreads(c,b,i)
      s_q[c][b][i] = r_ress;

    gjCubeThreads(c,b,a){
      if(a<p_Nq && b<p_Nq && c<p_Nq){
	dfloat tmp = 0;
	#pragma unroll p_gjNq
	  for(int n=0;n<p_gjNq;++n)
	    tmp += s_I[n][a]*s_q[c][b][n];
	// could store in s_q again
	const int id = emap*p_Np + c*p_Nq2 + b*p_Nq + a;
	Aq[id] = tmp;
      }
    }
  }
}



// Version of Kasia @kernel
@kernel void ellipticPartialAxHex3D_cube2(const int Nelements,
					 @restrict const  int *  elementList,
					 @restrict const  dfloat *  gjGeo,
					 @restrict const  dfloat *  gjD,
					 @restrict const  dfloat *  gjI,
					 const dfloat   lambda,
					 @restrict const  dfloat *  q,
					 @restrict dfloat *  Aq,
					 @restrict dfloat *  tmpq){


  // interpolate to GJ nodes
  for(int e=0;e<Nelements;++e;@outer(0)){

    @shared dfloat s_I[p_gjNq][p_Nq];
    @shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];

    @exclusive int emap;
    @exclusive dfloat r_resr, r_ress, r_rest, r_resI;

    // prefetch D and I matrices and zero register storage
    gjCubeThreads(c,b,a){
      const int t = a + p_gjNq*b + p_gjNq2*c;

      if(t<p_Nq*p_gjNq)
	s_I[0][t] = gjI[t];

      emap = elementList[e];

      if(t<p_Np){
	const int ta = t%p_Nq;
	const int tb = (t/p_Nq)%p_Nq;
	const int tc = t/(p_Nq*p_Nq);
	s_q[tc][tb][ta] = q[emap*p_Np+t];
      }
    }

    gjCubeThreads(c,b,i){
      if(b<p_Nq && c<p_Nq){
	dfloat tmp = 0;
	#pragma unroll p_Nq
	  for(int a=0;a<p_Nq;++a) // transform in 'a'
	    tmp += s_I[i][a]*s_q[c][b][a];
	r_resr = tmp;
      }
    }

    gjCubeThreads(c,b,i)
      s_q[c][b][i] = r_resr;

    gjCubeThreads(c,j,i){
      if(c<p_Nq){
	dfloat tmp = 0;
	#pragma unroll p_Nq
	  for(int b=0;b<p_Nq;++b) // transform in 'b'
	    tmp += s_I[j][b]*s_q[c][b][i];
	r_ress = tmp;
      }
    }

    gjCubeThreads(c,j,i)
      s_q[c][j][i] = r_ress;

    gjCubeThreads(k,j,i){
      dfloat tmp = 0;
      #pragma unroll p_Nq
	for(int c=0;c<p_Nq;++c) // transform in 'c'
	  tmp += s_I[k][c]*s_q[c][j][i];

      tmpq[emap*p_gjNp + k*p_gjNq2 + j*p_gjNq + i] = tmp;
    }
  }

  // perform differentiation
  for(int e=0;e<Nelements;++e;@outer(0)){

    @shared dfloat s_gjD[p_gjNq][p_gjNq];
    @shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];

    @exclusive int emap;
    @exclusive dfloat r_resr, r_ress, r_rest, r_resI;

    // prefetch D and I matrices and zero register storage
    gjCubeThreads(k,j,i){
      const int t = i + p_gjNq*j + p_gjNq2*k;

      if(t<p_gjNq*p_gjNq)
	s_gjD[0][t] = gjD[t];

      emap = elementList[e];

      s_q[k][j][i] = tmpq[emap*p_gjNp+k*p_gjNq2+j*p_gjNq+i];
    }

    gjCubeThreads(k,j,i){
      const int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
      const dfloat r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
      const dfloat r_G00 = gjGeo[base+p_G00ID*p_gjNp];
      const dfloat r_G01 = gjGeo[base+p_G01ID*p_gjNp];
      const dfloat r_G02 = gjGeo[base+p_G02ID*p_gjNp];

      const dfloat r_G11 = gjGeo[base+p_G11ID*p_gjNp];
      const dfloat r_G12 = gjGeo[base+p_G12ID*p_gjNp];
      const dfloat r_G22 = gjGeo[base+p_G22ID*p_gjNp];

      dfloat qr = 0, qs = 0, qt = 0;

      #pragma unroll p_gjNq
	for(int n=0;n<p_gjNq;++n){
	  qr += s_gjD[i][n]*s_q[k][j][n];
	  qs += s_gjD[j][n]*s_q[k][n][i];
	  qt += s_gjD[k][n]*s_q[n][j][i];
	}

      // apply chain rule (notice the swtich of indices in i,j)
      r_resr = r_G00*qr + r_G01*qs + r_G02*qt;
      r_ress = r_G01*qr + r_G11*qs + r_G12*qt;
      r_rest = r_G02*qr + r_G12*qs + r_G22*qt;
      r_resI = r_GwJ*s_q[k][j][i]*lambda;
    }

    // compute 'r' weak derivative of resr
    gjCubeThreads(k,j,i)
      s_q[k][j][i] = r_resr;

    gjCubeThreads(k,j,i){
      dfloat tmp = 0;
      #pragma unroll p_gjNq
	for(int n=0;n<p_gjNq;++n)
	  tmp += s_gjD[n][i]*s_q[k][j][n]; // transpose(D)
      r_resI += tmp;
    }

    // compute 's' weak derivative of resr
    gjCubeThreads(k,j,i)
      s_q[k][j][i] = r_ress;

    gjCubeThreads(k,j,i){
      dfloat tmp = 0;
      #pragma unroll p_gjNq
	for(int n=0;n<p_gjNq;++n)
	  tmp += s_gjD[n][j]*s_q[k][n][i]; // transpose(D)
      r_resI += tmp;
    }

    // compute 't' weak derivative of resr
    gjCubeThreads(k,j,i)
      s_q[k][j][i] = r_rest;

    gjCubeThreads(k,j,i){ // notice swapped
      dfloat tmp = 0;
      #pragma unroll p_gjNq
	for(int n=0;n<p_gjNq;++n)
	  tmp += s_gjD[n][k]*s_q[n][j][i]; // transpose(D)
      r_resI += tmp;

      tmpq[emap*p_gjNp+k*p_gjNq2+j*p_gjNq+i] = r_resI;
    }
  }

  // interpolate back
  for(int e=0;e<Nelements;++e;@outer(0)){

    @shared dfloat s_I[p_gjNq][p_Nq];
    @shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];

    @exclusive int emap;
    @exclusive dfloat r_ress, r_rest, r_resI;

    // NOW REVERSE: transform back in 't'
    gjCubeThreads(k,j,i){
      const int t = i + p_gjNq*j + p_gjNq2*k;
      if(t<p_Nq*p_gjNq)

      emap = elementList[e];
      s_q[k][j][i] = tmpq[emap*p_gjNp+t];
    }

    gjCubeThreads(c,j,i){
      dfloat tmp = 0;
      if(c<p_Nq){
	#pragma unroll p_gjNq
	  for(int n=0;n<p_gjNq;++n)
	    tmp += s_I[n][c]*s_q[n][j][i];
      }
      r_rest = tmp;
    }

    // transform back in 's'
    gjCubeThreads(c,j,i)
      s_q[c][j][i] = r_rest;

    gjCubeThreads(c,b,i){
      dfloat tmp = 0;
      if(c<p_Nq && b<p_Nq){
	#pragma unroll p_gjNq
	  for(int n=0;n<p_gjNq;++n)
	    tmp += s_I[n][b]*s_q[c][n][i];
      }
      r_ress = tmp;
    }

    // transform back in 'r'
    gjCubeThreads(c,b,i)
      s_q[c][b][i] = r_ress;

    gjCubeThreads(c,b,a){
      if(a<p_Nq && b<p_Nq && c<p_Nq){
	dfloat tmp = 0;
	#pragma unroll p_gjNq
	  for(int n=0;n<p_gjNq;++n)
	    tmp += s_I[n][a]*s_q[c][b][n];
	// could store in s_q again
	const int id = emap*p_Np + c*p_Nq2 + b*p_Nq + a;
	Aq[id] = tmp;
      }
    }
  }
}*/

#endif