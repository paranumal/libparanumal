#define RXID 0  
#define RYID 1  
#define SXID 2  
#define SYID 3

// function to compute collocation differentiation
// contributions to nodal DG rhs for acoustics
@kernel void acousticsVolume2D(const int Nelements,
				     @restrict const  dfloat *  vgeo,
				     @restrict const  dfloat *  DrT,
				     @restrict const  dfloat *  DsT,
				     @restrict const  dfloat *  q,
				     @restrict dfloat *  rhsq){
  
	for(int e=0;e<Nelements;++e;@outer(0)){  // for all elements
  	for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element

	    // prefetch geometric factors (constant on triangle)
	    const dfloat drdx = vgeo[e*p_Nvgeo + RXID];
	    const dfloat drdy = vgeo[e*p_Nvgeo + RYID];
	    const dfloat dsdx = vgeo[e*p_Nvgeo + SXID];
	    const dfloat dsdy = vgeo[e*p_Nvgeo + SYID];
	      
	    // compute 'r' and 's' derivatives of (u,v,p) at node n
	    dfloat dudr = 0, duds = 0;
	    dfloat dvdr = 0, dvds = 0;
	    dfloat dpdr = 0, dpds = 0;
	      
	    for(int i=0;i<p_Np;++i){
				// load data at node i of element e
				const int id = p_Nfields*(e*p_Np + i);
				const dfloat u = q[id+0], v = q[id+1], p = q[id+2];

			 	const dfloat Drni = DrT[n+i*p_Np];
				const dfloat Dsni = DsT[n+i*p_Np];

				// differentiate (u,v,p) with respect to 'r' and 's'
				dudr += Drni*u; duds += Dsni*u;
				dvdr += Drni*v; dvds += Dsni*v;
				dpdr += Drni*p;	dpds += Dsni*p;
      }

	    // chain rule
	    const dfloat dudx = drdx*dudr + dsdx*duds;
	    const dfloat dvdy = drdy*dvdr + dsdy*dvds;
	    const dfloat dpdx = drdx*dpdr + dsdx*dpds;
	    const dfloat dpdy = drdy*dpdr + dsdy*dpds;
	      
	    // store acoustics rhs contributions from collocation differentiation
	    const int id = p_Nfields*(e*p_Np + n);
	    rhsq[id+0] = -dpdx;
	    rhsq[id+1] = -dpdy;
	    rhsq[id+2] = -dudx-dvdy;
    }
	}
}


@kernel void acousticsVolume2Dbbdg(const int Nelements,
					@restrict const  dfloat *  vgeo,
					@restrict const  int *  D1ids,
					@restrict const  int *  D2ids,
					@restrict const  int *  D3ids,
					@restrict const  dfloat *  Dvals,		
					@restrict const  dfloat *  q,
					@restrict dfloat *  rhsq){
  
  for(int eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){  // for all elements

    @shared dfloat s_u[p_NblockV][p_Np];
    @shared dfloat s_v[p_NblockV][p_Np];
    @shared dfloat s_p[p_NblockV][p_Np];

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element

				int e = eo+es; // element in block

				if(e<Nelements){
				  const int id = p_Nfields*(e*p_Np + n);
		  	  s_u[es][n] = q[id+0];
		  	  s_v[es][n] = q[id+1];
		  	  s_p[es][n] = q[id+2];
				}
      }
    }

    // make sure all node data is loaded into @shared
    @barrier("local");

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element
	
				int e = eo+es; // element in block
				if(e<Nelements){
				  
				  // prefetch geometric factors (constant on triangle)
				  const dfloat drdx = vgeo[e*p_Nvgeo + RXID];
				  const dfloat drdy = vgeo[e*p_Nvgeo + RYID];
				  const dfloat dsdx = vgeo[e*p_Nvgeo + SXID];
				  const dfloat dsdy = vgeo[e*p_Nvgeo + SYID];

				  // compute 'r' and 's' derivatives of (q_m) at node n
				  const int D1i1 = D1ids[n];
				  const int D2i1 = D2ids[n];
				  const int D3i1 = D3ids[n];
				  const dfloat Dval1 = Dvals[n];
				  
				  const int D1i2 = D1ids[n+p_Np];
				  const int D2i2 = D2ids[n+p_Np];
				  const int D3i2 = D3ids[n+p_Np];
				  const dfloat Dval2 = Dvals[n+p_Np];

				  const int D1i3 = D1ids[n+2*p_Np];
				  const int D2i3 = D2ids[n+2*p_Np];
				  const int D3i3 = D3ids[n+2*p_Np];	  
				  const dfloat Dval3 = Dvals[n+2*p_Np];

				  const dfloat dudr = .5f*(Dval1*(s_u[es][D2i1] - s_u[es][D1i1]) +
							    Dval2*(s_u[es][D2i2] - s_u[es][D1i2]) +
							    Dval3*(s_u[es][D2i3] - s_u[es][D1i3]));
				  const dfloat duds = .5f*(Dval1*(s_u[es][D3i1] - s_u[es][D1i1]) +
							    Dval2*(s_u[es][D3i2] - s_u[es][D1i2]) +
							    Dval3*(s_u[es][D3i3] - s_u[es][D1i3]));
				  
				  const dfloat dvdr = .5f*(Dval1*(s_v[es][D2i1] - s_v[es][D1i1]) +
							    Dval2*(s_v[es][D2i2] - s_v[es][D1i2]) +
							    Dval3*(s_v[es][D2i3] - s_v[es][D1i3]));
				  const dfloat dvds = .5f*(Dval1*(s_v[es][D3i1] - s_v[es][D1i1]) +
							    Dval2*(s_v[es][D3i2] - s_v[es][D1i2]) +
							    Dval3*(s_v[es][D3i3] - s_v[es][D1i3]));
				  
				  const dfloat dpdr = .5f*(Dval1*(s_p[es][D2i1] - s_p[es][D1i1]) +
							    Dval2*(s_p[es][D2i2] - s_p[es][D1i2]) +
							    Dval3*(s_p[es][D2i3] - s_p[es][D1i3]));
				  const dfloat dpds = .5f*(Dval1*(s_p[es][D3i1] - s_p[es][D1i1]) +
							    Dval2*(s_p[es][D3i2] - s_p[es][D1i2]) +
							    Dval3*(s_p[es][D3i3] - s_p[es][D1i3]));

				  // chain rule
				  dfloat dudx = drdx*dudr + dsdx*duds;
				  dfloat dvdy = drdy*dvdr + dsdy*dvds;
				  dfloat dpdx = drdx*dpdr + dsdx*dpds;
				  dfloat dpdy = drdy*dpdr + dsdy*dpds;
				  
				  const int id = p_Nfields*(e*p_Np + n);
	  			rhsq[id+0] = -dpdx;
	  			rhsq[id+1] = -dpdy;
	  			rhsq[id+2] = -dudx-dvdy;
				}
      }
    }
  }
}
