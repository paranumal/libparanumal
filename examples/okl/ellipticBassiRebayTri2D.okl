
@kernel void ellipticBRGradientVolume2D(const int Nelements,
        @restrict const  dfloat *  vgeo,
        @restrict const  dfloat *  DrT,
        @restrict const  dfloat *  DsT,
        @restrict const  dfloat *  q,
        @restrict dfloat *  gradq){

  for(int eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){
    // for all elements
    @shared dfloat s_q[p_NblockV][p_Np];

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element
        int e = eo+es; // element in block
        if(e<Nelements){
          s_q[es][n]  = q[n + e*p_Np];
        }
      }
    }

    // Make sure all node data is loaded into @shared
    @barrier("local");

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element

        int e = eo+es; // element in block
        if(e<Nelements){
          // prefetch geometric factors (constant on triangle)
          const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
          const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
          const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
          const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];

          dfloat dqdr  = 0.f, dqds  = 0.f;
          #pragma unroll p_Np
            for(int i=0;i<p_Np;++i){
              const dfloat Drni = DrT[n+i*p_Np];
              const dfloat Dsni = DsT[n+i*p_Np];

              dqdr  += Drni*s_q[es][i];
              dqds  += Dsni*s_q[es][i];
            }

          const int id = e*2*p_Np;
          gradq[id+     n] = drdx*dqdr + dsdx*dqds;
          gradq[id+p_Np+n] = drdy*dqdr + dsdy*dqds;
        }
      }
    }
  }
}

@kernel void ellipticBRGradientSurface2D(const int Nelements,
         @restrict const  int   *  vmapM,
         @restrict const  int   *  vmapP,
         @restrict const  dfloat *  sgeo,
         @restrict const  int   *  EToB,
         @restrict const  dfloat *  LIFTT,
         @restrict const  dfloat *  q,
         @restrict dfloat *  gradq){

  // for all elements
  for(int eo=0;eo<Nelements;eo+=p_NblockS;@outer(0)){

    @shared dfloat s_fluxqx[p_NblockS][p_Nfp*p_Nfaces];
    @shared dfloat s_fluxqy[p_NblockS][p_Nfp*p_Nfaces];

    // for all face nodes of all elements
    for(int es=0;es<p_NblockS;++es;@inner(1)){
      for(int n=0;n<p_maxNodes;++n;@inner(0)){ // maxNodes = max(Nfp*Nfaces,Np)
        int e = eo + es;
        if(e<Nelements){
          if(n<p_Nfp*p_Nfaces){
            // find face that owns this node
            int face = n/p_Nfp;
            // load surface geofactors for this face
            int sid    = p_Nsgeo*(e*p_Nfaces+face);
            dfloat nx   = sgeo[sid+p_NXID];
            dfloat ny   = sgeo[sid+p_NYID];
            dfloat sJ   = sgeo[sid+p_SJID];
            dfloat invJ = sgeo[sid+p_IJID];

            // indices of negative and positive traces of face node
            int id  = e*p_Nfp*p_Nfaces + n;
            const int idM = vmapM[id];
            const int idP = vmapP[id];

            dfloat  qM = q[idM], qP = q[idP];

            // apply boundary condition
            int bc = EToB[face+p_Nfaces*e];
            if(bc>0) {
              dfloat qxM = 0.f, qyM = 0.f;
              dfloat qxP = 0.f, qyP = 0.f;
              ellipticHomogeneousBC2D(bc, qM, qxM, qyM, qP, qxP, qyP);
              qP = 2*qP - qM;
            }

            // evaluate "flux" terms: LLF
            const dfloat sc = invJ * sJ ;

            // Centered flux for pr p*-p = 0.5(PP-PM) // Central Flux
            s_fluxqx[es][n]  = sc*(.5f*nx*(qP-qM));
            s_fluxqy[es][n]  = sc*(.5f*ny*(qP-qM));
          }
        }
      }
    }

    // wait for all flux functions are written to @shared
    @barrier("local");

    // for each node in the element
    for(int es=0;es<p_NblockS;++es;@inner(1)){
      for(int n=0;n<p_maxNodes;++n;@inner(0)){
        int e = eo + es;
        if(e<Nelements){
          if(n<p_Np){
            int id = e*2*p_Np;

            dfloat qx  = gradq[id+     n];
            dfloat qy  = gradq[id+p_Np+n];

            // Lift
            #pragma unroll p_NfacesNfp
              for(int m=0;m<p_Nfaces*p_Nfp;++m){
                dfloat L = LIFTT[n+m*p_Np];
                qx += L*s_fluxqx[es][m];
                qy += L*s_fluxqy[es][m];
              }

            gradq[id+     n] = qx;
            gradq[id+p_Np+n] = qy;
          }
        }
      }
    }
  }
}

@kernel void ellipticBRDivergenceVolume2D(const int Nelements,
        @restrict const  dfloat *  vgeo,
        @restrict const  dfloat *  DrT,
        @restrict const  dfloat *  DsT,
        @restrict const  dfloat *  gradq,
        @restrict dfloat *  Aq){

  for(int eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){
    // for all elements
    @shared dfloat s_qx[p_NblockV][p_Np];
    @shared dfloat s_qy[p_NblockV][p_Np];

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element
        int e = eo+es; // element in block
        if(e<Nelements){
          s_qx[es][n]  = gradq[n +        e*2*p_Np];
          s_qy[es][n]  = gradq[n + p_Np + e*2*p_Np];
        }
      }
    }

    // Make sure all node data is loaded into @shared
    @barrier("local");

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element

        int e = eo+es; // element in block
        if(e<Nelements){
          // prefetch geometric factors (constant on triangle)
          const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
          const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
          const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
          const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];

          dfloat dqxdr  = 0.f, dqxds  = 0.f;
          dfloat dqydr  = 0.f, dqyds  = 0.f;
          #pragma unroll p_Np
            for(int i=0;i<p_Np;++i){
              const dfloat Drni = DrT[n+i*p_Np];
              const dfloat Dsni = DsT[n+i*p_Np];

              dqxdr  += Drni*s_qx[es][i];
              dqxds  += Dsni*s_qx[es][i];
              dqydr  += Drni*s_qy[es][i];
              dqyds  += Dsni*s_qy[es][i];
            }

          const int id = e*p_Np;
          Aq[id+n] = drdx*dqxdr + dsdx*dqxds + drdy*dqydr + dsdy*dqyds;
        }
      }
    }
  }
}

@kernel void ellipticBRDivergenceSurface2D(const int Nelements,
         @restrict const  int   *  vmapM,
         @restrict const  int   *  vmapP,
         const dfloat lambda,
         const dfloat tau,
         @restrict const  dfloat *  vgeo,
         @restrict const  dfloat *  sgeo,
         @restrict const  int   *  EToB,
         @restrict const  dfloat *  LIFTT,
         @restrict const  dfloat *  MM,
         @restrict const  dfloat *  q,
         @restrict const  dfloat *  gradq,
         @restrict dfloat *  Aq){

  // for all elements
  for(int eo=0;eo<Nelements;eo+=p_NblockS;@outer(0)){

    @shared dfloat s_flux[p_NblockS][p_Nfp*p_Nfaces];
    @shared dfloat s_Aq[p_NblockS][p_Np];

    // for all face nodes of all elements
    for(int es=0;es<p_NblockS;++es;@inner(1)){
      for(int n=0;n<p_maxNodes;++n;@inner(0)){ // maxNodes = max(Nfp*Nfaces,Np)
        int e = eo + es;
        if(e<Nelements){
          if(n<p_Nfp*p_Nfaces){
            // find face that owns this node
            int face = n/p_Nfp;
            // load surface geofactors for this face
            int sid    = p_Nsgeo*(e*p_Nfaces+face);
            dfloat nx   = sgeo[sid+p_NXID];
            dfloat ny   = sgeo[sid+p_NYID];
            dfloat sJ   = sgeo[sid+p_SJID];
            dfloat invJ = sgeo[sid+p_IJID];

            // indices of negative and positive traces of face node
            int id  = e*p_Nfp*p_Nfaces + n;
            const int idM = vmapM[id]%p_Np;
            const int idP = vmapP[id]%p_Np;

            const int eM = vmapM[id]/p_Np;
            const int eP = vmapP[id]/p_Np;

            dfloat  qM  = q[idM+p_Np*eM], qP  = q[idP+p_Np*eP];
            dfloat  qxM = gradq[idM+     2*p_Np*eM], qxP = gradq[idP+     2*p_Np*eP];
            dfloat  qyM = gradq[idM+p_Np+2*p_Np*eM], qyP = gradq[idP+p_Np+2*p_Np*eP];

            // apply boundary condition
            int bc = EToB[face+p_Nfaces*e];
            if(bc>0) {
              ellipticHomogeneousBC2D(bc, qM, qxM, qyM, qP, qxP, qyP);
              qP  = 2*qP  - qM;
              qxP = 2*qxP - qxM;
              qyP = 2*qyP - qyM;
            }

            const dfloat sc = 0.5f*invJ * sJ ;

            // Central Flux + penalty
            s_flux[es][n]  = sc*(nx*(qxP-qxM)+ny*(qyP-qyM)+tau*(qP-qM));
          }
        }
      }
    }

    // wait for all flux functions are written to @shared
    @barrier("local");

    // for each node in the element
    for(int es=0;es<p_NblockS;++es;@inner(1)){
      for(int n=0;n<p_maxNodes;++n;@inner(0)){
        int e = eo + es;
        if(e<Nelements){
          if(n<p_Np){
            int id = e*p_Np;

            dfloat Aqn = Aq[id+n];
            dfloat qn  = q[id+n];

            // Lift
            #pragma unroll p_NfacesNfp
              for(int m=0;m<p_Nfaces*p_Nfp;++m){
                dfloat L = LIFTT[n+m*p_Np];
                Aqn += L*s_flux[es][m];
              }

            s_Aq[es][n] = -Aqn+lambda*qn;
          }
        }
      }
    }

    @barrier("local");

    for(int es=0;es<p_NblockS;++es;@inner(1)){
      for(int n=0;n<p_maxNodes;++n;@inner(0)){
        int e = eo + es;
        if(e<Nelements){
          if(n<p_Np){

            const dfloat J = vgeo[e*p_Nvgeo + p_JID];
            int id = e*p_Np;

            dfloat MAqn = 0.f;

            // multiply by mass matrix
            #pragma unroll p_Np
              for(int i=0;i<p_Np;++i){
                MAqn += MM[n+i*p_Np]*s_Aq[es][i];
              }

            Aq[id+n] = J*MAqn;
          }
        }
      }
    }
  }
}

@kernel void ellipticBRDivergenceSurfaceNonSym2D(const int Nelements,
         @restrict const  int   *  vmapM,
         @restrict const  int   *  vmapP,
         const dfloat lambda,
         const dfloat tau,
         @restrict const  dfloat *  vgeo,
         @restrict const  dfloat *  sgeo,
         @restrict const  int   *  EToB,
         @restrict const  dfloat *  LIFTT,
         @restrict const  dfloat *  MM,
         @restrict const  dfloat *  q,
         @restrict const  dfloat *  gradq,
         @restrict dfloat *  Aq){

  // for all elements
  for(int eo=0;eo<Nelements;eo+=p_NblockS;@outer(0)){

    @shared dfloat s_flux[p_NblockS][p_Nfp*p_Nfaces];
    @shared dfloat s_Aq[p_NblockS][p_Np];

    // for all face nodes of all elements
    for(int es=0;es<p_NblockS;++es;@inner(1)){
      for(int n=0;n<p_maxNodes;++n;@inner(0)){ // maxNodes = max(Nfp*Nfaces,Np)
        int e = eo + es;
        if(e<Nelements){
          if(n<p_Nfp*p_Nfaces){
            // find face that owns this node
            int face = n/p_Nfp;
            // load surface geofactors for this face
            int sid    = p_Nsgeo*(e*p_Nfaces+face);
            dfloat nx   = sgeo[sid+p_NXID];
            dfloat ny   = sgeo[sid+p_NYID];
            dfloat sJ   = sgeo[sid+p_SJID];
            dfloat invJ = sgeo[sid+p_IJID];

            // indices of negative and positive traces of face node
            int id  = e*p_Nfp*p_Nfaces + n;
            const int idM = vmapM[id]%p_Np;
            const int idP = vmapP[id]%p_Np;

            const int eM = vmapM[id]/p_Np;
            const int eP = vmapP[id]/p_Np;

            dfloat  qM  = q[idM+p_Np*eM], qP  = q[idP+p_Np*eP];
            dfloat  qxM = gradq[idM+     2*p_Np*eM], qxP = gradq[idP+     2*p_Np*eP];
            dfloat  qyM = gradq[idM+p_Np+2*p_Np*eM], qyP = gradq[idP+p_Np+2*p_Np*eP];

            // apply boundary condition
            int bc = EToB[face+p_Nfaces*e];
            if(bc>0) {
              ellipticHomogeneousBC2D(bc, qM, qxM, qyM, qP, qxP, qyP);
              qP  = 2*qP  - qM;
              qxP = 2*qxP - qxM;
              qyP = 2*qyP - qyM;
            }

            const dfloat sc = 0.5f*invJ * sJ ;

            // Central Flux + penalty
            s_flux[es][n]  = sc*(nx*(qxP-qxM)+ny*(qyP-qyM)+tau*(qP-qM));
          }
        }
      }
    }

    // wait for all flux functions are written to @shared
    @barrier("local");

    // for each node in the element
    for(int es=0;es<p_NblockS;++es;@inner(1)){
      for(int n=0;n<p_maxNodes;++n;@inner(0)){
        int e = eo + es;
        if(e<Nelements){
          if(n<p_Np){
            const dfloat J = vgeo[e*p_Nvgeo + p_JID];
            int id = e*p_Np;

            dfloat Aqn = Aq[id+n];
            dfloat qn  = q[id+n];

            // Lift
            #pragma unroll p_NfacesNfp
              for(int m=0;m<p_Nfaces*p_Nfp;++m){
                dfloat L = LIFTT[n+m*p_Np];
                Aqn += L*s_flux[es][m];
              }

            Aq[id+n] = J*(-Aqn+lambda*qn);
          }
        }
      }
    }
  }
}

