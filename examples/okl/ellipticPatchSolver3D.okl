#define p_patchNelements (p_Nfaces+1)
#define p_patchNp (p_Np*(p_Nfaces+1))


// experimental overlapping patch solver
@kernel void ellipticExactPatchSolver3D(const int Nelements,
				       @restrict const  dfloat *  invAP,
				       @restrict const  int   *  EToE,
				       @restrict const  dfloat *  invDegree,
				       @restrict const  dfloat *  q,
				       @restrict dfloat *  invAPq){
  
  // assume one patch per outer iteration (tune later)
  for(int eo=0;eo<Nelements;eo+=p_NblockP;@outer(0)){

    @shared dfloat s_q[p_NblockP][p_patchNp];
    
    for(int e=eo;e<eo+p_NblockP;++e;@inner(2)){
      for(int es=0;es<p_patchNelements;++es;@inner(1)){
        for(int n=0;n<p_Np;++n;@inner(0)){
          s_q[e-eo][es*p_Np+n] = 0.f;
        }
      }
    }

    @barrier("local");

    // loop over elements in sub-patch e and load q
    for(int e=eo;e<eo+p_NblockP;++e;@inner(2)){
      for(int es=0;es<p_patchNelements;++es;@inner(1)){
        for(int n=0;n<p_Np;++n;@inner(0)){
          if(e<Nelements){
            const int eP = (es==0) ? e: EToE[e*p_Nfaces+es-1]; // load element e first

            if(eP>=0){
              s_q[e-eo][es*p_Np+n] = q[eP*p_Np+n];
            }
          }
        }
      }
    }

    @barrier("local");

    // loop over elements/nodes in patch and do local smooth
    for(int e=eo;e<eo+p_blockV;++e;@inner(2)){
      for(int es=0;es<p_patchNelements;++es;@inner(1)){
        for(int n=0;n<p_Np;++n;@inner(0)){
          if(e<Nelements){
            const int offset = e*p_patchNp*p_patchNp + es*p_Np + n; // patch matrices offset
            dfloat res1 = 0.f, res2 = 0.f, res3 = 0.f, res4 = 0.f, res5 = 0.f;

            //      #pragma unroll p_patchNp
            #pragma unroll p_Np
              for(int m=0;m<p_Np;++m){
                res1 += invAP[offset + (m       )*p_patchNp]*s_q[e-eo][m];
                res2 += invAP[offset + (m+  p_Np)*p_patchNp]*s_q[e-eo][m+p_Np];
                res3 += invAP[offset + (m+2*p_Np)*p_patchNp]*s_q[e-eo][m+2*p_Np];
                res4 += invAP[offset + (m+3*p_Np)*p_patchNp]*s_q[e-eo][m+3*p_Np];
                res5 += invAP[offset + (m+4*p_Np)*p_patchNp]*s_q[e-eo][m+4*p_Np];
              }

            const dfloat invDeg = invDegree[e];

            invAPq[p_patchNp*e+es*p_Np+n] = invDeg*(res1+res2+res3+res4+res5);
          }
        }
      }
    }
  }
}

// experimental overlapping patch solver
@kernel void ellipticApproxPatchSolver3D(const int Nelements,
					@restrict const  int   *  patchesIndex,
					@restrict const  dfloat *  invAP,
					@restrict const  int   *  EToE,
					@restrict const  dfloat *  invDegree,
					@restrict const  dfloat *  q,
					@restrict dfloat *  invAPq){
  
  // assume one patch per outer iteration (tune later)
  for(int eo=0;eo<Nelements;eo+=p_NblockP;@outer(0)){

    @shared dfloat s_q[p_NblockP][p_patchNp];

    // loop over elements in sub-patch e and load q
    for(int e=eo;e<eo+p_NblockP;++e;@inner(2)){
      for(int es=0;es<p_patchNelements;++es;@inner(1)){
        for(int n=0;n<p_Np;++n;@inner(0)){
          if(e<Nelements){
            const int eP = (es==0) ? e: EToE[e*p_Nfaces+es-1]; // load element e first

            s_q[e-eo][es*p_Np+n] = 0.f;
            if(eP>=0){
              s_q[e-eo][es*p_Np+n] = q[eP*p_Np+n];
            }
          }
        }
      }
    }

    @barrier("local");

    // loop over elements/nodes in patch and do local smooth
    for(int e=eo;e<eo+p_NblockP;++e;@inner(2)){
      for(int es=0;es<p_patchNelements;++es;@inner(1)){
        for(int n=0;n<p_Np;++n;@inner(0)){
          if(e<Nelements){
            const dfloat invDeg = invDegree[e];

            // patch matrices offset
            const int offset = patchesIndex[e]*p_patchNp*p_patchNp + es*p_Np + n;
            dfloat res1 = 0.f, res2 = 0.f, res3 = 0.f, res4 = 0.f, res5 = 0.f;
            #pragma unroll p_Np
              for(int m=0;m<p_Np;++m){
                res1 += invAP[offset + (m       )*p_patchNp ]*s_q[e-eo][m];
                res2 += invAP[offset + (m  +p_Np)*p_patchNp ]*s_q[e-eo][m+p_Np];
                res3 += invAP[offset + (m+2*p_Np)*p_patchNp ]*s_q[e-eo][m+2*p_Np];
                res4 += invAP[offset + (m+3*p_Np)*p_patchNp ]*s_q[e-eo][m+3*p_Np];
                res5 += invAP[offset + (m+4*p_Np)*p_patchNp ]*s_q[e-eo][m+4*p_Np];
              }

            invAPq[p_patchNp*e+es*p_Np+n] = invDeg*(res1+res2+res3+res4+res5);
          }
        }
      }
    }
  }
}

// experimental overlapping patch solver
@kernel void ellipticExactFacePatchSolver3D(const int NfacePairs,
					   @restrict const  dfloat *  invAP,
					   @restrict const  int   *  FPairsToE,
					   @restrict const  dfloat *  invDegree,
					   @restrict const  dfloat *  q,
					   @restrict dfloat *  invAPq){

  //tune later
  for(int f=0;f<NfacePairs;f++;@outer(0)){

    @shared dfloat s_q[2*p_Np];

    // loop over elements in sub-patch e and load q
    for(int es=0;es<2;++es;@inner(1)){
      for(int n=0;n<p_Np;++n;@inner(0)){
        if(f<NfacePairs){
          const int e = FPairsToE[2*f+es];

          s_q[es*p_Np+n] = 0.f;
          if(e>=0){
            s_q[es*p_Np+n] = q[e*p_Np+n];
          }
        }
      }
    }

    @barrier("local");

    // loop over elements/nodes in patch and do local smooth
    for(int es=0;es<2;++es;@inner(1)){
      for(int n=0;n<p_Np;++n;@inner(0)){
        if(f<NfacePairs){
          const int offset = f*2*p_Np*2*p_Np + es*p_Np + n; // patch matrices offset
          dfloat res1 = 0.f, res2 = 0.f;

          #pragma unroll p_Np
            for(int m=0;m<p_Np;++m){
              res1 += invAP[offset + (m     )*2*p_Np]*s_q[m     ];
              res2 += invAP[offset + (m+p_Np)*2*p_Np]*s_q[m+p_Np];
            }

          const int e = FPairsToE[2*f+es];
          dfloat invDeg;
          if(e>=0) {
            invDeg = invDegree[e];
          } else {
            invDeg = 0.f;
          }

          invAPq[2*p_Np*f+es*p_Np+n] = invDeg*(res1+res2);
        }
      }
    }
  }
}

// experimental overlapping patch solver
@kernel void ellipticApproxFacePatchSolver3D(const int NfacePairs,
					    @restrict const  int   *  patchesIndex,
					    @restrict const  dfloat *  invAP,
					    @restrict const  int   *  FPairsToE,
					    @restrict const  dfloat *  invDegree,
					    @restrict const  dfloat *  q,
					    @restrict dfloat *  invAPq){

  //tune later
  for(int f=0;f<NfacePairs;f++;@outer(0)){

    @shared dfloat s_q[2*p_Np];
    @exclusive int e;

    // loop over elements in sub-patch f and load q
    for(int es=0;es<2;++es;@inner(1)){
      for(int n=0;n<p_Np;++n;@inner(0)){
	e = FPairsToE[2*f+es];
	
	s_q[es*p_Np+n] = 0.f;
	if(e>=0)
	  s_q[es*p_Np+n] = q[e*p_Np+n];
      }
    }

    @barrier("local");

    // loop over elements/nodes in patch and do local smooth
    for(int es=0;es<2;++es;@inner(1)){
      for(int n=0;n<p_Np;++n;@inner(0)){

	
	const int offset = patchesIndex[f]*2*p_Np*2*p_Np + es*p_Np + n; // patch matrices offset

	dfloat invDeg = (e>=0) ? invDegree[e]:0.f;

	dfloat res1 = 0.f, res2 = 0.f;
	
	#pragma unroll p_Np
	  for(int m=0;m<p_Np;++m){
	    res1 += invAP[offset + (m     )*2*p_Np]*s_q[m     ];
	    res2 += invAP[offset + (m+p_Np)*2*p_Np]*s_q[m+p_Np];
	  }
	

	invAPq[2*p_Np*f+es*p_Np+n] = invDeg*(res1+res2);
      }
    }
  }
}


// experimental overlapping patch solver
@kernel void ellipticExactBlockJacobiSolver3D(const int Nelements,
					     @restrict const  dfloat *  invAP,
					     @restrict const  dfloat *  invDegree,
					     @restrict const  dfloat *  q,
					     @restrict dfloat *  invAPq){

  // assume one patch per outer iteration (tune later)
  for(int eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){

    @shared dfloat s_q[p_NblockV][p_Np];

    // loop over elements and load q
    for(int e=eo;e<eo+p_NblockV;++e;@inner(1)){
      for(int n=0;n<p_Np;++n;@inner(0)){
        if(e<Nelements){
          s_q[e-eo][n] = q[e*p_Np+n];
        }
      }
    }

    @barrier("local");

    // loop over elements/nodes in patch and do local smooth
    for(int e=eo;e<eo+p_blockV;++e;@inner(1)){
      for(int n=0;n<p_Np;++n;@inner(0)){
        if(e<Nelements){
          const dfloat invDeg = invDegree[e];
          const int offset = e*p_Np*p_Np + n; // patch matrices offset
          dfloat res = 0.f;

          #pragma unroll p_Np
            for(int m=0;m<p_Np;++m){
              res += invAP[offset + m*p_Np]*s_q[e-eo][m];
            }

          invAPq[p_Np*e+n] = invDeg*res;
        }
      }
    }
  }
}

// experimental overlapping patch solver
@kernel void ellipticApproxBlockJacobiSolver3D(const int Nelements,
					      @restrict const  int   *  patchesIndex,
					      @restrict const  dfloat *  invAP,
					      @restrict const  dfloat *  invDegree,
					      @restrict const  dfloat *  q,
					      @restrict dfloat *  invAPq){

  // assume one patch per outer iteration (tune later)
  for(int eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){

    @shared dfloat s_q[p_NblockV][p_Np];

    // loop over elements and load q
    for(int e=eo;e<eo+p_NblockV;++e;@inner(1)){
      for(int n=0;n<p_Np;++n;@inner(0)){
        if(e<Nelements){
          s_q[e-eo][n] = q[e*p_Np+n];
        }
      }
    }

    @barrier("local");

    // loop over elements/nodes in patch and do local smooth
    for(int e=eo;e<eo+p_NblockV;++e;@inner(1)){
      for(int n=0;n<p_Np;++n;@inner(0)){
        if(e<Nelements){
          const dfloat invDeg = invDegree[e];

          // patch matrices offset
          const int offset = patchesIndex[e]*p_Np*p_Np + n;
          dfloat res = 0.f;
          #pragma unroll p_Np
            for(int m=0;m<p_Np;++m){
              res += invAP[offset + m*p_Np ]*s_q[e-eo][m];
            }

          invAPq[p_Np*e+n] = invDeg*res;
        }
      }
    }
  }
}


