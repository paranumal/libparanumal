
@kernel void boltzmannSplitPmlRelaxation2D(const int Nelements,
					     @restrict const  int *  elementIds,
					     @restrict const  dfloat *  cubInterpT,
					     @restrict const  dfloat *  cubProjectT,
					     @restrict const  dfloat4 *  q,
					     @restrict dfloat *  rhspmlqx,
					     @restrict dfloat *  rhspmlqy,
					     @restrict dfloat *  rhspmlNT){
  
  for(int eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){  // for all elements

    // @shared memory for q at nodes
    @shared dfloat s_q[p_NblockV][6][p_Np];

    // sub-group of p_Np cubature node interpolants of N4,N5,N6
    @shared dfloat s_cubN4[p_NblockV][p_cubNp];
    @shared dfloat s_cubN5[p_NblockV][p_cubNp];
    @shared dfloat s_cubN6[p_NblockV][p_cubNp];

    @exclusive int element;

    // prefetch q to @shared
    for(int es=0;es<p_NblockV;++es;@inner(1)){
      for(int n=0;n<p_maxNodesVolume;++n;@inner(0)){    
	
	int e = eo+es; // element in block
	if(e<Nelements){
	  element = elementIds[e];

	  if(n<p_Np){
	    const int id = element*p_Np+n;
	    dfloat4 qan = q[2*id];
	    dfloat4 qbn = q[2*id+1];
	    
	    s_q[es][0][n] = qan.x;
	    s_q[es][1][n] = qan.y;
	    s_q[es][2][n] = qan.z;
	    s_q[es][3][n] = qan.w;
	    
	    s_q[es][4][n] = qbn.x;
	    s_q[es][5][n] = qbn.y;
	  }
	}
      }
    }
    
    // make sure all node data is loaded into @shared
    @barrier("local");

    // interpolate q to cubature
    for(int es=0;es<p_NblockV;++es;@inner(1)){
      for(int n=0;n<p_maxNodesVolume;++n;@inner(0)){     
	
	int e = eo+es; // element in block
	if(e<Nelements){
	  if(n<p_cubNp){
	    dfloat cubq1 = 0.0f, cubq2 = 0.0f, cubq3 = 0.0f;
	    dfloat cubq4 = 0.0f, cubq5 = 0.0f, cubq6 = 0.0f;
	    
	    for(int m=0;m<p_Np;++m){
	      const dfloat Icn  = cubInterpT[m*p_cubNp+n];
	      cubq1 += Icn*s_q[es][0][m];
	      cubq2 += Icn*s_q[es][1][m];
	      cubq3 += Icn*s_q[es][2][m];
	      cubq4 += Icn*s_q[es][3][m];
	      cubq5 += Icn*s_q[es][4][m];
	      cubq6 += Icn*s_q[es][5][m];
	    }
	    
	    // BGK relaxation approximation to the Boltzmann collision operator
	    s_cubN4[es][n] = -p_tauInv*(cubq4-(           cubq2*cubq3/cubq1));
	    s_cubN5[es][n] = -p_tauInv*(cubq5-(p_invsqrt2*cubq2*cubq2/cubq1));
	    s_cubN6[es][n] = -p_tauInv*(cubq6-(p_invsqrt2*cubq3*cubq3/cubq1));
	  }
	}
      }
    }

    // make sure all cubature node data is loaded into @shared
    @barrier("local");
    
    // partial projection to nodes from cubature-sub-group
    for(int es=0;es<p_NblockV;++es;@inner(1)){
      for(int n=0;n<p_maxNodesVolume;++n;@inner(0)){     
	
	int e = eo+es; // element in block
	if(e<Nelements){
	  if(n<p_Np){
	    int base = element*p_Np*p_Nfields+n;
	    
	    // use temporaries for part sums for N4,N5,N6 because of @exclusives
	    dfloat N4 = 0.f, N5 = 0.f, N6 = 0.f;
	    for(int i=0;i<p_cubNp;++i){
	      const dfloat Pnc  = cubProjectT[i*p_Np+n];
	      N4 += Pnc*s_cubN4[es][i];
	      N5 += Pnc*s_cubN5[es][i];
	      N6 += Pnc*s_cubN6[es][i];
	    }
	    
	    // split relaxation
	    rhspmlqx[base+3*p_Np] += 0.5f*N4;
	    rhspmlqx[base+4*p_Np] += 0.5f*N5;
	    rhspmlqx[base+5*p_Np] += 0.5f*N6;
	    
	    rhspmlqy[base+3*p_Np] += 0.5f*N4;
	    rhspmlqy[base+4*p_Np] += 0.5f*N5;
	    rhspmlqy[base+5*p_Np] += 0.5f*N6;
	    
	    rhspmlNT[base+3*p_Np] = N4;
	    rhspmlNT[base+4*p_Np] = N5;
	    rhspmlNT[base+5*p_Np] = N6;
	  }
	}
      }
    }
  }
}

// c1: working (reproduces c0)
@kernel void boltzmannSplitPmlRelaxation2D_c1(const int Nelements,
					     @restrict const  int *  elementIds,
					     @restrict const  dfloat *  cubInterpT,
					     @restrict const  dfloat *  cubProjectT,
					     @restrict const  dfloat4 *  q,
					     @restrict dfloat *  rhspmlqx,
					     @restrict dfloat *  rhspmlqy,
					     @restrict dfloat *  rhspmlNT){
  
  for(int eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){  // for all elements

    // @shared memory for q at nodes
    @shared dfloat s_q[p_NblockV][p_Nfields][p_Np];

    // sub-group of p_Np cubature node interpolants of N4,N5,N6
    @shared dfloat s_cubN4[p_NblockV][p_Np];
    @shared dfloat s_cubN5[p_NblockV][p_Np];
    @shared dfloat s_cubN6[p_NblockV][p_Np];

    // result of interpolation and projection
    @exclusive dfloat N4, N5, N6;
    @exclusive int element;

    // prefetch q to @shared
    for(int es=0;es<p_NblockV;++es;@inner(1)){
      for(int n=0;n<p_Np;++n;@inner(0)){    
	
	int e = eo+es; // element in block
	if(e<Nelements){

	  element = elementIds[e];

	  const int id = element*p_Np+n;
	  dfloat4 qan = q[2*id];
	  dfloat4 qbn = q[2*id+1];
	  
	  s_q[es][0][n] = qan.x;
	  s_q[es][1][n] = qan.y;
	  s_q[es][2][n] = qan.z;
	  s_q[es][3][n] = qan.w;

	  s_q[es][4][n] = qbn.x;
	  s_q[es][5][n] = qbn.y;
	}

	N4 = 0.f; N5 = 0.f; N6 = 0.f;
      }
    }
    
    // interpolate q to cubature
    for(int co=0;co<p_cubNp;co+=p_Np){

      // make sure all node data is loaded into @shared
      @barrier("local");

      // interpolate to sub-group of p_Np cubature nodes 
      for(int es=0;es<p_NblockV;++es;@inner(1)){
	for(int n=0;n<p_Np;++n;@inner(0)){     
	  
	  int e = eo+es; // element in block
	  if(e<Nelements){
	    if(n+co<p_cubNp){
	      dfloat cubq1 = 0.0f, cubq2 = 0.0f, cubq3 = 0.0f;
	      dfloat cubq4 = 0.0f, cubq5 = 0.0f, cubq6 = 0.0f;
	      
	      #pragma unroll p_Np
	      for(int m=0;m<p_Np;++m){
		const dfloat Icn  = cubInterpT[m*p_cubNp+n+co];
		cubq1 += Icn*s_q[es][0][m];
		cubq2 += Icn*s_q[es][1][m];
		cubq3 += Icn*s_q[es][2][m];
		cubq4 += Icn*s_q[es][3][m];
		cubq5 += Icn*s_q[es][4][m];
		cubq6 += Icn*s_q[es][5][m];
	      }	     
	      
	      // BGK relaxation approximation to the Boltzmann collision operator
	      dfloat icubq1 = 1.f/cubq1;     	       
	      s_cubN4[es][n] = -p_tauInv*(cubq4-           cubq2*cubq3*icubq1);
	      s_cubN5[es][n] = -p_tauInv*(cubq5-p_invsqrt2*cubq2*cubq2*icubq1);
	      s_cubN6[es][n] = -p_tauInv*(cubq6-p_invsqrt2*cubq3*cubq3*icubq1);
	    }
	  }
	}
      }

      // make sure all cubature node data is loaded into @shared
      @barrier("local");
      
      // partial projection to nodes from cubature-sub-group
      for(int es=0;es<p_NblockV;++es;@inner(1)){
	for(int n=0;n<p_Np;++n;@inner(0)){     
	  
	  int e = eo+es; // element in block
	  if(e<Nelements){
	    // use temporaries for part sums for N4,N5,N6 because of @exclusives
	    dfloat partN4 = 0.f, partN5 = 0.f, partN6 = 0.f;
	    for(int i=0;i<p_Np;++i){
	      if(i+co<p_cubNp){
		const dfloat Pnc  = cubProjectT[(i+co)*p_Np+n];
		partN4 += Pnc*s_cubN4[es][i];
		partN5 += Pnc*s_cubN5[es][i];
		partN6 += Pnc*s_cubN6[es][i];
	      }
	    }
	    N4 += partN4; N5 += partN5; N6 += partN6;
	  }
	}
      }
    } // end of chunked cubature loop
  
    // write out
    for(int es=0;es<p_NblockV;++es;@inner(1)){
      for(int n=0;n<p_Np;++n;@inner(0)){     
	
	int e = eo+es; // element in block
	if(e<Nelements){
	  // slightly inefficient since splits warp
	  int base = element*p_Np*p_Nfields+n;

	  // split relaxation
	  rhspmlqx[base+3*p_Np] += 0.5f*N4;
	  rhspmlqx[base+4*p_Np] += 0.5f*N5;
	  rhspmlqx[base+5*p_Np] += 0.5f*N6;

	  rhspmlqy[base+3*p_Np] += 0.5f*N4;
	  rhspmlqy[base+4*p_Np] += 0.5f*N5;
	  rhspmlqy[base+5*p_Np] += 0.5f*N6;
	    
	  rhspmlNT[base+3*p_Np] = N4;
	  rhspmlNT[base+4*p_Np] = N5;
	  rhspmlNT[base+5*p_Np] = N6;
	}
      }
    }
  }
}


// c2: do not interpolate q4,q5,q6
@kernel void boltzmannSplitPmlRelaxation2D_c2(const int Nelements,
					  @restrict const  int *  elementIds,
					  @restrict const  dfloat *  cubInterpT,
					  @restrict const  dfloat *  cubProjectT,
					  @restrict const  dfloat4 *  q,
					  @restrict dfloat *  rhspmlqx,
					  @restrict dfloat *  rhspmlqy,
					  @restrict dfloat *  rhspmlNT){
  
  for(int eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){  // for all elements

    // @shared memory for q at nodes
    @shared dfloat s_q1[p_NblockV][p_Np];
    @shared dfloat s_q2[p_NblockV][p_Np];
    @shared dfloat s_q3[p_NblockV][p_Np];

    // sub-group of p_Np cubature node interpolants of N4,N5,N6
    @shared dfloat s_cubN4[p_NblockV][p_Np];
    @shared dfloat s_cubN5[p_NblockV][p_Np];
    @shared dfloat s_cubN6[p_NblockV][p_Np];

    // result of interpolation and projection
    @exclusive dfloat N4, N5, N6;
    @exclusive int element;

    // prefetch q to @shared
    for(int es=0;es<p_NblockV;++es;@inner(1)){
      for(int n=0;n<p_Np;++n;@inner(0)){    
	
	int e = eo+es; // element in block
	if(e<Nelements){
	  element = elementIds[e];

	  const int id = element*p_Np+n;
	  dfloat4 qan = q[2*id];
	  dfloat4 qbn = q[2*id+1];
	  
	  s_q1[es][n] = qan.x;
	  s_q2[es][n] = qan.y;
	  s_q3[es][n] = qan.z;

	  // first part of  -p_tauInv*(q4-cubq2*cubq3*icubq1);
	  N4 = -p_tauInv*qan.w;
	  N5 = -p_tauInv*qbn.x;
	  N6 = -p_tauInv*qbn.y;
	}
      }
    }
    
    // interpolate q to cubature
    for(int co=0;co<p_cubNp;co+=p_Np){

      // make sure all node data is loaded into @shared
      @barrier("local");

      // interpolate to sub-group of p_Np cubature nodes 
      for(int es=0;es<p_NblockV;++es;@inner(1)){
	for(int n=0;n<p_Np;++n;@inner(0)){     
	  
	  int e = eo+es; // element in block
	  if(e<Nelements){

	    if(n+co<p_cubNp){
	      dfloat cubq1 = 0.0f, cubq2 = 0.0f, cubq3 = 0.0f;
	      
	      #pragma unroll p_Np
	      for(int m=0;m<p_Np;++m){
		const dfloat Icn  = cubInterpT[m*p_cubNp+n+co];
		cubq1 += Icn*s_q1[es][m];
		cubq2 += Icn*s_q2[es][m];
		cubq3 += Icn*s_q3[es][m];
	      }
	      
	      dfloat icubq1 = 1.f/cubq1;
	      
	      // BGK relaxation approximation to the Boltzmann collision operator
	      s_cubN4[es][n] = -p_tauInv*(-cubq2*cubq3*icubq1);
	      s_cubN5[es][n] = -p_tauInv*(-p_invsqrt2*cubq2*cubq2*icubq1);
	      s_cubN6[es][n] = -p_tauInv*(-p_invsqrt2*cubq3*cubq3*icubq1);
	    }
	  }
	}
      }

      // make sure all cubature node data is loaded into @shared
      @barrier("local");
      
      // partial projection to nodes from cubature-sub-group
      for(int es=0;es<p_NblockV;++es;@inner(1)){
	for(int n=0;n<p_Np;++n;@inner(0)){     
	  
	  int e = eo+es; // element in block
	  if(e<Nelements){
	    // use temporaries for part sums for N4,N5,N6 because of @exclusives
	    dfloat partN4 = 0.f, partN5 = 0.f, partN6 = 0.f;
	    for(int i=0;i<p_Np;++i){
	      if(i+co<p_cubNp){
		const dfloat Pnc  = cubProjectT[(i+co)*p_Np+n];
		partN4 += Pnc*s_cubN4[es][i];
		partN5 += Pnc*s_cubN5[es][i];
		partN6 += Pnc*s_cubN6[es][i];
	      }
	    }
	    N4 += partN4;
	    N5 += partN5;
	    N6 += partN6;
	  }
	}
      }
    } // end of chunked cubature loop
    
    // write out
    for(int es=0;es<p_NblockV;++es;@inner(1)){
      for(int n=0;n<p_Np;++n;@inner(0)){     
	
	int e = eo+es; // element in block
	if(e<Nelements){
	  // slightly inefficient since splits warp
	  const int base = element*p_Np*p_Nfields+n;
	  
	  // split relaxation
	  rhspmlqx[base+3*p_Np] += 0.5f*N4;
	  rhspmlqx[base+4*p_Np] += 0.5f*N5;
	  rhspmlqx[base+5*p_Np] += 0.5f*N6;

	  rhspmlqy[base+3*p_Np] += 0.5f*N4;
	  rhspmlqy[base+4*p_Np] += 0.5f*N5;
	  rhspmlqy[base+5*p_Np] += 0.5f*N6;
	    
	  rhspmlNT[base+3*p_Np] = N4;
	  rhspmlNT[base+4*p_Np] = N5;
	  rhspmlNT[base+5*p_Np] = N6;
	}
      }
    }
  }
}


