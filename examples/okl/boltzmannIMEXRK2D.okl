
@kernel void boltzmannIMEXRKStageUpdate2D(const int Nelements,
                                         @restrict const  int *  elementIds,
                                         const int NtotalElements,
                                         const int rk,
                                         const dfloat dt,  
                                         @restrict const  dfloat *  rkAex,
                                         @restrict const  dfloat *  rkAim,
                                         @restrict const  dfloat *  q,
                                         @restrict const  dfloat *  rkrhsqex,
                                         @restrict const  dfloat *  rkrhsqim,
                                               @restrict dfloat *  rkq){
  
  // Runge Kutta intermediate stage
  for(int es=0;es<Nelements;++es;@outer(0)){
    for(int n=0;n<p_Np;++n;@inner(0)){

      const int e = elementIds[es];
      const int id = p_Nfields*(n + e*p_Np);

      for(int fld=0; fld< p_Nfields; ++fld){

        // const int idn = id + fld;        
        dfloat r_q = q[id +fld];

        for (int i=0;i<rk;i++) {
          const int offset = NtotalElements*p_Nfields*p_Np;
          r_q += dt*(rkAex[p_NrkStages*rk + i]*rkrhsqex[id + fld +i*offset] +
                     rkAim[p_NrkStages*rk + i]*rkrhsqim[id + fld +i*offset] );
        }

        rkq[id + fld] = r_q;
      }
    }
  }
} 


@kernel void boltzmannIMEXRKPmlStageUpdate2D(const int pmlNelements,
                                        @restrict const  int   *  pmlElementIds,
                                        @restrict const  int   *  pmlIds,
                                        const int NtotalElements,
                                        const int rk,
                                        const dfloat dt,  
                                        @restrict const  dfloat *  rkAex,
                                        @restrict const  dfloat *  rkAim,
                                        @restrict const  dfloat *  q,
                                        @restrict const  dfloat *  qx,
                                        @restrict const  dfloat *  qy,
                                        @restrict const  dfloat *  rkrhsqex,
                                        @restrict const  dfloat *  rkrhsqim,
                                        @restrict const  dfloat *  rkrhsqx,
                                        @restrict const  dfloat *  rkrhsqy,
                                              @restrict dfloat *  rkq,
                                              @restrict dfloat *  rkqx,
                                              @restrict dfloat *  rkqy){
  
  // Runge Kutta intermediate stage
  for(int es=0;es<pmlNelements;++es;@outer(0)){
    @exclusive int e;
    for(int n=0; n < p_Np; ++n; @inner(0)){
      e = pmlElementIds[es];
      if (n < p_Np){
        const int pmlId = pmlIds[es];
        const int id  = p_Nfields*(e*p_Np + n);
        const int pid = p_Nfields*(pmlId*p_Np + n);

        for(int fld=0; fld< p_Nfields; ++fld){
          // const int idn = id + fld;        
          dfloat r_q  = q[id  + fld];
          dfloat r_qx = qx[pid+ fld];
          dfloat r_qy = qy[pid+ fld];

          for (int i=0;i<rk;i++) {
            const int offset    = NtotalElements*p_Nfields*p_Np;
            const int offsetpml = pmlNelements*p_Nfields*p_Np;

            r_q  += dt*(rkAex[p_NrkStages*rk+i]*rkrhsqex[id+fld+i*offset] + 
                        rkAim[p_NrkStages*rk+i]*rkrhsqim[id+fld+i*offset]);

            r_qx += dt*rkAex[p_NrkStages*rk+i]*rkrhsqx[pid+fld+i*offsetpml];

            r_qy += dt*rkAex[p_NrkStages*rk+i]*rkrhsqy[pid+fld+i*offsetpml];
          }
        rkq [id  +fld] = r_q;
        rkqx[pid +fld] = r_qx;
        rkqy[pid +fld] = r_qy;
      }
    }
  }
}

}




@kernel void boltzmannIMEXRKUpdate2D(const int Nelements,
                                    @restrict const  int *  elementIds,
                                    const int NtotalElements,
                                    const int rk,
                                    const dfloat dt,  
                                    @restrict const  dfloat *  rkBex,
                                    @restrict const  dfloat *  rkBim,
                                    @restrict const  dfloat *  rkEex,
                                    @restrict const  dfloat *  rkEim,
                                    @restrict const  dfloat *  rhsqex,
                                    @restrict const  dfloat *  rhsqim,
                                          @restrict dfloat *  rkrhsqex,
                                          @restrict dfloat *  rkrhsqim,
                                    @restrict const  dfloat *  q,
                                          @restrict dfloat *  rkq,
                                          @restrict dfloat *  rkerr){
  
  // Runge Kutta intermediate stage
  for(int es=0;es<Nelements;++es;@outer(0)){
    for(int n=0;n<p_Np;++n;@inner(0)){

      const int e = elementIds[es];
      const int id = p_Nfields*(n + e*p_Np);

      for(int fld=0; fld< p_Nfields; ++fld){
        // const int idn = id + fld; 
        const int offset = NtotalElements*p_Nfields*p_Np;
  
        dfloat r_rhsqex = rhsqex[id + fld];
        dfloat r_rhsqim = rhsqim[id + fld];

        if (rk==(p_NrkStages-1)) { //last stage

          dfloat r_q = q[id +fld];
          dfloat r_rkerr = 0.f;
          for (int i=0;i<(p_NrkStages-1);i++) {
            r_q     += dt*(rkBex[i]*rkrhsqex[id + fld + i*offset] + 
                           rkBim[i]*rkrhsqim[id + fld + i*offset]);

            r_rkerr += dt*(rkEex[i]*rkrhsqex[id + fld + i*offset] + 
                           rkEim[i]*rkrhsqim[id + fld + i*offset]);
          }

          r_q     += dt*(rkBex[p_NrkStages-1]*r_rhsqex + rkBim[p_NrkStages-1]*r_rhsqim);
          r_rkerr += dt*(rkEex[p_NrkStages-1]*r_rhsqex + rkEim[p_NrkStages-1]*r_rhsqim);

          rkq[id   +fld] = r_q;
          rkerr[id +fld] = r_rkerr;
        }

        rkrhsqex[id+fld+rk*offset] = r_rhsqex;
        rkrhsqim[id+fld+rk*offset] = r_rhsqim;
      }
    }
  }
}


@kernel void boltzmannIMEXRKPmlUpdate2D(const int pmlNelements,
                                        @restrict const  int   *  pmlElementIds,
                                        @restrict const  int   *  pmlIds,
                                        const int NtotalElements,
                                        const int rk,
                                        const dfloat dt,  
                                        @restrict const  dfloat *  rkBex,
                                        @restrict const  dfloat *  rkBim,
                                        @restrict const  dfloat *  rkEex,
                                        @restrict const  dfloat *  rkEim,
                                        @restrict const  dfloat *  q,
                                        @restrict const  dfloat *  qx,
                                        @restrict const  dfloat *  qy,
                                        @restrict const  dfloat *  rhsqex,
                                        @restrict const  dfloat *  rhsqim,
                                        @restrict const  dfloat *  rhsqx,
                                        @restrict const  dfloat *  rhsqy,
                                              @restrict dfloat *  rkrhsqex,
                                              @restrict dfloat *  rkrhsqim,
                                              @restrict dfloat *  rkrhsqx,
                                              @restrict dfloat *  rkrhsqy,
                                              @restrict dfloat *  rkq,
                                              @restrict dfloat *  rkqx,
                                              @restrict dfloat *  rkqy,
                                              @restrict dfloat *  rkerr){
  // Runge Kutta intermediate stage
  for(int es=0;es<pmlNelements;++es;@outer(0)){
    @exclusive int e;
    for(int n=0; n < p_Np; ++n; @inner(0)){
      e = pmlElementIds[es];
      if (n < p_Np){
        const int pmlId = pmlIds[es];
        const int id  = p_Nfields*(e*p_Np + n);
        const int pid = p_Nfields*(pmlId*p_Np + n);

        for(int fld=0; fld< p_Nfields; ++fld){

          const int offset    = NtotalElements*p_Nfields*p_Np;
          const int offsetpml = pmlNelements*p_Nfields*p_Np;

          dfloat r_rhsqex = rhsqex[id + fld];
          dfloat r_rhsqim = rhsqim[id + fld];
          dfloat r_rhsqx  = rhsqx[pid + fld];
          dfloat r_rhsqy  = rhsqy[pid + fld];

          if (rk==(p_NrkStages-1)) { //last stage

            dfloat r_q  = q [id  +fld];
            dfloat r_qx = qx[pid +fld];
            dfloat r_qy = qy[pid +fld];

            dfloat r_rkerr = 0.f;

            for (int i=0;i<(p_NrkStages-1);i++) {
              r_q     += dt*(rkBex[i]*rkrhsqex[id + fld + i*offset] + 
                             rkBim[i]*rkrhsqim[id + fld + i*offset]);

              r_rkerr += dt*(rkEex[i]*rkrhsqex[id + fld + i*offset] + 
                             rkEim[i]*rkrhsqim[id + fld + i*offset]);

              r_qx    += dt*rkBex[i]*rkrhsqx[pid + fld + i*offsetpml];
              r_qy    += dt*rkBex[i]*rkrhsqy[pid + fld + i*offsetpml];
            }

            r_q     += dt*(rkBex[p_NrkStages-1]*r_rhsqex + rkBim[p_NrkStages-1]*r_rhsqim);
            
            r_rkerr += dt*(rkEex[p_NrkStages-1]*r_rhsqex + rkEim[p_NrkStages-1]*r_rhsqim);

            r_qx    += dt*rkBex[p_NrkStages-1]*r_rhsqx;
            r_qy    += dt*rkBex[p_NrkStages-1]*r_rhsqy;

            rkq[  id  +fld] = r_q;
            rkqx[pid  +fld] = r_qx;
            rkqy[pid  +fld] = r_qy;

            rkerr[id +fld] = r_rkerr;
          }

        rkrhsqex[id+fld+rk*offset]      = r_rhsqex;
        rkrhsqim[id+fld+rk*offset]      = r_rhsqim;
        rkrhsqx[pid+fld+rk*offsetpml]   = r_rhsqx;
        rkrhsqy[pid+fld+rk*offsetpml]   = r_rhsqy;
        }
      }
    }
  }
}




@kernel void boltzmannIMEXRKImplicitSolveCub2D(const int Nelements,
                          const int rk, 
                          const dfloat dt, 
                          @restrict const  dfloat *  rkAim, 
                          @restrict const  dfloat *  cubInterpT,
                          @restrict const  dfloat *  cubProjectT,
                                @restrict dfloat *  q,
                                @restrict dfloat *  rhsqim){ 

  for(int eo=0;eo<Nelements;eo+=p_NblockCub;@outer(0)){  // for all elements

    // @shared memory for q at nodes
    @shared dfloat s_q[p_NblockCub][p_Nfields][p_Np];
    // sub-group of p_Np cubature node interpolants of N4,N5,N6
    @shared dfloat s_cubN4[p_NblockCub][p_cubNp];
    @shared dfloat s_cubN5[p_NblockCub][p_cubNp];
    @shared dfloat s_cubN6[p_NblockCub][p_cubNp];

    @exclusive int   e;  

    @exclusive dfloat akk; 
    //
    @exclusive dfloat N4c, N5c, N6c;
    //
    @exclusive dfloat qi4, qi5, qi6;
    // @exclusive dfloat q1, q2, q3 ;  
    @exclusive dfloat q4, q5, q6 ; 

    // prefetch q to @shared
    for(int es=0;es<p_NblockCub;++es;@inner(1)){
      for(int n=0;n<p_maxCubNodes;++n;@inner(0)){    
       int et = eo+es; // element in block
        if(et<Nelements){
        e = et;
          if(n<p_Np){   
            const int id = p_Nfields*(e*p_Np + n);
            for(int fld=0; fld<p_Nfields;++fld){
             s_q[es][fld][n] = q[id+fld];
            } 
          } 
        }
       }
     }
    
    // make sure all node data is loaded into @shared
    @barrier("local");

    // interpolate q to cubature
    for(int es=0;es<p_NblockCub;++es;@inner(1)){
      for(int n=0;n<p_maxCubNodes;++n;@inner(0)){

        int et = eo+es; // element in block
        if(et<Nelements){
          if(n<p_cubNp){
            dfloat q1 = 0.f, q2 = 0.f, q3 =0.f ;
            q4=0.f ;  q5 =0.f ; q6 =0.f ;

            #pragma unroll p_Np
            for(int m=0;m<p_Np;++m){

              const dfloat Icn  = cubInterpT[m*p_cubNp+n];
              //
              q1 += Icn*s_q[es][0][m];
              q2 += Icn*s_q[es][1][m];
              q3 += Icn*s_q[es][2][m];
              q4 += Icn*s_q[es][3][m];
              q5 += Icn*s_q[es][4][m];
              q6 += Icn*s_q[es][5][m];
            }
        
        //
        
        dfloat  iq1 = 1.f/q1;
         
        // Hold the constant part of nonlinear function
         N4c = -(q2*q3*iq1 );
         N5c = -p_invsqrt2*( q2*q2*iq1 );
         N6c = -p_invsqrt2*( q3*q3*iq1 );      
        
         // Initialize q after implicit solve
         qi4 = q4;
         qi5 = q5;
         qi6 = q6; 

        }
     }
    }
  }

    // make sure all node data is loaded into @shared
    @barrier("local");  
      // partial projection to nodes from cubature-sub-group
    for(int es=0;es<p_NblockCub;++es;@inner(1)){
    for(int n=0;n<p_maxCubNodes;++n;@inner(0)){
      int et = eo+es; // element in block
      if(et<Nelements){

        akk = rkAim[p_NrkStages*rk + rk];

        if(n<p_cubNp){
          if(akk>0){    
            dfloat cc  = akk * dt * p_tauInv;
            dfloat icc = 1.0f/(cc+1.0f); 
            //N(Y)
            dfloat N4 = -cc*( qi4 + N4c);
            dfloat N5 = -cc*( qi5 + N5c);
            dfloat N6 = -cc*( qi6 + N6c);
            // z0 = y + akk*dt*N(Y);
            qi4 = q4 +  N4 ;
            qi5 = q5 +  N5 ;
            qi6 = q6 +  N6 ;
            // akk*dt*N(z0)
            N4 = -cc*( qi4 + N4c);
            N5 = -cc*( qi5 + N5c);
            N6 = -cc*( qi6 + N6c);
            //Update Qim = Qim + (I-akk*dt*del(N)/del(Qim) )^-1 * ( Qex-Qim + N(Qim) )
            // Qim += icc*(y-z+akk*dt*N(z0) )
            qi4 += (q4 - qi4  + N4)*icc;
            qi5 += (q5 - qi5  + N5)*icc;
            qi6 += (q6 - qi6  + N6)*icc;
            }

            // BGK relaxation approximation to the Boltzmann collision operator
            s_cubN4[es][n] = -p_tauInv*(qi4 + N4c);
            s_cubN5[es][n] = -p_tauInv*(qi5 + N5c);
            s_cubN6[es][n] = -p_tauInv*(qi6 + N6c);
        }
      }
    }
      }
      
      // make sure all cubature node data is loaded into @shared
    @barrier("local");
      
      // partial projection to nodes from cubature-sub-group
  for(int es=0;es<p_NblockCub;++es;@inner(1)){
    for(int n=0;n<p_maxCubNodes;++n;@inner(0)){
      int et = eo+es; // element in block
      if(et<Nelements){
        if(n<p_Np){

       
      // use temporaries for part sums for N4,N5,N6 because of @exclusives
        dfloat N4 = 0.f, N5 = 0.f, N6 = 0.f;

        for(int i=0;i<p_cubNp;++i){
          const dfloat Pnc  = cubProjectT[i*p_Np+n];
          N4 += Pnc*s_cubN4[es][i];
          N5 += Pnc*s_cubN5[es][i];
          N6 += Pnc*s_cubN6[es][i];
        }

         const int id = p_Nfields*(e*p_Np + n);
         q4  = s_q[es][3][n]; 
         q5  = s_q[es][4][n]; 
         q6  = s_q[es][5][n]; 
        
        // Update rkq according to new available rhsqim
        q[id+3] =  q4 + akk*dt*N4 ;
        q[id+4] =  q5 + akk*dt*N5 ;
        q[id+5] =  q6 + akk*dt*N6 ;  
                  
        // do not update q1 ,q2 ,q3 
        rhsqim[id+0] =  0. ;
        rhsqim[id+1] =  0. ;
        rhsqim[id+2] =  0. ;  
        rhsqim[id+3] =  N4 ;
        rhsqim[id+4] =  N5 ;
        rhsqim[id+5] =  N6 ;  
          
        }
      }
    }
      }
  }
}



// Fully Explicit Scheme Uses Clasical half Half Splitting
@kernel void boltzmannIMEXRKPmlDampingCub2D(const int pmlNelements,
                                    @restrict const  int *  pmlElementIds,
                                    @restrict const  int *  pmlIds,
                                    const int nrhs,
                                    const int shift,
                                    @restrict const  dfloat *  cubInterpT,
                                    @restrict const  dfloat *  cubProjectT,
                                    @restrict const  dfloat *  pmlSigmaX,
                                    @restrict const  dfloat *  pmlSigmaY, 
                                    @restrict const  dfloat *  q,
                                    @restrict const  dfloat *  pmlqx,
                                    @restrict const  dfloat *  pmlqy,
                                          @restrict dfloat *  rhsq,
                                          @restrict dfloat *  pmlrhsqx,
                                          @restrict dfloat *  pmlrhsqy){

    for(int eo=0;eo<pmlNelements;eo+=p_NblockCub;@outer(0)){  // for all elements

    // @shared memory for q at nodes
    @shared dfloat  s_q[p_NblockCub][p_Nfields][p_Np];
    @shared dfloat s_qx[p_NblockCub][p_Nfields][p_Np];
    @shared dfloat s_qy[p_NblockCub][p_Nfields][p_Np];

    // sub-group of p_Np cubature node interpolants of N4,N5,N6
    @shared dfloat s_cubq[p_NblockCub][p_Nfields][p_cubNp];
    @shared dfloat s_cubqx[p_NblockCub][p_Nfields][p_cubNp];
    @shared dfloat s_cubqy[p_NblockCub][p_Nfields][p_cubNp];
   
    @exclusive int e, pmlId;

    // prefetch q to @shared
    for(int es=0;es<p_NblockCub;++es;@inner(1)){
      for(int n=0;n<p_maxCubNodes;++n;@inner(0)){      
        int et = eo+es; // element in block
        if(et<pmlNelements){
            e     = pmlElementIds[et];
            pmlId = pmlIds[et];
            
            if(n<p_Np){
              const int id  = p_Nfields*(e*p_Np + n);
              const int pid = p_Nfields*(pmlId*p_Np + n);
              
              #pragma unroll p_Nfields
              for(int fld=0; fld<p_Nfields;++fld){
                s_q[es][fld][n]   = q[id +fld];
                s_qx[es][fld][n]  = pmlqx[pid+fld];
                s_qy[es][fld][n]  = pmlqy[pid+fld];
              }
            }
         }
       }
    }
    
    // make sure all node data is loaded into @shared
    @barrier("local");

    // interpolate q to cubature
    for(int es=0;es<p_NblockCub;++es;@inner(1)){
      for(int n=0;n<p_maxCubNodes;++n;@inner(0)){     
        int et = eo+es; // element in block
        if(et<pmlNelements){
          if(n<p_cubNp){
            dfloat r_q[p_Nfields];
            dfloat r_qx[p_Nfields];
            dfloat r_qy[p_Nfields];
            
            #pragma unroll p_Nfields
            for(int fld=0; fld<p_Nfields ; fld++){
              r_q[fld]  = 0.f;
              r_qx[fld] = 0.f;
              r_qy[fld] = 0.f;
            }
            
            #pragma unroll p_Np
            for(int m=0;m<p_Np;++m){
              const dfloat Icn  = cubInterpT[m*p_cubNp+n];   
              #pragma unroll p_Nfields
              for(int fld=0; fld<p_Nfields;++fld){
                r_q[fld]  += Icn*s_q[es][fld][m];
                r_qx[fld] += Icn*s_qx[es][fld][m];
                r_qy[fld] += Icn*s_qy[es][fld][m];
              }
            }
            
            // Prefetch sigma
            const dfloat sigmaxe = pmlSigmaX[pmlId*p_cubNp+n];
            const dfloat sigmaye = pmlSigmaY[pmlId*p_cubNp+n];
            // M-PML sigma midification
            const dfloat msigmaxe = sigmaxe + sigmaye*p_pmlAlpha;
            const dfloat msigmaye = sigmaye + sigmaxe*p_pmlAlpha;
            
            #pragma unroll p_Nfields
            for(int fld=0; fld<p_Nfields;++fld){       
              s_cubqx[es][fld][n] = -msigmaxe*r_qx[fld];
              s_cubqy[es][fld][n] = -msigmaye*r_qy[fld];
              s_cubq [es][fld][n] = -msigmaxe*r_qx[fld]-msigmaye*r_qy[fld];
            }
            // dfloat icubq1 = 1.f/r_q[0];
            // // BGK relaxation approximation to the Boltzmann collision operator
            // s_cubq[es][3][n] -= p_tauInv*(r_q[3]-(           r_q[1]*r_q[2]*icubq1));
            // s_cubq[es][4][n] -= p_tauInv*(r_q[4]-(p_invsqrt2*r_q[1]*r_q[1]*icubq1));
            // s_cubq[es][5][n] -= p_tauInv*(r_q[5]-(p_invsqrt2*r_q[2]*r_q[2]*icubq1));
          }
        }
      }
    }

    // make sure all cubature node data is loaded into @shared
    @barrier("local");
    
    // partial projection to nodes from cubature-sub-group
    for(int es=0;es<p_NblockCub;++es;@inner(1)){
      for(int n=0;n<p_maxCubNodes;++n;@inner(0)){     
    
        int et = eo+es; // element in block
          if(et<pmlNelements){
            if(n<p_Np){
          // Update
              const int rhsId    = nrhs*p_Nfields*(p_Np*e + n)     + p_Nfields*shift;
              const int pmlrhsId = nrhs*p_Nfields*(p_Np*pmlId + n) + p_Nfields*shift;

              dfloat r_rhsq[p_Nfields];
              dfloat r_rhsqx[p_Nfields];
              dfloat r_rhsqy[p_Nfields]; 
              // dfloat r_rhsqt[p_Nfields];
            
              #pragma unroll p_Nfields
              for(int fld=0; fld<p_Nfields;++fld){
                r_rhsq[fld]  = 0.f;
                r_rhsqx[fld] = 0.f;
                r_rhsqy[fld] = 0.f;
              }

              // use temporaries for part sums for N4,N5,N6 because of @exclusives
              #pragma unroll p_cubNp
              for(int m=0;m<p_cubNp;++m){
                const dfloat Pnc  = cubProjectT[m*p_Np+n];                  
                 #pragma unroll p_Nfields
                 for(int fld=0; fld<p_Nfields; fld++){
                  r_rhsq [fld] += Pnc*s_cubq[es][fld][m];
                  r_rhsqx[fld] += Pnc*s_cubqx[es][fld][m];
                  r_rhsqy[fld] += Pnc*s_cubqy[es][fld][m];
                 }
              }
                
             #pragma unroll p_Nfields 
             for(int fld=0; fld<p_Nfields;++fld){
                pmlrhsqx[pmlrhsId + fld] += r_rhsqx[fld];
                pmlrhsqy[pmlrhsId + fld] += r_rhsqy[fld];
                rhsq[rhsId + fld]        += r_rhsq[fld];
              }   
          }
        }
      }
    }

  }
}
