 
 /*
 #if p_Nq < 11
#define sliceThickness 1
#elif p_Nq <= 13
#define sliceThickness 2
#elif p_Nq p_Nq == 14
#define sliceThickness 3
#elif p_Nq <=16
#define sliceThickness 4
#else
#define sliceThickness 6
#endif

#if p_Nq < 11
#define shift p_Nq
#else
#define shift  1024/(p_Nq*p_Nq)
#endif

#define cubeThreadsSliced                             \
	for(int k=0; k<shift; ++k; @inner(2))            \
		for(int j=0; j<p_Nq; ++j; @inner(1))          \
			for(int i=0; i<p_Nq; ++i; @inner(0))

@kernel void ellipticAxHex3D_rDir(const int Nelements,
                                 @restrict const  int *  elementList,
                                 @restrict const  dfloat *  ggeo,
                                 @restrict const  dfloat *  D,
                                 const dfloat lambda,
                                 @restrict const  dfloat *  q,
                                 @restrict dfloat *  Aq,
                                 @restrict dfloat *  aux
                                ){
	for(int e=0; e<Nelements; ++e; @outer(0)) {

		@shared dfloat s_q[p_Nq][p_Nq][p_Nq];
		//@shared dfloat s_q2[p_Nq][p_Nq][p_Nq];
		@shared dfloat s_D[p_Nq][p_Nq];
		//	@exclusive dfloat r_qr[sliceThickness];
		// prefetch q(:,:,:,e) to @shared
		cubeThreadsSliced {

		  //  #pragma unroll p_Nq
		  for (int s=k; s<p_Nq;s+=shift){
		  const int base = i + j*p_Nq + s*p_Nq*p_Nq + elementList[e]*p_Np;
			  s_q[s][j][i] = q[base];
		  }
		  if(k==0) // fetch D to @shared
		  s_D[j][i] = D[j*p_Nq+i];

		}


		@barrier("local");



		cubeThreadsSliced {


		  for (int s=k; s<p_Nq;s+=shift){

		  int base = elementList[e]*p_Nggeo*p_Np + s*p_Nq*p_Nq + j*p_Nq + i;

			  // assumes w*J built into G entries
			  const dfloat GwJ = ggeo[base+p_GWJID*p_Np];



			  dfloat qr = 0.f, qs = 0.f, qt = 0.f;

			  for(int n=0; n<p_Nq; ++n) {
				  qr += s_D[i][n]*s_q[s][j][n];
				  qs += s_D[j][n]*s_q[s][n][i];
				  qt += s_D[s][n]*s_q[n][j][i];
			  }



			  const dfloat G00 = ggeo[base+p_G00ID*p_Np];
			  const dfloat G01 = ggeo[base+p_G01ID*p_Np];
			  const dfloat G02 = ggeo[base+p_G02ID*p_Np];


			  const dfloat qqr = G00*qr + G01*qs + G02*qt;
			  //	  r_qr[s/shift] = qqr;
			  // base = i + j*p_Nq + s*p_Nq*p_Nq + elementList[e]*p_Np;
			  //s_q2[s][j][i] = qqr;

		  }//cube threads


		}


		//synchronize
		@barrier("local");
		cubeThreadsSliced {
		  for (int s=k; s<p_Nq;s+=shift){


		  dfloat tmp = 0.f;
		  for(int n=0; n<p_Nq; ++n)
				  //	 tmp += s_D[n][i]*s_q2[s][j][n];
				  const int base = i + j*p_Nq + s*p_Nq*p_Nq + elementList[e]*p_Np;
			  //	  Aq[base] = tmp;



		  }
		}



	}//e
}//@kernel
*/
// KASIA TRILINEAR KERNEL 3 (fly @kernel 3)
// in this @kernel:
//1) i-j marching --> i-k marching --> j-k matching -->
//2) cube load structure (4 x 4 cubes)
//3) geofactors  on the fly, with assumption of nice tensor product structure

#define T 3

@kernel void ellipticAxHex3D_trilinear3(const int Nelements,
                                       @restrict const  int *  elementList,
                                       @restrict const  dfloat *  ggeo,
                                       @restrict const  dfloat *  D,
                                       const dfloat lambda,
                                       @restrict const  dfloat *  q,
                                       @restrict dfloat *  Aq,
                                       @restrict const  dfloat *  grad){

	for(int e=0; e<Nelements; ++e; @outer(0)) {
// rename to make less confusing
		@shared dfloat s_tmp1[4][p_Nq][p_Nq];
		@shared dfloat s_tmp2[4][p_Nq][p_Nq];
		@shared dfloat s_q[p_Nq][p_Nq];
		@shared dfloat s_D[p_Nq][p_Nq];

		@shared dfloat s_EXYZ[9][3];
		@shared dfloat s_rw[2][p_Nq];

		//new --> we will load 16 cubes per slice, every cube is 4x4x4
		// 16 is heuristic, change it later
		// exactly 1024, will keep every thread busy
		@shared dfloat s_slice[16][4][4][4];

		//end of new

		//	@exclusive dfloat r_q[p_Nq];
		//	@exclusive dfloat r_Aq[p_Nq], r_qt, r_tmpt;
		@exclusive int emap;
		@exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22;
		@exclusive dfloat r_GwJ;

		for (int k =0; k<4; ++k; @inner(2)){
			for(int j=0; j<p_Nq; ++j; @inner(1)) {
				for(int i=0; i<p_Nq; ++i; @inner(0)) {

					emap = elementList[e];
					if (k== 0){
						s_D[i][j] = D[j*p_Nq+i];

						int t = i+j*p_Nq;

						while(t<2*p_Nq){
							s_rw[0][t] = ggeo[t];
							t += p_Nq*p_Nq;
						}

						t = i+j*p_Nq;
						while(t<9*3){ // 54
							s_EXYZ[0][t] = ggeo[2*p_Nq + emap*p_Nverts*9 + t];
							t += p_Nq*p_Nq;
						}
					}
				}
			}
		}//k

		@barrier("local");

		#pragma unroll 4
		for (int p=0; p<4; ++p)
		{
			// first, load a slice
			for(int k=0; k<4; ++k; @inner(2)) {
				for(int j=0; j<p_Nq; ++j; @inner(1)) {
					for(int i=0; i<p_Nq; ++i; @inner(0)) {
						//load
						const int base = i + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np;
						// 4 x 16 x 16
						//cube number
						int cn = 4*(j/4)+(i/4);
						// i, j inside cube
						s_slice[cn][k][j%4][i%4] =  q[base];
						//	k j i
					}
				}
			}//k




			for(int k=0; k<4; ++k; @inner(2)) {

				for(int j=0; j<p_Nq; ++j; @inner(1)) {
					for(int i=0; i<p_Nq; ++i; @inner(0)) {
						
						const dfloat rn = s_rw[0][i];
						const dfloat sn = s_rw[0][j];
						const dfloat tn = s_rw[0][k];

						const dfloat xr = (1.-tn)*(1.-sn)*(s_EXYZ[0][0]) + (1.-tn)*(1.+sn)*(s_EXYZ[0][1]) + (1.+tn)*(1.-sn)*(s_EXYZ[0][2]);
						const dfloat xs = (1.-tn)*(1.-rn)*(s_EXYZ[1][0]) + (1.-tn)*(1.+rn)*(s_EXYZ[1][1]) + (1.+tn)*(1.-rn)*(s_EXYZ[1][2]);
						const dfloat xt = (1.-rn)*(1.-sn)*(s_EXYZ[2][0]) + (1.+rn)*(1.-sn)*(s_EXYZ[2][1]) + (1.+rn)*(1.+sn)*(s_EXYZ[2][2]);

						const dfloat yr = (1.-tn)*(1.-sn)*(s_EXYZ[3][0]) + (1.-tn)*(1.+sn)*(s_EXYZ[3][1]) + (1.+tn)*(1.-sn)*(s_EXYZ[3][2]);
						const dfloat ys = (1.-tn)*(1.-rn)*(s_EXYZ[4][0]) + (1.-tn)*(1.+rn)*(s_EXYZ[4][1]) + (1.+tn)*(1.-rn)*(s_EXYZ[4][2]);
						const dfloat yt = (1.-rn)*(1.-sn)*(s_EXYZ[5][0]) + (1.+rn)*(1.-sn)*(s_EXYZ[5][1]) + (1.+rn)*(1.+sn)*(s_EXYZ[5][2]);

						const dfloat zr = (1.-tn)*(1.-sn)*(s_EXYZ[6][0]) + (1.-tn)*(1.+sn)*(s_EXYZ[6][1]) + (1.+tn)*(1.-sn)*(s_EXYZ[6][2]);
						const dfloat zs = (1.-tn)*(1.-rn)*(s_EXYZ[7][0]) + (1.-tn)*(1.+rn)*(s_EXYZ[7][1]) + (1.+tn)*(1.-rn)*(s_EXYZ[7][2]);
						const dfloat zt = (1.-rn)*(1.-sn)*(s_EXYZ[8][0]) + (1.+rn)*(1.-sn)*(s_EXYZ[8][1]) + (1.+rn)*(1.+sn)*(s_EXYZ[8][2]);

						
						const dfloat J = xr*(ys*zt-zs*yt) - yr*(xs*zt-zs*xt) + zr*(xs*yt-ys*xt);
						const dfloat Jinv = 1./J;

						const dfloat rx =  (ys*zt - zs*yt), ry = -(xs*zt - zs*xt), rz =  (xs*yt - ys*xt); // removed Jinv factor to below
						const dfloat sx = -(yr*zt - zr*yt), sy =  (xr*zt - zr*xt), sz = -(xr*yt - yr*xt);
						//	const dfloat tx =  (yr*zs - zr*ys), ty = -(xr*zs - zr*xs), tz =  (xr*ys - yr*xs);

						//	const dfloat JW = J*s_rw[1][i]*s_rw[1][j]*s_rw[1][k];

						
						r_G00 = Jinv*(rx*rx + ry*ry + rz*rz); // removed J factor to below
						r_G01 = Jinv*(rx*sx + ry*sy + rz*sz);
						//	r_G02 = Jinv*(rx*tx + ry*ty + rz*tz);
						r_G11 = Jinv*(sx*sx + sy*sy + sz*sz);
						//	r_G12 = Jinv*(sx*tx + sy*ty + sz*tz);
						//	r_G22 = Jinv*(tx*tx + ty*ty + tz*tz);
						//	r_GwJ = JW;

						// now differentiate in i j  dir
						dfloat qs =0.0f, qr = 0.0f;
						#pragma unroll p_Nq
						for(int n=0; n<p_Nq; ++n) {
							int cn = 4*(j/4)+(n/4);
							//cube numbwe
							qr += s_D[i][n]*s_slice[cn][k][j%4][n%4];
							//s_q[j][n];
							cn = 4*(n/4)+(i/4);
							qs += s_D[j][n]*s_slice[cn][k][n%4][j%4];
							//s_q[n][i];
						}
					  s_tmp1[k][j][i]=qr;
					  //+ r_G01*qs;
					  s_tmp2[k][j][i]=qs;
						
					  }//i
				  }//j
			  }//k
			  @barrier("local");
			for(int k=0; k<4; ++k; @inner(2)) {
				for(int j=0; j<p_Nq; ++j; @inner(1)) {
					for(int i=0; i<p_Nq; ++i; @inner(0)) {
						dfloat Aq1 = 0.0f, Aq2 = 0.0f;

						#pragma unroll p_Nq
						for(int n=0; n<p_Nq; ++n) {
							Aq1 += s_D[n][i]*(r_G00*s_tmp1[k][j][n] + r_G01*s_tmp2[k][j][n]);
							Aq2 += s_D[n][j]*(r_G01*s_tmp1[k][n][i] + r_G11*s_tmp2[k][n][i]);
						}

						//r_Aq[k] +=  Aq1 + Aq2 + r_GwJ*lambda*s_q[j][i];
						Aq[emap*p_Np+k*p_Nq*p_Nq+j*p_Nq+i] =  Aq1 + Aq2;

					}
				}
			}
		}//p
		// so now go through i-k slices
		
		
		
		
		
		
		
	}//e
}

