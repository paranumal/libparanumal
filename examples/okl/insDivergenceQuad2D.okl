// Compute Gradient in Strong Form
@kernel void insDivergenceVolumeQuad2D(const dlong Nelements,
                                      @restrict const  dfloat *  vgeo,
                                      @restrict const  dfloat *  D,
                                      const dlong offset,
                                      @restrict const  dfloat *  U,
                                      @restrict const  dfloat *  V,
                                            @restrict dfloat *  divU){

  for(dlong eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){  // for all elements

    @shared dfloat s_U[p_NblockV][p_Nq][p_Nq];
    @shared dfloat s_V[p_NblockV][p_Nq][p_Nq];
    @shared dfloat s_D[p_Nq][p_Nq];

    for(int es=0;es<p_NblockV;++es;@inner(2)){   
      for(int j=0;j<p_Nq;++j;@inner(1)){ 
        for(int i=0;i<p_Nq;++i;@inner(0)){    
          const dlong e = eo+es; // element in block
          if(e<Nelements){ 
            const dlong id = (e+offset)*p_Np + j*p_Nq+i;
            
            s_U[es][j][i] = U[id];
            s_V[es][j][i] = V[id];
      
            if (es==0)
              s_D[j][i] = D[j*p_Nq+i];
          }
        }
      }
    }

    // Make sure all node data is loaded into @shared
    @barrier("local");

    for(int es=0;es<p_NblockV;++es;@inner(2)){ 
      for(int j=0;j<p_Nq;++j;@inner(1)){ 
        for(int i=0;i<p_Nq;++i;@inner(0)){  
          const dlong e = eo+es; 
          if(e<Nelements){ 
            const dlong gid = e*p_Np*p_Nvgeo+ j*p_Nq +i;
            const dfloat drdx = vgeo[gid + p_RXID*p_Np];
            const dfloat drdy = vgeo[gid + p_RYID*p_Np];
            const dfloat dsdx = vgeo[gid + p_SXID*p_Np];
            const dfloat dsdy = vgeo[gid + p_SYID*p_Np];

            dfloat dUdr  = 0.f, dUds  = 0.f;
            dfloat dVdr  = 0.f, dVds  = 0.f;

            #pragma unroll p_Nq
              for(int n=0;n<p_Nq;++n){
                const dfloat Dr = s_D[i][n];
                const dfloat Ds = s_D[j][n];

                dUdr += Dr*s_U[es][j][n];
                dUds += Ds*s_U[es][n][i];
                dVdr += Dr*s_V[es][j][n];
                dVds += Ds*s_V[es][n][i];
              }

            const dlong id = e*p_Np + j*p_Nq + i;
            const dfloat dUdx = drdx*dUdr + dsdx*dUds;
            const dfloat dVdy = drdy*dVdr + dsdy*dVds;

            divU[id] = dUdx + dVdy;
          }
        }
      }
    }
  }  
}


#define surfaceTerms(sk,face,i, j)                                      \
  {                                                                     \
  const dlong idM = vmapM[sk]+p_Np*offset;                              \
  const dlong idP = vmapP[sk]+p_Np*offset;                              \
                                                                        \
  const dfloat nx = sgeo[sk*p_Nsgeo+p_NXID];                            \
  const dfloat ny = sgeo[sk*p_Nsgeo+p_NYID];                            \
  const dfloat sJ = sgeo[sk*p_Nsgeo+p_SJID];                            \
  const dfloat invWJ = sgeo[sk*p_Nsgeo+p_WIJID];                        \
                                                                        \
  const dfloat uM = U[idM], vM = V[idM];                                \
        dfloat uP = U[idP], vP = V[idP];                                \
                                                                        \
  const int bc = EToB[face+p_Nfaces*e];                                 \
  if(bc>0) {                                                            \
    const dlong idm = vmapM[sk];                                        \
    insVelocityDirichletConditions2D(bc, time, x[idm], y[idm], nx, ny, uM, vM, &uP, &vP);\
    uP = 2.f*uP-uM;                                                     \
    vP = 2.f*vP-vM;                                                     \
  }                                                                     \
                                                                        \
  const dfloat sc = invWJ * sJ;                                         \
  s_fluxU[es][j][i] = 0.5f*sc*(nx*(uP-uM) + ny*(vP-vM));                \
  }

@kernel void insDivergenceSurfaceQuad2D(const dlong Nelements,
                                       @restrict const  dfloat *  sgeo,
                                       @restrict const  dlong  *  vmapM,
                                       @restrict const  dlong  *  vmapP,
                                       @restrict const  int    *  EToB,
                                       const dfloat time,
                                       @restrict const  dfloat *  x,
                                       @restrict const  dfloat *  y,
                                       const dlong offset,
                                       @restrict const  dfloat *  U,
                                       @restrict const  dfloat *  V,
                                             @restrict dfloat *  divU){

  // for all elements
  for(dlong eo=0;eo<Nelements;eo+=p_NblockS;@outer(0)){
    // @shared storage for flux terms
    @shared dfloat s_fluxU[p_NblockS][p_Nq][p_Nq];

    for(int j=0;j<p_Nq;++j){
      for(int es=0;es<p_NblockS;++es;@inner(1)){
        for(int i=0;i<p_Nq;++i;@inner(0)){
          s_fluxU[es][j][i] = 0.;
        }
      }
    }

    @barrier("local");

    // for all face nodes of all elements
    // face 0 & 2
    for(int es=0;es<p_NblockS;++es;@inner(1)){
      for(int i=0;i<p_Nq;++i;@inner(0)){
        const dlong e = eo + es;
        if(e<Nelements){
          dlong sk0 = e*p_Nfp*p_Nfaces + 0*p_Nfp + i;
          dlong sk2 = e*p_Nfp*p_Nfaces + 2*p_Nfp + i;

          surfaceTerms(sk0,0,i,0     );
          surfaceTerms(sk2,2,i,p_Nq-1);
        }
      }
    }

    @barrier("local");

    // face 1 & 3
    for(int es=0;es<p_NblockS;++es;@inner(1)){
      for(int j=0;j<p_Nq;++j;@inner(0)){
        const dlong e = eo + es;
        if(e<Nelements){
          dlong sk1 = e*p_Nfp*p_Nfaces + 1*p_Nfp + j;
          dlong sk3 = e*p_Nfp*p_Nfaces + 3*p_Nfp + j;

          surfaceTerms(sk1,1,p_Nq-1,j);
          surfaceTerms(sk3,3,0     ,j);
        }
      }
    }

    @barrier("local");

    // for each node in the element
    for(int j=0;j<p_Nq;++j){
      for(int es=0;es<p_NblockS;++es;@inner(1)){
        for(int i=0;i<p_Nq;++i;@inner(0)){
          const dlong e = eo + es;
          if(e<Nelements){
            const dlong id = e*p_Np + j*p_Nq + i;
            divU[id] += s_fluxU[es][j][i];
          }
        }
      }
    }
  }
}

