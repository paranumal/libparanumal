
// Perform an update like Y = Q + c_im*Res_IM + c_ex*Res_EX;
@kernel void boltzmannIMEXResidualUpdate2D(const int Nelements,
            @restrict const  int *  elementIds,
            const dfloat dt, 
            const dfloat c_im,
            const dfloat c_ex, 
            @restrict const  dfloat4 *  q,
            @restrict const  dfloat4 *  qZ,
                  @restrict dfloat4 *  qY){
  // Low storage Runge Kutta time step update
  for(int e=0;e<Nelements;++e;@outer(0)){
    for(int n=0;n<p_Np;++n;@inner(0)){
      const int element = elementIds[e];

      const int id0 = 2*(n + element*p_Np);
      const int id1 = id0 + 1; 

      dfloat4 qima = qZ[id0];
      dfloat4 qimb = qZ[id1];

      dfloat4 qexa = qY[id0];
      dfloat4 qexb = qY[id1];
      //
      dfloat4 qa  = q[id0];
      dfloat4 qb  = q[id1];

      qY[id0] = qa  + c_ex*qexa + c_im*qima;
      qY[id1] = qb  + c_ex*qexb + c_im*qimb;
      

    }
  }
}


// Perform an update like Y = Q + c_im*Res_IM + c_ex*Res_EX;
@kernel void boltzmannIMEXImplicitUpdate2D(const int Nelements,
            @restrict const  int *  elementIds,
            const dfloat dt, 
            const dfloat akk,
            @restrict const  dfloat4 *  qZ,
            @restrict const  dfloat4 *  qY,
                  @restrict dfloat4 *  q,
                  @restrict dfloat4 *  qS){
  // Low storage Runge Kutta time step update
  for(int e=0;e<Nelements;++e;@outer(0)){
    for(int n=0;n<p_Np;++n;@inner(0)){
      const int element = elementIds[e];

      const int id0 = 2*(n + element*p_Np);
      const int id1 = id0 + 1; 

      dfloat4 qima = qZ[id0];
      dfloat4 qimb = qZ[id1];

      dfloat4 qexa = qY[id0];
      dfloat4 qexb = qY[id1];
      //
      dfloat4 qa  = q[id0];
      dfloat4 qb  = q[id1];

      qS[id0] = qa; 
      qS[id1] = qb; 

      q[id0] = qexa + akk*dt*qima;
      q[id1] = qexb + akk*dt*qimb;      

    }
  }
}


// Perform an update like Y = Q + c_im*Res_IM + c_ex*Res_EX;
@kernel void boltzmannIMEXUpdate2D(const int Nelements,
            @restrict const  int *  elementIds,
            const dfloat dt, 
            const dfloat akk,
            @restrict const  dfloat4 *  qZ,
            @restrict const  dfloat4 *  qY,
            @restrict const  dfloat4 *  qS,
                  @restrict dfloat4 *  q){
  // Low storage Runge Kutta time step update
  for(int e=0;e<Nelements;++e;@outer(0)){
    for(int n=0;n<p_Np;++n;@inner(0)){
      const int element = elementIds[e];

      const int id0 = 2*(n + element*p_Np);
      const int id1 = id0 + 1; 

      dfloat4 qia = qZ[id0];
      dfloat4 qib = qZ[id1];

      dfloat4 qea = qY[id0];
      dfloat4 qeb = qY[id1];
      //
      dfloat4 qa  = qS[id0];
      dfloat4 qb  = qS[id1];

      
      q[id0] = qa+ akk*dt*(qia + qea);
      q[id1] = qb+ akk*dt*(qib + qeb);     

    }
  }
}

// Perform an update like Y = Q + c_im*Res_IM + c_ex*Res_EX;
@kernel void boltzmannIMEXSplitPmlImplicitUpdate2D(const int Nelements,
            @restrict const  int *  elementIds,
            const dfloat dt, 
            const dfloat akk,
            const dfloat ramp,
            @restrict const  dfloat  *  qZx,
            @restrict const  dfloat  *  qZy,
            @restrict const  dfloat  *  qZnt,     
            @restrict const  dfloat  *  qYx,
            @restrict const  dfloat  *  qYy,
            @restrict const  dfloat  *  qYnt,
                  @restrict dfloat  *  pmlqx,
                  @restrict dfloat  *  pmlqy,
                  @restrict dfloat  *  pmlNT,     
                  @restrict dfloat  *  qSx,
                  @restrict dfloat  *  qSy,
                  @restrict dfloat  *  qSnt,
                  @restrict dfloat4 *  q ){
  // Low storage Runge Kutta time step update
  for(int e=0;e<Nelements;++e;@outer(0)){
    for(int n=0;n<p_Np;++n;@inner(0)){
      const int element = elementIds[e];

      //
      const int base = n + element*p_Nfields*p_Np;
      const int id1 = base + 0*p_Np;
      const int id2 = base + 1*p_Np;
      const int id3 = base + 2*p_Np;
      const int id4 = base + 3*p_Np;
      const int id5 = base + 4*p_Np;
      const int id6 = base + 5*p_Np;


      // PML UPDATES
      dfloat qx1 = pmlqx[id1];
      dfloat qx2 = pmlqx[id2];
      dfloat qx3 = pmlqx[id3];
      dfloat qx4 = pmlqx[id4];
      dfloat qx5 = pmlqx[id5];
      dfloat qx6 = pmlqx[id6]; 
      //
      dfloat qy1 = pmlqy[id1];
      dfloat qy2 = pmlqy[id2];
      dfloat qy3 = pmlqy[id3];
      dfloat qy4 = pmlqy[id4];
      dfloat qy5 = pmlqy[id5];
      dfloat qy6 = pmlqy[id6]; 
      //
      dfloat nt1 = pmlNT[id1];
      dfloat nt2 = pmlNT[id2];
      dfloat nt3 = pmlNT[id3];
      dfloat nt4 = pmlNT[id4];
      dfloat nt5 = pmlNT[id5];
      dfloat nt6 = pmlNT[id6]; 

      // PML UPDATES
      dfloat qxi1 = qZx[id1];
      dfloat qxi2 = qZx[id2];
      dfloat qxi3 = qZx[id3];
      dfloat qxi4 = qZx[id4];
      dfloat qxi5 = qZx[id5];
      dfloat qxi6 = qZx[id6]; 
      //
      dfloat qyi1 = qZy[id1];
      dfloat qyi2 = qZy[id2];
      dfloat qyi3 = qZy[id3];
      dfloat qyi4 = qZy[id4];
      dfloat qyi5 = qZy[id5];
      dfloat qyi6 = qZy[id6]; 
      //
      dfloat nti1 = qZnt[id1];
      dfloat nti2 = qZnt[id2];
      dfloat nti3 = qZnt[id3];
      dfloat nti4 = qZnt[id4];
      dfloat nti5 = qZnt[id5];
      dfloat nti6 = qZnt[id6]; 

      // PML UPDATES
      dfloat qxe1 = qYx[id1];
      dfloat qxe2 = qYx[id2];
      dfloat qxe3 = qYx[id3];
      dfloat qxe4 = qYx[id4];
      dfloat qxe5 = qYx[id5];
      dfloat qxe6 = qYx[id6]; 
      //
      dfloat qye1 = qYy[id1];
      dfloat qye2 = qYy[id2];
      dfloat qye3 = qYy[id3];
      dfloat qye4 = qYy[id4];
      dfloat qye5 = qYy[id5];
      dfloat qye6 = qYy[id6]; 
      //
      dfloat nte1 = qYnt[id1];
      dfloat nte2 = qYnt[id2];
      dfloat nte3 = qYnt[id3];
      dfloat nte4 = qYnt[id4];
      dfloat nte5 = qYnt[id5];
      dfloat nte6 = qYnt[id6]; 

      // PML UPDATES
      qSx[id1] = qx1;
      qSx[id2] = qx2;
      qSx[id3] = qx3;
      qSx[id4] = qx4;
      qSx[id5] = qx5;
      qSx[id6] = qx6; 
      //
      qSy[id1] = qy1;
      qSy[id2] = qy2;
      qSy[id3] = qy3;
      qSy[id4] = qy4;
      qSy[id5] = qy5;
      qSy[id6] = qy6; 

      qSnt[id1] = nt1;
      qSnt[id2] = nt2;
      qSnt[id3] = nt3;
      qSnt[id4] = nt4;
      qSnt[id5] = nt5;
      qSnt[id6] = nt6; 
      //

      // PML UPDATES
      qx1 = qxe1 + akk*dt*qxi1;
      qx2 = qxe2 + akk*dt*qxi2;
      qx3 = qxe3 + akk*dt*qxi3;
      qx4 = qxe4 + akk*dt*qxi4;
      qx5 = qxe5 + akk*dt*qxi5;
      qx6 = qxe6 + akk*dt*qxi6; 
       // PML UPDATES
      qy1 = qye1 + akk*dt*qyi1;
      qy2 = qye2 + akk*dt*qyi2;
      qy3 = qye3 + akk*dt*qyi3;
      qy4 = qye4 + akk*dt*qyi4;
      qy5 = qye5 + akk*dt*qyi5;
      qy6 = qye6 + akk*dt*qyi6; 

      
      // PML UPDATES
      pmlqx[id1] = qx1;
      pmlqx[id2] = qx2;
      pmlqx[id3] = qx3;
      pmlqx[id4] = qx4;
      pmlqx[id5] = qx5;
      pmlqx[id6] = qx6; 
       // PML UPDATES
      pmlqy[id1] = qy1;
      pmlqy[id2] = qy2;
      pmlqy[id3] = qy3;
      pmlqy[id4] = qy4;
      pmlqy[id5] = qy5;
      pmlqy[id6] = qy6; 

      // PML UPDATES
      pmlNT[id1] = nte1 + akk*dt*nti1;
      pmlNT[id2] = nte2 + akk*dt*nti2;
      pmlNT[id3] = nte3 + akk*dt*nti3;
      pmlNT[id4] = nte4 + akk*dt*nti4;
      pmlNT[id5] = nte5 + akk*dt*nti5;
      pmlNT[id6] = nte6 + akk*dt*nti6; 


      dfloat4 temp;

      temp.x =  p_q1bar                 + qx1 + qy1;
      temp.y =  ramp*p_q2bar            + qx2 + qy2;
      temp.z =  ramp*p_q3bar            + qx3 + qy3;
      temp.w =  ramp*ramp*p_q4bar       + qx4 + qy4;

      q[2*(n + element*p_Np)] = temp;

      temp.x =  ramp*ramp*p_q5bar       + qx5 + qy5;
      temp.y =  ramp*ramp*p_q6bar       + qx6 + qy6;
      temp.z =  0.0;
      temp.w =  0.0;

       q[2*(n + element*p_Np) +1] = temp;

    }
  }
}


// Perform an update like Y = Q + c_im*Res_IM + c_ex*Res_EX;
@kernel void boltzmannIMEXSplitPmlUpdate2D(const int Nelements,
            @restrict const  int *  elementIds,
            const dfloat dt, 
            const dfloat akk,
            const dfloat ramp,
            @restrict const  dfloat  *  qZx,
            @restrict const  dfloat  *  qZy,
            @restrict const  dfloat  *  qZnt,     
            @restrict const  dfloat  *  qYx,
            @restrict const  dfloat  *  qYy,
            @restrict const  dfloat  *  qYnt,
            @restrict const  dfloat  *  qSx,
                  @restrict dfloat  *  qSy,
                  @restrict dfloat  *  qSnt,     
                  @restrict dfloat  *  pmlqx,
                  @restrict dfloat  *  pmlqy,
                  @restrict dfloat  *  pmlNT,
                  @restrict dfloat4 *  q ){
  // Low storage Runge Kutta time step update
  for(int e=0;e<Nelements;++e;@outer(0)){
    for(int n=0;n<p_Np;++n;@inner(0)){
      const int element = elementIds[e];

      //
      const int base = n + element*p_Nfields*p_Np;
      const int id1 = base + 0*p_Np;
      const int id2 = base + 1*p_Np;
      const int id3 = base + 2*p_Np;
      const int id4 = base + 3*p_Np;
      const int id5 = base + 4*p_Np;
      const int id6 = base + 5*p_Np;


     
      // PML UPDATES
      dfloat qxi1 = qZx[id1];
      dfloat qxi2 = qZx[id2];
      dfloat qxi3 = qZx[id3];
      dfloat qxi4 = qZx[id4];
      dfloat qxi5 = qZx[id5];
      dfloat qxi6 = qZx[id6]; 
      //
      dfloat qyi1 = qZy[id1];
      dfloat qyi2 = qZy[id2];
      dfloat qyi3 = qZy[id3];
      dfloat qyi4 = qZy[id4];
      dfloat qyi5 = qZy[id5];
      dfloat qyi6 = qZy[id6]; 
      //
      dfloat nti1 = qZnt[id1];
      dfloat nti2 = qZnt[id2];
      dfloat nti3 = qZnt[id3];
      dfloat nti4 = qZnt[id4];
      dfloat nti5 = qZnt[id5];
      dfloat nti6 = qZnt[id6]; 

      // PML UPDATES
      dfloat qxe1 = qYx[id1];
      dfloat qxe2 = qYx[id2];
      dfloat qxe3 = qYx[id3];
      dfloat qxe4 = qYx[id4];
      dfloat qxe5 = qYx[id5];
      dfloat qxe6 = qYx[id6]; 
      //
      dfloat qye1 = qYy[id1];
      dfloat qye2 = qYy[id2];
      dfloat qye3 = qYy[id3];
      dfloat qye4 = qYy[id4];
      dfloat qye5 = qYy[id5];
      dfloat qye6 = qYy[id6]; 
      //
      dfloat nte1 = qYnt[id1];
      dfloat nte2 = qYnt[id2];
      dfloat nte3 = qYnt[id3];
      dfloat nte4 = qYnt[id4];
      dfloat nte5 = qYnt[id5];
      dfloat nte6 = qYnt[id6]; 

      // PML UPDATES
      dfloat qsx1 = qSx[id1];
      dfloat qsx2 = qSx[id2];
      dfloat qsx3 = qSx[id3];
      dfloat qsx4 = qSx[id4];
      dfloat qsx5 = qSx[id5];
      dfloat qsx6 = qSx[id6]; 
      // PML UPDATES
      dfloat qsy1 = qSy[id1];
      dfloat qsy2 = qSy[id2];
      dfloat qsy3 = qSy[id3];
      dfloat qsy4 = qSy[id4];
      dfloat qsy5 = qSy[id5];
      dfloat qsy6 = qSy[id6];  

      // PML UPDATES
      dfloat nts1 = qSnt[id1];
      dfloat nts2 = qSnt[id2];
      dfloat nts3 = qSnt[id3];
      dfloat nts4 = qSnt[id4];
      dfloat nts5 = qSnt[id5];
      dfloat nts6 = qSnt[id6]; 
      //

      // PML UPDATES
      dfloat qx1 =qsx1 + akk*dt*( qxe1 + qxi1);
      dfloat qx2 =qsx2 + akk*dt*( qxe2 + qxi2);
      dfloat qx3 =qsx3 + akk*dt*( qxe3 + qxi3);
      dfloat qx4 =qsx4 + akk*dt*( qxe4 + qxi4);
      dfloat qx5 =qsx5 + akk*dt*( qxe5 + qxi5);
      dfloat qx6 =qsx6 + akk*dt*( qxe6 + qxi6); 
       // PML UPDATES
      dfloat qy1 =qsy1 + akk*dt*( qye1 + qyi1);
      dfloat qy2 =qsy2 + akk*dt*( qye2 + qyi2);
      dfloat qy3 =qsy3 + akk*dt*( qye3 + qyi3);
      dfloat qy4 =qsy4 + akk*dt*( qye4 + qyi4);
      dfloat qy5 =qsy5 + akk*dt*( qye5 + qyi5);
      dfloat qy6 =qsy6 + akk*dt*( qye6 + qyi6); 

       // PML UPDATES
      pmlqx[id1] =qx1;
      pmlqx[id2] =qx2;
      pmlqx[id3] =qx3;
      pmlqx[id4] =qx4;
      pmlqx[id5] =qx5;
      pmlqx[id6] =qx6; 
       // PML UPDATES
      pmlqy[id1] =qy1;
      pmlqy[id2] =qy2;
      pmlqy[id3] =qy3;
      pmlqy[id4] =qy4;
      pmlqy[id5] =qy5;
      pmlqy[id6] =qy6; 
     //
       // PML UPDATES
      pmlNT[id1] =nts1 + akk*dt*( nte1 + nti1);
      pmlNT[id2] =nts2 + akk*dt*( nte2 + nti2);
      pmlNT[id3] =nts3 + akk*dt*( nte3 + nti3);
      pmlNT[id4] =nts4 + akk*dt*( nte4 + nti4);
      pmlNT[id5] =nts5 + akk*dt*( nte5 + nti5);
      pmlNT[id6] =nts6 + akk*dt*( nte6 + nti6); 
      

      //
      dfloat4 temp;

      temp.x =  p_q1bar                 + qx1 + qy1;
      temp.y =  ramp*p_q2bar            + qx2 + qy2;
      temp.z =  ramp*p_q3bar            + qx3 + qy3;
      temp.w =  ramp*ramp*p_q4bar       + qx4 + qy4;

      q[2*(n + element*p_Np)] = temp;

      temp.x =  ramp*ramp*p_q5bar       + qx5 + qy5;
      temp.y =  ramp*ramp*p_q6bar       + qx6 + qy6;
      temp.z =  0.0;
      temp.w =  0.0;

       q[2*(n + element*p_Np) +1] = temp;

    }
  }
}





// Perform an update like Y = Q + c_im*Res_IM + c_ex*Res_EX;
@kernel void boltzmannIMEXSplitPmlResidualUpdate2D(const int Nelements,
            @restrict const  int *  elementIds,
            const dfloat dt, 
            const dfloat c_im,
            const dfloat c_ex, 
            @restrict const  dfloat  *  pmlqx,
            @restrict const  dfloat  *  pmlqy,
            @restrict const  dfloat  *  pmlnt,
            @restrict const  dfloat  *  pmlZx,
            @restrict const  dfloat  *  pmlZy,
            @restrict const  dfloat  *  pmlZnt,
                  @restrict dfloat  *  pmlYx,
                  @restrict dfloat  *  pmlYy,
                  @restrict dfloat  *  pmlYnt
                   ){
  Low storage Runge Kutta time step update
  for(int e=0;e<Nelements;++e;@outer(0)){
    for(int n=0;n<p_Np;++n;@inner(0)){
      const int element = elementIds[e];

      //
      const int base = n + element*p_Nfields*p_Np;
      const int id1 = base + 0*p_Np;
      const int id2 = base + 1*p_Np;
      const int id3 = base + 2*p_Np;
      const int id4 = base + 3*p_Np;
      const int id5 = base + 4*p_Np;
      const int id6 = base + 5*p_Np;


      // PML UPDATES
      dfloat qx1 = pmlqx[id1];
      dfloat qx2 = pmlqx[id2];
      dfloat qx3 = pmlqx[id3];
      dfloat qx4 = pmlqx[id4];
      dfloat qx5 = pmlqx[id5];
      dfloat qx6 = pmlqx[id6]; 
      //
      dfloat qy1 = pmlqy[id1];
      dfloat qy2 = pmlqy[id2];
      dfloat qy3 = pmlqy[id3];
      dfloat qy4 = pmlqy[id4];
      dfloat qy5 = pmlqy[id5];
      dfloat qy6 = pmlqy[id6]; 
      //
      dfloat nt1 = pmlnt[id1];
      dfloat nt2 = pmlnt[id2];
      dfloat nt3 = pmlnt[id3];
      dfloat nt4 = pmlnt[id4];
      dfloat nt5 = pmlnt[id5];
      dfloat nt6 = pmlnt[id6]; 

      // PML UPDATES
      dfloat qxim1 = pmlZx[id1];
      dfloat qxim2 = pmlZx[id2];
      dfloat qxim3 = pmlZx[id3];
      dfloat qxim4 = pmlZx[id4];
      dfloat qxim5 = pmlZx[id5];
      dfloat qxim6 = pmlZx[id6]; 
      //
      dfloat qyim1 = pmlZy[id1];
      dfloat qyim2 = pmlZy[id2];
      dfloat qyim3 = pmlZy[id3];
      dfloat qyim4 = pmlZy[id4];
      dfloat qyim5 = pmlZy[id5];
      dfloat qyim6 = pmlZy[id6]; 
      //
      dfloat ntim1 = pmlZnt[id1];
      dfloat ntim2 = pmlZnt[id2];
      dfloat ntim3 = pmlZnt[id3];
      dfloat ntim4 = pmlZnt[id4];
      dfloat ntim5 = pmlZnt[id5];
      dfloat ntim6 = pmlZnt[id6]; 

      // PML UPDATES
      dfloat qxex1 = pmlYx[id1];
      dfloat qxex2 = pmlYx[id2];
      dfloat qxex3 = pmlYx[id3];
      dfloat qxex4 = pmlYx[id4];
      dfloat qxex5 = pmlYx[id5];
      dfloat qxex6 = pmlYx[id6]; 
      //
      dfloat qyex1 = pmlYy[id1];
      dfloat qyex2 = pmlYy[id2];
      dfloat qyex3 = pmlYy[id3];
      dfloat qyex4 = pmlYy[id4];
      dfloat qyex5 = pmlYy[id5];
      dfloat qyex6 = pmlYy[id6]; 
      //
      dfloat ntex1 = pmlYnt[id1];
      dfloat ntex2 = pmlYnt[id2];
      dfloat ntex3 = pmlYnt[id3];
      dfloat ntex4 = pmlYnt[id4];
      dfloat ntex5 = pmlYnt[id5];
      dfloat ntex6 = pmlYnt[id6]; 

      // PML UPDATES
      pmlYx[id1] = qx1 + c_ex*qxex1 + c_im*qxim1;
      pmlYx[id2] = qx2 + c_ex*qxex2 + c_im*qxim2;
      pmlYx[id3] = qx3 + c_ex*qxex3 + c_im*qxim3;
      pmlYx[id4] = qx4 + c_ex*qxex4 + c_im*qxim4;
      pmlYx[id5] = qx5 + c_ex*qxex5 + c_im*qxim5;
      pmlYx[id6] = qx6 + c_ex*qxex6 + c_im*qxim6; 
      //
      pmlYy[id1] = qy1 + c_ex*qyex1 + c_im*qyim1;
      pmlYy[id2] = qy2 + c_ex*qyex2 + c_im*qyim2;
      pmlYy[id3] = qy3 + c_ex*qyex3 + c_im*qyim3;
      pmlYy[id4] = qy4 + c_ex*qyex4 + c_im*qyim4;
      pmlYy[id5] = qy5 + c_ex*qyex5 + c_im*qyim5;
      pmlYy[id6] = qy6 + c_ex*qyex6 + c_im*qyim6; 

      pmlYnt[id1] = nt1 + c_ex*ntex1 + c_im*ntim1;
      pmlYnt[id2] = nt2 + c_ex*ntex2 + c_im*ntim2;
      pmlYnt[id3] = nt3 + c_ex*ntex3 + c_im*ntim3;
      pmlYnt[id4] = nt4 + c_ex*ntex4 + c_im*ntim4;
      pmlYnt[id5] = nt5 + c_ex*ntex5 + c_im*ntim5;
      pmlYnt[id6] = nt6 + c_ex*ntex6 + c_im*ntim6; 


    }
  }
}