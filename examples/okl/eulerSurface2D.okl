
void upwind1D(const dfloat nx, const dfloat ny,
              const dfloat RM, const dfloat UM, const dfloat VM,
	      const dfloat RP, const dfloat UP, const dfloat VP,
              @restrict dfloat * @restrict RS, dfloat * @restrict US, dfloat *  VS){


  const dfloat RA = 0.5f*(RM+RP);
  const dfloat UA = 0.5f*(UM+UP);
  const dfloat VA = 0.5f*(VM+VP);

  const dfloat udotn = (UA*nx+VA*ny)/RA;
  const dfloat udott = (UA*ny-VA*nx)/RA;
  
  const dfloat W1 = udotn + p_sqrtRT;
  const dfloat W2 = udotn - p_sqrtRT;
  const dfloat W3 = udotn;
  
  // characteristic variables for wave speeds W1, W2, W3 on negative trace
  dfloat C1M = (0.5f*p_isqrtRT)*(-(udotn-p_sqrtRT)*RM+(+nx)*UM+(+ny)*VM);
  dfloat C2M = (0.5f*p_isqrtRT)*(+(udotn+p_sqrtRT)*RM+(-nx)*UM+(-ny)*VM);
  dfloat C3M = (udott)*RM+(-ny)*UM+(+nx)*VM;

  // characteristic variables for wave speeds W1, W2, W3 on positive trace
  dfloat C1P = (0.5f*p_isqrtRT)*(-(udotn-p_sqrtRT)*RP+(+nx)*UP+(+ny)*VP);
  dfloat C2P = (0.5f*p_isqrtRT)*(+(udotn+p_sqrtRT)*RP+(-nx)*UP+(-ny)*VP);
  dfloat C3P = (udott)*RP+(-ny)*UP+(+nx)*VP;

  // choose characteristics based on wave speed (may need to reverse)
  const dfloat C1U = (W1>0) ? C1M:C1P;
  const dfloat C2U = (W2>0) ? C2M:C2P;
  const dfloat C3U = (W3>0) ? C3M:C3P;
  
  *RS =                     C1U +                    C2U + (0.f)*C3U;
  *US = (UA/RA+p_sqrtRT*nx)*C1U +(UA/RA-p_sqrtRT*nx)*C2U + (-ny)*C3U;
  *VS = (VA/RA+p_sqrtRT*ny)*C1U +(VA/RA-p_sqrtRT*ny)*C2U + (+nx)*C3U;

}


void boundaryConditions2D(const int bc,
			  const dfloat t, 
			  const dfloat x,  const dfloat y, 
			  const dfloat nx, const dfloat ny,
			  const dfloat RM,  const dfloat UM, const dfloat VM,
			  @restrict dfloat * @restrict RB, dfloat * @restrict UB, dfloat *  VB){

  *RB = RM;
  *UB = -UM;
  *VB = -VM;

  //  printf("nx=%g,%g at x=%g,%g\n", nx, ny, x, y);
  
#if 0
  if(bc==1){
    *RB = RM;
    *UB = -UM;
    *VB = -VM;
  }
  if(bc>1){ // wall for non-mean flow
    *RB = 2.f*p_Rbar - RM;
    *UB = 2.f*p_Ubar - UM;
    *VB = 2.f*p_Vbar - VM; 
  }
#endif
}

#define p_half 0.5f

void laxFriedrichsFlux2D(const dfloat nx, const dfloat ny,
			 const dfloat RM, const dfloat UM, const dfloat VM,
			 const dfloat RP, const dfloat UP, const dfloat VP,
			 @restrict dfloat *  fluxR,
			 @restrict dfloat *  fluxU,
			 @restrict dfloat *  fluxV){

  const dfloat lambda = occaMax(fabs(UM*nx+VM*ny)/RM+p_RT,fabs(UP*nx+VP*ny)/RP+p_RT);

  const dfloat fxRM = -nx*UM-ny*VM;
  const dfloat fxUM = -nx*(UM*UM/RM+p_RT*RM)-ny*UM*VM/RM;
  const dfloat fxVM = -nx*UM*VM/RM - ny*(VM*VM/RM+p_RT*RM);

  const dfloat fxRP = -nx*UP-ny*VP;
  const dfloat fxUP = -nx*(UP*UP/RP+p_RT*RP)-ny*UP*VP/RP;
  const dfloat fxVP = -nx*UP*VP/RP - ny*(VP*VP/RP+p_RT*RP);

  *fluxR = p_half*(fxRM+fxRP+lambda*(RP-RM));
  *fluxU = p_half*(fxUM+fxUP+lambda*(UP-UM));
  *fluxV = p_half*(fxVM+fxVP+lambda*(VP-VM));

}
  

// batch process elements
// assume that the derivatives are on the test function
@kernel void eulerSurface2D(const int Nelements,
			   @restrict const  dfloat *  sgeo,
			   @restrict const  dfloat *  intInterpT, // interpolate to integration nodes
			   @restrict const  dfloat *  intLIFTT, // lift from integration to interpolation nodes
			   @restrict const  int   *  vmapM,
			   @restrict const  int   *  vmapP,
			   @restrict const  int   *  EToB,
			   const dfloat time,
			   @restrict const  dfloat *  intx, // integration nodes
			   @restrict const  dfloat *  inty,
			   @restrict const  dfloat4 *  q,
			   @restrict dfloat4 *  rhsq){
  
  // for all elements
  for(int eo=0;eo<Nelements;eo+=p_NblockS;@outer(0)){

    // @shared storage for flux terms
    @shared dfloat s_RM[p_NblockS][p_NfacesNfp];
    @shared dfloat s_UM[p_NblockS][p_NfacesNfp];
    @shared dfloat s_VM[p_NblockS][p_NfacesNfp];
    @shared dfloat s_RP[p_NblockS][p_NfacesNfp];
    @shared dfloat s_UP[p_NblockS][p_NfacesNfp];
    @shared dfloat s_VP[p_NblockS][p_NfacesNfp];
    @shared dfloat s_iRflux[p_NblockS][p_intNfpNfaces];
    @shared dfloat s_iUflux[p_NblockS][p_intNfpNfaces];
    @shared dfloat s_iVflux[p_NblockS][p_intNfpNfaces];

    
    // for all face nodes of all elements
    for(int es=0;es<p_NblockS;++es;@inner(1)){
      for(int n=0;n<p_maxSurfaceNodes;++n;@inner(0)){

	int e = eo + es;

	if(e<Nelements){
	  if(n<(p_Nfaces*p_Nfp)){
	    // indices of negative and positive traces of face node
	    const int id  = e*p_Nfp*p_Nfaces + n;

	    int idM = vmapM[id];
	    int idP = vmapP[id];

	    if(idP<0) idP = idM;
    
	    // load negative and positive trace node values of q
	    const dfloat4 qM = q[idM];
	    const dfloat4 qP = q[idP];
	    
	    dfloat RM = qM.x, UM = qM.y, VM = qM.z;
	    dfloat RP = qP.x, UP = qP.y, VP = qP.z;

	    s_RM[es][n] = RM;
	    s_UM[es][n] = UM;
	    s_VM[es][n] = VM;
	    
	    s_RP[es][n] = RP;
	    s_UP[es][n] = UP;
	    s_VP[es][n] = VP;
	  }
	}
      }
    }

    @barrier("local");

    // interpolate to surface integration nodes
    for(int es=0;es<p_NblockS;++es;@inner(1)){
      for(int n=0;n<p_maxSurfaceNodes;++n;@inner(0)){ 
	int e = eo + es;
	if(e<Nelements){
	  if(n<(p_Nfaces*p_intNfp)){

	    const int face = n/p_intNfp; // find face that owns this integration node
	  
	    // load surface geofactors for this face
	    const int sid = p_Nsgeo*(e*p_Nfaces+face);
	    const dfloat nx = sgeo[sid+0];
	    const dfloat ny = sgeo[sid+1];
	    const dfloat sJ = sgeo[sid+2];
	    const dfloat invJ = sgeo[sid+3];

	    dfloat iRM = 0.f, iUM = 0.f, iVM = 0.f;
	    dfloat iRP = 0.f, iUP = 0.f, iVP = 0.f;

	    // local block interpolation (face nodes to integration nodes)
	    // [ exact to here ]
	    for(int m=0;m<p_Nfp;++m){
	      const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
	      const int fm = face*p_Nfp+m;
	      iRM += iInm*s_RM[es][fm];
	      iUM += iInm*s_UM[es][fm];
	      iVM += iInm*s_VM[es][fm];

	      iRP += iInm*s_RP[es][fm];
	      iUP += iInm*s_UP[es][fm];
	      iVP += iInm*s_VP[es][fm];
	    }


	    // apply boundary condition
	    // [ exact to here ]
	    int bc = EToB[face+p_Nfaces*e];

	    if(bc>0){
	      boundaryConditions2D(bc, time, 
				   intx[n+e*p_Nfaces*p_intNfp], 
				   inty[n+e*p_Nfaces*p_intNfp], 
				   nx, ny,
				   iRM, iUM, iVM,
				   &iRP, &iUP, &iVP);
	    }

#if 1
	    // compute (q^*)
	    dfloat iRS, iUS, iVS;
	    upwind1D(nx, ny,
		     iRM, iUM, iVM, 
		     iRP, iUP, iVP, 
		     &iRS, &iUS, &iVS);

	    // evaluate "flux" terms: (sJ/J)*(A*nx+B*ny)*(q^*) at integration nodes
	    const dfloat sc = invJ*sJ;
	    
	    s_iRflux[es][n] = -sc*(nx*iUS+ny*iVS);
	    s_iUflux[es][n] = -sc*(nx*(iUS*iUS/iRS + iRS*p_RT)+ny*(iUS*iVS/iRS));
	    s_iVflux[es][n] = -sc*(nx*(iUS*iVS/iRS)+ny*(iVS*iVS/iRS + iRS*p_RT));
#else
	    dfloat fxR, fxU, fxV;
	    laxFriedrichsFlux2D(nx,ny,
				iRM, iUM, iVM,
				iRP, iUP, iVP,
				&fxR, &fxU, &fxV);

	    const dfloat sc = invJ*sJ;
	    s_iRflux[es][n] = sc*fxR;
	    s_iUflux[es][n] = sc*fxU;
	    s_iVflux[es][n] = sc*fxV;
#endif
	  }
	}
      }
    }
    
    // wait for all @shared memory writes of the previous inner loop to complete
    @barrier("local");

    // lift from surface integration to volume nodes
    for(int es=0;es<p_NblockS;++es;@inner(1)){
      for(int n=0;n<p_maxSurfaceNodes;++n;@inner(0)){
	const int e = eo + es;
	if(e<Nelements){
	  if(n<p_Np){
	    // prefetch volume rhs
	    dfloat4 rhsqn = rhsq[n+p_Np*e];
	    
	    dfloat rhsR = 0.f, rhsU = 0.f, rhsV = 0.f;
	    for(int m=0;m<p_intNfpNfaces;++m){
	      // RefMassMatrix^{-1}*cInterp^t*cWeight
#if 1
	      const dfloat L = intLIFTT[n+m*p_Np];
#else
	      const dfloat L = intLIFTT[n*p_Nfaces*p_intNfp+m];
#endif
	      double foo = s_iUflux[es][m];
	      
	      rhsR += L*s_iRflux[es][m];
	      rhsU += L*s_iUflux[es][m];
	      rhsV += L*s_iVflux[es][m];	      
	    }
	    
	    // increment volume RHS
	    rhsqn.x += rhsR;
	    rhsqn.y += rhsU;
	    rhsqn.z += rhsV;

	    rhsq[n+p_Np*e] = rhsqn;

	  }
	}
      }
    }

    
    
    
  }
}

