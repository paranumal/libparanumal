// surface @kernel, play with different implementations
// Base implementation


@kernel void insSubCycleCubatureSurface2D_v0(
					    int Nelements,
					    dfloat * sgeo,
					    dfloat * intInterpT, // interpolate to integration nodes
					    dfloat * intLIFTT, // lift from integration to interpolation nodes
					    int   * vmapM,
					    int   * vmapP,
					    int   * EToB,
					    dfloat time,
					    dfloat * intx, // integration nodes
					    dfloat * inty,
					    dfloat * U,
					    dfloat * V,
					    dfloat * Ud,
					    dfloat * Vd,
					    dfloat * rhsU,
					    dfloat * rhsV){
  // for all elements
  for(int e=0;e<Nelements;++e;@outer(0)){

    @shared dfloat s_iFluxU[p_intNfpNfaces];
    @shared dfloat s_iFluxV[p_intNfpNfaces];

    for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 

      if(e<Nelements){
        if(n<(p_Nfaces*p_intNfp)){

          int face = n/p_intNfp; // find face that owns this integration node

          // load surface geofactors for this face
          int sid    = p_Nsgeo*(e*p_Nfaces+face);
          dfloat nx   = sgeo[sid+p_NXID];
          dfloat ny   = sgeo[sid+p_NYID];
          dfloat sJ   = sgeo[sid+p_SJID];
          dfloat invJ = sgeo[sid+p_IJID];

          dfloat iUM  = 0.f, iVM  = 0.f;
          dfloat iUP  = 0.f, iVP  = 0.f;
          dfloat iUdM = 0.f, iVdM = 0.f;
          dfloat iUdP = 0.f, iVdP = 0.f;

          // local block interpolation (face nodes to integration nodes)
          //#pragma unroll p_Nfp
	  for(int m=0;m<p_Nfp;++m){
	    dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];

	    int id  = e*p_Nfp*p_Nfaces + face*p_Nfp + m;
	    int idM = vmapM[id];
	    int idP = vmapP[id];
	    //
	    iUM  += iInm*U[idM];
	    iVM  += iInm*V[idM];
	    iUdM += iInm*Ud[idM];
	    iVdM += iInm*Vd[idM];

	    iUP  += iInm*U[idP];
	    iVP  += iInm*V[idP];
	    iUdP += iInm*Ud[idP];
	    iVdP += iInm*Vd[idP];
	  }

          // apply boundary conditions
          int bc = EToB[face+p_Nfaces*e];

          if(bc>0){
            insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, iUdM,iVdM, &iUdP, &iVdP);
          }


          // Find max normal velocity on the face
          dfloat unm   = fabs(nx*iUM + ny*iVM);
          dfloat unp   = fabs(nx*iUP + ny*iVP);    
          dfloat unmax = (unm > unp) ? unm : unp;

          // evaluate "flux" terms: LLF
          dfloat sc = invJ * sJ ;

          s_iFluxU[n] = sc*(.5f*(nx*(iUP*iUdP + iUM*iUdM) 
				 +ny*(iVP*iUdP + iVM*iUdM) 
				 +unmax*(iUdM-iUdP) ));

          s_iFluxV[n] = sc*(.5f*(nx*(iUP*iVdP + iUM*iVdM) 
				 + ny*(iVP*iVdP + iVM*iVdM) 
				 + unmax*(iVdM-iVdP) ));
        }
      }
    }

    @barrier("local");

    // lift from surface integration to volume nodes
    for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
      if(e<Nelements){
        if(n<p_Np){
          int id = n + p_Np*e;
          // prefetch volume rhs
          dfloat rhsu = rhsU[id];
          dfloat rhsv = rhsV[id];

          //#pragma unroll p_intNfpNfaces
          for(int m=0;m<p_intNfpNfaces;++m){
	    // RefMassMatrix^{-1}*cInterp^t*cWeight
            dfloat L = intLIFTT[n+m*p_Np];

            rhsu += L*s_iFluxU[m];
            rhsv += L*s_iFluxV[m];
          }

          rhsU[id] = rhsu;  // 
          rhsV[id] = rhsv;  //  
        }
      }
    }
  }
}




// Add @shared memory for global read
@kernel void insSubCycleCubatureSurface2D_v1(
					    int Nelements,
					    dfloat * sgeo,
					    dfloat * intInterpT, // interpolate to integration nodes
					    dfloat * intLIFTT, // lift from integration to interpolation nodes
					    int   * vmapM,
					    int   * vmapP,
					    int   * EToB,
					    dfloat time,
					    dfloat * intx, // integration nodes
					    dfloat * inty,
					    dfloat * U,
					    dfloat * V,
					    dfloat * Ud,
					    dfloat * Vd,
					    dfloat * rhsU,
					    dfloat * rhsV){
  // for all elements
  for(int e=0;e<Nelements;++e;@outer(0)){

    // @shared storage for flux terms
    @shared dfloat s_UM[p_NfacesNfp];
    @shared dfloat s_VM[p_NfacesNfp];
    @shared dfloat s_UP[p_NfacesNfp];
    @shared dfloat s_VP[p_NfacesNfp];

    @shared dfloat s_UdM[p_NfacesNfp];
    @shared dfloat s_VdM[p_NfacesNfp];
    @shared dfloat s_UdP[p_NfacesNfp];
    @shared dfloat s_VdP[p_NfacesNfp];

    @shared dfloat s_iFluxU[p_intNfpNfaces];
    @shared dfloat s_iFluxV[p_intNfpNfaces];


    for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
      if(e<Nelements){
        if(n<(p_Nfaces*p_Nfp)){
          // indices of negative and positive traces of face node
          int id  = e*p_Nfp*p_Nfaces + n;

          int idM = vmapM[id];
          int idP = vmapP[id];

          if(idP<0) idP = idM;
	  // load negative and positive trace node values of velocity
	  s_UM[n] = U[idM];
	  s_VM[n] = V[idM];
	  s_UP[n] = U[idP];
	  s_VP[n] = V[idP];

	  s_UdM[n] = Ud[idM];
	  s_VdM[n] = Vd[idM];
	  s_UdP[n] = Ud[idP];
	  s_VdP[n] = Vd[idP];

	}
      }
    }

    @barrier("local");

  
    for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 

      if(e<Nelements){
	if(n<(p_Nfaces*p_intNfp)){

	  int face = n/p_intNfp; // find face that owns this integration node

	  // load surface geofactors for this face
	  int sid    = p_Nsgeo*(e*p_Nfaces+face);
	  dfloat nx   = sgeo[sid+p_NXID];
	  dfloat ny   = sgeo[sid+p_NYID];
	  dfloat sJ   = sgeo[sid+p_SJID];
	  dfloat invJ = sgeo[sid+p_IJID];

	  dfloat iUM  = 0.f, iVM  = 0.f;
	  dfloat iUP  = 0.f, iVP  = 0.f;
	  dfloat iUdM = 0.f, iVdM = 0.f;
	  dfloat iUdP = 0.f, iVdP = 0.f;

	  // local block interpolation (face nodes to integration nodes)
	  //#pragma unroll p_Nfp
	  for(int m=0;m<p_Nfp;++m){
	    dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
	    int fm = face*p_Nfp+m;

	    iUM  += iInm*s_UM[fm];
	    iVM  += iInm*s_VM[fm];
	    iUdM += iInm*s_UdM[fm];
	    iVdM += iInm*s_VdM[fm];

	    iUP  += iInm*s_UP[fm];
	    iVP  += iInm*s_VP[fm];
	    iUdP += iInm*s_UdP[fm];
	    iVdP += iInm*s_VdP[fm];
	  }

	  // apply boundary conditions
	  int bc = EToB[face+p_Nfaces*e];

	  if(bc>0){
	    insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, iUdM,iVdM, &iUdP, &iVdP);
	  }


	  // Find max normal velocity on the face
	  dfloat unm   = fabs(nx*iUM + ny*iVM);
	  dfloat unp   = fabs(nx*iUP + ny*iVP);    
	  dfloat unmax = (unm > unp) ? unm : unp;

	  // evaluate "flux" terms: LLF
	  dfloat sc = invJ * sJ ;

	  s_iFluxU[n] = sc*(.5f*(nx*(iUP*iUdP + iUM*iUdM) 
				 +ny*(iVP*iUdP + iVM*iUdM) 
				 +unmax*(iUdM-iUdP) ));

	  s_iFluxV[n] = sc*(.5f*(nx*(iUP*iVdP + iUM*iVdM) 
				 + ny*(iVP*iVdP + iVM*iVdM) 
				 + unmax*(iVdM-iVdP) ));
	}
      }
    }

    @barrier("local");

    // lift from surface integration to volume nodes
    for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
      if(e<Nelements){
	if(n<p_Np){
	  int id = n + p_Np*e;
	  // prefetch volume rhs
	  dfloat rhsu = 0.f;
	  dfloat rhsv = 0.f;

	  //#pragma unroll p_intNfpNfaces
	  for(int m=0;m<p_intNfpNfaces;++m){
            // RefMassMatrix^{-1}*cInterp^t*cWeight
	    dfloat L = intLIFTT[n+m*p_Np];

	    rhsu += L*s_iFluxU[m];
	    rhsv += L*s_iFluxV[m];
	  }

	  rhsU[id] = rhsu;  // 
	  rhsV[id] = rhsv;  //  
	}
      }
    }
  }
}



// Add const and loop unrolling
@kernel void insSubCycleCubatureSurface2D_v2(
					    const int Nelements,
					    @restrict const  dfloat *  sgeo,
					    @restrict const  dfloat *  intInterpT, // interpolate to integration nodes
					    @restrict const  dfloat *  intLIFTT, // lift from integration to interpolation nodes
					    @restrict const  int   *  vmapM,
					    @restrict const  int   *  vmapP,
					    @restrict const  int   *  EToB,
					    const dfloat time,
					    @restrict const  dfloat *  intx, // integration nodes
					    @restrict const  dfloat *  inty,
					    @restrict const  dfloat *  U,
					    @restrict const  dfloat *  V,
					    @restrict const  dfloat *  Ud,
					    @restrict const  dfloat *  Vd,
					    @restrict dfloat *  rhsU,
					    @restrict dfloat *  rhsV){
  // for all elements
  for(int e=0;e<Nelements;++e;@outer(0)){

    // @shared storage for flux terms
    @shared dfloat s_UM[p_NfacesNfp];
    @shared dfloat s_VM[p_NfacesNfp];
    @shared dfloat s_UP[p_NfacesNfp];
    @shared dfloat s_VP[p_NfacesNfp];

    @shared dfloat s_UdM[p_NfacesNfp];
    @shared dfloat s_VdM[p_NfacesNfp];
    @shared dfloat s_UdP[p_NfacesNfp];
    @shared dfloat s_VdP[p_NfacesNfp];

    @shared dfloat s_iFluxU[p_intNfpNfaces];
    @shared dfloat s_iFluxV[p_intNfpNfaces];

    //
    for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
      if(e<Nelements){
        if(n<(p_Nfaces*p_Nfp)){
          // indices of negative and positive traces of face node
          const int id  = e*p_Nfp*p_Nfaces + n;

          const int idM = vmapM[id];
                int idP = vmapP[id];

          if(idP<0) idP = idM;
		  // load negative and positive trace node values of velocity
		  s_UM[n] = U[idM];
		  s_VM[n] = V[idM];
		  s_UP[n] = U[idP];
		  s_VP[n] = V[idP];

		  s_UdM[n] = Ud[idM];
		  s_VdM[n] = Vd[idM];
		  s_UdP[n] = Ud[idP];
		  s_VdP[n] = Vd[idP];

	}
      }
    }

    @barrier("local");

  
    for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 

      if(e<Nelements){
	if(n<(p_Nfaces*p_intNfp)){

	  const int face = n/p_intNfp; // find face that owns this integration node

	  // load surface geofactors for this face
	  const int sid    = p_Nsgeo*(e*p_Nfaces+face);
	  const dfloat nx   = sgeo[sid+p_NXID];
	  const dfloat ny   = sgeo[sid+p_NYID];
	  const dfloat sJ   = sgeo[sid+p_SJID];
	  const dfloat invJ = sgeo[sid+p_IJID];

	  dfloat iUM  = 0.f, iVM  = 0.f;
	  dfloat iUP  = 0.f, iVP  = 0.f;
	  dfloat iUdM = 0.f, iVdM = 0.f;
	  dfloat iUdP = 0.f, iVdP = 0.f;

	  // local block interpolation (face nodes to integration nodes)
	  #pragma unroll p_Nfp
	    for(int m=0;m<p_Nfp;++m){
	      const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
	      const int fm = face*p_Nfp+m;

	      iUM  += iInm*s_UM[fm];
	      iVM  += iInm*s_VM[fm];
	      iUdM += iInm*s_UdM[fm];
	      iVdM += iInm*s_VdM[fm];

	      iUP  += iInm*s_UP[fm];
	      iVP  += iInm*s_VP[fm];
	      iUdP += iInm*s_UdP[fm];
	      iVdP += iInm*s_VdP[fm];
	    }

	  // apply boundary conditions
	  const int bc = EToB[face+p_Nfaces*e];

	  if(bc>0){
	    insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, iUdM,iVdM, &iUdP, &iVdP);
	  }


	  // Find max normal velocity on the face
	  const dfloat unm   = fabs(nx*iUM + ny*iVM);
	  const dfloat unp   = fabs(nx*iUP + ny*iVP);    
	  const dfloat unmax = (unm > unp) ? unm : unp;

	  // evaluate "flux" terms: LLF
	  const dfloat sc = invJ * sJ ;

	  s_iFluxU[n] = sc*(.5f*(nx*(iUP*iUdP + iUM*iUdM) 
				 +ny*(iVP*iUdP + iVM*iUdM) 
				 +unmax*(iUdM-iUdP) ));

	  s_iFluxV[n] = sc*(.5f*(nx*(iUP*iVdP + iUM*iVdM) 
				 + ny*(iVP*iVdP + iVM*iVdM) 
				 + unmax*(iVdM-iVdP) ));
	}
      }
    }

    @barrier("local");

    // lift from surface integration to volume nodes
    for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
      if(e<Nelements){
	if(n<p_Np){
	  const int id = n + p_Np*e;
	  // prefetch volume rhs
	  dfloat rhsu = 0.f;
	  dfloat rhsv = 0.f;

	  #pragma unroll p_intNfpNfaces
            for(int m=0;m<p_intNfpNfaces;++m){
	      // RefMassMatrix^{-1}*cInterp^t*cWeight
              const dfloat L = intLIFTT[n+m*p_Np];

              rhsu += L*s_iFluxU[m];
              rhsv += L*s_iFluxV[m];
            }

	  rhsU[id] += rhsu;  // 
	  rhsV[id] += rhsv;  //  
	}
      }
    }
  }
}






// Optimized sizes for @kernel 3
#if p_N==1
#define p_cubNblockS 14
#endif

#if p_N==2
#define p_cubNblockS 8
#endif

#if p_N==3
#define p_cubNblockS 7
#endif

#if p_N==4
#define p_cubNblockS 6
#endif

#if p_N==5
#define p_cubNblockS 6
#endif

#if p_N==6
#define p_cubNblockS 7
#endif

#if p_N==7
#define p_cubNblockS 7
#endif

#if p_N==8
#define p_cubNblockS 6
#endif

#if p_N==9
#define p_cubNblockS 4
#endif

#if p_N==10
#define p_cubNblockS 5
#endif





// Add multiple element per threadblock 
@kernel void insSubCycleCubatureSurface2D_v3(const int Nelements,
					    @restrict const  dfloat *  sgeo,
					    @restrict const  dfloat *  intInterpT, // interpolate to integration nodes
					    @restrict const  dfloat *  intLIFTT, // lift from integration to interpolation nodes
					    @restrict const  int   *  vmapM,
					    @restrict const  int   *  vmapP,
					    @restrict const  int   *  EToB,
					    const dfloat time,
					    @restrict const  dfloat *  intx, // integration nodes
					    @restrict const  dfloat *  inty,
					    @restrict const  dfloat *  U,
					    @restrict const  dfloat *  V,
					    @restrict const  dfloat *  Ud,
					    @restrict const  dfloat *  Vd,
					    @restrict dfloat *  rhsU,
					    @restrict dfloat *  rhsV){
  // for all elements
  for(int eo=0;eo<Nelements;eo+=p_cubNblockS;@outer(0)){

    // @shared storage for flux terms
    @shared dfloat s_UM[p_cubNblockS][p_NfacesNfp];
    @shared dfloat s_VM[p_cubNblockS][p_NfacesNfp];
    @shared dfloat s_UP[p_cubNblockS][p_NfacesNfp];
    @shared dfloat s_VP[p_cubNblockS][p_NfacesNfp];

    @shared dfloat s_UdM[p_cubNblockS][p_NfacesNfp];
    @shared dfloat s_VdM[p_cubNblockS][p_NfacesNfp];
    @shared dfloat s_UdP[p_cubNblockS][p_NfacesNfp];
    @shared dfloat s_VdP[p_cubNblockS][p_NfacesNfp];

    @shared dfloat s_iFluxU[p_cubNblockS][p_intNfpNfaces];
    @shared dfloat s_iFluxV[p_cubNblockS][p_intNfpNfaces];

    // for all face nodes of all elements
    for(int es=0;es<p_cubNblockS;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){

	int e = eo + es;

	if(e<Nelements){
	  if(n<(p_Nfaces*p_Nfp)){
	    // indices of negative and positive traces of face node
	    const int id  = e*p_Nfp*p_Nfaces + n;

	    int idM = vmapM[id];
	    int idP = vmapP[id];

	    if(idP<0) idP = idM;
	    // load negative and positive trace node values of velocity
	    s_UM[es][n] = U[idM];
	    s_VM[es][n] = V[idM];
	    s_UP[es][n] = U[idP];
	    s_VP[es][n] = V[idP];

	    s_UdM[es][n] = Ud[idM];
	    s_VdM[es][n] = Vd[idM];
	    s_UdP[es][n] = Ud[idP];
	    s_VdP[es][n] = Vd[idP];

	  }
	}
      }
    }

    @barrier("local");

    // interpolate to surface integration nodes
    for(int es=0;es<p_cubNblockS;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 

	int e = eo + es;

	if(e<Nelements){
	  if(n<(p_Nfaces*p_intNfp)){

	    const int face = n/p_intNfp; // find face that owns this integration node

	    // load surface geofactors for this face
	    const int sid    = p_Nsgeo*(e*p_Nfaces+face);
	    const dfloat nx   = sgeo[sid+p_NXID];
	    const dfloat ny   = sgeo[sid+p_NYID];
	    const dfloat sJ   = sgeo[sid+p_SJID];
	    const dfloat invJ = sgeo[sid+p_IJID];

	    dfloat iUM  = 0.f, iVM  = 0.f;
	    dfloat iUP  = 0.f, iVP  = 0.f;
	    dfloat iUdM = 0.f, iVdM = 0.f;
	    dfloat iUdP = 0.f, iVdP = 0.f;

	    // local block interpolation (face nodes to integration nodes)
	    #pragma unroll p_Nfp
	      for(int m=0;m<p_Nfp;++m){
		const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
		const int fm = face*p_Nfp+m;

		iUM  += iInm*s_UM[es][fm];
		iVM  += iInm*s_VM[es][fm];
		iUdM += iInm*s_UdM[es][fm];
		iVdM += iInm*s_VdM[es][fm];

		iUP  += iInm*s_UP[es][fm];
		iVP  += iInm*s_VP[es][fm];
		iUdP += iInm*s_UdP[es][fm];
		iVdP += iInm*s_VdP[es][fm];
	      }

	    // apply boundary conditions
	    int bc = EToB[face+p_Nfaces*e];

	    if(bc>0){
	      insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, iUdM,iVdM, &iUdP, &iVdP);
	    }


	    // Find max normal velocity on the face
	    dfloat unm   = fabs(nx*iUM + ny*iVM);
	    dfloat unp   = fabs(nx*iUP + ny*iVP);    
	    dfloat unmax = (unm > unp) ? unm : unp;

	    // evaluate "flux" terms: LLF
	    const dfloat sc = invJ * sJ ;

	    s_iFluxU[es][n] = sc*(.5f*(nx*(iUP*iUdP + iUM*iUdM) 
				       +ny*(iVP*iUdP + iVM*iUdM) 
				       +unmax*(iUdM-iUdP) ));

	    s_iFluxV[es][n] = sc*(.5f*(nx*(iUP*iVdP + iUM*iVdM) 
				       + ny*(iVP*iVdP + iVM*iVdM) 
				       + unmax*(iVdM-iVdP) ));
	  }
	}
      }
    }

    @barrier("local");

    // lift from surface integration to volume nodes
    for(int es=0;es<p_cubNblockS;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){

        const int e = eo + es;

        if(e<Nelements){
          if(n<p_Np){
            int id = n + p_Np*e;
            // prefetch volume rhs
            dfloat rhsu = rhsU[id];
            dfloat rhsv = rhsV[id];

            #pragma unroll p_intNfpNfaces
	      for(int m=0;m<p_intNfpNfaces;++m){
		// RefMassMatrix^{-1}*cInterp^t*cWeight
		const dfloat L = intLIFTT[n+m*p_Np];

		rhsu += L*s_iFluxU[es][m];
		rhsv += L*s_iFluxV[es][m];
	      }

            rhsU[id] = rhsu;  // 
            rhsV[id] = rhsv;  //  
          }
        }
      }
    }
  }

}


// Optimized sizes for @kernel 5
#if p_N==1
#define p_NblockS2 10
#define p_NnodesS2 2
#endif

#if p_N==2
#define p_NblockS2 8
#define p_NnodesS2 1
#endif

#if p_N==3
#define p_NblockS2 4
#define p_NnodesS2 2
#endif

#if p_N==4
#define p_NblockS2 3
#define p_NnodesS2 2
#endif

#if p_N==5
#define p_NblockS2 7
#define p_NnodesS2 2
#endif

#if p_N==6
#define p_NblockS2 2
#define p_NnodesS2 2
#endif

#if p_N==7
#define p_NblockS2 3
#define p_NnodesS2 2
#endif

#if p_N==8
#define p_NblockS2 2
#define p_NnodesS2 3
#endif

#if p_N==9
#define p_NblockS2 2
#define p_NnodesS2 3
#endif

#if p_N==10
#define p_NblockS2 3
#define p_NnodesS2 3
#endif



// Add multiple nodes to @kernel 3

@kernel void insSubCycleCubatureSurface2D_v4(const int Nelements,
              @restrict const  dfloat *  sgeo,
              @restrict const  dfloat *  intInterpT, // interpolate to integration nodes
              @restrict const  dfloat *  intLIFTT, // lift from integration to interpolation nodes
              @restrict const  int   *  vmapM,
              @restrict const  int   *  vmapP,
              @restrict const  int   *  EToB,
              const dfloat time,
              @restrict const  dfloat *  intx, // integration nodes
              @restrict const  dfloat *  inty,
              @restrict const  dfloat *  U,
              @restrict const  dfloat *  V,
              @restrict const  dfloat *  Ud,
              @restrict const  dfloat *  Vd,
              @restrict dfloat *  rhsU,
              @restrict dfloat *  rhsV){
  // for all elements
  for(int eo=0;eo<Nelements;eo+=(p_NblockS2*p_NnodesS2);@outer(0)){

    // @shared storage for flux terms
    @shared dfloat s_UM[p_NnodesS2][p_NblockS2][p_intNfpNfaces];
    @shared dfloat s_VM[p_NnodesS2][p_NblockS2][p_intNfpNfaces];
    @shared dfloat s_UP[p_NnodesS2][p_NblockS2][p_NfacesNfp];
    @shared dfloat s_VP[p_NnodesS2][p_NblockS2][p_NfacesNfp];

    @shared dfloat s_UdM[p_NnodesS2][p_NblockS2][p_NfacesNfp];
    @shared dfloat s_VdM[p_NnodesS2][p_NblockS2][p_NfacesNfp];
    @shared dfloat s_UdP[p_NnodesS2][p_NblockS2][p_NfacesNfp];
    @shared dfloat s_VdP[p_NnodesS2][p_NblockS2][p_NfacesNfp];

    #define s_iFluxU s_UM // Reuse @shared memory arrays
    #define s_iFluxV s_VM

    // @shared dfloat s_iFluxU[p_NnodesS2][p_NblockS2][p_intNfpNfaces];
    // @shared dfloat s_iFluxV[p_NnodesS2][p_NblockS2][p_intNfpNfaces];


    // @shared dfloat s_sgeo[p_NnodesS2][p_NblockS2][p_Nfaces][p_Nsgeo];
    // @shared dfloat s_bc[p_NnodesS2][p_NblockS2][p_Nfaces];
       
    // for all face nodes of all elements
    for(int es=0;es<p_NblockS2;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){

        #pragma unroll p_NnodesS2
     for(int em=0;em<p_NnodesS2;++em){ 
                
      const int e   = eo + es*p_NnodesS2 + em; 
      const int id  = e*p_NfacesNfp + n;

       // if(e<Nelements && n<p_Np ){
       //    int m = n + p_Np*es;
       //    // oad surface geofacs for all faces of all elements in block(s)
       //    while(m<p_NblockS2*p_Nfaces*p_Nsgeo*p_NnodesS2){
       //      const int id = eo*p_Nfaces*p_Nsgeo+ m;
       //       s_sgeo[0][0][0][m] = sgeo[id];
       //       m+=p_Np*p_NblockS2;
       //   }
       //  }

      if(e<Nelements && n<p_NfacesNfp ){
        int idM = vmapM[id];
        int idP = vmapP[id];

        if(idP<0) idP = idM;

        // //load negative and positive trace node values of velocity
        s_UM[em][es][n] = U[idM];
        s_VM[em][es][n] = V[idM];
        s_UP[em][es][n] = U[idP];
        s_VP[em][es][n] = V[idP];
       
        s_UdM[em][es][n] = Ud[idM];
        s_VdM[em][es][n] = Vd[idM];
        s_UdP[em][es][n] = Ud[idP];
        s_VdP[em][es][n] = Vd[idP];
         }

        
     }
    }
    }


    @barrier("local");

    // interpolate to surface integration nodes
    for(int es=0;es<p_NblockS2;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 
        if(n<(p_Nfaces*p_intNfp)){

    dfloat cUM[p_NnodesS2], cVM[p_NnodesS2], cUdM[p_NnodesS2], cVdM[p_NnodesS2];
    dfloat cUP[p_NnodesS2], cVP[p_NnodesS2], cUdP[p_NnodesS2], cVdP[p_NnodesS2];
    const int face = n/p_intNfp;       
         
          #pragma unroll p_NnodesS2
      for(int em=0;em<p_NnodesS2;++em){
        cUM [em] = 0.f;
        cVM [em] = 0.f;
        cUdM[em] = 0.f; 
        cVdM[em] = 0.f;
        //
        cUP [em] = 0.f;
        cVP [em] = 0.f;
        cUdP[em] = 0.f; 
        cVdP[em] = 0.f;
      }

          // local block interpolation (face nodes to integration nodes)
      #pragma unroll p_Nfp
      for(int m=0;m<p_Nfp;++m){
        const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
        const int fm = face*p_Nfp + m;
        #pragma unroll p_NnodesS2
    for(int em=0;em<p_NnodesS2;++em){

      cUM [em] += iInm*s_UM[em][es][fm];
      cVM [em] += iInm*s_VM[em][es][fm];
      cUdM[em] += iInm*s_UdM[em][es][fm];
      cVdM[em] += iInm*s_VdM[em][es][fm];

      cUP[em]  += iInm*s_UP[em][es][fm];
      cVP[em]  += iInm*s_VP[em][es][fm];
      cUdP[em] += iInm*s_UdP[em][es][fm];
      cVdP[em] += iInm*s_VdP[em][es][fm];
    }
      }

    #pragma unroll p_NnodesS2
      for(int em=0;em<p_NnodesS2;++em){
        const int e = eo + es*p_NnodesS2 + em;
        //const int sid    = p_Nsgeo*(e*p_Nfaces+face);
        // const dfloat nx   = s_sgeo[em][es][face][p_NXID];
        // const dfloat ny   = s_sgeo[em][es][face][p_NYID];
        // const dfloat sj   = s_sgeo[em][es][face][p_SJID];
        // const dfloat ij   = s_sgeo[em][es][face][p_IJID];

        // load surface geofactors for this face
	    const int sid    = p_Nsgeo*(e*p_Nfaces+face);
	    const dfloat nx   = sgeo[sid+p_NXID];
	    const dfloat ny   = sgeo[sid+p_NYID];
	    const dfloat sJ   = sgeo[sid+p_SJID];
	    const dfloat invJ = sgeo[sid+p_IJID];
        
		// apply boundary conditions
		const int bc = EToB[face+p_Nfaces*e];
		// if(bc>0){
		// 	insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, r_iUdM[em],r_iVdM[em], &(r_iUdP[em]), &(r_iVdP[em]));
		// }
        
        
        const dfloat sc = sJ*invJ; 
        //Find max normal velocity on the face
        const dfloat unm   = fabs(nx*cUM[em] + ny*cVM[em]);
        const dfloat unp   = fabs(nx*cUP[em] + ny*cVP[em]);    
        const dfloat unmax = (unm > unp) ? unm : unp;

        s_iFluxU[em][es][n] = sc*(.5f*(nx*(cUP[em]*cUdP[em] + cUM[em]*cUdM[em]) 
               +ny*(cVP[em]*cUdP[em] + cVM[em]*cUdM[em]) 
               +unmax*(cUdM[em]- cUdP[em]) ));

        s_iFluxV[em][es][n] = sc*(.5f*(nx*(cUP[em]*cVdP[em] + cUM[em]*cVdM[em]) 
               +ny*(cVP[em]*cVdP[em] + cVM[em]*cVdM[em]) 
               +unmax*(cVdM[em]-cVdP[em]) ));



      }
  }
      }
    }

    @barrier("local");

    // lift from surface integration to volume nodes
    for(int es=0;es<p_NblockS2;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
  dfloat rhsu[p_NnodesS2], rhsv[p_NnodesS2];

        if(n<p_Np){
    #pragma unroll p_NnodesS2
      for(int em=0;em<p_NnodesS2;++em){
        rhsu[em] = 0.f;
        rhsv[em] = 0.f;
      }
    //
    #pragma unroll p_intNfpNfaces
      for(int m=0;m<p_intNfpNfaces;++m){
        const dfloat L = intLIFTT[n+m*p_Np];
        #pragma unroll p_NnodesS2
    for(int em=0;em<p_NnodesS2;++em){
      rhsu[em] += L*s_iFluxU[em][es][m];
      rhsv[em] += L*s_iFluxV[em][es][m];
    }
      }

    #pragma unroll p_NnodesS2
      for(int em=0;em<p_NnodesS2;++em){
        int e = eo+es*p_NnodesS2+em;
        if(e<Nelements){
    const int id = e*p_Np+n;
    rhsU[id]   += rhsu[em]; // note  change in sign
    rhsV[id]   += rhsv[em];    

        }
      }
  }
      }
    }
     
  #undef s_iFluxU
  #undef s_iFluxV 

  }

}



// Optimized sizes for @kernel 5
#if p_N==1
#define p_NblockS5 14
#define p_NnodesS5 2
#endif

#if p_N==2
#define p_NblockS5 8
#define p_NnodesS5 2
#endif

#if p_N==3
#define p_NblockS5 7
#define p_NnodesS5 2
#endif

#if p_N==4
#define p_NblockS5 3
#define p_NnodesS5 2
#endif

#if p_N==5
#define p_NblockS5 7
#define p_NnodesS5 2
#endif

#if p_N==6
#define p_NblockS5 5
#define p_NnodesS5 2
#endif

#if p_N==7
#define p_NblockS5 7
#define p_NnodesS5 2
#endif

#if p_N==8
#define p_NblockS5 4
#define p_NnodesS5 3
#endif

#if p_N==9
#define p_NblockS5 2
#define p_NnodesS5 3
#endif

#if p_N==10
#define p_NblockS5 2
#define p_NnodesS5 4
#endif



// Multiple nodes per thread// use less @shared memory by factor 2 
@kernel void insSubCycleCubatureSurface2D_v5(const int Nelements,
              @restrict const  dfloat *  sgeo,
              @restrict const  dfloat *  intInterpT, // interpolate to integration nodes
              @restrict const  dfloat *  intLIFTT, // lift from integration to interpolation nodes
              @restrict const  int   *  vmapM,
              @restrict const  int   *  vmapP,
              @restrict const  int   *  EToB,
              const dfloat time,
              @restrict const  dfloat *  intx, // integration nodes
              @restrict const  dfloat *  inty,
              @restrict const  dfloat *  U,
              @restrict const  dfloat *  V,
              @restrict const  dfloat *  Ud,
              @restrict const  dfloat *  Vd,
              @restrict dfloat *  rhsU,
              @restrict dfloat *  rhsV){
  // for all elements
  for(int eo=0;eo<Nelements;eo+=(p_NblockS5*p_NnodesS5);@outer(0)){

    // @shared storage 
    @shared dfloat s_UM[p_NnodesS5][p_NblockS5][p_intNfpNfaces];
    @shared dfloat s_VM[p_NnodesS5][p_NblockS5][p_intNfpNfaces];
    @shared dfloat s_UP[p_NnodesS5][p_NblockS5][p_intNfpNfaces];
    @shared dfloat s_VP[p_NnodesS5][p_NblockS5][p_intNfpNfaces];
   
    #define s_iFluxU s_UM // Reuse @shared memory arrays
    #define s_iFluxV s_VM

    @exclusive dfloat r_iUM[p_NnodesS5],  r_iUP[p_NnodesS5];
    @exclusive dfloat r_iVM[p_NnodesS5],  r_iVP[p_NnodesS5];
    @exclusive dfloat r_iUdM[p_NnodesS5], r_iUdP[p_NnodesS5];
    @exclusive dfloat r_iVdM[p_NnodesS5], r_iVdP[p_NnodesS5];

     @exclusive int idM[p_NnodesS5], idP[p_NnodesS5];
     @exclusive int face;

    // Loop for minus traces
    // for all face nodes of all elements
    for(int es=0;es<p_NblockS5;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
        if(n<(p_Nfaces*p_Nfp)){
          #pragma unroll p_NnodesS5
          for (int em=0;em<p_NnodesS5;++em){
            const int e = em*p_NblockS5 + es + eo;
            if (e<Nelements) {
              // indices of negative and positive traces of face node
              const int id  = e*p_Nfp*p_Nfaces + n;
              idM[em] = vmapM[id];
              idP[em] = vmapP[id];

              // load negative and positive trace node values of velocity
              s_UM[em][es][n] = U[idM[em]];
              s_UP[em][es][n] = U[idP[em]];  
              s_VM[em][es][n] = V[idM[em]];
              s_VP[em][es][n] = V[idP[em]];              
            }
          }
        }
      }
    }

    @barrier("local");

    // interpolate to surface integration nodes
    for(int es=0;es<p_NblockS5;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 
        if(n<(p_Nfaces*p_intNfp)){
          face = n/p_intNfp; // find face that owns this integration node

          #pragma unroll p_NnodesS5
          for (int em=0;em<p_NnodesS5;++em){
            r_iUM[em]  = 0.f;
            r_iUP[em]  = 0.f;
            r_iVM[em]  = 0.f;
            r_iVP[em]  = 0.f;
          }

          // local block interpolation (face nodes to integration nodes)
          #pragma unroll p_Nfp
          for(int m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            const int fm = face*p_Nfp+m;

            #pragma unroll p_NnodesS5
            for (int em=0;em<p_NnodesS5;++em){
              r_iUM[em]  += iInm*s_UM[em][es][fm];
              r_iUP[em]  += iInm*s_UP[em][es][fm];
              r_iVM[em]  += iInm*s_VM[em][es][fm];
              r_iVP[em]  += iInm*s_VP[em][es][fm];
            }
          }
        }
      }
    }
    @barrier("local");

    // for all face nodes of all elements
    for(int es=0;es<p_NblockS5;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
        if(n<(p_Nfaces*p_Nfp)){
          #pragma unroll p_NnodesS5
          for (int em=0;em<p_NnodesS5;++em){
            const int e = em*p_NblockS5 + es + eo;
            if (e<Nelements) {
              // load negative and positive trace node values of advection field
              s_UM[em][es][n] = Ud[idM[em]];
              s_UP[em][es][n] = Ud[idP[em]]; 
              s_VM[em][es][n] = Vd[idM[em]];
              s_VP[em][es][n] = Vd[idP[em]];                     
            }
          }
        }
      }
    }

    @barrier("local");

    // interpolate to surface integration nodes
    for(int es=0;es<p_NblockS5;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 
        if(n<(p_Nfaces*p_intNfp)){
          #pragma unroll p_NnodesS5
          for (int em=0;em<p_NnodesS5;++em){
            r_iUdM[em]  = 0.f;
            r_iUdP[em]  = 0.f;
            r_iVdM[em]  = 0.f;
            r_iVdP[em]  = 0.f;
          }

          // local block interpolation (face nodes to integration nodes)
          #pragma unroll p_Nfp
          for(int m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            const int fm = face*p_Nfp+m;

            #pragma unroll p_NnodesS5
            for (int em=0;em<p_NnodesS5;++em){
              r_iUdM[em] += iInm*s_UM[em][es][fm];
              r_iUdP[em] += iInm*s_UP[em][es][fm];
              r_iVdM[em] += iInm*s_VM[em][es][fm];
              r_iVdP[em] += iInm*s_VP[em][es][fm];
            }
          }
        }
      }
    }
    @barrier("local");

    // Use traces to compuite and store flux
    for(int es=0;es<p_NblockS5;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 
        #pragma unroll p_NnodesS5
        for (int em=0;em<p_NnodesS5;++em){
          const int e = em*p_NblockS5 + es + eo;
          if((e<Nelements)&&(n<(p_Nfaces*p_intNfp))){
            // load surface geofactors for this face
            const int sid    = p_Nsgeo*(e*p_Nfaces+face);
            const dfloat nx   = sgeo[sid+p_NXID];
            const dfloat ny   = sgeo[sid+p_NYID];
            const dfloat sJ   = sgeo[sid+p_SJID];
            const dfloat invJ = sgeo[sid+p_IJID];

            // apply boundary conditions
            const int bc = EToB[face+p_Nfaces*e];
            if(bc>0){
              insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, r_iUdM[em],r_iVdM[em], &(r_iUdP[em]), &(r_iVdP[em]));
            }

            // Find max normal velocity on the face
            const dfloat unm   = fabs(nx*r_iUM[em] + ny*r_iVM[em]);
            const dfloat unp   = fabs(nx*r_iUP[em] + ny*r_iVP[em]);    
            const dfloat unmax = (unm > unp) ? unm : unp;

            // evaluate "flux" terms: LLF
            const dfloat sc = 0.5f*invJ*sJ;

            // bad notation here //
            s_iFluxU[em][es][n] = sc*(nx*(r_iUP[em]*r_iUdP[em] + r_iUM[em]*r_iUdM[em]) 
                                +ny*(r_iVP[em]*r_iUdP[em] + r_iVM[em]*r_iUdM[em]) 
                                +unmax*(r_iUdM[em]-r_iUdP[em]));

            s_iFluxV[em][es][n] = sc*(nx*(r_iUP[em]*r_iVdP[em] + r_iUM[em]*r_iVdM[em]) 
                               + ny*(r_iVP[em]*r_iVdP[em] + r_iVM[em]*r_iVdM[em]) 
                               + unmax*(r_iVdM[em]-r_iVdP[em]));
          }
        }
      }
    }

    @barrier("local");

    // lift from surface integration to volume nodes
    for(int es=0;es<p_NblockS5;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
        if(n<p_Np){
          #pragma unroll p_NnodesS5
          for (int em=0;em<p_NnodesS5;++em){
            const int e = em*p_NblockS5 + es + eo;
            if(e<Nelements) {
              const int id = n + p_Np*e;
              // prefemch volume rhs
              r_iUM[em] = rhsU[id];
              r_iVM[em] = rhsV[id];
            }
          }

          #pragma unroll p_intNfpNfaces
          for(int m=0;m<p_intNfpNfaces;++m){
            const dfloat L = intLIFTT[n+m*p_Np];

            #pragma unroll p_NnodesS5
            for (int em=0;em<p_NnodesS5;++em){
              r_iUM[em] += L*s_UM[em][es][m];
              r_iVM[em] += L*s_VM[em][es][m];
            }
          }

          #pragma unroll p_NnodesS5
          for (int em=0;em<p_NnodesS5;++em){
            const int e = em*p_NblockS5 + es + eo;
            if(e<Nelements) {
              const int id = n + p_Np*e;
              // prefemch volume rhs
              rhsU[id] = r_iUM[em];
              rhsV[id] = r_iVM[em];
            }
          }
        }
      }
    }
  #undef s_iFluxU
  #undef s_iFluxV  
  }
}





// Optimized sizes for @kernel 5
#if p_N==1
#define p_NblockS3 10
#define p_NnodesS3 2
#endif

#if p_N==2
#define p_NblockS3 8
#define p_NnodesS3 3
#endif

#if p_N==3
#define p_NblockS3 7
#define p_NnodesS3 5
#endif

#if p_N==4
#define p_NblockS3 6
#define p_NnodesS3 3
#endif

#if p_N==5
#define p_NblockS3 2
#define p_NnodesS3 5
#endif

#if p_N==6
#define p_NblockS3 2
#define p_NnodesS3 5
#endif

#if p_N==7
#define p_NblockS3 3
#define p_NnodesS3 5
#endif

#if p_N==8
#define p_NblockS3 2
#define p_NnodesS3 5
#endif

#if p_N==9
#define p_NblockS3 2
#define p_NnodesS3 4
#endif

#if p_N==10
#define p_NblockS3 2
#define p_NnodesS3 4
#endif

// Use less @shared memory by factor 4
@kernel void insSubCycleCubatureSurface2D_v6(const int Nelements,
                                            @restrict const  dfloat *  sgeo,
                                            @restrict const  dfloat *  intInterpT, // interpolate to integration nodes
                                            @restrict const  dfloat *  intLIFTT, // lift from integration to interpolation nodes
                                            @restrict const  int   *  vmapM,
                                            @restrict const  int   *  vmapP,
                                            @restrict const  int   *  EToB,
                                            const dfloat time,
                                            @restrict const  dfloat *  intx, // integration nodes
                                            @restrict const  dfloat *  inty,
                                            @restrict const  dfloat *  U,
                                            @restrict const  dfloat *  V,
                                            @restrict const  dfloat *  Ud,
                                            @restrict const  dfloat *  Vd,
                                            @restrict dfloat *  rhsU,
                                            @restrict dfloat *  rhsV){
  // for all elements
  for(int eo=0;eo<Nelements;eo+=(p_NblockS3*p_NnodesS3);@outer(0)){

    // @shared storage 
    @shared dfloat s_U[p_NnodesS3][p_NblockS3][p_intNfpNfaces];
    @shared dfloat s_V[p_NnodesS3][p_NblockS3][p_intNfpNfaces];
   
    #define s_iFluxU s_U // Reuse @shared memory arrays
    #define s_iFluxV s_V

    @exclusive dfloat r_iUM[p_NnodesS3],  r_iUP[p_NnodesS3];
    @exclusive dfloat r_iVM[p_NnodesS3],  r_iVP[p_NnodesS3];
    @exclusive dfloat r_iUdM[p_NnodesS3], r_iUdP[p_NnodesS3];
    @exclusive dfloat r_iVdM[p_NnodesS3], r_iVdP[p_NnodesS3];

     @exclusive int idM[p_NnodesS3], idP[p_NnodesS3];
    @exclusive int face;

    // Loop for minus traces
    // for all face nodes of all elements
    for(int es=0;es<p_NblockS3;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
        if(n<(p_Nfaces*p_Nfp)){
          #pragma unroll p_NnodesS3
          for (int em=0;em<p_NnodesS3;++em){
            const int e = em*p_NblockS3 + es + eo;
            if (e<Nelements) {
              // indices of negative and positive traces of face node
              const int id  = e*p_Nfp*p_Nfaces + n;
              idM[em] = vmapM[id];
              idP[em] = vmapP[id];

              // load negative and positive trace node values of velocity
              s_U[em][es][n] = U[idM[em]];
              s_V[em][es][n] = V[idM[em]];              
            }
          }
        }
      }
    }

    @barrier("local");

    // interpolate to surface integration nodes
    for(int es=0;es<p_NblockS3;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 
        if(n<(p_Nfaces*p_intNfp)){
          face = n/p_intNfp; // find face that owns this integration node

          #pragma unroll p_NnodesS3
          for (int em=0;em<p_NnodesS3;++em){
            r_iUM[em]  = 0.f;
            r_iVM[em]  = 0.f;
          }

          // local block interpolation (face nodes to integration nodes)
          #pragma unroll p_Nfp
          for(int m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            const int fm = face*p_Nfp+m;

            #pragma unroll p_NnodesS3
            for (int em=0;em<p_NnodesS3;++em){
              r_iUM[em]  += iInm*s_U[em][es][fm];
              r_iVM[em]  += iInm*s_V[em][es][fm];
            }
          }
        }
      }
    }


    @barrier("local");

    // for all face nodes of all elements
    for(int es=0;es<p_NblockS3;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
        if(n<(p_Nfaces*p_Nfp)){
          #pragma unroll p_NnodesS3
          for (int em=0;em<p_NnodesS3;++em){
            const int e = em*p_NblockS3 + es + eo;
            if (e<Nelements) {
              // load negative and positive trace node values of advection field
              s_U[em][es][n] = Ud[idM[em]];
              s_V[em][es][n] = Vd[idM[em]];              
            }
          }
        }
      }
    }


    @barrier("local");

    // interpolate to surface integration nodes
    for(int es=0;es<p_NblockS3;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 
        if(n<(p_Nfaces*p_intNfp)){
          #pragma unroll p_NnodesS3
          for (int em=0;em<p_NnodesS3;++em){
            r_iUdM[em]  = 0.f;
            r_iVdM[em]  = 0.f;
          }

          // local block interpolation (face nodes to integration nodes)
          #pragma unroll p_Nfp
          for(int m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            const int fm = face*p_Nfp+m;

            #pragma unroll p_NnodesS3
            for (int em=0;em<p_NnodesS3;++em){
              r_iUdM[em]  += iInm*s_U[em][es][fm];
              r_iVdM[em]  += iInm*s_V[em][es][fm];
            }
          }
        }
      }
    }
    @barrier("local");

      // Loop for positive traces
    // for all face nodes of all elements
    for(int es=0;es<p_NblockS3;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
        if(n<(p_Nfaces*p_Nfp)){
          #pragma unroll p_NnodesS3
          for (int em=0;em<p_NnodesS3;++em){
            const int e = em*p_NblockS3 + es + eo;
            if (e<Nelements) {
              // load negative and positive trace node values of velocity
              s_U[em][es][n] = U[idP[em]];
              s_V[em][es][n] = V[idP[em]];              
            }
          }
        }
      }
    }

    @barrier("local");

    // interpolate to surface integration nodes
    for(int es=0;es<p_NblockS3;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 
        if(n<(p_Nfaces*p_intNfp)){
          #pragma unroll p_NnodesS3
          for (int em=0;em<p_NnodesS3;++em){
            r_iUP[em]  = 0.f;
            r_iVP[em]  = 0.f;
          }

          // local block interpolation (face nodes to integration nodes)
          #pragma unroll p_Nfp
          for(int m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            const int fm = face*p_Nfp+m;

            #pragma unroll p_NnodesS3
            for (int em=0;em<p_NnodesS3;++em){
              r_iUP[em]  += iInm*s_U[em][es][fm];
              r_iVP[em]  += iInm*s_V[em][es][fm];
            }
          }
        }
      }
    }
    @barrier("local");

    // for all face nodes of all elements
    for(int es=0;es<p_NblockS3;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
        if(n<(p_Nfaces*p_Nfp)){
          #pragma unroll p_NnodesS3
          for (int em=0;em<p_NnodesS3;++em){
            const int e = em*p_NblockS3 + es + eo;
            if (e<Nelements) {
              // load negative and positive trace node values of advection field
              s_U[em][es][n] = Ud[idP[em]];
              s_V[em][es][n] = Vd[idP[em]];              
            }
          }
        }
      }
    }

    @barrier("local");

    // interpolate to surface integration nodes
    for(int es=0;es<p_NblockS3;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 
        if(n<(p_Nfaces*p_intNfp)){
          #pragma unroll p_NnodesS3
          for (int em=0;em<p_NnodesS3;++em){
            r_iUdP[em]  = 0.f;
            r_iVdP[em]  = 0.f;
          }

          // local block interpolation (face nodes to integration nodes)
          #pragma unroll p_Nfp
          for(int m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            const int fm = face*p_Nfp+m;

            #pragma unroll p_NnodesS3
            for (int em=0;em<p_NnodesS3;++em){
              r_iUdP[em]  += iInm*s_U[em][es][fm];
              r_iVdP[em]  += iInm*s_V[em][es][fm];
            }
          }
        }
      }
    }
    @barrier("local");

    // Use traces to compuite and store flux
    for(int es=0;es<p_NblockS3;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 
        #pragma unroll p_NnodesS3
        for (int em=0;em<p_NnodesS3;++em){
          const int e = em*p_NblockS3 + es + eo;
          if((e<Nelements)&&(n<(p_Nfaces*p_intNfp))){
            // load surface geofactors for this face
            const int sid    = p_Nsgeo*(e*p_Nfaces+face);
            const dfloat nx   = sgeo[sid+p_NXID];
            const dfloat ny   = sgeo[sid+p_NYID];
            const dfloat sJ   = sgeo[sid+p_SJID];
            const dfloat invJ = sgeo[sid+p_IJID];

            // apply boundary conditions
            const int bc = EToB[face+p_Nfaces*e];
            if(bc>0){
              insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, r_iUdM[em],r_iVdM[em], &(r_iUdP[em]), &(r_iVdP[em]));
            }

            // Find max normal velocity on the face
            const dfloat unm   = fabs(nx*r_iUM[em] + ny*r_iVM[em]);
            const dfloat unp   = fabs(nx*r_iUP[em] + ny*r_iVP[em]);    
            const dfloat unmax = (unm > unp) ? unm : unp;

            // evaluate "flux" terms: LLF
            const dfloat sc = 0.5f*invJ*sJ;

            // bad notation here //
            s_iFluxU[em][es][n] = sc*(nx*(r_iUP[em]*r_iUdP[em] + r_iUM[em]*r_iUdM[em]) 
                                +ny*(r_iVP[em]*r_iUdP[em] + r_iVM[em]*r_iUdM[em]) 
                                +unmax*(r_iUdM[em]-r_iUdP[em]));

            s_iFluxV[em][es][n] = sc*(nx*(r_iUP[em]*r_iVdP[em] + r_iUM[em]*r_iVdM[em]) 
                               + ny*(r_iVP[em]*r_iVdP[em] + r_iVM[em]*r_iVdM[em]) 
                               + unmax*(r_iVdM[em]-r_iVdP[em]));
          }
        }
      }
    }

    @barrier("local");

    // lift from surface integration to volume nodes
    for(int es=0;es<p_NblockS3;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
        if(n<p_Np){
          #pragma unroll p_NnodesS3
          for (int em=0;em<p_NnodesS3;++em){
            const int e = em*p_NblockS3 + es + eo;
            if(e<Nelements) {
              const int id = n + p_Np*e;
              // prefemch volume rhs
              r_iUM[em] = rhsU[id];
              r_iVM[em] = rhsV[id];
            }
          }

          #pragma unroll p_intNfpNfaces
          for(int m=0;m<p_intNfpNfaces;++m){
            const dfloat L = intLIFTT[n+m*p_Np];

            #pragma unroll p_NnodesS3
            for (int em=0;em<p_NnodesS3;++em){
              r_iUM[em] += L*s_U[em][es][m];
              r_iVM[em] += L*s_V[em][es][m];
            }
          }

          #pragma unroll p_NnodesS3
          for (int em=0;em<p_NnodesS3;++em){
            const int e = em*p_NblockS3 + es + eo;
            if(e<Nelements) {
              const int id = n + p_Np*e;
              // prefemch volume rhs
              rhsU[id] = r_iUM[em];
              rhsV[id] = r_iVM[em];
            }
          }
        }
      }
    }
  #undef s_iFluxU
  #undef s_iFluxV  
  }
}














// Optimized sizes for @kernel 5
#if p_N==1
#define p_NblockS4 7
#define p_NnodesS4 5
#endif

#if p_N==2
#define p_NblockS4 8
#define p_NnodesS4 3
#endif

#if p_N==3
#define p_NblockS4 7
#define p_NnodesS4 5
#endif

#if p_N==4
#define p_NblockS4 3
#define p_NnodesS4 5
#endif

#if p_N==5
#define p_NblockS4 7
#define p_NnodesS4 5
#endif

#if p_N==6
#define p_NblockS4 2
#define p_NnodesS4 5
#endif

#if p_N==7
#define p_NblockS4 7
#define p_NnodesS4 5
#endif

#if p_N==8
#define p_NblockS4 2
#define p_NnodesS4 5
#endif

#if p_N==9
#define p_NblockS4 1
#define p_NnodesS4 5
#endif

#if p_N==10
#define p_NblockS4 2
#define p_NnodesS4 4
#endif



// Multiple nodes per thread// use less @shared memory by factor 4 
@kernel void insSubCycleCubatureSurface2D_v7(const int Nelements,
              @restrict const  dfloat *  sgeo,
              @restrict const  dfloat *  intInterpT, // interpolate to integration nodes
              @restrict const  dfloat *  intLIFTT, // lift from integration to interpolation nodes
              @restrict const  int   *  vmapM,
              @restrict const  int   *  vmapP,
              @restrict const  int   *  EToB,
              const dfloat time,
              @restrict const  dfloat *  intx, // integration nodes
              @restrict const  dfloat *  inty,
              @restrict const  dfloat *  U,
              @restrict const  dfloat *  V,
              @restrict const  dfloat *  Ud,
              @restrict const  dfloat *  Vd,
              @restrict dfloat *  rhsU,
              @restrict dfloat *  rhsV){
  // for all elements
  for(int eo=0;eo<Nelements;eo+=(p_NblockS4*p_NnodesS4);@outer(0)){

    // @shared storage 
    @shared dfloat s_U[p_NnodesS4][p_NblockS4][p_intNfpNfaces];
    @shared dfloat s_V[p_NnodesS4][p_NblockS4][p_intNfpNfaces];
   
    #define s_iFluxU s_U // Reuse @shared memory arrays
    #define s_iFluxV s_V

    @exclusive dfloat r_iUM[p_NnodesS4],  r_iUP[p_NnodesS4];
    @exclusive dfloat r_iVM[p_NnodesS4],  r_iVP[p_NnodesS4];
    @exclusive dfloat r_iUdM[p_NnodesS4], r_iUdP[p_NnodesS4];
    @exclusive dfloat r_iVdM[p_NnodesS4], r_iVdP[p_NnodesS4];

     @exclusive int idM[p_NnodesS4], idP[p_NnodesS4];
    @exclusive int face;

    // Loop for minus traces
    // for all face nodes of all elements
    for(int es=0;es<p_NblockS4;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
        if(n<(p_Nfaces*p_Nfp)){
          #pragma unroll p_NnodesS4
          for (int em=0;em<p_NnodesS4;++em){
            const int e = em*p_NblockS4 + es + eo;
            if (e<Nelements) {
              // indices of negative and positive traces of face node
              const int id  = e*p_Nfp*p_Nfaces + n;
              idM[em] = vmapM[id];
              idP[em] = vmapP[id];

              // load negative and positive trace node values of velocity
              s_U[em][es][n] = U[idM[em]];
              s_V[em][es][n] = U[idP[em]];              
            }
          }
        }
      }
    }

    @barrier("local");

    // interpolate to surface integration nodes
    for(int es=0;es<p_NblockS4;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 
        if(n<(p_Nfaces*p_intNfp)){
          face = n/p_intNfp; // find face that owns this integration node

          #pragma unroll p_NnodesS4
          for (int em=0;em<p_NnodesS4;++em){
            r_iUM[em]  = 0.f;
            r_iUP[em]  = 0.f;
          }

          // local block interpolation (face nodes to integration nodes)
          #pragma unroll p_Nfp
          for(int m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            const int fm = face*p_Nfp+m;

            #pragma unroll p_NnodesS4
            for (int em=0;em<p_NnodesS4;++em){
              r_iUM[em]  += iInm*s_U[em][es][fm];
              r_iUP[em]  += iInm*s_V[em][es][fm];
            }
          }
        }
      }
    }
    @barrier("local");

    // for all face nodes of all elements
    for(int es=0;es<p_NblockS4;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
        if(n<(p_Nfaces*p_Nfp)){
          #pragma unroll p_NnodesS4
          for (int em=0;em<p_NnodesS4;++em){
            const int e = em*p_NblockS4 + es + eo;
            if (e<Nelements) {
              // load negative and positive trace node values of advection field
              s_U[em][es][n] = Ud[idM[em]];
              s_V[em][es][n] = Ud[idP[em]];              
            }
          }
        }
      }
    }

    @barrier("local");

    // interpolate to surface integration nodes
    for(int es=0;es<p_NblockS4;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 
        if(n<(p_Nfaces*p_intNfp)){
          #pragma unroll p_NnodesS4
          for (int em=0;em<p_NnodesS4;++em){
            r_iUdM[em]  = 0.f;
            r_iUdP[em]  = 0.f;
          }

          // local block interpolation (face nodes to integration nodes)
          #pragma unroll p_Nfp
          for(int m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            const int fm = face*p_Nfp+m;

            #pragma unroll p_NnodesS4
            for (int em=0;em<p_NnodesS4;++em){
              r_iUdM[em]  += iInm*s_U[em][es][fm];
              r_iUdP[em]  += iInm*s_V[em][es][fm];
            }
          }
        }
      }
    }
    @barrier("local");

      // Loop for positive traces
    // for all face nodes of all elements
    for(int es=0;es<p_NblockS4;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
        if(n<(p_Nfaces*p_Nfp)){
          #pragma unroll p_NnodesS4
          for (int em=0;em<p_NnodesS4;++em){
            const int e = em*p_NblockS4 + es + eo;
            if (e<Nelements) {
              // load negative and positive trace node values of velocity
              s_U[em][es][n] = V[idM[em]];
              s_V[em][es][n] = V[idP[em]];              
            }
          }
        }
      }
    }

    @barrier("local");

    // interpolate to surface integration nodes
    for(int es=0;es<p_NblockS4;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 
        if(n<(p_Nfaces*p_intNfp)){
          #pragma unroll p_NnodesS4
          for (int em=0;em<p_NnodesS4;++em){
            r_iVM[em]  = 0.f;
            r_iVP[em]  = 0.f;
          }

          // local block interpolation (face nodes to integration nodes)
          #pragma unroll p_Nfp
          for(int m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            const int fm = face*p_Nfp+m;

            #pragma unroll p_NnodesS4
            for (int em=0;em<p_NnodesS4;++em){
              r_iVM[em]  += iInm*s_U[em][es][fm];
              r_iVP[em]  += iInm*s_V[em][es][fm];
            }
          }
        }
      }
    }
    @barrier("local");

    // for all face nodes of all elements
    for(int es=0;es<p_NblockS4;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
        if(n<(p_Nfaces*p_Nfp)){
          #pragma unroll p_NnodesS4
          for (int em=0;em<p_NnodesS4;++em){
            const int e = em*p_NblockS4 + es + eo;
            if (e<Nelements) {
              // load negative and positive trace node values of advection field
              s_U[em][es][n] = Vd[idM[em]];
              s_V[em][es][n] = Vd[idP[em]];              
            }
          }
        }
      }
    }

    @barrier("local");

    // interpolate to surface integration nodes
    for(int es=0;es<p_NblockS4;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 
        if(n<(p_Nfaces*p_intNfp)){
          #pragma unroll p_NnodesS4
          for (int em=0;em<p_NnodesS4;++em){
            r_iVdM[em]  = 0.f;
            r_iVdP[em]  = 0.f;
          }

          // local block interpolation (face nodes to integration nodes)
          #pragma unroll p_Nfp
          for(int m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            const int fm = face*p_Nfp+m;

            #pragma unroll p_NnodesS4
            for (int em=0;em<p_NnodesS4;++em){
              r_iVdM[em]  += iInm*s_U[em][es][fm];
              r_iVdP[em]  += iInm*s_V[em][es][fm];
            }
          }
        }
      }
    }
    @barrier("local");

    // Use traces to compuite and store flux
    for(int es=0;es<p_NblockS4;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 
        #pragma unroll p_NnodesS4
        for (int em=0;em<p_NnodesS4;++em){
          const int e = em*p_NblockS4 + es + eo;
          if((e<Nelements)&&(n<(p_Nfaces*p_intNfp))){
            // load surface geofactors for this face
            const int sid    = p_Nsgeo*(e*p_Nfaces+face);
            const dfloat nx   = sgeo[sid+p_NXID];
            const dfloat ny   = sgeo[sid+p_NYID];
            const dfloat sJ   = sgeo[sid+p_SJID];
            const dfloat invJ = sgeo[sid+p_IJID];

            // apply boundary conditions
            const int bc = EToB[face+p_Nfaces*e];
            if(bc>0){
              insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, r_iUdM[em],r_iVdM[em], &(r_iUdP[em]), &(r_iVdP[em]));
            }

            // Find max normal velocity on the face
            const dfloat unm   = fabs(nx*r_iUM[em] + ny*r_iVM[em]);
            const dfloat unp   = fabs(nx*r_iUP[em] + ny*r_iVP[em]);    
            const dfloat unmax = (unm > unp) ? unm : unp;

            // evaluate "flux" terms: LLF
            const dfloat sc = 0.5f*invJ*sJ;

            // bad notation here //
            s_iFluxU[em][es][n] = sc*(nx*(r_iUP[em]*r_iUdP[em] + r_iUM[em]*r_iUdM[em]) 
                                +ny*(r_iVP[em]*r_iUdP[em] + r_iVM[em]*r_iUdM[em]) 
                                +unmax*(r_iUdM[em]-r_iUdP[em]));

            s_iFluxV[em][es][n] = sc*(nx*(r_iUP[em]*r_iVdP[em] + r_iUM[em]*r_iVdM[em]) 
                               + ny*(r_iVP[em]*r_iVdP[em] + r_iVM[em]*r_iVdM[em]) 
                               + unmax*(r_iVdM[em]-r_iVdP[em]));
          }
        }
      }
    }

    @barrier("local");

    // lift from surface integration to volume nodes
    for(int es=0;es<p_NblockS4;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
        if(n<p_Np){
          #pragma unroll p_NnodesS4
          for (int em=0;em<p_NnodesS4;++em){
            const int e = em*p_NblockS4 + es + eo;
            if(e<Nelements) {
              const int id = n + p_Np*e;
              // prefemch volume rhs
              r_iUM[em] = rhsU[id];
              r_iVM[em] = rhsV[id];
            }
          }

          #pragma unroll p_intNfpNfaces
          for(int m=0;m<p_intNfpNfaces;++m){
            const dfloat L = intLIFTT[n+m*p_Np];

            #pragma unroll p_NnodesS4
            for (int em=0;em<p_NnodesS4;++em){
              r_iUM[em] += L*s_U[em][es][m];
              r_iVM[em] += L*s_V[em][es][m];
            }
          }

          #pragma unroll p_NnodesS4
          for (int em=0;em<p_NnodesS4;++em){
            const int e = em*p_NblockS4 + es + eo;
            if(e<Nelements) {
              const int id = n + p_Np*e;
              // prefemch volume rhs
              rhsU[id] = r_iUM[em];
              rhsV[id] = r_iVM[em];
            }
          }
        }
      }
    }
  #undef s_iFluxU
  #undef s_iFluxV  
  }
}
































// // Optimized sizes for @kernel 3
// #if p_N==1
// #define p_NblockS1 14
// #endif

// #if p_N==2
// #define p_NblockS1 16
// #endif

// #if p_N==3
// #define p_NblockS1 16
// #endif

// #if p_N==4
// #define p_NblockS1 14
// #endif

// #if p_N==5
// #define p_NblockS1 13
// #endif

// #if p_N==6
// #define p_NblockS1 13
// #endif

// #if p_N==7
// #define p_NblockS1 8
// #endif

// #if p_N==8
// #define p_NblockS1 7
// #endif

// #if p_N==9
// #define p_NblockS1 5
// #endif

// #if p_N==10
// #define p_NblockS1 5
// #endif


// // Use less @shared memory by factor 2
// @kernel void insSubCycleCubatureSurface2D_v4(const int Nelements,
//                                             @restrict const  dfloat *  sgeo,
//                                             @restrict const  dfloat *  intInterpT, // interpolate to integration nodes
//                                             @restrict const  dfloat *  intLIFTT, // lift from integration to interpolation nodes
//                                             @restrict const  int   *  vmapM,
//                                             @restrict const  int   *  vmapP,
//                                             @restrict const  int   *  EToB,
//                                             const dfloat time,
//                                             @restrict const  dfloat *  intx, // integration nodes
//                                             @restrict const  dfloat *  inty,
//                                             @restrict const  dfloat *  U,
//                                             @restrict const  dfloat *  V,
//                                             @restrict const  dfloat *  Ud,
//                                             @restrict const  dfloat *  Vd,
//                                             @restrict dfloat *  rhsU,
//                                             @restrict dfloat *  rhsV){
//   // for all elements
//   for(int eo=0;eo<Nelements;eo+=p_NblockS1;@outer(0)){

//     // @shared storage for flux terms
//     @shared dfloat s_U[p_NblockS1][p_intNfpNfaces];
//     @shared dfloat s_V[p_NblockS1][p_intNfpNfaces];
//     @shared dfloat s_Ud[p_NblockS1][p_NfacesNfp];
//     @shared dfloat s_Vd[p_NblockS1][p_NfacesNfp];

//    #define s_iFluxU s_U
//    #define s_iFluxV s_V
  
//     @exclusive dfloat r_iUM,  r_iUP;
//     @exclusive dfloat r_iVM,  r_iVP;
//     @exclusive dfloat r_iUdM, r_iUdP;
//     @exclusive dfloat r_iVdM, r_iVdP;

//     // Loop for minus traces //
//     // for all face nodes of all elements
//     for(int es=0;es<p_NblockS1;++es;@inner(1)){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
//         const int e = eo + es;
//         if(e<Nelements){
//           if(n<(p_Nfaces*p_Nfp)){
//             // indices of negative and positive traces of face node
//             const int id  = e*p_Nfp*p_Nfaces + n;
//             const int idM = vmapM[id];

//             // load negative and positive trace node values of velocity
//             s_U[es][n] = U[idM];
//             s_V[es][n] = V[idM];
//             s_Ud[es][n] = Ud[idM];
//             s_Vd[es][n] = Vd[idM];
//           }
//         }
//       }
//     }

//     @barrier("local");

//     // interpolate to surface integration nodes
//     for(int es=0;es<p_NblockS1;++es;@inner(1)){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 
//         const int e = eo + es;
//         if(e<Nelements){
//           if(n<(p_Nfaces*p_intNfp)){
//             const int face = n/p_intNfp; // find face that owns this integration node

//             r_iUM  = 0.f;
//             r_iVM  = 0.f;
//             r_iUdM = 0.f;
//             r_iVdM = 0.f;

//             // local block interpolation (face nodes to integration nodes)
//             #pragma unroll p_Nfp
//               for(int m=0;m<p_Nfp;++m){
//                 const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
//                 const int fm = face*p_Nfp+m;

//                 r_iUM  += iInm*s_U[es][fm];
//                 r_iVM  += iInm*s_V[es][fm];
//                 r_iUdM += iInm*s_Ud[es][fm];
//                 r_iVdM += iInm*s_Vd[es][fm];
//               }
//           }
//         }
//       }
//     }
//     @barrier("local");

//     // Loop for positive traces 
//     // for all face nodes of all elements
//     for(int es=0;es<p_NblockS1;++es;@inner(1)){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
//         const int e = eo + es;
//         if(e<Nelements){
//           if(n<(p_Nfaces*p_Nfp)){
//             // indices of negative and positive traces of face node
//             const int id  = e*p_Nfp*p_Nfaces + n;
//             const int idP = vmapP[id];

//             // load negative and positive trace node values of velocity
//             s_U[es][n] = U[idP];
//             s_V[es][n] = V[idP];
//             s_Ud[es][n] = Ud[idP];
//             s_Vd[es][n] = Vd[idP];
//           }
//         }
//       }
//     }

//     @barrier("local");

//     // interpolate to surface integration nodes
//     for(int es=0;es<p_NblockS1;++es;@inner(1)){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 
//         const int e = eo + es;
//         if(e<Nelements){
//           if(n<(p_Nfaces*p_intNfp)){
//             const int face = n/p_intNfp; // find face that owns this integration node

//             r_iUP  = 0.f;
//             r_iVP  = 0.f;
//             r_iUdP = 0.f;
//             r_iVdP = 0.f;

//             // local block interpolation (face nodes to integration nodes)
//             #pragma unroll p_Nfp
//               for(int m=0;m<p_Nfp;++m){
//                 const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
//                 const int fm = face*p_Nfp+m;

//                 r_iUP  += iInm*s_U[es][fm];
//                 r_iVP  += iInm*s_V[es][fm];
//                 r_iUdP += iInm*s_Ud[es][fm];
//                 r_iVdP += iInm*s_Vd[es][fm];
//               }
//           }
//         }
//       }
//     }
//     @barrier("local");


//     // Use traces to compuite and store flux 
//     for(int es=0;es<p_NblockS1;++es;@inner(1)){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 
//         const int e = eo + es;
//         if(e<Nelements){
//           if(n<(p_Nfaces*p_intNfp)){
//             const int face = n/p_intNfp; // find face that owns this integration node

//             // load surface geofactors for this face
//             const int sid    = p_Nsgeo*(e*p_Nfaces+face);
//             const dfloat nx   = sgeo[sid+p_NXID];
//             const dfloat ny   = sgeo[sid+p_NYID];
//             const dfloat sJ   = sgeo[sid+p_SJID];
//             const dfloat invJ = sgeo[sid+p_IJID];

//             // apply boundary conditions
//             const int bc = EToB[face+p_Nfaces*e];
//             if(bc>0){
//               insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, r_iUdM,r_iVdM, &r_iUdP, &r_iVdP);
//             }

//             // Find max normal velocity on the face
//             const dfloat unm   = fabs(nx*r_iUM + ny*r_iVM);
//             const dfloat unp   = fabs(nx*r_iUP + ny*r_iVP);    
//             const dfloat unmax = (unm > unp) ? unm : unp;

//             // evaluate "flux" terms: LLF
//             const dfloat sc = 0.5f*invJ*sJ ;

//             // bad notation here //
//             s_iFluxU[es][n] = sc*(nx*(r_iUP*r_iUdP + r_iUM*r_iUdM) 
//                              +ny*(r_iVP*r_iUdP + r_iVM*r_iUdM) 
//                              +unmax*(r_iUdM-r_iUdP));

//             s_iFluxV[es][n] = sc*(nx*(r_iUP*r_iVdP + r_iUM*r_iVdM) 
//                             + ny*(r_iVP*r_iVdP + r_iVM*r_iVdM) 
//                             + unmax*(r_iVdM-r_iVdP));
//           }
//         }
//       }
//     }

//     @barrier("local");

//     // lift from surface integration to volume nodes
//     for(int es=0;es<p_NblockS1;++es;@inner(1)){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
//         const int e = eo + es;
//         if(e<Nelements){
//           if(n<p_Np){
//             const int id = n + p_Np*e;
//             // prefetch volume rhs
//             dfloat rhsu = rhsU[id];
//             dfloat rhsv = rhsV[id];

//             #pragma unroll p_intNfpNfaces
//               for(int m=0;m<p_intNfpNfaces;++m){
//                 const dfloat L = intLIFTT[n+m*p_Np];
//                 rhsu += L*s_U[es][m];
//                 rhsv += L*s_V[es][m];
//               }

//             rhsU[id] = rhsu;
//             rhsV[id] = rhsv; 
//           }
//         }
//       }
//     }


//   #undef s_iFluxU
//   #undef s_iFluxV   
//   }
// }





// // Optimized sizes for @kernel 3
// #if p_N==1
// #define p_NblockS2 14
// #endif

// #if p_N==2
// #define p_NblockS2 8
// #endif

// #if p_N==3
// #define p_NblockS2 16
// #endif

// #if p_N==4
// #define p_NblockS2 18
// #endif

// #if p_N==5
// #define p_NblockS2 13
// #endif

// #if p_N==6
// #define p_NblockS2 17
// #endif

// #if p_N==7
// #define p_NblockS2 8
// #endif

// #if p_N==8
// #define p_NblockS2 11
// #endif

// #if p_N==9
// #define p_NblockS2 6
// #endif

// #if p_N==10
// #define p_NblockS2 7
// #endif


// // Use less @shared memory by factor 4
// @kernel void insSubCycleCubatureSurface2D_v5(const int Nelements,
//                                             @restrict const  dfloat *  sgeo,
//                                             @restrict const  dfloat *  intInterpT, // interpolate to integration nodes
//                                             @restrict const  dfloat *  intLIFTT, // lift from integration to interpolation nodes
//                                             @restrict const  int   *  vmapM,
//                                             @restrict const  int   *  vmapP,
//                                             @restrict const  int   *  EToB,
//                                             const dfloat time,
//                                             @restrict const  dfloat *  intx, // integration nodes
//                                             @restrict const  dfloat *  inty,
//                                             @restrict const  dfloat *  U,
//                                             @restrict const  dfloat *  V,
//                                             @restrict const  dfloat *  Ud,
//                                             @restrict const  dfloat *  Vd,
//                                             @restrict dfloat *  rhsU,
//                                             @restrict dfloat *  rhsV){
//   // for all elements
//   for(int eo=0;eo<Nelements;eo+=p_NblockS2;@outer(0)){

//     // @shared storage for flux terms
//     @shared dfloat s_U[p_NblockS2][p_intNfpNfaces];
//     @shared dfloat s_V[p_NblockS2][p_intNfpNfaces];
    
//    	#define s_iFluxU s_U
//    	#define s_iFluxV s_V
  
//     @exclusive dfloat r_iUM,  r_iUP;
//     @exclusive dfloat r_iVM,  r_iVP;
//     @exclusive dfloat r_iUdM, r_iUdP;
//     @exclusive dfloat r_iVdM, r_iVdP;

//     @exclusive int idM, idP; 

//     //Loop for minus traces //
//     // for all face nodes of all elements
//     for(int es=0;es<p_NblockS2;++es;@inner(1)){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
//         const int e = eo + es;
//         if(e<Nelements){
//           if(n<(p_Nfaces*p_Nfp)){
//             // indices of negative and positive traces of face node
//             const int id  = e*p_Nfp*p_Nfaces + n;
//             idM = vmapM[id];
//             // load negative and positive trace node values of velocity
//             s_U[es][n] = U[idM];
//             s_V[es][n] = V[idM];
//           }
//         }
//       }
//     }

//     @barrier("local");

//     // interpolate to surface integration nodes
//     for(int es=0;es<p_NblockS2;++es;@inner(1)){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 
//         const int e = eo + es;
//         if(e<Nelements){
//           if(n<(p_Nfaces*p_intNfp)){
//             const int face = n/p_intNfp; // find face that owns this integration node
//             r_iUM  = 0.f;
//             r_iVM  = 0.f;        
//             // local block interpolation (face nodes to integration nodes)
//             #pragma unroll p_Nfp
//               for(int m=0;m<p_Nfp;++m){
//                 const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
//                 const int fm = face*p_Nfp+m;
//                 r_iUM  += iInm*s_U[es][fm];
//                 r_iVM  += iInm*s_V[es][fm];
//               }
//           }
//         }
//       }
//     }
//     @barrier("local");



//     //Loop for minus traces //
//     // for all face nodes of all elements
//     for(int es=0;es<p_NblockS2;++es;@inner(1)){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
//         const int e = eo + es;
//         if(e<Nelements){
//           if(n<(p_Nfaces*p_Nfp)){
//             // load negative and positive trace node values of velocity
//             s_U[es][n] = Ud[idM];
//             s_V[es][n] = Vd[idM];
//           }
//         }
//       }
//     }

//     @barrier("local");

//     // interpolate to surface integration nodes
//     for(int es=0;es<p_NblockS2;++es;@inner(1)){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 
//         const int e = eo + es;
//         if(e<Nelements){
//           if(n<(p_Nfaces*p_intNfp)){
//             const int face = n/p_intNfp; // find face that owns this integration node
//             r_iUdM = 0.f;
//             r_iVdM = 0.f;
//             // local block interpolation (face nodes to integration nodes)
//             #pragma unroll p_Nfp
//               for(int m=0;m<p_Nfp;++m){
//                 const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
//                 const int fm = face*p_Nfp+m;
//                 r_iUdM += iInm*s_U[es][fm];
//                 r_iVdM += iInm*s_V[es][fm];
//               }
//           }
//         }
//       }
//     }

//     @barrier("local");

//     // Loop for positive traces //
//     // for all face nodes of all elements
//     for(int es=0;es<p_NblockS2;++es;@inner(1)){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
//         const int e = eo + es;
//         if(e<Nelements){
//           if(n<(p_Nfaces*p_Nfp)){
//             // indices of negative and positive traces of face node
//             const int id  = e*p_Nfp*p_Nfaces + n;
//             idP = vmapP[id];

//             // load negative and positive trace node values of velocity
//             s_U[es][n] = U[idP];
//             s_V[es][n] = V[idP];
//           }
//         }
//       }
//     }

//     @barrier("local");

//     // interpolate to surface integration nodes
//     for(int es=0;es<p_NblockS2;++es;@inner(1)){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 
//         const int e = eo + es;
//         if(e<Nelements){
//           if(n<(p_Nfaces*p_intNfp)){
//             const int face = n/p_intNfp; // find face that owns this integration node

//             r_iUP  = 0.f;
//             r_iVP  = 0.f;
            
//             // local block interpolation (face nodes to integration nodes)
//             #pragma unroll p_Nfp
//               for(int m=0;m<p_Nfp;++m){
//                 const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
//                 const int fm = face*p_Nfp+m;
//                 r_iUP  += iInm*s_U[es][fm];
//                 r_iVP  += iInm*s_V[es][fm];
//               }
//           }
//         }
//       }
//     }

//      @barrier("local");

//     // Loop for positive traces //
//     // for all face nodes of all elements
//     for(int es=0;es<p_NblockS2;++es;@inner(1)){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
//         const int e = eo + es;
//         if(e<Nelements){
//           if(n<(p_Nfaces*p_Nfp)){
//             s_U[es][n] = Ud[idP];
//             s_V[es][n] = Vd[idP];
//           }
//         }
//       }
//     }

//     @barrier("local");

//     // interpolate to surface integration nodes
//     for(int es=0;es<p_NblockS2;++es;@inner(1)){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 
//         const int e = eo + es;
//         if(e<Nelements){
//           if(n<(p_Nfaces*p_intNfp)){
//             const int face = n/p_intNfp; // find face that owns this integration node
//             r_iUdP = 0.f;
//             r_iVdP = 0.f;

//             // local block interpolation (face nodes to integration nodes)
//             #pragma unroll p_Nfp
//               for(int m=0;m<p_Nfp;++m){
//                 const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
//                 const int fm = face*p_Nfp+m;
//                 r_iUdP += iInm*s_U[es][fm];
//                 r_iVdP += iInm*s_V[es][fm];
//               }
//           }
//         }
//       }
//     }


//     @barrier("local");


//     // Use traces to compuite and store flux //
//     for(int es=0;es<p_NblockS2;++es;@inner(1)){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 
//         const int e = eo + es;
//         if(e<Nelements){
//           if(n<(p_Nfaces*p_intNfp)){
//             const int face = n/p_intNfp; // find face that owns this integration node

//             // load surface geofactors for this face
//             const int sid    = p_Nsgeo*(e*p_Nfaces+face);
//             const dfloat nx   = sgeo[sid+p_NXID];
//             const dfloat ny   = sgeo[sid+p_NYID];
//             const dfloat sJ   = sgeo[sid+p_SJID];
//             const dfloat invJ = sgeo[sid+p_IJID];

//             // apply boundary conditions
//             const int bc = EToB[face+p_Nfaces*e];
//             if(bc>0){
//               insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, r_iUdM,r_iVdM, &r_iUdP, &r_iVdP);
//             }

//             // Find max normal velocity on the face
//             const dfloat unm   = fabs(nx*r_iUM + ny*r_iVM);
//             const dfloat unp   = fabs(nx*r_iUP + ny*r_iVP);    
//             const dfloat unmax = (unm > unp) ? unm : unp;

//             // evaluate "flux" terms: LLF
//             const dfloat sc = 0.5f*invJ*sJ ;

//             // bad notation here //
//             s_iFluxU[es][n] = sc*(nx*(r_iUP*r_iUdP + r_iUM*r_iUdM) 
//                              +ny*(r_iVP*r_iUdP + r_iVM*r_iUdM) 
//                              +unmax*(r_iUdM-r_iUdP));

//             s_iFluxV[es][n] = sc*(nx*(r_iUP*r_iVdP + r_iUM*r_iVdM) 
//                             + ny*(r_iVP*r_iVdP + r_iVM*r_iVdM) 
//                             + unmax*(r_iVdM-r_iVdP));
//           }
//         }
//       }
//     }

//     @barrier("local");

//     // lift from surface integration to volume nodes
//     for(int es=0;es<p_NblockS2;++es;@inner(1)){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
//         const int e = eo + es;
//         if(e<Nelements){
//           if(n<p_Np){
//             const int id = n + p_Np*e;
//             // prefetch volume rhs
//             dfloat rhsu = rhsU[id];
//             dfloat rhsv = rhsV[id];

//             #pragma unroll p_intNfpNfaces
//               for(int m=0;m<p_intNfpNfaces;++m){
//                 const dfloat L = intLIFTT[n+m*p_Np];
//                 rhsu += L*s_U[es][m];
//                 rhsv += L*s_V[es][m];
//               }

//             rhsU[id] = rhsu;
//             rhsV[id] = rhsv; 
//           }
//         }
//       }
//     }


//   #undef s_iFluxU
//   #undef s_iFluxV   
//   }
// }














/*

// Optimized sizes for @kernel 5
#if p_N==1
#define p_NblockS3 7
#endif

#if p_N==2
#define p_NblockS3 8
#endif

#if p_N==3
#define p_NblockS3 7
#endif

#if p_N==4
#define p_NblockS3 9
#endif

#if p_N==5
#define p_NblockS3 6
#endif

#if p_N==6
#define p_NblockS3 7
#endif

#if p_N==7
#define p_NblockS3 7
#endif

#if p_N==8
#define p_NblockS3 7
#endif

#if p_N==9
#define p_NblockS3 4
#endif

#if p_N==10
#define p_NblockS3 4
#endif


// Use shmem for interp and geo and less @shared memeory for factor 2
@kernel void insSubCycleCubatureSurface2D_v6(const int Nelements,
                                            @restrict const  dfloat *  sgeo,
                                            @restrict const  dfloat *  intInterpT, // interpolate to integration nodes
                                            @restrict const  dfloat *  intLIFTT, // lift from integration to interpolation nodes
                                            @restrict const  int   *  vmapM,
                                            @restrict const  int   *  vmapP,
                                            @restrict const  int   *  EToB,
                                            const dfloat time,
                                            @restrict const  dfloat *  intx, // integration nodes
                                            @restrict const  dfloat *  inty,
                                            @restrict const  dfloat *  U,
                                            @restrict const  dfloat *  V,
                                            @restrict const  dfloat *  Ud,
                                            @restrict const  dfloat *  Vd,
                                            @restrict dfloat *  rhsU,
                                            @restrict dfloat *  rhsV){
  // for all elements
  for(int eo=0;eo<Nelements;eo+=p_NblockS3;@outer(0)){

    // @shared storage for flux terms
    @shared dfloat s_U[p_NblockS3][p_intNfpNfaces];
    @shared dfloat s_V[p_NblockS3][p_intNfpNfaces];
    @shared dfloat s_Ud[p_NblockS3][p_NfacesNfp];
    @shared dfloat s_Vd[p_NblockS3][p_NfacesNfp];
    
    // Load geo and @shared memory to
    @shared dfloat s_sgeo[p_NblockS3][p_Nfaces][p_Nsgeo];
    @shared dfloat s_intInterpT[p_Nfaces*p_intNfp*p_Nfp];

   #define s_iFluxU s_U // Reuse shemem array
   #define s_iFluxV s_V
  
    @exclusive dfloat r_iUM,  r_iUP;
    @exclusive dfloat r_iVM,  r_iVP;
    @exclusive dfloat r_iUdM, r_iUdP;
    @exclusive dfloat r_iVdM, r_iVdP;

    // for all face nodes of all elements
    for(int es=0;es<p_NblockS3;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
        const int e = eo + es;
          if(e<Nelements){
            if(n<p_Np ){
              int m = n + p_Np*es;
            // oad surface geofacs for all faces of all elements in block(s)
              while(m<p_NblockS3*p_Nfaces*p_Nsgeo){
                const int id = eo*p_Nfaces*p_Nsgeo+ m;
                s_sgeo[0][0][m] = sgeo[id];
                m+=p_Np*p_NblockS3;
             }
              if (es==0) {
                for(int m=n;m<p_Nfaces*p_Nfp*p_Nfp;m+=p_Np){
                  s_intInterpT[m] = intInterpT[m];
                }
             }
            }
      
          if(n<(p_Nfaces*p_Nfp)){
            // indices of negative and positive traces of face node
            const int id  = e*p_Nfp*p_Nfaces + n;
            const int idM = vmapM[id];

            // load negative and positive trace node values of velocity
            s_U[es][n] = U[idM];
            s_V[es][n] = V[idM];
            s_Ud[es][n] = Ud[idM];
            s_Vd[es][n] = Vd[idM];
          }
        }
      }
    }

    @barrier("local");

    // interpolate to surface integration nodes
    for(int es=0;es<p_NblockS3;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 
        const int e = eo + es;
        if(e<Nelements){
          if(n<(p_Nfaces*p_intNfp)){
            const int face = n/p_intNfp; // find face that owns this integration node

            r_iUM  = 0.f;
            r_iVM  = 0.f;
            r_iUdM = 0.f;
            r_iVdM = 0.f;

            // local block interpolation (face nodes to integration nodes)
            #pragma unroll p_Nfp
              for(int m=0;m<p_Nfp;++m){
                const dfloat iInm = s_intInterpT[n+m*p_Nfaces*p_intNfp];
                const int fm = face*p_Nfp+m;

                r_iUM  += iInm*s_U[es][fm];
                r_iVM  += iInm*s_V[es][fm];
                r_iUdM += iInm*s_Ud[es][fm];
                r_iVdM += iInm*s_Vd[es][fm];
              }
          }
        }
      }
    }
    @barrier("local");

    // Loop for positive traces
    // for all face nodes of all elements
    for(int es=0;es<p_NblockS3;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
        const int e = eo + es;
        if(e<Nelements){
          if(n<(p_Nfaces*p_Nfp)){
            // indices of negative and positive traces of face node
            const int id  = e*p_Nfp*p_Nfaces + n;
            const int idP = vmapP[id];

            // load negative and positive trace node values of velocity
            s_U[es][n] = U[idP];
            s_V[es][n] = V[idP];
            s_Ud[es][n] = Ud[idP];
            s_Vd[es][n] = Vd[idP];
          }
        }
      }
    }

    @barrier("local");

    // interpolate to surface integration nodes
    for(int es=0;es<p_NblockS3;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 
        const int e = eo + es;
        if(e<Nelements){
          if(n<(p_Nfaces*p_intNfp)){
            const int face = n/p_intNfp; // find face that owns this integration node

            r_iUP  = 0.f;
            r_iVP  = 0.f;
            r_iUdP = 0.f;
            r_iVdP = 0.f;

            // local block interpolation (face nodes to integration nodes)
            #pragma unroll p_Nfp
              for(int m=0;m<p_Nfp;++m){
                const dfloat iInm = s_intInterpT[n+m*p_Nfaces*p_intNfp];
                const int fm = face*p_Nfp+m;

                r_iUP  += iInm*s_U[es][fm];
                r_iVP  += iInm*s_V[es][fm];
                r_iUdP += iInm*s_Ud[es][fm];
                r_iVdP += iInm*s_Vd[es][fm];
              }
          }
        }
      }
    }
    @barrier("local");


    // Use traces to compuite and store flux //
    for(int es=0;es<p_NblockS3;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 
        const int e = eo + es;
        if(e<Nelements){
          if(n<(p_Nfaces*p_intNfp)){
            const int face = n/p_intNfp; // find face that owns this integration node

            // load surface geofactors for this face
            const dfloat nx   = s_sgeo[es][face][p_NXID];
            const dfloat ny   = s_sgeo[es][face][p_NYID];
            const dfloat sJ   = s_sgeo[es][face][p_SJID];
            const dfloat invJ = s_sgeo[es][face][p_IJID];
            
            // apply boundary conditions
            const int bc = EToB[face+p_Nfaces*e];
            if(bc>0){
              insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, r_iUdM,r_iVdM, &r_iUdP, &r_iVdP);
            }

            // Find max normal velocity on the face
            const dfloat unm   = fabs(nx*r_iUM + ny*r_iVM);
            const dfloat unp   = fabs(nx*r_iUP + ny*r_iVP);    
            const dfloat unmax = (unm > unp) ? unm : unp;

            // evaluate "flux" terms: LLF
            const dfloat sc = 0.5f*invJ*sJ ;

            // bad notation here //
            s_iFluxU[es][n] = sc*(nx*(r_iUP*r_iUdP + r_iUM*r_iUdM) 
                             +ny*(r_iVP*r_iUdP + r_iVM*r_iUdM) 
                             +unmax*(r_iUdM-r_iUdP));

            s_iFluxV[es][n] = sc*(nx*(r_iUP*r_iVdP + r_iUM*r_iVdM) 
                            + ny*(r_iVP*r_iVdP + r_iVM*r_iVdM) 
                            + unmax*(r_iVdM-r_iVdP));
          }
        }
      }
    }

    @barrier("local");

    // lift from surface integration to volume nodes
    for(int es=0;es<p_NblockS3;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
        const int e = eo + es;
        if(e<Nelements){
          if(n<p_Np){
            const int id = n + p_Np*e;
            // prefetch volume rhs
            dfloat rhsu = rhsU[id];
            dfloat rhsv = rhsV[id];

            #pragma unroll p_intNfpNfaces
              for(int m=0;m<p_intNfpNfaces;++m){
                const dfloat L = intLIFTT[n+m*p_Np];
                rhsu += L*s_U[es][m];
                rhsv += L*s_V[es][m];
              }

            rhsU[id] = rhsu;
            rhsV[id] = rhsv; 
          }
        }
      }
    }


  #undef s_iFluxU
  #undef s_iFluxV   
  }
}









































// Optimized sizes for @kernel 5
#if p_N==1
#define p_NblockS5 8
#define p_NnodesS5S4 4
#endif

#if p_N==2
#define p_NblockS4 2
#define p_NnodesS4 3
#endif

#if p_N==3
#define p_NblockS4 4
#define p_NnodesS4 5
#endif

#if p_N==4
#define p_NblockS4 2
#define p_NnodesS4 3
#endif

#if p_N==5
#define p_NblockS4 4
#define p_NnodesS4 5
#endif

#if p_N==6
#define p_NblockS4 4
#define p_NnodesS4 5
#endif

#if p_N==7
#define p_NblockS4 5
#define p_NnodesS4 2
#endif

#if p_N==8
#define p_NblockS4 1
#define p_NnodesS4 4
#endif

#if p_N==9
#define p_NblockS4 3
#define p_NnodesS4 2
#endif

#if p_N==10
#define p_NblockS4 2
#define p_NnodesS4 3
#endif



// Multiple nodes per thread// use less @shared memory by factor 2 
// fetch (or not)  geo and interp into @shared
@kernel void insSubCycleCubatureSurface2D_v7(const int Nelements,
              @restrict const  dfloat *  sgeo,
              @restrict const  dfloat *  intInterpT, // interpolate to integration nodes
              @restrict const  dfloat *  intLIFTT, // lift from integration to interpolation nodes
              @restrict const  int   *  vmapM,
              @restrict const  int   *  vmapP,
              @restrict const  int   *  EToB,
              const dfloat time,
              @restrict const  dfloat *  intx, // integration nodes
              @restrict const  dfloat *  inty,
              @restrict const  dfloat *  U,
              @restrict const  dfloat *  V,
              @restrict const  dfloat *  Ud,
              @restrict const  dfloat *  Vd,
              @restrict dfloat *  rhsU,
              @restrict dfloat *  rhsV){
  // for all elements
  for(int eo=0;eo<Nelements;eo+=(p_NblockS4*p_NnodesS4);@outer(0)){

    // @shared storage 
    @shared dfloat s_U[p_NnodesS4][p_NblockS4][p_intNfpNfaces];
    @shared dfloat s_V[p_NnodesS4][p_NblockS4][p_intNfpNfaces];
    
    @shared dfloat s_Ud[p_NnodesS4][p_NblockS4][p_NfacesNfp];
    @shared dfloat s_Vd[p_NnodesS4][p_NblockS4][p_NfacesNfp];

    #define s_iFluxU s_U // Reuse @shared memory arrays
    #define s_iFluxV s_V

    @exclusive dfloat r_iUM[p_NnodesS4],  r_iUP[p_NnodesS4];
    @exclusive dfloat r_iVM[p_NnodesS4],  r_iVP[p_NnodesS4];
    @exclusive dfloat r_iUdM[p_NnodesS4], r_iUdP[p_NnodesS4];
    @exclusive dfloat r_iVdM[p_NnodesS4], r_iVdP[p_NnodesS4];

    // @shared dfloat s_sgeo[p_NnodesS4][p_NblockS4][p_Nfaces][p_Nsgeo];
    // @shared dfloat s_intInterpT[p_Nfaces*p_intNfp*p_Nfp];
    
    // for all face nodes of all elements
    for(int es=0;es<p_NblockS4;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){

        #pragma unroll p_NnodesS4
     for(int em=0;em<p_NnodesS4;++em){ 
                
      const int e   = eo + es*p_NnodesS4 + em; 
      const int id  = e*p_NfacesNfp + n;

       // if(e<Nelements && n<p_Np ){
       //    int m = n + p_Np*es;
       //    // oad surface geofacs for all faces of all elements in block(s)
       //    while(m<p_NblockS4*p_Nfaces*p_Nsgeo*p_NnodesS4){
       //      const int id = eo*p_Nfaces*p_Nsgeo+ m;
       //       s_sgeo[0][0][0][m] = sgeo[id];
       //       m+=p_Np*p_NblockS4;
       //   }
     
       //    if (es==0 && em==0) {
       //      for(int m=n;m<p_Nfaces*p_Nfp*p_Nfp;m+=p_Np){
       //      s_intInterpT[m] = intInterpT[m];
       //      }
       //    }
       //  }

      if(e<Nelements && n<p_NfacesNfp ){
        int idM = vmapM[id];
        // //load negative and positive trace node values of velocity
        s_U[em][es][n]  = U[idM];
        s_V[em][es][n]  = V[idM];
        s_Ud[em][es][n] = Ud[idM];
        s_Vd[em][es][n] = Vd[idM];
        }        
     }
    }
    }

    @barrier("local");

    // interpolate to surface integration nodes
    for(int es=0;es<p_NblockS4;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 
        if(n<(p_Nfaces*p_intNfp)){
           const int face = n/p_intNfp;       
            #pragma unroll p_NnodesS4
            for(int em=0;em<p_NnodesS4;++em){
              r_iUM [em] = 0.f;  
              r_iVM [em] = 0.f;  
              r_iUdM[em] = 0.f; 
              r_iVdM[em] = 0.f;              
            }

          // local block interpolation (face nodes to integration nodes)
          #pragma unroll p_Nfp
          for(int m=0;m<p_Nfp;++m){
            // const dfloat iInm = s_intInterpT[n+m*p_Nfaces*p_intNfp];
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            const int fm = face*p_Nfp + m;
            #pragma unroll p_NnodesS4
              for(int em=0;em<p_NnodesS4;++em){
              r_iUM [em] += iInm*s_U[em][es][fm];
              r_iVM [em] += iInm*s_V[em][es][fm];
              r_iUdM[em] += iInm*s_Ud[em][es][fm];
              r_iVdM[em] += iInm*s_Vd[em][es][fm];
            }
          }
        }
      }
    }
    
    @barrier("local");



    // for all face nodes of all elements
    for(int es=0;es<p_NblockS4;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
      #pragma unroll p_NnodesS4
      for(int em=0;em<p_NnodesS4;++em){           
       const int e   = eo + es*p_NnodesS4 + em; 
       const int id  = e*p_NfacesNfp + n;
      if(e<Nelements && n<p_NfacesNfp ){
        int idP = vmapP[id];
        // //load negative and positive trace node values of velocity
        s_U[em][es][n]  = U[idP];
        s_V[em][es][n]  = V[idP];
        s_Ud[em][es][n] = Ud[idP];
        s_Vd[em][es][n] = Vd[idP];
        }        
     }
    }
    }

    @barrier("local");

    // interpolate to surface integration nodes
    for(int es=0;es<p_NblockS4;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 
        if(n<(p_Nfaces*p_intNfp)){
           const int face = n/p_intNfp;       
            #pragma unroll p_NnodesS4
            for(int em=0;em<p_NnodesS4;++em){
              r_iUP [em] = 0.f;  
              r_iVP [em] = 0.f;  
              r_iUdP[em] = 0.f; 
              r_iVdP[em] = 0.f;              
            }

          // local block interpolation (face nodes to integration nodes)
          #pragma unroll p_Nfp
          for(int m=0;m<p_Nfp;++m){
            // const dfloat iInm = s_intInterpT[n+m*p_Nfaces*p_intNfp];
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            const int fm = face*p_Nfp + m;
            #pragma unroll p_NnodesS4
              for(int em=0;em<p_NnodesS4;++em){
              r_iUP [em] += iInm*s_U[em][es][fm];
              r_iVP [em] += iInm*s_V[em][es][fm];
              r_iUdP[em] += iInm*s_Ud[em][es][fm];
              r_iVdP[em] += iInm*s_Vd[em][es][fm];
            }
          }
        }
      }
    }
    
    @barrier("local");


     // interpolate to surface integration nodes
    for(int es=0;es<p_NblockS4;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 
        if(n<(p_Nfaces*p_intNfp)){
          const int face = n/p_intNfp;       
          #pragma unroll p_NnodesS4
          for(int em=0;em<p_NnodesS4;++em){
            const int e   = eo + es*p_NnodesS4 + em; 
            // const dfloat nx   = s_sgeo[em][es][face][p_NXID];
            // const dfloat ny   = s_sgeo[em][es][face][p_NYID];
            // const dfloat sJ   = s_sgeo[em][es][face][p_SJID];
            // const dfloat invJ = s_sgeo[em][es][face][p_IJID];

            // load surface geofactors for this face
            const int sid    = p_Nsgeo*(e*p_Nfaces+face);
            const dfloat nx   = sgeo[sid+p_NXID];
            const dfloat ny   = sgeo[sid+p_NYID];
            const dfloat sJ   = sgeo[sid+p_SJID];
            const dfloat invJ = sgeo[sid+p_IJID];  

        
            const int bc = EToB[face+p_Nfaces*e];
            // if(bc>0){
            //   insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, r_iUdM,r_iVdM, &r_iUdP[em], &r_iVdP[em]);
            // }

            const dfloat sc = sJ*invJ; 
            //Find max normal velocity on the face
            const dfloat unm   = fabs(nx*r_iUM[em] + ny*r_iVM[em]);
            const dfloat unp   = fabs(nx*r_iUP[em] + ny*r_iVP[em]);    
            const dfloat unmax = (unm > unp) ? unm : unp;

            s_iFluxU[em][es][n] = sc*(.5f*(nx*(r_iUP[em]*r_iUdP[em] + r_iUM[em]*r_iUdM[em]) 
                   +ny*(r_iVP[em]*r_iUdP[em] + r_iVM[em]*r_iUdM[em]) 
                   +unmax*(r_iUdM[em]- r_iUdP[em]) ));

            s_iFluxV[em][es][n] = sc*(.5f*(nx*(r_iUP[em]*r_iVdP[em] + r_iUM[em]*r_iVdM[em]) 
                   +ny*(r_iVP[em]*r_iVdP[em] + r_iVM[em]*r_iVdM[em]) 
                   +unmax*(r_iVdM[em]-r_iVdP[em]) ));
           }
        }
      }
    }

    barrier(localMemeFence);
    // lift from surface integration to volume nodes
    for(int es=0;es<p_NblockS4;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
        dfloat rhsu[p_NnodesS4], rhsv[p_NnodesS4];

        if(n<p_Np){
          #pragma unroll p_NnodesS4
         for(int em=0;em<p_NnodesS4;++em){
			const int e = eo+es*p_NnodesS4+em;
			const int id = e*p_Np+n;
			rhsu[em] = rhsU[id];
			rhsv[em] = rhsV[id];
          }
        //
          #pragma unroll p_intNfpNfaces
          for(int m=0;m<p_intNfpNfaces;++m){
            const dfloat L = intLIFTT[n+m*p_Np];
            #pragma unroll p_NnodesS4
            for(int em=0;em<p_NnodesS4;++em){
              rhsu[em] += L*s_iFluxU[em][es][m];
              rhsv[em] += L*s_iFluxV[em][es][m];
           }
         }

        #pragma unroll p_NnodesS4
       for(int em=0;em<p_NnodesS4;++em){
        int e = eo+es*p_NnodesS4+em;
          if(e<Nelements){
            const int id = e*p_Np+n;
            rhsU[id]   = rhsu[em]; // note  change in sign
            rhsV[id]   = rhsv[em];    

           }
        }
        }
      }
    }
  #undef s_iFluxU
  #undef s_iFluxV   

  }

}







// Optimized sizes for @kernel 5
#if p_N==1
#define p_NblockS5 8
#define p_NnodesS5 4
#endif

#if p_N==2
#define p_NblockS5 2
#define p_NnodesS5 3
#endif

#if p_N==3
#define p_NblockS5 4
#define p_NnodesS5 5
#endif

#if p_N==4
#define p_NblockS5 2
#define p_NnodesS5 3
#endif

#if p_N==5
#define p_NblockS5 4
#define p_NnodesS5 5
#endif

#if p_N==6
#define p_NblockS5 4
#define p_NnodesS5 5
#endif

#if p_N==7
#define p_NblockS5 5
#define p_NnodesS5 2
#endif

#if p_N==8
#define p_NblockS5 1
#define p_NnodesS5 4
#endif

#if p_N==9
#define p_NblockS5 3
#define p_NnodesS5 2
#endif

#if p_N==10
#define p_NblockS5 2
#define p_NnodesS5 3
#endif



// add "@restrict to p_Np thread"  to @kernel 5
@kernel void insSubCycleCubatureSurface2D_v8(const int Nelements,
                                            @restrict const  dfloat *  sgeo,
                                            @restrict const  dfloat *  intInterpT, // interpolate to integration nodes
                                            @restrict const  dfloat *  intLIFTT, // lift from integration to interpolation nodes
                                            @restrict const  int   *  vmapM,
                                            @restrict const  int   *  vmapP,
                                            @restrict const  int   *  EToB,
                                            const dfloat time,
                                            @restrict const  dfloat *  intx, // integration nodes
                                            @restrict const  dfloat *  inty,
                                            @restrict const  dfloat *  U,
                                            @restrict const  dfloat *  V,
                                            @restrict const  dfloat *  Ud,
                                            @restrict const  dfloat *  Vd,
                                            @restrict dfloat *  rhsU,
                                            @restrict dfloat *  rhsV){
  // for all elements
  for(int eo=0;eo<Nelements;eo+=p_NblocksS5*p_NnodesS5;@outer(0)){

    // @shared storage for flux terms
    @shared dfloat s_U[p_NnodesS5][p_NblocksS5][p_intNfpNfaces];
    @shared dfloat s_V[p_NnodesS5][p_NblocksS5][p_intNfpNfaces];
    @shared dfloat s_Ud[p_NnodesS5][p_NblocksS5][p_NfacesNfp];
    @shared dfloat s_Vd[p_NnodesS5][p_NblocksS5][p_NfacesNfp];

    #define s_iFluxU s_U // Reuse @shared memory arrays
    #define s_iFluxV s_V

    @exclusive dfloat r_iUM[p_NnodesS5],  r_iUP[p_NnodesS5];
    @exclusive dfloat r_iVM[p_NnodesS5],  r_iVP[p_NnodesS5];
    @exclusive dfloat r_iUdM[p_NnodesS5], r_iUdP[p_NnodesS5];
    @exclusive dfloat r_iVdM[p_NnodesS5], r_iVdP[p_NnodesS5];

   //@shared dfloat s_sgeo[p_NnodesS5][p_NblocksS5][p_Nfaces][p_Nsgeo];
   //@shared dfloat s_intInterpT[p_Nfaces*p_intNfp*p_Nfp];
    
    for (int es=0;es<p_NblocksS5;++es;@inner(1)){
      for (int n=0;n<p_Np;++n;@inner(0)) { //all faces*facenodes on this element
        int m = n + p_Np*es;
       // if(e<Nelements){
       //    int m = n + p_Np*es;
       //    // oad surface geofacs for all faces of all elements in block(s)
       //    while(m<p_NblockS4*p_Nfaces*p_Nsgeo*p_NnodesS4){
       //      const int id = eo*p_Nfaces*p_Nsgeo+ m;
       //       s_sgeo[0][0][0][m] = sgeo[id];
       //       m+=p_Np*p_NblockS4;
       //   }
     
       //    if (es==0 && em==0) {
       //      for(int m=n;m<p_Nfaces*p_Nfp*p_Nfp;m+=p_Np){
       //      s_intInterpT[m] = intInterpT[m];
       //      }
       //    }
       //  }
        
        #pragma unroll p_NnodesS5
        for (int em=0;em<p_NnodesS5;++em){
          const int e = em*p_NblocksS5 + es + eo;
          if(e<Nelements){
            for(int m=n;m<p_Nfaces*p_Nfp;m+=p_Np){
              // indices of negative and positive traces of face node
              const int id  = e*p_Nfp*p_Nfaces + m;

              const int idM = vmapM[id];
              // load negative and positive trace node values of velocity
              s_U[em][es][m] = U[idM];
              s_V[em][es][m] = V[idM];
              s_Ud[em][es][m] = Ud[idM];
              s_Vd[em][es][m] = Vd[idM];
            }
          }
        }
      }
    }

    @barrier("local");







    for (int es=0;es<p_NblocksS5;++es;@inner(1)){
      for (int n=0;n<p_Np;++n;@inner(0)) { //all faces*facenodes on this element
        int m = n + p_Np*es;        
        #pragma unroll p_NnodesS5
        for (int em=0;em<p_NnodesS5;++em){
          const int e = em*p_NblocksS5 + es + eo;
          if(e<Nelements){
            for(int m=n;m<p_Nfaces*p_Nfp;m+=p_Np){
              // indices of negative and positive traces of face node
              const int id  = e*p_Nfp*p_Nfaces + m;
              const int idP = vmapP[id];
              // load negative and positive trace node values of velocity
              s_U[em][es][m] = U[idP];
              s_V[em][es][m] = V[idP];
              s_Ud[em][es][m] = Ud[idP];
              s_Vd[em][es][m] = Vd[idP];
            }
          }
        }
      }
    }

    @barrier("local");






    // interpolate to surface integration nodes
    for(int es=0;es<p_NblocksS5;++es;@inner(1)){
      for(int n=0;n<p_Np;++n;@inner(0)){ 
        
        dfloat iUM [p_NnodesS5], iVM [p_NnodesS5];
        dfloat iUP [p_NnodesS5], iVP [p_NnodesS5];
        dfloat iUdM[p_NnodesS5], iVdM[p_NnodesS5];
        dfloat iUdP[p_NnodesS5], iVdP[p_NnodesS5];

        for(int m=n;m<p_Nfaces*p_intNfp;m+=p_Np){

          #pragma unroll p_NnodesS5
          for (int et=0;et<p_NnodesS5;++et){
            iUM [et] = 0.f, iVM [et] = 0.f;
            iUP [et] = 0.f, iVP [et] = 0.f;
            iUdM[et] = 0.f, iVdM[et] = 0.f;
            iUdP[et] = 0.f, iVdP[et] = 0.f;
          }
      
          const int face = m/p_intNfp; // find face that owns this integration node
          // local block interpolation (face nodes to integration nodes)
          #pragma unroll p_Nfp
            for(int k=0;k<p_Nfp;++k){
              const dfloat iInm = intInterpT[m+k*p_Nfaces*p_intNfp];
              const int fm = face*p_Nfp+k;

              #pragma unroll p_NnodesS5
              for (int et=0;et<p_NnodesS5;++et){

                iUM [et] += iInm* s_UM[et][es][fm];
                iVM [et] += iInm* s_VM[et][es][fm];
                iUdM[et] += iInm*s_UdM[et][es][fm];
                iVdM[et] += iInm*s_VdM[et][es][fm];

                iUP [et] += iInm* s_UP[et][es][fm];
                iVP [et] += iInm* s_VP[et][es][fm];
                iUdP[et] += iInm*s_UdP[et][es][fm];
                iVdP[et] += iInm*s_VdP[et][es][fm];
              }
            }

          #pragma unroll p_NnodesS5
          for (int et=0;et<p_NnodesS5;++et){
            const int e = et*p_NblocksS5 + es + eo;
            if (e<Nelements) {
              // load surface geofactors for this face
              const dfloat nx   = s_sgeo[et][es][face][p_NXID];
              const dfloat ny   = s_sgeo[et][es][face][p_NYID];
              const dfloat sJ   = s_sgeo[et][es][face][p_SJID];
              const dfloat invJ = s_sgeo[et][es][face][p_IJID];

              // apply boundary conditions
              const int bc = EToB[face+p_Nfaces*e];
              if(bc>0){
                insAdvectionBoundaryConditions2D(bc,time, intx[m+e*p_Nfaces*p_intNfp], inty[m+e*p_Nfaces*p_intNfp], nx, ny, iUdM[et],iVdM[et], &(iUdP[et]), &(iVdP[et]));
              }

              // Find max normal velocity on the face
              const dfloat unm   = fabs(nx*iUM[et]+ ny*iVM[et]);
              const dfloat unp   = fabs(nx*iUP[et]+ ny*iVP[et]);    
              const dfloat unmax = (unm > unp) ? unm : unp;

              // evaluate "flux" terms: LLF
              const dfloat sc = 0.5f*invJ*sJ ;

              s_iFluxU[et][es][m] = sc*(nx*(iUP[et]*iUdP[et] + iUM[et]*iUdM[et]) 
                                   +ny*(iVP[et]*iUdP[et] + iVM[et]*iUdM[et]) 
                                   +unmax*(iUdM[et]-iUdP[et]));

              s_iFluxV[et][es][m] = sc*(nx*(iUP[et]*iVdP[et] + iUM[et]*iVdM[et]) 
                                  + ny*(iVP[et]*iVdP[et] + iVM[et]*iVdM[et]) 
                                  + unmax*(iVdM[et]-iVdP[et]));
            }
          }
        }
      }
    }

    @barrier("local");

    // lift from surface integration to volume nodes
    for(int es=0;es<p_NblocksS5;++es;@inner(1)){
      for(int n=0;n<p_Np;++n;@inner(0)){
        
        dfloat rhsu[p_NnodesS5];
        dfloat rhsv[p_NnodesS5];
        
        #pragma unroll p_NnodesS5
        for (int et=0;et<p_NnodesS5;++et){
          rhsu[et] = 0;
          rhsv[et] = 0;
        }
        
        #pragma unroll p_intNfpNfaces
          for(int m=0;m<p_intNfpNfaces;++m){
            const dfloat L = intLIFTT[n+m*p_Np];
            #pragma unroll p_NnodesS5
            for (int et=0;et<p_NnodesS5;++et){
              rhsu[et] += L*s_iFluxU[et][es][m];
              rhsv[et] += L*s_iFluxV[et][es][m];
            }
          }
        
        #pragma unroll p_NnodesS5
        for (int et=0;et<p_NnodesS5;++et){
          const int e = et*p_NblocksS5 + es + eo;
          if(e<Nelements){
            const int id = n + p_Np*e;
            rhsU[id] += rhsu[et];
            rhsV[id] += rhsv[et];
          }
        }
      }
    }
  }
}


























/*


// Optimized sizes for @kernel 5
#if p_N==1
#define p_NblockS3 10
#define p_NnodesS3 2
#endif

#if p_N==2
#define p_NblockS3 8
#define p_NnodesS3 2
#endif

#if p_N==3
#define p_NblockS3 7
#define p_NnodesS3 2
#endif

#if p_N==4
#define p_NblockS3 3
#define p_NnodesS3 3
#endif

#if p_N==5
#define p_NblockS3 1
#define p_NnodesS3 3
#endif

#if p_N==6
#define p_NblockS3 2
#define p_NnodesS3 2
#endif

#if p_N==7
#define p_NblockS3 5
#define p_NnodesS3 2
#endif

#if p_N==8
#define p_NblockS3 4
#define p_NnodesS3 3
#endif

#if p_N==9
#define p_NblockS3 1
#define p_NnodesS3 3
#endif

#if p_N==10
#define p_NblockS3 7
#define p_NnodesS3 2
#endif


// Based on 4; Add multiple nodes // use all @shared memory
@kernel void insSubCycleCubatureSurface2D_v6(const int Nelements,
              @restrict const  dfloat *  sgeo,
              @restrict const  dfloat *  intInterpT, // interpolate to integration nodes
              @restrict const  dfloat *  intLIFTT, // lift from integration to interpolation nodes
              @restrict const  int   *  vmapM,
              @restrict const  int   *  vmapP,
              @restrict const  int   *  EToB,
              const dfloat time,
              @restrict const  dfloat *  intx, // integration nodes
              @restrict const  dfloat *  inty,
              @restrict const  dfloat *  U,
              @restrict const  dfloat *  V,
              @restrict const  dfloat *  Ud,
              @restrict const  dfloat *  Vd,
              @restrict dfloat *  rhsU,
              @restrict dfloat *  rhsV){
  // for all elements
  for(int eo=0;eo<Nelements;eo+=(p_NblockS3*p_NnodesS3);@outer(0)){

    // @shared storage 
    @shared dfloat s_U[p_NnodesS3][p_NblockS3][p_intNfpNfaces];
    @shared dfloat s_V[p_NnodesS3][p_NblockS3][p_intNfpNfaces];
    
    @shared dfloat s_Ud[p_NnodesS3][p_NblockS3][p_NfacesNfp];
    @shared dfloat s_Vd[p_NnodesS3][p_NblockS3][p_NfacesNfp];

    #define s_iFluxU s_U // Reuse @shared memory arrays
    #define s_iFluxV s_V

    @exclusive dfloat r_iUM[p_NnodesS3],  r_iUP[p_NnodesS3];
    @exclusive dfloat r_iVM[p_NnodesS3],  r_iVP[p_NnodesS3];
    @exclusive dfloat r_iUdM[p_NnodesS3], r_iUdP[p_NnodesS3];
    @exclusive dfloat r_iVdM[p_NnodesS3], r_iVdP[p_NnodesS3];


//     @shared dfloat s_sgeo[p_NnodesS3][p_NblockS3][p_Nfaces][p_Nsgeo];
//     @shared dfloat s_intInterpT[p_Nfaces*p_intNfp*p_Nfp];
    
    // for all face nodes of all elements
    for(int es=0;es<p_NblockS3;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){

        #pragma unroll p_NnodesS3
     for(int em=0;em<p_NnodesS3;++em){ 
                
      const int e   = eo + es*p_NnodesS3 + em; 
      const int id  = e*p_NfacesNfp + n;

       // if(e<Nelements && n<p_Np ){
       //    int m = n + p_Np*es;
       //    // oad surface geofacs for all faces of all elements in block(s)
       //    while(m<p_NblockS3*p_Nfaces*p_Nsgeo*p_NnodesS3){
       //      const int id = eo*p_Nfaces*p_Nsgeo+ m;
       //       s_sgeo[0][0][0][m] = sgeo[id];
       //       m+=p_Np*p_NblockS3;
       //   }
          
       //    if (es==0 && em==0) {
       //      for(int m=n;m<p_Nfaces*p_Nfp*p_Nfp;m+=p_Np){
       //      s_intInterpT[m] = intInterpT[m];
       //      }
       //    }
       //  }

      if(e<Nelements && n<p_NfacesNfp ){
        int idM = vmapM[id];
        // //load negative and positive trace node values of velocity
        s_U[em][es][n]  = U[idM];
        s_V[em][es][n]  = V[idM];
        s_Ud[em][es][n] = Ud[idM];
        s_Vd[em][es][n] = Vd[idM];
        }        
     }
    }
    }

    @barrier("local");

    // interpolate to surface integration nodes
    for(int es=0;es<p_NblockS3;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 
        if(n<(p_Nfaces*p_intNfp)){
           const int face = n/p_intNfp;       
            #pragma unroll p_NnodesS3
            for(int em=0;em<p_NnodesS3;++em){
              r_iUM [em] = 0.f;  
              r_iVM [em] = 0.f;  
              r_iUdM[em] = 0.f; 
              r_iVdM[em] = 0.f;              
            }

          // local block interpolation (face nodes to integration nodes)
          #pragma unroll p_Nfp
          for(int m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            //const dfloat iInm = s_intInterpT[n+m*p_Nfaces*p_intNfp];
            const int fm = face*p_Nfp + m;
            #pragma unroll p_NnodesS3
              for(int em=0;em<p_NnodesS3;++em){
              r_iUM [em] += iInm*s_U[em][es][fm];
              r_iVM [em] += iInm*s_V[em][es][fm];
              r_iUdM[em] += iInm*s_Ud[em][es][fm];
              r_iVdM[em] += iInm*s_Vd[em][es][fm];
            }
          }
        }
      }
    }
    
    @barrier("local");



    // for all face nodes of all elements
    for(int es=0;es<p_NblockS3;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
      #pragma unroll p_NnodesS3
      for(int em=0;em<p_NnodesS3;++em){           
       const int e   = eo + es*p_NnodesS3 + em; 
       const int id  = e*p_NfacesNfp + n;
      if(e<Nelements && n<p_NfacesNfp ){
        int idP = vmapP[id];
        // //load negative and positive trace node values of velocity
        s_U[em][es][n]  = U[idP];
        s_V[em][es][n]  = V[idP];
        s_Ud[em][es][n] = Ud[idP];
        s_Vd[em][es][n] = Vd[idP];
        }        
     }
    }
    }

    @barrier("local");

    // interpolate to surface integration nodes
    for(int es=0;es<p_NblockS3;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 
        if(n<(p_Nfaces*p_intNfp)){
           const int face = n/p_intNfp;       
            #pragma unroll p_NnodesS3
            for(int em=0;em<p_NnodesS3;++em){
              r_iUP [em] = 0.f;  
              r_iVP [em] = 0.f;  
              r_iUdP[em] = 0.f; 
              r_iVdP[em] = 0.f;              
            }

          // local block interpolation (face nodes to integration nodes)
          #pragma unroll p_Nfp
          for(int m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            //const dfloat iInm = s_intInterpT[n+m*p_Nfaces*p_intNfp];
            const int fm = face*p_Nfp + m;
            #pragma unroll p_NnodesS3
              for(int em=0;em<p_NnodesS3;++em){
              r_iUP [em] += iInm*s_U[em][es][fm];
              r_iVP [em] += iInm*s_V[em][es][fm];
              r_iUdP[em] += iInm*s_Ud[em][es][fm];
              r_iVdP[em] += iInm*s_Vd[em][es][fm];
            }
          }
        }
      }
    }
    
    @barrier("local");


     // interpolate to surface integration nodes
    for(int es=0;es<p_NblockS3;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 
        if(n<(p_Nfaces*p_intNfp)){
          const int face = n/p_intNfp;       
          #pragma unroll p_NnodesS3
          for(int em=0;em<p_NnodesS3;++em){
            const int e   = eo + es*p_NnodesS3 + em; 

            // load surface geofactors for this face
            const int sid    = p_Nsgeo*(e*p_Nfaces+face);
            const dfloat nx   = sgeo[sid+p_NXID];
            const dfloat ny   = sgeo[sid+p_NYID];
            const dfloat sJ   = sgeo[sid+p_SJID];
            const dfloat invJ = sgeo[sid+p_IJID];


            // const dfloat nx   = s_sgeo[em][es][face][p_NXID];
            // const dfloat ny   = s_sgeo[em][es][face][p_NYID];
            // const dfloat sJ   = s_sgeo[em][es][face][p_SJID];
            // const dfloat invJ   = s_sgeo[em][es][face][p_IJID];
        
            const int bc = EToB[face+p_Nfaces*e];
            // if(bc>0){
            //   insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, r_iUdM,r_iVdM, &r_iUdP[em], &r_iVdP[em]);
            // }

            const dfloat sc = sJ*invJ; 
            //Find max normal velocity on the face
            const dfloat unm   = fabs(nx*r_iUM[em] + ny*r_iVM[em]);
            const dfloat unp   = fabs(nx*r_iUP[em] + ny*r_iVP[em]);    
            const dfloat unmax = (unm > unp) ? unm : unp;

            s_iFluxU[em][es][n] = sc*(.5f*(nx*(r_iUP[em]*r_iUdP[em] + r_iUM[em]*r_iUdM[em]) 
                   +ny*(r_iVP[em]*r_iUdP[em] + r_iVM[em]*r_iUdM[em]) 
                   +unmax*(r_iUdM[em]- r_iUdP[em]) ));

            s_iFluxV[em][es][n] = sc*(.5f*(nx*(r_iUP[em]*r_iVdP[em] + r_iUM[em]*r_iVdM[em]) 
                   +ny*(r_iVP[em]*r_iVdP[em] + r_iVM[em]*r_iVdM[em]) 
                   +unmax*(r_iVdM[em]-r_iVdP[em]) ));
           }
        }
      }
    }

    barrier(localMemeFence);
    // lift from surface integration to volume nodes
    for(int es=0;es<p_NblockS3;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
        dfloat rhsu[p_NnodesS3], rhsv[p_NnodesS3];

        if(n<p_Np){
          #pragma unroll p_NnodesS3
         for(int em=0;em<p_NnodesS3;++em){
          rhsu[em] = 0.f;
          rhsv[em] = 0.f;
          }
        //
          #pragma unroll p_intNfpNfaces
          for(int m=0;m<p_intNfpNfaces;++m){
            const dfloat L = intLIFTT[n+m*p_Np];
            #pragma unroll p_NnodesS3
            for(int em=0;em<p_NnodesS3;++em){
              rhsu[em] += L*s_iFluxU[em][es][m];
              rhsv[em] += L*s_iFluxV[em][es][m];
           }
         }

        #pragma unroll p_NnodesS3
       for(int em=0;em<p_NnodesS3;++em){
        int e = eo+es*p_NnodesS3+em;
          if(e<Nelements){
            const int id = e*p_Np+n;
            rhsU[id]   += rhsu[em]; // note  change in sign
            rhsV[id]   += rhsv[em];    

           }
        }
        }
      }
    }
  #undef s_iFluxU
  #undef s_iFluxV   

  }

}



// Optimized sizes for @kernel 5
#if p_N==1
#define p_NblockS4 8
#define p_NnodesS4 4
#endif

#if p_N==2
#define p_NblockS4 2
#define p_NnodesS4 3
#endif

#if p_N==3
#define p_NblockS4 4
#define p_NnodesS4 5
#endif

#if p_N==4
#define p_NblockS4 2
#define p_NnodesS4 3
#endif

#if p_N==5
#define p_NblockS4 4
#define p_NnodesS4 5
#endif

#if p_N==6
#define p_NblockS4 4
#define p_NnodesS4 5
#endif

#if p_N==7
#define p_NblockS4 5
#define p_NnodesS4 2
#endif

#if p_N==8
#define p_NblockS4 1
#define p_NnodesS4 4
#endif

#if p_N==9
#define p_NblockS4 3
#define p_NnodesS4 2
#endif

#if p_N==10
#define p_NblockS4 2
#define p_NnodesS4 3
#endif



// Based on 4; Add multiple nodes // use all @shared memory

@kernel void insSubCycleCubatureSurface2D_v7(const int Nelements,
              @restrict const  dfloat *  sgeo,
              @restrict const  dfloat *  intInterpT, // interpolate to integration nodes
              @restrict const  dfloat *  intLIFTT, // lift from integration to interpolation nodes
              @restrict const  int   *  vmapM,
              @restrict const  int   *  vmapP,
              @restrict const  int   *  EToB,
              const dfloat time,
              @restrict const  dfloat *  intx, // integration nodes
              @restrict const  dfloat *  inty,
              @restrict const  dfloat2 *  UM,
              @restrict const  dfloat2 *  UP,
              @restrict const  dfloat2 *  UdM,
              @restrict const  dfloat2 *  UdP,
              @restrict dfloat *  rhsU,
              @restrict dfloat *  rhsV){
  // for all elements
  for(int eo=0;eo<Nelements;eo+=(p_NblockS4*p_NnodesS4);@outer(0)){

    // @shared storage 
    @shared dfloat s_U[p_NnodesS4][p_NblockS4][p_intNfpNfaces];
    @shared dfloat s_V[p_NnodesS4][p_NblockS4][p_intNfpNfaces];
    
    @shared dfloat s_Ud[p_NnodesS4][p_NblockS4][p_NfacesNfp];
    @shared dfloat s_Vd[p_NnodesS4][p_NblockS4][p_NfacesNfp];

    #define s_iFluxU s_U // Reuse @shared memory arrays
    #define s_iFluxV s_V

    @exclusive dfloat r_iUM[p_NnodesS4],  r_iUP[p_NnodesS4];
    @exclusive dfloat r_iVM[p_NnodesS4],  r_iVP[p_NnodesS4];
    @exclusive dfloat r_iUdM[p_NnodesS4], r_iUdP[p_NnodesS4];
    @exclusive dfloat r_iVdM[p_NnodesS4], r_iVdP[p_NnodesS4];
    
    // for all face nodes of all elements
    for(int es=0;es<p_NblockS4;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){

        #pragma unroll p_NnodesS4
     for(int em=0;em<p_NnodesS4;++em){ 
                
      const int e   = eo + es*p_NnodesS4 + em; 
      const int id  = e*p_NfacesNfp + n;

      if(e<Nelements && n<p_NfacesNfp ){
        //int idM = vmapM[id];
        // //load negative and positive trace node values of velocity
        // s_U[em][es][n]  = U[idM];
        // s_V[em][es][n]  = V[idM];
        // s_Ud[em][es][n] = Ud[idM];
        // s_Vd[em][es][n] = Vd[idM];
        dfloat2 um  = UM[id];
        dfloat2 udm = UdM[id];

        s_U[em][es][n]  = um.x;
        s_V[em][es][n]  = um.y;
        s_Ud[em][es][n] = udm.x;
        s_Vd[em][es][n] = udm.y;


        }        
     }
    }
    }

    @barrier("local");

    // interpolate to surface integration nodes
    for(int es=0;es<p_NblockS4;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 
        if(n<(p_Nfaces*p_intNfp)){
           const int face = n/p_intNfp;       
            #pragma unroll p_NnodesS4
            for(int em=0;em<p_NnodesS4;++em){
              r_iUM [em] = 0.f;  
              r_iVM [em] = 0.f;  
              r_iUdM[em] = 0.f; 
              r_iVdM[em] = 0.f;              
            }

          // local block interpolation (face nodes to integration nodes)
          #pragma unroll p_Nfp
          for(int m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            //const dfloat iInm = s_intInterpT[n+m*p_Nfaces*p_intNfp];
            const int fm = face*p_Nfp + m;
            #pragma unroll p_NnodesS4
              for(int em=0;em<p_NnodesS4;++em){
              r_iUM [em] += iInm*s_U[em][es][fm];
              r_iVM [em] += iInm*s_V[em][es][fm];
              r_iUdM[em] += iInm*s_Ud[em][es][fm];
              r_iVdM[em] += iInm*s_Vd[em][es][fm];
            }
          }
        }
      }
    }
    
    @barrier("local");



    // for all face nodes of all elements
    for(int es=0;es<p_NblockS4;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
      #pragma unroll p_NnodesS4
      for(int em=0;em<p_NnodesS4;++em){           
       const int e   = eo + es*p_NnodesS4 + em; 
       const int id  = e*p_NfacesNfp + n;
      if(e<Nelements && n<p_NfacesNfp ){
        // int idP = vmapP[id];
        // // //load negative and positive trace node values of velocity
        // s_U[em][es][n]  = U[idP];
        // s_V[em][es][n]  = V[idP];
        // s_Ud[em][es][n] = Ud[idP];
        // s_Vd[em][es][n] = Vd[idP];

        dfloat2 up  = UP[id];
        dfloat2 udp = UdP[id];

        s_U[em][es][n]  = up.x;
        s_V[em][es][n]  = up.y;
        s_Ud[em][es][n] = udp.x;
        s_Vd[em][es][n] = udp.y;
        }        
     }
    }
    }

    @barrier("local");

    // interpolate to surface integration nodes
    for(int es=0;es<p_NblockS4;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 
        if(n<(p_Nfaces*p_intNfp)){
           const int face = n/p_intNfp;       
            #pragma unroll p_NnodesS4
            for(int em=0;em<p_NnodesS4;++em){
              r_iUP [em] = 0.f;  
              r_iVP [em] = 0.f;  
              r_iUdP[em] = 0.f; 
              r_iVdP[em] = 0.f;              
            }

          // local block interpolation (face nodes to integration nodes)
          #pragma unroll p_Nfp
          for(int m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            //const dfloat iInm = s_intInterpT[n+m*p_Nfaces*p_intNfp];
            const int fm = face*p_Nfp + m;
            #pragma unroll p_NnodesS4
              for(int em=0;em<p_NnodesS4;++em){
              r_iUP [em] += iInm*s_U[em][es][fm];
              r_iVP [em] += iInm*s_V[em][es][fm];
              r_iUdP[em] += iInm*s_Ud[em][es][fm];
              r_iVdP[em] += iInm*s_Vd[em][es][fm];
            }
          }
        }
      }
    }
    
    @barrier("local");


     // interpolate to surface integration nodes
    for(int es=0;es<p_NblockS4;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 
        if(n<(p_Nfaces*p_intNfp)){
          const int face = n/p_intNfp;       
          #pragma unroll p_NnodesS4
          for(int em=0;em<p_NnodesS4;++em){
            const int e   = eo + es*p_NnodesS4 + em; 

            // load surface geofactors for this face
            const int sid    = p_Nsgeo*(e*p_Nfaces+face);
            const dfloat nx   = sgeo[sid+p_NXID];
            const dfloat ny   = sgeo[sid+p_NYID];
            const dfloat sJ   = sgeo[sid+p_SJID];
            const dfloat invJ = sgeo[sid+p_IJID];
       
            const int bc = EToB[face+p_Nfaces*e];
            // if(bc>0){
            //   insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, r_iUdM,r_iVdM, &r_iUdP[em], &r_iVdP[em]);
            // }

            const dfloat sc = sJ*invJ; 
            //Find max normal velocity on the face
            const dfloat unm   = fabs(nx*r_iUM[em] + ny*r_iVM[em]);
            const dfloat unp   = fabs(nx*r_iUP[em] + ny*r_iVP[em]);    
            const dfloat unmax = (unm > unp) ? unm : unp;

            s_iFluxU[em][es][n] = sc*(.5f*(nx*(r_iUP[em]*r_iUdP[em] + r_iUM[em]*r_iUdM[em]) 
                   +ny*(r_iVP[em]*r_iUdP[em] + r_iVM[em]*r_iUdM[em]) 
                   +unmax*(r_iUdM[em]- r_iUdP[em]) ));

            s_iFluxV[em][es][n] = sc*(.5f*(nx*(r_iUP[em]*r_iVdP[em] + r_iUM[em]*r_iVdM[em]) 
                   +ny*(r_iVP[em]*r_iVdP[em] + r_iVM[em]*r_iVdM[em]) 
                   +unmax*(r_iVdM[em]-r_iVdP[em]) ));
           }
        }
      }
    }

    barrier(localMemeFence);
    // lift from surface integration to volume nodes
    for(int es=0;es<p_NblockS4;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
        dfloat rhsu[p_NnodesS4], rhsv[p_NnodesS4];

        if(n<p_Np){
          #pragma unroll p_NnodesS4
         for(int em=0;em<p_NnodesS4;++em){
          rhsu[em] = 0.f;
          rhsv[em] = 0.f;
          }
        //
          #pragma unroll p_intNfpNfaces
          for(int m=0;m<p_intNfpNfaces;++m){
            const dfloat L = intLIFTT[n+m*p_Np];
            #pragma unroll p_NnodesS4
            for(int em=0;em<p_NnodesS4;++em){
              rhsu[em] += L*s_iFluxU[em][es][m];
              rhsv[em] += L*s_iFluxV[em][es][m];
           }
         }

        #pragma unroll p_NnodesS4
       for(int em=0;em<p_NnodesS4;++em){
        int e = eo+es*p_NnodesS4+em;
          if(e<Nelements){
            const int id = e*p_Np+n;
            rhsU[id]   += rhsu[em]; // note  change in sign
            rhsV[id]   += rhsv[em];    

           }
        }
        }
      }
    }
  #undef s_iFluxU
  #undef s_iFluxV   

  }

}


// Based on 4; Add multiple nodes // use all @shared memory

@kernel void insSubCycleCubatureSurface2D_v8(const int Nelements,
              @restrict const  dfloat *  sgeo,
              @restrict const  dfloat *  intInterpT, // interpolate to integration nodes
              @restrict const  dfloat *  intLIFTT, // lift from integration to interpolation nodes
              @restrict const  int   *  vmapM,
              @restrict const  int   *  vmapP,
              @restrict const  int   *  EToB,
              const dfloat time,
              @restrict const  dfloat *  intx, // integration nodes
              @restrict const  dfloat *  inty,
              @restrict const  dfloat *  U,
              @restrict const  dfloat *  V,
              @restrict const  dfloat *  Ud,
              @restrict const  dfloat *  Vd,
              @restrict dfloat *  rhsU,
              @restrict dfloat *  rhsV){
  // for all elements
  for(int eo=0;eo<Nelements;eo+=(p_NblockS5*p_NnodesS5);@outer(0)){

    // @shared storage 
    @shared dfloat s_U[p_NnodesS5][p_NblockS5][p_intNfpNfaces];
    @shared dfloat s_V[p_NnodesS5][p_NblockS5][p_intNfpNfaces];
   
    #define s_iFluxU s_U // Reuse @shared memory arrays
    #define s_iFluxV s_V

    @exclusive dfloat r_iUM[p_NnodesS5],  r_iUP[p_NnodesS5];
    @exclusive dfloat r_iVM[p_NnodesS5],  r_iVP[p_NnodesS5];
    @exclusive dfloat r_iUdM[p_NnodesS5], r_iUdP[p_NnodesS5];
    @exclusive dfloat r_iVdM[p_NnodesS5], r_iVdP[p_NnodesS5];

    @exclusive int idM[p_NnodesS5], idP[p_NnodesS5]; 


//     @shared dfloat s_sgeo[p_NnodesS5][p_NblockS5][p_Nfaces][p_Nsgeo];
//     @shared dfloat s_intInterpT[p_Nfaces*p_intNfp*p_Nfp];
    
    // for all face nodes of all elements
    for(int es=0;es<p_NblockS5;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){

      #pragma unroll p_NnodesS5
        for(int em=0;em<p_NnodesS5;++em){ 
                
        const int e   = eo + es*p_NnodesS5 + em; 
        const int id  = e*p_NfacesNfp + n;

        if(e<Nelements && n<p_NfacesNfp ){
          idM[em] = vmapM[id];
          // //load negative and positive trace node values of velocity
          s_U[em][es][n]  = U[idM[em]];
          s_V[em][es][n]  = V[idM[em]];
          }        
       }
      }
    }

    @barrier("local");

    // interpolate to surface integration nodes
    for(int es=0;es<p_NblockS5;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 
        if(n<(p_Nfaces*p_intNfp)){
           const int face = n/p_intNfp;       
            #pragma unroll p_NnodesS5
            for(int em=0;em<p_NnodesS5;++em){
              r_iUM [em] = 0.f;  
              r_iVM [em] = 0.f;          
            }

          // local block interpolation (face nodes to integration nodes)
          #pragma unroll p_Nfp
          for(int m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            //const dfloat iInm = s_intInterpT[n+m*p_Nfaces*p_intNfp];
            const int fm = face*p_Nfp + m;
            #pragma unroll p_NnodesS5
              for(int em=0;em<p_NnodesS5;++em){
              r_iUM[em] += iInm*s_U[em][es][fm];
              r_iVM[em] += iInm*s_V[em][es][fm];
            }
          }
        }
      }
    }
    
  
    @barrier("local");

    // for all face nodes of all elements
    for(int es=0;es<p_NblockS5;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){

        #pragma unroll p_NnodesS5
     for(int em=0;em<p_NnodesS5;++em){ 
                
      const int e   = eo + es*p_NnodesS5 + em; 
      const int id  = e*p_NfacesNfp + n;

      if(e<Nelements && n<p_NfacesNfp ){
        s_U[em][es][n]  = Ud[idM[em]];
        s_V[em][es][n]  = Vd[idM[em]];
        }        
     }
    }
    }

    @barrier("local");

    // interpolate to surface integration nodes
    for(int es=0;es<p_NblockS5;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 
        if(n<(p_Nfaces*p_intNfp)){
           const int face = n/p_intNfp;       
            #pragma unroll p_NnodesS5
            for(int em=0;em<p_NnodesS5;++em){
              r_iUdM[em] = 0.f; 
              r_iVdM[em] = 0.f;              
            }

          // local block interpolation (face nodes to integration nodes)
          #pragma unroll p_Nfp
          for(int m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            //const dfloat iInm = s_intInterpT[n+m*p_Nfaces*p_intNfp];
            const int fm = face*p_Nfp + m;
            #pragma unroll p_NnodesS5
              for(int em=0;em<p_NnodesS5;++em){
              r_iUdM[em] += iInm*s_U[em][es][fm];
              r_iVdM[em] += iInm*s_V[em][es][fm];
            }
          }
        }
      }
    }
    


    @barrier("local");




    // for all face nodes of all elements
    for(int es=0;es<p_NblockS5;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
      #pragma unroll p_NnodesS5
      for(int em=0;em<p_NnodesS5;++em){           
       const int e   = eo + es*p_NnodesS5 + em; 
       const int id  = e*p_NfacesNfp + n;
      if(e<Nelements && n<p_NfacesNfp ){
        idP[em] = vmapP[id];
        // //load negative and positive trace node values of velocity
        s_U[em][es][n]  = U[idP[em]];
        s_V[em][es][n]  = V[idP[em]];
        }        
     }
    }
    }

    @barrier("local");

    // interpolate to surface integration nodes
    for(int es=0;es<p_NblockS5;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 
        if(n<(p_Nfaces*p_intNfp)){
           const int face = n/p_intNfp;       
            #pragma unroll p_NnodesS5
            for(int em=0;em<p_NnodesS5;++em){
              r_iUP [em] = 0.f;  
              r_iVP [em] = 0.f;            
            }

          // local block interpolation (face nodes to integration nodes)
          #pragma unroll p_Nfp
          for(int m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            //const dfloat iInm = s_intInterpT[n+m*p_Nfaces*p_intNfp];
            const int fm = face*p_Nfp + m;
            #pragma unroll p_NnodesS5
              for(int em=0;em<p_NnodesS5;++em){
              r_iUP [em] += iInm*s_U[em][es][fm];
              r_iVP [em] += iInm*s_V[em][es][fm];
            }
          }
        }
      }
    }
    
    @barrier("local");



     // for all face nodes of all elements
    for(int es=0;es<p_NblockS5;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
      #pragma unroll p_NnodesS5
      for(int em=0;em<p_NnodesS5;++em){           
       const int e   = eo + es*p_NnodesS5 + em; 
       const int id  = e*p_NfacesNfp + n;
      if(e<Nelements && n<p_NfacesNfp ){
        //idP[em] = vmapP[id];
        // //load negative and positive trace node values of velocity
        s_U[em][es][n]  = Ud[idP[em]];
        s_V[em][es][n]  = Vd[idP[em]];
        }        
     }
    }
    }

    @barrier("local");

    // interpolate to surface integration nodes
    for(int es=0;es<p_NblockS5;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 
        if(n<(p_Nfaces*p_intNfp)){
           const int face = n/p_intNfp;       
            #pragma unroll p_NnodesS5
            for(int em=0;em<p_NnodesS5;++em){
              r_iUdP[em] = 0.f; 
              r_iVdP[em] = 0.f;              
            }

          // local block interpolation (face nodes to integration nodes)
          #pragma unroll p_Nfp
          for(int m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            //const dfloat iInm = s_intInterpT[n+m*p_Nfaces*p_intNfp];
            const int fm = face*p_Nfp + m;
            #pragma unroll p_NnodesS5
              for(int em=0;em<p_NnodesS5;++em){
              r_iUdP[em] += iInm*s_U[em][es][fm];
              r_iVdP[em] += iInm*s_V[em][es][fm];
            }
          }
        }
      }
    }
    
    @barrier("local");


     // interpolate to surface integration nodes
    for(int es=0;es<p_NblockS5;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 
        if(n<(p_Nfaces*p_intNfp)){
          const int face = n/p_intNfp;       
          #pragma unroll p_NnodesS5
          for(int em=0;em<p_NnodesS5;++em){
            const int e   = eo + es*p_NnodesS5 + em; 

            // load surface geofactors for this face
            const int sid    = p_Nsgeo*(e*p_Nfaces+face);
            const dfloat nx   = sgeo[sid+p_NXID];
            const dfloat ny   = sgeo[sid+p_NYID];
            const dfloat sJ   = sgeo[sid+p_SJID];
            const dfloat invJ = sgeo[sid+p_IJID];


            // const dfloat nx   = s_sgeo[em][es][face][p_NXID];
            // const dfloat ny   = s_sgeo[em][es][face][p_NYID];
            // const dfloat sJ   = s_sgeo[em][es][face][p_SJID];
            // const dfloat invJ   = s_sgeo[em][es][face][p_IJID];
        
            const int bc = EToB[face+p_Nfaces*e];
            // if(bc>0){
            //   insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, r_iUdM,r_iVdM, &r_iUdP[em], &r_iVdP[em]);
            // }

            const dfloat sc = sJ*invJ; 
            //Find max normal velocity on the face
            const dfloat unm   = fabs(nx*r_iUM[em] + ny*r_iVM[em]);
            const dfloat unp   = fabs(nx*r_iUP[em] + ny*r_iVP[em]);    
            const dfloat unmax = (unm > unp) ? unm : unp;

            s_iFluxU[em][es][n] = sc*(.5f*(nx*(r_iUP[em]*r_iUdP[em] + r_iUM[em]*r_iUdM[em]) 
                   +ny*(r_iVP[em]*r_iUdP[em] + r_iVM[em]*r_iUdM[em]) 
                   +unmax*(r_iUdM[em]- r_iUdP[em]) ));

            s_iFluxV[em][es][n] = sc*(.5f*(nx*(r_iUP[em]*r_iVdP[em] + r_iUM[em]*r_iVdM[em]) 
                   +ny*(r_iVP[em]*r_iVdP[em] + r_iVM[em]*r_iVdM[em]) 
                   +unmax*(r_iVdM[em]-r_iVdP[em]) ));
           }
        }
      }
    }

    barrier(localMemeFence);
    // lift from surface integration to volume nodes
    for(int es=0;es<p_NblockS5;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
        dfloat rhsu[p_NnodesS5], rhsv[p_NnodesS5];

        if(n<p_Np){
          #pragma unroll p_NnodesS5
         for(int em=0;em<p_NnodesS5;++em){
          rhsu[em] = 0.f;
          rhsv[em] = 0.f;
          }
        //
          #pragma unroll p_intNfpNfaces
          for(int m=0;m<p_intNfpNfaces;++m){
            const dfloat L = intLIFTT[n+m*p_Np];
            #pragma unroll p_NnodesS5
            for(int em=0;em<p_NnodesS5;++em){
              rhsu[em] += L*s_iFluxU[em][es][m];
              rhsv[em] += L*s_iFluxV[em][es][m];
           }
         }

        #pragma unroll p_NnodesS5
       for(int em=0;em<p_NnodesS5;++em){
        int e = eo+es*p_NnodesS5+em;
          if(e<Nelements){
            const int id = e*p_Np+n;
            rhsU[id]   += rhsu[em]; // note  change in sign
            rhsV[id]   += rhsv[em];    

           }
        }
        }
      }
    }
  #undef s_iFluxU
  #undef s_iFluxV   

  }

}



