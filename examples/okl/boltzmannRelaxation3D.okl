
// Fully Explicit Scheme Uses Clasical half Half Splitting
@kernel void boltzmannRelaxationCub3D(const int Nelements,
					     @restrict const  int *  elementIds,
					     @restrict const  dfloat *  cubInterpT,
					     @restrict const  dfloat *  cubProjectT,
					     @restrict const  dfloat4 *  q,
					           @restrict dfloat4 *  rhsq){
  
  for(int eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){  // for all elements

    // @shared memory for q at nodes
    @shared dfloat s_q[p_NblockV][10][p_Np];

    // sub-group of p_Np cubature node interpolants of N4,N5,N6
    @shared dfloat s_cubN5[p_NblockV][p_cubNp];
    @shared dfloat s_cubN6[p_NblockV][p_cubNp];
    @shared dfloat s_cubN7[p_NblockV][p_cubNp];
    @shared dfloat s_cubN8[p_NblockV][p_cubNp];
    @shared dfloat s_cubN9[p_NblockV][p_cubNp];
    @shared dfloat s_cubN10[p_NblockV][p_cubNp];

    @exclusive int element;

    // prefetch q to @shared
    for(int es=0;es<p_NblockV;++es;@inner(1)){
      for(int n=0;n<p_maxNodesVolume;++n;@inner(0)){    
	
	int e = eo+es; // element in block
	if(e<Nelements){
	  element = elementIds[e];

	  if(n<p_Np){
	    const int id = 3*(element*p_Np+n);
	    dfloat4 qan = q[id+0], qbn = q[id+1], qcn =  q[id+2] ;    
	    s_q[es][0][n] = qan.x;
	    s_q[es][1][n] = qan.y;
	    s_q[es][2][n] = qan.z;
	    s_q[es][3][n] = qan.w;
	    //
	    s_q[es][4][n] = qbn.x;
	    s_q[es][5][n] = qbn.y;
	    s_q[es][6][n] = qbn.z;
	    s_q[es][7][n] = qbn.w;
	    //
	    s_q[es][8][n] = qcn.x;
	    s_q[es][9][n] = qcn.y;
	    
	  }
	}
      }
    }
    
    // make sure all node data is loaded into @shared
    @barrier("local");

    // interpolate q to cubature
    for(int es=0;es<p_NblockV;++es;@inner(1)){
      for(int n=0;n<p_maxNodesVolume;++n;@inner(0)){     
	
	int e = eo+es; // element in block
	if(e<Nelements){
	  if(n<p_cubNp){
	    dfloat cubq1 = 0.f, cubq2 = 0.f, cubq3 = 0.f, cubq4 = 0.f, cubq5  = 0.f;
	    dfloat cubq6 = 0.f, cubq7 = 0.f, cubq8 = 0.f, cubq9 = 0.f, cubq10 = 0.f;
	    
	    for(int m=0;m<p_Np;++m){
	      const dfloat Icn  = cubInterpT[m*p_cubNp+n];
	      cubq1  += Icn*s_q[es][0][m];
	      cubq2  += Icn*s_q[es][1][m];
	      cubq3  += Icn*s_q[es][2][m];
	      cubq4  += Icn*s_q[es][3][m];
	      cubq5  += Icn*s_q[es][4][m];
	      cubq6  += Icn*s_q[es][5][m];
	      cubq7  += Icn*s_q[es][6][m];
	      cubq8  += Icn*s_q[es][7][m];
	      cubq9  += Icn*s_q[es][8][m];
	      cubq10 += Icn*s_q[es][9][m];
	    }
	   
        dfloat icubq1 = 1.f/cubq1;

	    // BGK relaxation approximation to the Boltzmann collision operator
	    s_cubN5[es][n]  = -p_tauInv*(cubq5 -(cubq2*cubq3*icubq1));
	    s_cubN6[es][n]  = -p_tauInv*(cubq6 -(cubq2*cubq4*icubq1));
	    s_cubN7[es][n]  = -p_tauInv*(cubq7 -(cubq3*cubq4*icubq1));
	    s_cubN8[es][n]  = -p_tauInv*(cubq8 -(p_invsqrt2*cubq2*cubq2*icubq1));
	    s_cubN9[es][n]  = -p_tauInv*(cubq9 -(p_invsqrt2*cubq3*cubq3*icubq1));
	    s_cubN10[es][n] = -p_tauInv*(cubq10-(p_invsqrt2*cubq4*cubq4*icubq1));
	    
	  }
	}
      }
    }

    // make sure all cubature node data is loaded into @shared
    @barrier("local");
    
    // partial projection to nodes from cubature-sub-group
    for(int es=0;es<p_NblockV;++es;@inner(1)){
      for(int n=0;n<p_maxNodesVolume;++n;@inner(0)){     
	
	int e = eo+es; // element in block
	if(e<Nelements){
	  if(n<p_Np){
	    const int id = 3*(element*p_Np+n);
	    
	    // use temporaries for part sums for N4,N5,N6 because of @exclusives
	    dfloat N5 = 0.f, N6 = 0.f, N7 = 0.f, N8 = 0.f, N9 = 0.f, N10 = 0.f;
	    for(int i=0;i<p_cubNp;++i){
	      const dfloat Pnc  = cubProjectT[i*p_Np+n];
	      N5  += Pnc*s_cubN5[es][i];
	      N6  += Pnc*s_cubN6[es][i];
	      N7  += Pnc*s_cubN7[es][i];
	      N8  += Pnc*s_cubN8[es][i];
	      N9  += Pnc*s_cubN9[es][i];
	      N10 += Pnc*s_cubN10[es][i];
	    }
	    
	    dfloat4 rhsqb,rhsqc;
	    //
	    rhsqb.x = N5;
	    rhsqb.y = N6;
	    rhsqb.z = N7;
	    rhsqb.w = N8;
	    //
	    rhsqc.x = N9;
	    rhsqc.y = N10;
	    //
	    rhsq[id+1] += rhsqb; 
	    rhsq[id+2] += rhsqc; 
	    
	  }
	}
      }
    }
  }
}


// Fully Explicit Scheme Uses Clasical half Half Splitting
@kernel void boltzmannSARelaxationCub3D(const int Nelements,
					     @restrict const  int *  elementIds,
					     @restrict const  dfloat *  cubInterpT,
					     @restrict const  dfloat *  cubProjectT,
					     @restrict const  dfloat4 *  q,
					           @restrict dfloat4 *  rhsq){
  
  for(int eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){  // for all elements

    // @shared memory for q at nodes
    @shared dfloat s_q[p_NblockV][4][p_Np];

    // sub-group of p_Np cubature node interpolants of N4,N5,N6
    @shared dfloat s_cubN5[p_NblockV][p_cubNp];
    @shared dfloat s_cubN6[p_NblockV][p_cubNp];
    @shared dfloat s_cubN7[p_NblockV][p_cubNp];
    @shared dfloat s_cubN8[p_NblockV][p_cubNp];
    @shared dfloat s_cubN9[p_NblockV][p_cubNp];
    @shared dfloat s_cubN10[p_NblockV][p_cubNp];

    @exclusive int element;

    // prefetch q to @shared
    for(int es=0;es<p_NblockV;++es;@inner(1)){
      for(int n=0;n<p_maxNodesVolume;++n;@inner(0)){    
	
	int e = eo+es; // element in block
	if(e<Nelements){
	  element = elementIds[e];

	  if(n<p_Np){
	    const int id = 3*(element*p_Np+n);
	    dfloat4 qan = q[id+0] ;    
	    s_q[es][0][n] = qan.x;
	    s_q[es][1][n] = qan.y;
	    s_q[es][2][n] = qan.z;
	    s_q[es][3][n] = qan.w;
	    	    
	  }
	}
      }
    }
    
    // make sure all node data is loaded into @shared
    @barrier("local");

    // interpolate q to cubature
    for(int es=0;es<p_NblockV;++es;@inner(1)){
      for(int n=0;n<p_maxNodesVolume;++n;@inner(0)){     
	
	int e = eo+es; // element in block
	if(e<Nelements){
	  if(n<p_cubNp){
	    dfloat cubq1 = 0.f, cubq2 = 0.f, cubq3 = 0.f, cubq4 = 0.f;
	    
	    for(int m=0;m<p_Np;++m){
	      const dfloat Icn  = cubInterpT[m*p_cubNp+n];
	      cubq1  += Icn*s_q[es][0][m];
	      cubq2  += Icn*s_q[es][1][m];
	      cubq3  += Icn*s_q[es][2][m];
	      cubq4  += Icn*s_q[es][3][m];
	    }
	   
        dfloat icubq1 = 1.f/cubq1;
	    // BGK relaxation approximation to the Boltzmann collision operator
	    s_cubN5[es][n]  = p_tauInv*(cubq2*cubq3*icubq1);
	    s_cubN6[es][n]  = p_tauInv*(cubq2*cubq4*icubq1);
	    s_cubN7[es][n]  = p_tauInv*(cubq3*cubq4*icubq1);
	    s_cubN8[es][n]  = p_tauInv*(p_invsqrt2*cubq2*cubq2*icubq1);
	    s_cubN9[es][n]  = p_tauInv*(p_invsqrt2*cubq3*cubq3*icubq1);
	    s_cubN10[es][n] = p_tauInv*(p_invsqrt2*cubq4*cubq4*icubq1);
	    
	  }
	}
      }
    }

    // make sure all cubature node data is loaded into @shared
    @barrier("local");
    
    // partial projection to nodes from cubature-sub-group
    for(int es=0;es<p_NblockV;++es;@inner(1)){
      for(int n=0;n<p_maxNodesVolume;++n;@inner(0)){     
	
	int e = eo+es; // element in block
	if(e<Nelements){
	  if(n<p_Np){
	    const int id = 3*(element*p_Np+n);
	    
	    // use temporaries for part sums for N4,N5,N6 because of @exclusives
	    dfloat N5 = 0.f, N6 = 0.f, N7 = 0.f, N8 = 0.f, N9 = 0.f, N10 = 0.f;
	    for(int i=0;i<p_cubNp;++i){
	      const dfloat Pnc  = cubProjectT[i*p_Np+n];
	      N5  += Pnc*s_cubN5[es][i];
	      N6  += Pnc*s_cubN6[es][i];
	      N7  += Pnc*s_cubN7[es][i];
	      N8  += Pnc*s_cubN8[es][i];
	      N9  += Pnc*s_cubN9[es][i];
	      N10 += Pnc*s_cubN10[es][i];
	    }
	    
	    dfloat4 rhsqb,rhsqc;
	    //
	    rhsqb.x = N5;
	    rhsqb.y = N6;
	    rhsqb.z = N7;
	    rhsqb.w = N8;
	    //
	    rhsqc.x = N9;
	    rhsqc.y = N10;
	    //
	    rhsq[id+1] += rhsqb; 
	    rhsq[id+2] += rhsqc; 
	    
	  }
	}
      }
    }
  }
}

