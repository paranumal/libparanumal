// compute div(NU)  = div(uxu) in collocation way
kernel void mnsLevelSetCubatureVolumeTri2D(const dlong Nelements,
                                          const dfloat * restrict vgeo,
                                          const dfloat * restrict cubvgeo, // only quad
                                          const dfloat * restrict cubDmatrices,
                                          const dfloat * restrict cubInterpT,
                                          const dfloat * restrict cubProjectT,
                                          const dlong offset,
                                          const dfloat time,  
                                          const dfloat * restrict U,
                                          const dfloat * restrict Phi, 
                                                dfloat * restrict rhsPhi){

  for(dlong eo=0;eo<Nelements;eo+=p_cubNblockV;outer0){  // for all elements

    // Hold Flux Vector on Shared, use symmetry f21 = f12
    shared dfloat s_U[p_cubNblockV][p_Np];
    shared dfloat s_V[p_cubNblockV][p_Np];
    shared dfloat s_Phi[p_cubNblockV][p_Np];
    //
    shared dfloat s_cFr[p_cubNblockV][p_cubNp];
    shared dfloat s_cFs[p_cubNblockV][p_cubNp];
    
    for(int es=0;es<p_cubNblockV;++es;inner1){// for all elements in block
      for(int n=0;n<p_maxNodesVolumeCub;++n;inner0){  // for all nodes in this element
        dlong e = eo+es; // element in block
        if(e<Nelements){
          if(n<p_Np){
            const int id = e*p_Np+n;

            #if 1
            const dfloat factor = occaCos(OCCA_PI*time/8.0f);
            s_U[es][n]    = factor*U[id + 0*offset];
            s_V[es][n]    = factor*U[id + 1*offset];
            s_Phi[es][n]  = Phi[id];
            #else
            s_U[es][n]    = U[id + 0*offset];
            s_V[es][n]    = U[id + 1*offset];
            s_Phi[es][n]  = Phi[id];
            #endif
          }
        } 
      }
    }

    barrier(localMemFence);

    for(int es=0;es<p_cubNblockV;++es;inner1){// for all elements in block
      for(int n=0;n<p_maxNodesVolumeCub;++n;inner0){     // for all nodes in this element
        dlong  e = eo+es; // element in block
        if(e<Nelements && n<p_cubNp){
          // prefetch geometric factors (constant on triangle)
          const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
          const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
          const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
          const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];

          dfloat cu = 0.f, cv = 0.f, cphi = 0.f;
          occaUnroll(p_Np)
          for(int i=0;i<p_Np;++i){
            dfloat cI = cubInterpT[n+i*p_cubNp];
            cu    += cI*s_U[es][i];
            cv    += cI*s_V[es][i];
            cphi  += cI*s_Phi[es][i]; 
          }
          s_cFr[es][n] = cphi*(drdx*cu + drdy*cv);
          s_cFs[es][n] = cphi*(dsdx*cu + dsdy*cv);
         }
      }
    }

    // Make sure all node data is loaded into shared
    barrier(localMemFence);

    for(int es=0;es<p_cubNblockV;++es;inner1){// for all elements in block
      for(int n=0;n<p_maxNodesVolumeCub;++n;inner0){     // for all nodes in this element
        dlong e = eo+es; 
        if(e<Nelements && n<p_Np){        
          // compute 'r' and 's' derivatives of (q_m) at node n
          dfloat dfdr = 0.f, dfds = 0.f; 
          occaUnroll(p_cubNp)
            for(int i=0;i<p_cubNp;++i){
              const dfloat cDrWni = cubDmatrices[n+i*p_Np+0*p_cubNp*p_Np];
              const dfloat cDsWni = cubDmatrices[n+i*p_Np+1*p_cubNp*p_Np];
              dfdr += cDrWni*s_cFr[es][i];
              dfds += cDsWni*s_cFs[es][i];
            }
          // Update
          rhsPhi[e*p_Np+n] = (dfdr + dfds);    
        }
      }
    }

  }
}



kernel void mnsLevelSetCubatureSurfaceTri2D(const dlong Nelements,
                                            const dfloat * restrict vgeo,
                                            const dfloat * restrict sgeo,
                                            const dfloat * restrict cubsgeo,
                                            const dfloat * restrict intInterpT, // interpolate to integration nodes
                                            const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
                                            const dfloat * restrict cubInterpT, 
                                            const dfloat * restrict cubProjectT, 
                                            const dlong  * restrict vmapM,
                                            const dlong  * restrict vmapP,
                                            const int    * restrict EToB,
                                            const dfloat time,
                                            const dfloat * restrict intx, 
                                            const dfloat * restrict inty,
                                            const dfloat * restrict intz,
                                            const dlong offset,
                                            const dfloat * restrict U,
                                            const dfloat * restrict Phi,
                                                  dfloat * restrict rhsPhi){

  // for all elements
  for(dlong eo=0;eo<Nelements;eo+=p_cubNblockS;outer0){

    // shared storage for flux terms
    shared dfloat s_UM[p_cubNblockS][p_NfacesNfp];
    shared dfloat s_VM[p_cubNblockS][p_NfacesNfp];
    shared dfloat s_UP[p_cubNblockS][p_NfacesNfp];
    shared dfloat s_VP[p_cubNblockS][p_NfacesNfp];
    //
    shared dfloat s_PhiM[p_cubNblockS][p_NfacesNfp];
    shared dfloat s_PhiP[p_cubNblockS][p_NfacesNfp];
    //
    shared dfloat s_fluxPhi[p_cubNblockS][p_intNfpNfaces];

    // for all face nodes of all elements
    for(int es=0;es<p_cubNblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        dlong e = eo + es;
        if(e<Nelements && n<(p_Nfaces*p_Nfp)){
          const int id  = e*p_Nfp*p_Nfaces + n;
          const dlong idM = vmapM[id];
          const dlong idP = vmapP[id];
          // load negative and positive trace node values of velocity
            #if 1
            const dfloat factor = occaCos(OCCA_PI*time/8.0f);
            s_UM[es][n] = factor*U[idM + 0*offset];
            s_VM[es][n] = factor*U[idM + 1*offset];
            s_UP[es][n] = factor*U[idP + 0*offset];
            s_VP[es][n] = factor*U[idP + 1*offset];
            #else
            s_UM[es][n] = U[idM + 0*offset];
            s_VM[es][n] = U[idM + 1*offset];
            s_UP[es][n] = U[idP + 0*offset];
            s_VP[es][n] = U[idP + 1*offset];
            #endif
          
          //
          s_PhiM[es][n] = Phi[idM];
          s_PhiP[es][n] = Phi[idP];
      }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(int es=0;es<p_cubNblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
        const dlong e = eo + es;
        if(e<Nelements && n<(p_Nfaces*p_intNfp)){
            const int face = n/p_intNfp; // find face that owns this integration node

            // load surface geofactors for this face
            const dlong sid   = p_Nsgeo*(e*p_Nfaces+face);
            const dfloat nx   = sgeo[sid+p_NXID];
            const dfloat ny   = sgeo[sid+p_NYID];
            const dfloat sJ   = sgeo[sid+p_SJID];
            const dfloat invJ = sgeo[sid+p_IJID];

            dfloat um    = 0.f, vm    = 0.f;
            dfloat up    = 0.f, vp    = 0.f;
            dfloat phim  = 0.f, phip  = 0.f;

            // local block interpolation (face nodes to integration nodes)
            occaUnroll(p_Nfp)
            for(int i=0;i<p_Nfp;++i){
              const dfloat iIni = intInterpT[n+i*p_Nfaces*p_intNfp];
              const int fm = face*p_Nfp+i;
            
              um += iIni*s_UM[es][fm];
              vm += iIni*s_VM[es][fm];
              up += iIni*s_UP[es][fm];
              vp += iIni*s_VP[es][fm];
              
              phim += iIni*s_PhiM[es][fm];
              phip += iIni*s_PhiP[es][fm];

            }

            // apply boundary condition
            int bc = EToB[face+p_Nfaces*e];
            if(bc>0){
              const dlong idB = n+e*p_Nfaces*p_intNfp;
              mnsLevelSetBoundaryConditions2D(bc,time, intx[idB],inty[idB],nx, ny, phim, &phip);
            }

            // Find max normal velocity on the face
            dfloat unM   = occaFabs(nx*um + ny*vm);
            dfloat unP   = occaFabs(nx*up + ny*vp);    
            dfloat unMax = (unM > unP) ? unM : unP;

            // evaluate "flux" terms: LLF
            const dfloat sc = invJ * sJ ;  // notice sign changes in flux because of weak form
            s_fluxPhi[es][n] = -0.5f*sc*(nx*(up*phip + um*phim) + ny*(vp*phip + vm*phim) 
                                                                + unMax*(phim-phip) );
          }
      }
    }

    // wait for all shared memory writes of the previous inner loop to complete
    barrier(localMemFence);

    // lift from surface integration to volume nodes
    for(int es=0;es<p_cubNblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        const dlong e = eo + es;
        if(e<Nelements && n<p_Np ){
            const dlong id = n + p_Np*e;
            // prefetch volume rhs
            dfloat rhs = rhsPhi[id];

            occaUnroll(p_intNfp*p_Nfaces)
            for(int i=0;i<(p_intNfp*p_Nfaces);++i){
              rhs += intLIFTT[n+i*p_Np]*s_fluxPhi[es][i];
            }
            rhsPhi[id] = rhs;
          }
      }
    }
  }
}



kernel void mnsLevelSetUpdateTri2D(const dlong Nelements,
                                   const dfloat dt,  
                                   const dfloat rka,
                                   const dfloat rkb,
                                   const dfloat * restrict rhsPhi,
                                         dfloat * restrict resPhi,
                                         dfloat * restrict Phi){
  // Low storage Runge Kutta time step update
  for(dlong e=0;e<Nelements;++e;outer0){

    for(int n=0;n<p_Np;++n;inner0){
      const int id = n + e*p_Np;
      
      dfloat r_resphi = resPhi[id];
      dfloat r_rhsphi = rhsPhi[id]; 
      dfloat r_phi    = Phi[id];
      //
      r_resphi = rka*r_resphi + dt*r_rhsphi;
      r_phi   += rkb*r_resphi;

      //
      resPhi[id] = r_resphi;
      Phi[id]    = r_phi;
    }
  }
}



